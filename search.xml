<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AppScan v10.0.7.28135 安装破解</title>
    <url>/2207220210/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>HCL AppScan（原名IBM Security AppScan）是原IBM的Rational软件部门的一组网络安全测试和监控工具，2019年被HCL技术公司收购。AppScan旨在在开发过程中对Web应用程序的安全漏洞进行测试。  </p>
<span id="more"></span>

<h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Windows Server 2016 Datacenter</li>
<li>AppScan v10.0.7.28135</li>
</ul>
<h3 id="AppScan-安装激活"><a href="#AppScan-安装激活" class="headerlink" title="AppScan 安装激活"></a>AppScan 安装激活</h3><p>下载链接<br><a href="https://www.yunzhongzhuan.com/#sharefile=H51riiWG_46315">www.ddosi.org下载入口</a></p>
<blockquote>
<p>解压密码:<a href="http://www.ddosi.org/">www.ddosi.org</a></p>
</blockquote>
<p><a href="https://s.csms.tech/file/HCL_AppScan_Standard_v10.0.7.28135.rar">其他下载地址</a></p>
<p>下载安装包后，点击文件 <code>Appscan_Setup_v10.0.7.28135.exe</code> 安装</p>
<p>安装完成后，复制Crack目录下的文件 <code>AppScanSDK.dll</code>,<code>HclLicenseProvider.dll</code> 到 APPscan安装目录(默认为 <code>C:\Program Files (x86)\HCL\AppScan Standard</code>) 进行替换，完成破解</p>
<p>成功破解后的截图如下</p>
<p><img src="https://i.csms.tech/img_17.png"> </p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.ddosi.org/appscan-2/">参考链接</a></p>
]]></content>
      <categories>
        <category>安全</category>
        <category>AppScan</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>AppScan</tag>
      </tags>
  </entry>
  <entry>
    <title>Django+uwsgi+nginx 配置示例</title>
    <url>/7d1a39d2/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>centos 7</li>
<li>Python 3.10</li>
<li>Django 4.0</li>
<li>uwsgi 2.0.20</li>
<li>nginx 1.20.1</li>
<li>venv<blockquote>
<p>示例中虚拟环境位于 <code>/opt/vb/</code>, Django工程目录位于 <code>/opt/vb/vb/</code> , 工程名称为vb</p>
</blockquote>
</li>
</ul>
<h3 id="uwsgi配置文件-uwsgi-ini-配置示例"><a href="#uwsgi配置文件-uwsgi-ini-配置示例" class="headerlink" title="uwsgi配置文件 (uwsgi.ini) 配置示例"></a>uwsgi配置文件 (uwsgi.ini) 配置示例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[uwsgi]</span><br><span class="line">socket = 127.0.0.1:8081</span><br><span class="line">chdir = /opt/vb/vb</span><br><span class="line">wsgi-file = ./vb/wsgi.py</span><br><span class="line">master = true         //主进程</span><br><span class="line">vhost = true          //多站模式</span><br><span class="line">no-site = true        //多站模式时不设置入口模块和文件</span><br><span class="line">workers = 2           //子进程数</span><br><span class="line">reload-mercy = 10     </span><br><span class="line">vacuum = true         //退出、重启时清理文件</span><br><span class="line">max-requests = 1000   </span><br><span class="line">limit-as = 512</span><br><span class="line">buffer-size = 30000</span><br><span class="line">pidfile = uwsgi-8081.pid</span><br><span class="line">daemonize = uwsgi-8081.log</span><br><span class="line">pythonpath = /opt/vb/env/lib/python3.10/site-packages/</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h3 id="nginx-配置文件示例"><a href="#nginx-配置文件示例" class="headerlink" title="nginx 配置文件示例"></a>nginx 配置文件示例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">       listen 80;</span><br><span class="line">       server_name csms.tech;</span><br><span class="line"></span><br><span class="line">        location / &#123;            </span><br><span class="line">            include  uwsgi_params;</span><br><span class="line">            uwsgi_pass  127.0.0.1:8081;</span><br><span class="line">            uwsgi_param UWSGI_SCRIPT vb.wsgi;</span><br><span class="line">            uwsgi_param UWSGI_CHDIR /opt/vb/vb;       </span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        location /static/ &#123;</span><br><span class="line">                alias /opt/vb/vb/staticCollects/;</span><br><span class="line">        &#125;</span><br><span class="line">        access_log log/uwsgi.access.log main;</span><br><span class="line">        error_log log/uwsgi.error.log;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a href="/d5da7d5e/" title="Django 常见错误">Django 常见错误</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Nginx</tag>
        <tag>Django</tag>
        <tag>Uwsgi</tag>
      </tags>
  </entry>
  <entry>
    <title>Django 常见错误</title>
    <url>/d5da7d5e/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><hr>
<h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>centos7</li>
<li>python3.6</li>
</ul>
<h2 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h2><blockquote>
<p>ModuleNotFoundError: No module named ‘MySQLdb’<br>…<br>django.core.exceptions.ImproperlyConfigured: Error loading MySQLdb module.</p>
</blockquote>
<p><strong>解决方法</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip3 install pymysql</span><br></pre></td></tr></table></figure>

<p>编辑文件<code>./python36/lib/python3.6/site-packages/django/db/backends/mysql/__init__.py</code>, 输入以下内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql </span><br><span class="line">pymysql.install_as_MySQLdb()</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<hr>
<h2 id="报错信息-1"><a href="#报错信息-1" class="headerlink" title="报错信息"></a>报错信息</h2><p><code>django-admin runserver</code></p>
<blockquote>
<p>django.core.exceptions.ImproperlyConfigured: Requested setting DEBUG, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings</p>
</blockquote>
<p><strong>解决方法</strong></p>
<p>使用命令<br><code>python3 manage.py runserver</code></p>
<hr>
<h1 id="环境信息-1"><a href="#环境信息-1" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>centos7</li>
<li>python3.10</li>
<li>uwsgi 2.0.20</li>
<li>venv</li>
</ul>
<h2 id="报错信息-2"><a href="#报错信息-2" class="headerlink" title="报错信息"></a>报错信息</h2><p>uwsgi 启动后报错(查看 uwsgi 日志输出)</p>
<blockquote>
<p>from django.core.wsgi import get_wsgi_application<br>ModuleNotFoundError: No module named ‘django’</p>
</blockquote>
<p><strong>解决方法</strong></p>
<p>uwsgi 配置文件(<code>uwsgi.ini</code> )中添加 python 路径, 在配置文件中添加如下配置：</p>
<figure class="highlight python"><figcaption><span>uwsgi.ini</span></figcaption><table><tr><td class="code"><pre><span class="line">pythonpath = /env/lib/python3<span class="number">.10</span>/site-packages/</span><br></pre></td></tr></table></figure>

<p>完整 uwsgi 配置文件示例(使用 python venv 模块创建虚拟环境情况下)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[uwsgi]</span><br><span class="line">socket = 127.0.0.1:8081</span><br><span class="line">chdir = /opt/vb/vb</span><br><span class="line">wsgi-file = ./vb/wsgi.py</span><br><span class="line">master = true         //主进程</span><br><span class="line">vhost = true          //多站模式</span><br><span class="line">no-site = true        //多站模式时不设置入口模块和文件</span><br><span class="line">workers = 2           //子进程数</span><br><span class="line">reload-mercy = 10     </span><br><span class="line">vacuum = true         //退出、重启时清理文件</span><br><span class="line">max-requests = 1000   </span><br><span class="line">limit-as = 512</span><br><span class="line">buffer-size = 30000</span><br><span class="line">pidfile = uwsgi-8081.pid</span><br><span class="line">daemonize = uwsgi-8081.log</span><br><span class="line">pythonpath = /opt/vb/env/lib/python3.10/site-packages/</span><br></pre></td></tr></table></figure>

<h2 id="报错信息-3"><a href="#报错信息-3" class="headerlink" title="报错信息"></a>报错信息</h2><p>uwsgi 启动后报错(查看uwsgi日志输出)</p>
<blockquote>
<p>unable to load app 0 (mountpoint&#x3D;’|’) (callable not found or import error)<br>— no python application found, check your startup logs for errors —</p>
</blockquote>
<p><strong>解决方法</strong> </p>
<p>uwsgi 配置文件(<code>uwsgi.ini</code> )中添加 <code>wsgi.py</code> 路径, 在配置文件中添加如下配置：</p>
<figure class="highlight shell"><figcaption><span>uwsgi.ini</span></figcaption><table><tr><td class="code"><pre><span class="line">wsgi-file = ./vb/wsgi.py</span><br></pre></td></tr></table></figure>

<h2 id="django-db-utils-OperationalError"><a href="#django-db-utils-OperationalError" class="headerlink" title="django.db.utils.OperationalError"></a>django.db.utils.OperationalError</h2><p>项目根目录执行 <code>python manage.py  migrate</code> 时报错 <code>django.db.utils.OperationalError: (1366, &quot;Incorrect string value: &#39;\\xE6\\x9C\\x8D\\xE5\\x8A\\xA1...&#39; for column &#39;name&#39; at row 1&quot;)</code></p>
<p><strong>排查步骤</strong></p>
<ol>
<li><p>查看数据库编码设置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">show variables like <span class="string">&quot;%char%&quot;</span>;</span></span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| Variable_name            | Value                      |</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| character_set_client     | utf8                       |</span><br><span class="line">| character_set_connection | utf8                       |</span><br><span class="line">| character_set_database   | latin1                     |</span><br><span class="line">| character_set_filesystem | binary                     |</span><br><span class="line">| character_set_results    | utf8                       |</span><br><span class="line">| character_set_server     | latin1                     |</span><br><span class="line">| character_set_system     | utf8                       |</span><br><span class="line">| character_sets_dir       | /usr/share/mysql/charsets/ |</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">8 rows in set (0.01 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>修改数据库编码为 <code>utf8</code></p>
<p>修改数据库配置文件 <code>my.cnf</code>，添加以下配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"></span><br><span class="line">character-set-server = utf8</span><br><span class="line">collation-server=utf8_general_ci</span><br></pre></td></tr></table></figure>
<p>重启数据库，检查编码设置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">show variables like <span class="string">&quot;%char%&quot;</span>;</span></span><br><span class="line"></span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| Variable_name            | Value                      |</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| character_set_client     | utf8                       |</span><br><span class="line">| character_set_connection | utf8                       |</span><br><span class="line">| character_set_database   | utf8                       |</span><br><span class="line">| character_set_filesystem | binary                     |</span><br><span class="line">| character_set_results    | utf8                       |</span><br><span class="line">| character_set_server     | utf8                       |</span><br><span class="line">| character_set_system     | utf8                       |</span><br><span class="line">| character_sets_dir       | /usr/share/mysql/charsets/ |</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">8 rows in set (0.05 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>重新执行 <code>python manage.py  migrate</code> 依旧返回同样的报错，检查之前创建的数据库编码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">show create database mydb;</span></span><br><span class="line">+-----------------+----------------------------------------------------------------------------+</span><br><span class="line">| Database        | Create Database                                                            |</span><br><span class="line">+-----------------+----------------------------------------------------------------------------+</span><br><span class="line">| mydb | CREATE DATABASE `mydb` /*!40100 DEFAULT CHARACTER SET latin1 */ |</span><br><span class="line">+-----------------+----------------------------------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>编码显示为 <code>latin1</code>，删除数据库重新创建</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">drop database mydb;</span></span><br><span class="line">Query OK, 12 rows affected (0.10 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">create database mydb;</span></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">show create database mydb;</span></span><br><span class="line">+-----------------+--------------------------------------------------------------------------+</span><br><span class="line">| Database        | Create Database                                                          |</span><br><span class="line">+-----------------+--------------------------------------------------------------------------+</span><br><span class="line">| mydb | CREATE DATABASE `mydb` /*!40100 DEFAULT CHARACTER SET utf8 */ |</span><br><span class="line">+-----------------+--------------------------------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>新建的数据库编码为 <code>utf8</code>，重新执行 <code>python manage.py  makemigrations</code>，<code>python manage.py  migrate</code>，执行成功。删除数据库重建后，如若使用后台，需要为后台重新生成 superuser。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Django 模板中循环嵌套</title>
    <url>/c97b0902/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>模板中需要循环中循环，<code>&#123;% for i in alist %&#125;</code>,假如i是个元组或列表，需要继续循环：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">for</span> i <span class="keyword">in</span> alist %&#125;</span><br><span class="line">	&#123;% <span class="keyword">with</span> temp=I %&#125;</span><br><span class="line">		&#123;% <span class="keyword">for</span> k <span class="keyword">in</span> temp %&#125;</span><br><span class="line">		    …</span><br><span class="line">		&#123;% endfor %&#125;</span><br><span class="line">	&#123;% endwith %&#125;</span><br><span class="line">&#123;%endfor%&#125;</span><br></pre></td></tr></table></figure>
<p>或使用如下方式，data &#x3D; [[1,2],[3,4]]：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">for</span> l <span class="keyword">in</span> data%&#125;</span><br><span class="line"></span><br><span class="line">	&#123;% <span class="keyword">for</span> temp <span class="keyword">in</span> l % &#125;</span><br><span class="line">		&#123;% <span class="keyword">if</span> forloop.first % &#125;</span><br><span class="line">			<span class="string">&#x27;&#123;&#123;temp&#125;&#125;&#x27;</span>,</span><br><span class="line">		&#123;% <span class="keyword">else</span> %&#125;</span><br><span class="line">			&#123;&#123;temp&#125;&#125;</span><br><span class="line">		&#123;% endif %&#125;</span><br><span class="line">	&#123;% endfor %&#125;</span><br><span class="line"></span><br><span class="line">&#123;%endfor%&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Django model 外键的反向引用</title>
    <url>/dcca5850/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Question</span>(models.Model):</span><br><span class="line">	question_text=models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">	pub_date=models.DateTimeField(<span class="string">&#x27;datepublished&#x27;</span>)</span><br><span class="line"></span><br><span class="line">	def__str__(self):</span><br><span class="line">		returnself.question_text</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Choice</span>(models.Model):</span><br><span class="line">	question=models.ForeignKey(Question,on_delete=models.CASCADE)</span><br><span class="line">	choice_text=models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">	votes=models.IntegerField(default=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	def__str__(self):</span><br><span class="line">		returnself.choice_text</span><br><span class="line">  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上例中，Choice引用了Question作为外键，在模板中通过Question对象获取所有引用了Question对象的Choice对象，可以使用以下方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% for choice in question.choice_set.all %&#125;</span><br><span class="line">	&lt;li&gt;&#123;&#123;choice.choice_text&#125;&#125;&lt;/li&gt;</span><br><span class="line">&#123;%endfor%&#125;</span><br></pre></td></tr></table></figure>

<p>使用question.choice_set.all的方式获取所有引用question对象的Choice对象实例</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Python</tag>
        <tag>Model</tag>
      </tags>
  </entry>
  <entry>
    <title>Dockerfile 简介</title>
    <url>/202208050928/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Dockerfile 是一个文本文件，其内包含了一条条的 <code>指令(Instruction)</code>，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p>
<span id="more"></span>

<h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><p><code>docker build</code> 命令使用 <code>Dockerfile</code> 进行镜像构建。其格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build [选项] &lt;上下文路径/URL/-&gt;</span><br></pre></td></tr></table></figure>

<h4 id="docker-build-命令常用选项"><a href="#docker-build-命令常用选项" class="headerlink" title="docker build 命令常用选项"></a><code>docker build</code> 命令常用选项</h4><table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>-t, --tag</code></td>
<td>给新构建的镜像一个新的标签，格式为：<code>name:tag</code></td>
<td><code>docker build -t nginx:v3 .</code></td>
</tr>
<tr>
<td><code>-f, --file string </code></td>
<td><code>Dockerfile</code>的路径（文件名），默认为 <code>上下文（Context）目录/Dockerfile</code></td>
<td></td>
</tr>
</tbody></table>
<h4 id="上下文路径-格式"><a href="#上下文路径-格式" class="headerlink" title="上下文路径 格式"></a><code>上下文路径</code> 格式</h4><p>上下文路径可以是以下方式</p>
<ul>
<li><p>本地路径</p>
</li>
<li><p>用 <code>Git repo</code> 进行构建</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t hello-world https://github.com/docker-library/hello-world.git#master:amd64/hello-world</span><br></pre></td></tr></table></figure>

<p>  这行命令指定了构建所需的 Git repo，并且指定分支为 master，构建目录为 &#x2F;amd64&#x2F;hello-world&#x2F;，然后 Docker 就会自己去 git clone 这个项目、切换到指定分支、并进入到指定目录后开始构建。</p>
</li>
<li><p>用给定的 <code>tar</code> 压缩包构建</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build http://server/context.tar.gz</span><br></pre></td></tr></table></figure>
<p>如果所给出的 URL 不是个 Git repo，而是个 tar 压缩包，那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。</p>
</li>
<li><p>从标准输入中读取 <code>Dockerfile</code> 进行构建</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build - &lt; Dockerfile</span><br></pre></td></tr></table></figure>
<p>或</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat Dockerfile | docker build -</span><br></pre></td></tr></table></figure>
<p>  如果标准输入传入的是文本文件，则将其视为 <code>Dockerfile</code>，并开始构建。这种形式由于直接从标准输入中读取 <code>Dockerfile</code> 的内容，它没有上下文，因此不可以像其他方法那样可以将本地文件 <code>COPY</code> 进镜像之类的事情。  </p>
</li>
<li><p>从标准输入中读取上下文压缩包进行构建</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build - &lt; context.tar.gz</span><br></pre></td></tr></table></figure>
<p>如果发现标准输入的文件格式是 <code>gzip</code>、<code>bzip2</code> 以及 <code>xz</code> 的话，将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。</p>
</li>
</ul>
<h3 id="镜像构建上下文（Context）"><a href="#镜像构建上下文（Context）" class="headerlink" title="镜像构建上下文（Context）"></a>镜像构建上下文（Context）</h3><p>Docker 在运行时分为 <code>Docker 引擎</code>（也就是服务端守护进程）和<code>客户端工具</code>。Docker 的引擎提供了一组 <code>REST API</code>，被称为 <a href="https://docs.docker.com/engine/api/sdk/"><code>Docker Remote API</code></a>，而如 <code>docker</code> 命令这样的客户端工具，则是通过这组 <code>API</code> 与 <code>Docker 引擎</code> 交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 <code>docker</code> 功能，但实际上，一切都是使用的远程调用形式在服务端（<code>Docker 引擎</code>）完成。也因为这种 C&#x2F;S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[使用 Dockerfile 定制镜像](https://yeasy.gitbook.io/docker_practice/image/build)  ">[1]</span></a></sup></p>
<p>当我们进行镜像构建的时候，并非所有定制都会通过 <code>RUN</code> 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 <code>COPY</code> 指令、<code>ADD</code> 指令等。而 <code>docker build</code> 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 <code>Docker 引擎</code> 中构建的。那么在这种客户端&#x2F;服务端的架构中，如何才能让服务端获得本地文件呢？</p>
<p>这就引入了 <code>上下文</code> 的概念。当构建的时候，用户会指定构建镜像上下文的路径，<code>docker build</code> 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 <code>Docker 引擎</code>。这样 <code>Docker 引擎</code> 收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p>
<p>如果在 Dockerfile 中这么写：</p>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">COPY ./package.json /app/</span><br></pre></td></tr></table></figure>

<p>这并不是要复制执行 <code>docker build</code> 命令所在的目录下的 <code>package.json</code>，也不是复制 <code>Dockerfile</code> 所在目录下的 <code>package.json</code>，而是复制 <code>上下文（context）</code> 目录下的 <code>package.json</code>。</p>
<p>因此，<code>COPY</code> 这类指令中的源文件的路径都是相对路径。</p>
<p>一般来说，应该会将 <code>Dockerfile</code> 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 <code>Docker 引擎</code>，那么可以用 <code>.gitignore</code> 一样的语法写一个 <code>.dockerignore</code>，该文件是用于剔除不需要作为上下文传递给 <code>Docker 引擎</code> 的。</p>
<p>默认情况下，如果不额外指定 <code>Dockerfile</code> 的话，会将上下文目录下的名为 <code>Dockerfile</code> 的文件作为 <code>Dockerfile</code>。</p>
<p>这只是默认行为，实际上 <code>Dockerfile</code> 的文件名并不要求必须为 <code>Dockerfile</code>，而且并不要求必须位于上下文目录中，比如可以用 <code>-f ../Dockerfile.php</code> 参数指定某个文件作为 <code>Dockerfile</code>。<br>当然，一般大家习惯性的会使用默认的文件名 <code>Dockerfile</code>，以及会将其置于镜像构建上下文目录中</p>
<h3 id="Dockerfile-指令详解"><a href="#Dockerfile-指令详解" class="headerlink" title="Dockerfile 指令详解"></a>Dockerfile 指令详解</h3><p><code>Dockerfile</code> 文件示例</p>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN echo &#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27; &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure>

<h4 id="FROM-指令"><a href="#FROM-指令" class="headerlink" title="FROM 指令"></a>FROM 指令</h4><p>定制镜像，一定要以一个镜像为基础，在其上进行定制。</p>
<p><code>FROM</code> 就是指定 <code>基础镜像</code>，因此一个 <code>Dockerfile</code> 中 <code>FROM</code> 是<strong>必备的指令</strong>，并且<strong>必须是第一条指令</strong>。<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[使用 Dockerfile 定制镜像](https://yeasy.gitbook.io/docker_practice/image/build)  ">[1]</span></a></sup>  </p>
<p>除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 <code>scratch</code>。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。</p>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">FROM scratch</span><br></pre></td></tr></table></figure>

<p>如果以 <code>scratch</code> 为基础镜像的话，意味着不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。</p>
<h4 id="RUN-指令"><a href="#RUN-指令" class="headerlink" title="RUN 指令"></a>RUN 指令</h4><p><code>RUN</code> 指令是用来执行命令行命令的。由于命令行的强大能力，<code>RUN</code> 指令在定制镜像时是最常用的指令之一。<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[使用 Dockerfile 定制镜像](https://yeasy.gitbook.io/docker_practice/image/build)  ">[1]</span></a></sup>其格式有两种：</p>
<ul>
<li>shell 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样。<a href="#Dockerfile-%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3">上面</a>写的 <code>Dockerfile</code> 中的 <code>RUN</code> 指令就是这种格式。  </li>
<li>exec 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式。</li>
</ul>
<p>既然 RUN 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样：  </p>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">FROM debian:stretch</span><br><span class="line"></span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install -y gcc libc6-dev make wget</span><br><span class="line">RUN wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span><br><span class="line">RUN mkdir -p /usr/src/redis</span><br><span class="line">RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</span><br><span class="line">RUN make -C /usr/src/redis</span><br><span class="line">RUN make -C /usr/src/redis install</span><br></pre></td></tr></table></figure>

<p><code>Dockerfile</code> 中每一个指令都会建立一层，<code>RUN</code> 也不例外。每一个 <code>RUN</code> 的行为，就和我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，<code>commit</code> 这一层的修改，构成新的镜像。<br>每一个 RUN 都是启动一个容器、执行命令、然后提交存储层文件变更。当前的 <code>RUN</code> 指令和前后的 <code>RUN</code> 指令是<strong>不存在环境变量的共享及关联的</strong></p>
<p>而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。</p>
<p><code>Union FS</code> 是有最大层数限制的，比如 <code>AUFS</code>，曾经是最大不得超过 42 层，现在是不得超过 127 层。</p>
<p>上面的 <code>Dockerfile</code> 正确的写法应该是这样：</p>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">FROM debian:stretch</span><br><span class="line"></span><br><span class="line">RUN set -x; buildDeps=&#x27;gcc libc6-dev make wget&#x27; \</span><br><span class="line">    &amp;&amp; apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y $buildDeps \</span><br><span class="line">    &amp;&amp; wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot; \</span><br><span class="line">    &amp;&amp; mkdir -p /usr/src/redis \</span><br><span class="line">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis install \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/* \</span><br><span class="line">    &amp;&amp; rm redis.tar.gz \</span><br><span class="line">    &amp;&amp; rm -r /usr/src/redis \</span><br><span class="line">    &amp;&amp; apt-get purge -y --auto-remove $buildDeps</span><br></pre></td></tr></table></figure>

<p>首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 <code>RUN</code> 一一对应不同的命令，而是仅仅使用一个 <code>RUN</code> 指令，并使用 <code>&amp;&amp;</code> 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 <code>Dockerfile</code> 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。  </p>
<p>并且，这里为了格式化还进行了换行。<code>Dockerfile</code> 支持 <code>Shell</code> 类的行尾添加 <code>\</code> 的命令换行方式，以及行首 <code>#</code> 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。  </p>
<p>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 apt 缓存文件。这是很重要的一步，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p>
<h4 id="COPY-复制文件指令"><a href="#COPY-复制文件指令" class="headerlink" title="COPY 复制文件指令"></a>COPY 复制文件指令</h4><p><code>COPY</code> 指令将构建上下文目录中的 <code>&lt;源路径&gt;</code> 的文件&#x2F;目录复制到新的一层镜像内的 <code>&lt;目标路径&gt;</code> 位置。<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[COPY 复制文件](https://yeasy.gitbook.io/docker_practice/image/dockerfile/copy)">[2]</span></a></sup></p>
<p>命令格式：</p>
<ul>
<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;</code></li>
<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></li>
</ul>
<p><code>&lt;源路径&gt;</code> 可以是多个，甚至可以是通配符，其通配符规则要满足 <code>Go</code> 的 <a href="https://pkg.go.dev/path/filepath#Match"><code>filepath.Match</code></a> 规则，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">COPY hom* /mydir/</span><br><span class="line">COPY hom?.txt /mydir/</span><br></pre></td></tr></table></figure>

<p>如果源路径为文件夹，复制的时候不是直接复制该文件夹，而是将文件夹中的内容复制到目标路径。  </p>
<p><code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <code>WORKDIR</code> 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p>
<p>使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。  </p>
<p><code>COPY</code> 指令其他选项：</p>
<style>
table th:nth-of-type(1){
width: 10%;
}
table th:nth-of-type(2){
width: 20%;
}
table th:nth-of-type(3){
width: 70%;
}
</style>

<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>--from</code></td>
<td>从其他镜像或构件阶段拷贝文件</td>
<td><code>COPY --from=0 /go/app .</code>  多阶段构建 <sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Dockerfile 多阶段构建](https://yeasy.gitbook.io/docker_practice/image/multistage-builds)">[6]</span></a></sup> 中，从第1阶段的镜像中复制文件<br/><code>COPY --from=step1 /go/app .</code> 多阶段构建中，从名为 <code>step1</code> 的镜像中复制<br/></td>
</tr>
</tbody></table>
<h4 id="CMD-容器启动指令"><a href="#CMD-容器启动指令" class="headerlink" title="CMD 容器启动指令"></a>CMD 容器启动指令</h4><p>镜像启动时默认执行的指令，在启动容器时，容器后面跟其他指令，会替换默认指令</p>
<p><code>CMD</code> 指令<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[CMD 容器启动命令](https://yeasy.gitbook.io/docker_practice/image/dockerfile/cmd)">[3]</span></a></sup>的格式和 <code>RUN</code> 相似，也是两种格式：  </p>
<ul>
<li>shell 格式：<code>CMD &lt;命令&gt;</code>  </li>
<li>exec 格式：<code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code>  </li>
<li>参数列表格式：<code>CMD [&quot;参数1&quot;, &quot;参数2&quot;...]</code>。在指定了 <code>ENTRYPOINT</code> 指令后，用 <code>CMD</code> 指定具体的参数。</li>
</ul>
<p>如果使用 <code>shell</code> 格式的话，实际的命令会被包装为 <code>sh -c</code> 的参数的形式进行执行。比如：</p>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">CMD echo $HOME</span><br></pre></td></tr></table></figure>

<p>在实际执行中，会将其变更为：</p>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</span><br></pre></td></tr></table></figure>

<p>其中主进程是 <code>sh</code> 。Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 <code>systemd</code> 去启动后台服务，容器内没有后台服务的概念。  </p>
<p>比如以下指令：</p>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">CMD service nginx start</span><br></pre></td></tr></table></figure>

<p>容器执行后就会立即退出，对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。</p>
<p>而使用 <code>service nginx start</code> 或 <code>systemctl start nginx</code> 等类似命令，被理解为 <code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;systemctl start nginx&quot;]</code>，因此主进程实际上是 <code>sh</code>, 那么当 <code>systemctl start nginx</code> 命令结束后，<code>sh</code> 也就结束了，<code>sh</code> 作为主进程退出了，自然就会令容器退出。  </p>
<p>正确的做法是直接执行 <code>nginx</code> 可执行文件，并且要求以前台形式运行。比如：</p>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</span><br></pre></td></tr></table></figure>

<h4 id="ENTRYPOINT-容器启动程序指令"><a href="#ENTRYPOINT-容器启动程序指令" class="headerlink" title="ENTRYPOINT 容器启动程序指令"></a>ENTRYPOINT 容器启动程序指令</h4><p><code>ENTRYPOINT</code> 的格式和 <a href="#RUN-%E6%8C%87%E4%BB%A4"><code>RUN</code> 指令格式</a>一样，分为 <code>exec</code> 格式和 <code>shell</code> 格式。  </p>
<p><code>ENTRYPOINT</code> 的目的和 <a href="#CMD-%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%8C%87%E4%BB%A4"><code>CMD</code></a> 一样，都是在指定容器启动程序及参数。<code>ENTRYPOINT</code> 在容器启动时也可以替代，不过比 <code>CMD</code> 要略显繁琐，需要通过 <code>docker run</code> 的参数 <a href="https://csms.tech/202208041317/#运行镜像"><code>--entrypoint</code></a> 来指定。<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[ENTRYPOINT 入口点 | ENTRYPOINT 和 CMD 的不同使用场景](https://yeasy.gitbook.io/docker_practice/image/dockerfile/entrypoint)">[4]</span></a></sup>  </p>
<p>当指定了 <code>ENTRYPOINT</code> 后，<code>CMD</code> (包括 <code>Dockerfile</code> 和 <code>docker run</code> 中的 <code>CMD</code>)的含义就发生了改变，不再是直接的运行其命令，而是将 <code>CMD</code> 的内容作为参数传给 <code>ENTRYPOINT</code> 指令，即实际执行时，将变为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</span><br></pre></td></tr></table></figure>

<h4 id="ENV-设置环境变量指令"><a href="#ENV-设置环境变量指令" class="headerlink" title="ENV 设置环境变量指令"></a>ENV 设置环境变量指令</h4><p>设置环境变量，无论是后面的其它指令，如 <code>RUN</code>，还是运行时的应用，都可以直接使用这里定义的环境变量。</p>
<p>当使用生成的镜像运行容器时，使用 <code>ENV</code> 设置的环境变量将持久存在于容器内。 你可以使用 <code>docker inspect</code> 查看这些值，并使用 <code>docker run --env &lt;key&gt;=&lt;value&gt;</code> 修改它们</p>
<blockquote>
<p>环境变量持久性可能会导致意想不到的副作用。 例如，设置 <code>ENV DEBIAN_FRONTEND=noninteractive</code> 会改变 <code>apt-get</code> 的行为，并可能让使用镜像的用户感到困惑。<br>如果只在构建过程中需要环境变量，而不是在最终镜像中使用，可以使用 <a href="#ARG-%E6%9E%84%E5%BB%BA%E5%8F%82%E6%95%B0"><code>ARG</code></a>，它不会在最终镜像中持久存在</p>
</blockquote>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">ENV VERSION=1.0 DEBUG=on \</span><br><span class="line">    NAME=&quot;Happy Feet&quot;</span><br></pre></td></tr></table></figure>

<p>调用方式：</p>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">RUN echo $VERSION</span><br></pre></td></tr></table></figure>

<h4 id="ARG-构建参数"><a href="#ARG-构建参数" class="headerlink" title="ARG 构建参数"></a>ARG 构建参数</h4><p>格式：<code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code>  </p>
<p>构建参数和 <code>ENV</code> 的效果一样，都是设置环境变量。所不同的是，<code>ARG</code> 所设置的是<strong>构建环境的环境变量，在将来容器运行时是不会存在</strong>这些环境变量的。但是不要因此就使用 ARG 保存密码之类的信息，因为 <code>docker history</code> 还是可以看到所有值的。  </p>
<p><code>Dockerfile</code> 中的 <code>ARG</code> 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 <code>docker build</code> 中用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖。</p>
<p><code>ARG</code> 指令有生效范围，如果在 <code>FROM</code> 指令之前指定，那么只能用于 <code>FROM</code> 指令中。  </p>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">ARG DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line">FROM $&#123;DOCKER_USERNAME&#125;/alpine</span><br><span class="line"></span><br><span class="line">RUN set -x ; echo $&#123;DOCKER_USERNAME&#125;</span><br></pre></td></tr></table></figure>
<p>使用上述 <code>Dockerfile</code> 会发现无法输出 <code>$&#123;DOCKER_USERNAME&#125;</code> 变量的值，要想正常输出，你必须在 <code>FROM</code> 之后再次指定 <code>ARG</code>  </p>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只在 FROM 中生效</span></span><br><span class="line">ARG DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line">FROM $&#123;DOCKER_USERNAME&#125;/alpine</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">要想在 FROM 之后使用，必须再次指定</span></span><br><span class="line">ARG DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line">RUN set -x ; echo $&#123;DOCKER_USERNAME&#125;</span><br></pre></td></tr></table></figure>

<h4 id="VOLUME-定义匿名卷指令"><a href="#VOLUME-定义匿名卷指令" class="headerlink" title="VOLUME 定义匿名卷指令"></a>VOLUME 定义匿名卷指令</h4><p>容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。  </p>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">VOLUME /data</span><br></pre></td></tr></table></figure>

<p>这里的 <code>/data</code> 目录就会在容器运行时自动挂载为匿名卷，任何向 <code>/data</code> 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行容器时可以覆盖这个挂载设置。比如：  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -v mydata:/data xxxx</span><br></pre></td></tr></table></figure>

<p>在这行命令中，就使用了 <code>mydata</code> 这个命名卷挂载到了 <code>/data</code> 这个位置，替代了 <code>Dockerfile</code> 中定义的匿名卷的挂载配置。  </p>
<h4 id="EXPOSE-暴露端口指令"><a href="#EXPOSE-暴露端口指令" class="headerlink" title="EXPOSE 暴露端口指令"></a>EXPOSE 暴露端口指令</h4><p>格式为 <code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code>。</p>
<p><code>EXPOSE</code> 指令是声明容器运行时提供服务的端口，这<strong>只是一个声明</strong>，在容器运行时并<strong>不会因为这个声明，应用就会开启这个端口</strong>的服务。在 <code>Dockerfile</code> 中写入这样的声明有两个好处:</p>
<ul>
<li>一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；</li>
<li>另一个用处则是在运行时使用随机端口映射时，也就是 <code>docker run -P</code> 时，会自动随机映射 <code>EXPOSE</code> 的端口。</li>
</ul>
<p>要将 <code>EXPOSE</code> 和在运行时使用 <code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 区分开来。<code>-p</code>，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 <code>EXPOSE</code> 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p>
<h4 id="WORKDIR-指定工作目录指令"><a href="#WORKDIR-指定工作目录指令" class="headerlink" title="WORKDIR 指定工作目录指令"></a>WORKDIR 指定工作目录指令</h4><p>格式为 <code>WORKDIR &lt;工作目录路径&gt;</code>。  </p>
<p>使用 <code>WORKDIR</code> 指令可以来指定工作目录（或者称为当前目录），<strong>以后各层</strong>的当前目录就被改为指定的目录，如该目录不存在，<code>WORKDIR</code> 会帮你建立目录。  </p>
<p>如果 <code>WORKDIR</code> 指令使用的是<code>相对路径</code>，那么所切换的路径与之前的 <code>WORKDIR</code> 有关</p>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">WORKDIR /a</span><br><span class="line">WORKDIR b</span><br><span class="line">WORKDIR c</span><br><span class="line"></span><br><span class="line">RUN pwd</span><br></pre></td></tr></table></figure>

<p><code>RUN pwd</code> 的工作目录为 &#x2F;a&#x2F;b&#x2F;c。</p>
<h4 id="USER-指定当前用户指令"><a href="#USER-指定当前用户指令" class="headerlink" title="USER 指定当前用户指令"></a>USER 指定当前用户指令</h4><p>格式：<code>USER &lt;用户名&gt;[:&lt;用户组&gt;]</code></p>
<p><code>USER</code> 指令和 <a href="#WORKDIR-%E6%8C%87%E5%AE%9A%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%E6%8C%87%E4%BB%A4"><code>WORKDIR</code></a> 相似，都是改变环境状态并影响以后的层。<code>WORKDIR</code> 是改变工作目录，<code>USER</code> 则是改变之后层的执行 <code>RUN</code>, <code>CMD</code> 以及 <code>ENTRYPOINT</code> 这类命令的身份。 <code>USER</code> 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。</p>
<h4 id="HEALTHCHECK-健康状态检查命令"><a href="#HEALTHCHECK-健康状态检查命令" class="headerlink" title="HEALTHCHECK 健康状态检查命令"></a>HEALTHCHECK 健康状态检查命令</h4><p>格式：<br><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>：设置检查容器健康状况的命令 <sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[HEALTHCHECK 健康检查](https://yeasy.gitbook.io/docker_practice/image/dockerfile/healthcheck)">[5]</span></a></sup><br><code>HEALTHCHECK NONE</code>：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令  </p>
<p>HEALTHCHECK 支持下列选项：</p>
<style>
table th:nth-of-type(1){
width: 15%;
}
table th:nth-of-type(2){
width: 40%;
}
table th:nth-of-type(3){
width: 35%;
}
</style>

<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>--interval=&lt;30s&gt;</code></td>
<td>两次健康检查的间隔，默认为 30 秒</td>
<td></td>
</tr>
<tr>
<td><code>--timeout=&lt;30s&gt;</code></td>
<td>健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；</td>
<td></td>
</tr>
<tr>
<td><code>--retries=&lt;次数&gt;</code></td>
<td>当连续失败指定次数后，则将容器状态视为 <code>unhealthy</code>，默认 3 次。</td>
<td></td>
</tr>
</tbody></table>
<p>当在一个镜像指定了 <code>HEALTHCHECK</code> 指令后，用其启动容器，初始状态会为 <code>starting</code>，在 <code>HEALTHCHECK</code> 指令检查成功后变为 <code>healthy</code>，如果连续一定次数失败，则会变为 <code>unhealthy</code>。  </p>
<p>和 <code>CMD</code>, <code>ENTRYPOINT</code> 一样，<code>HEALTHCHECK</code> 只可以出现一次，如果写了多个，只有最后一个生效。  </p>
<p>在 <code>HEALTHCHECK [选项] CMD</code> 后面的命令，格式和 <code>ENTRYPOINT</code> 一样，分为 <code>shell</code> 格式，和 <code>exec</code> 格式。命令的返回值决定了该次健康检查的成功与否：  </p>
<ul>
<li>0：成功；</li>
<li>1：失败；</li>
<li>2：保留，不要使用这个值。</li>
</ul>
<p>假设我们有个镜像是个最简单的 Web 服务，我们希望增加健康检查来判断其 Web 服务是否在正常工作，我们可以用 <code>curl</code> 来帮助判断，其 <code>Dockerfile</code> 的 <code>HEALTHCHECK</code> 可以这么写：  </p>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN yum install -y curl &amp;&amp; yum clean all</span><br><span class="line">HEALTHCHECK --interval=5s --timeout=3s CMD \</span><br><span class="line">  curl -fs http://localhost/ || exit 1</span><br></pre></td></tr></table></figure>

<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://yeasy.gitbook.io/docker_practice/">docker 从入门到实践</a>  </p>
<h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://yeasy.gitbook.io/docker_practice/image/build">使用 Dockerfile 定制镜像</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/copy">COPY 复制文件</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/cmd">CMD 容器启动命令</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/entrypoint">ENTRYPOINT 入口点 | ENTRYPOINT 和 CMD 的不同使用场景</a><a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/healthcheck">HEALTHCHECK 健康检查</a><a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://yeasy.gitbook.io/docker_practice/image/multistage-builds">Dockerfile 多阶段构建</a><a href="#fnref:6" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo Next 安装部署及配置示例</title>
    <url>/202207241754/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Hexo 6.2.0</li>
<li>Next 8.12.2</li>
</ul>
<blockquote>
<p>Hexo 查看版本方式： <code>npm list</code><br>Next 版本信息可在文件 <code>themes/next/package.json </code> 中查看</p>
</blockquote>
<span id="more"></span>

<h1 id="Hexo-常用配置"><a href="#Hexo-常用配置" class="headerlink" title="Hexo 常用配置"></a>Hexo 常用配置</h1><h2 id="首页按照更新时间排序"><a href="#首页按照更新时间排序" class="headerlink" title="首页按照更新时间排序"></a>首页按照更新时间排序</h2><p>更改主配置文件 <code>_config.yml</code> 中的以下部分(<code>index_generator.order_by</code>):  </p>
<figure class="highlight shell"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">index_generator:</span><br><span class="line">  path: &#x27;&#x27;</span><br><span class="line">  per_page: 10</span><br><span class="line">  order_by: -updated</span><br></pre></td></tr></table></figure>

<h2 id="代码块不显示行号"><a href="#代码块不显示行号" class="headerlink" title="代码块不显示行号"></a>代码块不显示行号</h2><p>更改 <code>Hexo</code> 配置文件 <code>_config.yml</code>，修改以下配置</p>
<figure class="highlight shell"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">highlight:</span><br><span class="line">  enable: true</span><br><span class="line">  line_number: false </span><br></pre></td></tr></table></figure>

<p>将 <code>line_number</code> 值改为 <code>false</code></p>
<h2 id="配置站点地图"><a href="#配置站点地图" class="headerlink" title="配置站点地图"></a>配置站点地图</h2><p>通过设置站点地图( sitemap )，可以让搜索引擎获取你的页面信息，这样可以增加别人搜索到你的几率，具体配置参考官网步骤<br><a href="https://hexo-next.readthedocs.io/zh_CN/latest/next/advanced/Baidu-Google-%E7%AB%99%E7%82%B9%E5%9C%B0%E5%9B%BE/">官网说明</a></p>
<h1 id="Next-主题常用配置"><a href="#Next-主题常用配置" class="headerlink" title="Next 主题常用配置"></a>Next 主题常用配置</h1><h2 id="调整页面显示宽度"><a href="#调整页面显示宽度" class="headerlink" title="调整页面显示宽度"></a>调整页面显示宽度</h2><p>针对 Next 中的主题方案<code>Pisces</code>或<code>Gemini</code>, 更改 Next 主题中的文件 <code>themes/next/source/css/_variables/Pisces.styl</code> <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[官网说明](https://hexo-next.readthedocs.io/zh_CN/latest/next/advanced/%E8%B0%83%E6%95%B4%E9%A1%B5%E9%9D%A2%E5%AE%BD%E5%BA%A6/)">[1]</span></a></sup> </p>
<figure class="highlight shell"><figcaption><span>Pisces.styl</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">content-desktop-large        = 90em;</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">content-desktop-largest      = 90%;</span></span><br></pre></td></tr></table></figure>

<h2 id="启用-gitalk-评论系统"><a href="#启用-gitalk-评论系统" class="headerlink" title="启用 gitalk 评论系统"></a>启用 gitalk 评论系统</h2><p>具体配置 <a href="https://www.cnblogs.com/qisi007/p/13731562.html">参考文章</a></p>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://hexo-next.readthedocs.io/zh_CN/latest/next/advanced/%E8%B0%83%E6%95%B4%E9%A1%B5%E9%9D%A2%E5%AE%BD%E5%BA%A6/">官网说明</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.cnblogs.com/ywang-wnlo/p/16110411.html">Next 主题配置记录</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo markdown常用语法</title>
    <url>/2215beeb/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="url-链接"><a href="#url-链接" class="headerlink" title="url 链接"></a>url 链接</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[这是一个链接](https://csms.tech [title])</span><br></pre></td></tr></table></figure>
<p><a href="https://csms.tech/">这是一个链接</a></p>
<h3 id="图片链接"><a href="#图片链接" class="headerlink" title="图片链接"></a>图片链接</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![图片名称](https://i.csms.tech/img_10.png [title])</span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_10.png" alt="图片名称"></p>
<span id="more"></span>

<h3 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;https://csms.tech&gt;</span><br></pre></td></tr></table></figure>
<p><a href="https://csms.tech/">https://csms.tech</a><br><a href="https://csms.tech/">https://csms.tech</a></p>
<h3 id="链接到文章内的标题"><a href="#链接到文章内的标题" class="headerlink" title="链接到文章内的标题"></a>链接到文章内的标题</h3><p><code>Hexo</code> 会自动为各个层级的标题添加锚点，锚点 id 为标题名称，如果标题名称中有 <code>空格</code>、<code>)</code>、<code>(</code>，会被替换成<code>-</code>，多个空格合并成一个。如果标题开头中包含 <code>/</code>，会被替换成 <code>x2F-</code>，如果标题中间出现 <code>/</code>，会被替换成 <code>-x2F-</code>。要查看标签的具体值，也可以通过查看网页源代码的方式查找对应 id 。使用示例如下</p>
<table>
<thead>
<tr>
<th>标题</th>
<th>锚点 id</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>### 三级标题</td>
<td><code>id=&quot;三级标题&quot;</code></td>
<td></td>
</tr>
<tr>
<td>### this is  title</td>
<td><code>id=&quot;this-is-title&quot;</code></td>
<td>多个空格会合并成一个</td>
</tr>
<tr>
<td>### &#x2F;home&#x2F;dir</td>
<td><code>id=&quot;x2F-home-x2F-dir&quot;</code></td>
<td></td>
</tr>
</tbody></table>
<p>在文章中要跳转到指定的锚点，可以使用以下方式：  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[这是一个锚点](#this-is-title)</span><br></pre></td></tr></table></figure>

<h3 id="链接到本站其他文章的指定标题"><a href="#链接到本站其他文章的指定标题" class="headerlink" title="链接到本站其他文章的指定标题"></a>链接到本站其他文章的指定标题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[名称](https://csms.tech&#123;% post_path &#x27;文章文件名&#x27; %&#125;#id)</span><br></pre></td></tr></table></figure>
<p><code>&#123;% post_path 'Hexo-markdown-grammar' %&#125;</code> 的值为： <code>/2022/07/Hexo-markdown-grammar/</code><br><a href="https://csms.tech/2215beeb/#图片链接">跳转</a></p>
<h3 id="链接到标题之外的锚点"><a href="#链接到标题之外的锚点" class="headerlink" title="链接到标题之外的锚点"></a>链接到标题之外的锚点</h3><p>可以使用html标签先创建对应锚点，如<code>&lt;div id=&#39;1&#39;&gt;这是一个文章锚点&lt;/div&gt;</code></p>
<div id='1'>这是一个文章锚点</div>

<p><a href="#1">跳转到id&#x3D;1的锚点</a></p>
<h3 id="站内文章链接"><a href="#站内文章链接" class="headerlink" title="站内文章链接"></a>站内文章链接</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% post_link &#x27;文章文件名&#x27; [&#x27;显示的名称, 默认为文章title&#x27;] %&#125;</span><br></pre></td></tr></table></figure>
<p>本篇文章 <a href="/2215beeb/" title="hexo markdown常用语法">hexo markdown常用语法</a></p>
<h3 id="note标签"><a href="#note标签" class="headerlink" title="note标签"></a>note标签</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;% note class %&#125;</span><br><span class="line">文本内容 (支持行内标签)</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
<p>支持的class包括：<code>default</code> <code>primary</code> <code>success</code> <code>info</code> <code>warning</code> <code>danger</code></p>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><figure class="highlight shell"><figcaption><span>代码块示例</span><a href="https://csms.tech">主页</a></figcaption><table><tr><td class="code"><pre><span class="line">```shell name url urlshowname</span><br><span class="line">log-bin=binlog</span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| title1 | title2  | title3 |</span><br><span class="line">|:------|:-------:|-------:|</span><br><span class="line">| 第1列 |第2列     |第3列  |</span><br><span class="line">|左对齐| 居中对齐   | 右对齐|</span><br><span class="line">| 竖线 &amp;#124; |竖线 &amp;#x7C; |</span><br><span class="line">|Hexo中竖线使用 `\|`||</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="left">title1</th>
<th align="center">title2</th>
<th align="right">title3</th>
</tr>
</thead>
<tbody><tr>
<td align="left">第1列</td>
<td align="center">第2列</td>
<td align="right">第3列</td>
</tr>
<tr>
<td align="left">左对齐</td>
<td align="center">居中对齐</td>
<td align="right">右对齐</td>
</tr>
<tr>
<td align="left">竖线 <code>&amp;#124;</code></td>
<td align="center">竖线 <code>&amp;#x7C;</code></td>
<td align="right"></td>
</tr>
<tr>
<td align="left">Hexo中竖线使用 <code>|</code></td>
<td align="center"></td>
<td align="right"></td>
</tr>
</tbody></table>
<blockquote>
<p>要在表格中使用<code>|</code>, 可用以下2中之一代替</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&amp;#124;</span><br><span class="line">&amp;#x7C;</span><br></pre></td></tr></table></figure>
<p>Hexo 表格中需要使用 <code>\|</code> 方式输出 <code>|</code></p>
</blockquote>
<p>设置表格宽度，在表格之前使用以下 <code>style</code>：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line"><span class="selector-tag">table</span> <span class="selector-tag">th</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">10%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">table</span> <span class="selector-tag">th</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">2</span>)&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">70%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">table</span> <span class="selector-tag">th</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">3</span>)&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">20%</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">table th:nth-of-type(1)&#123;</span><br><span class="line">width: 10%;</span><br><span class="line">&#125;</span><br><span class="line">table th:nth-of-type(2)&#123;</span><br><span class="line">width: 70%;</span><br><span class="line">&#125;</span><br><span class="line">table th:nth-of-type(3)&#123;</span><br><span class="line">width: 20%;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">| 选项      | 说明    |示例|</span><br><span class="line">|:--------|--------|---|</span><br><span class="line">|第一列：10%|第二列：70%|第三列：20%|</span><br></pre></td></tr></table></figure>

<p>以上输出显示效果如下：</p>
<style>
table th:nth-of-type(1){
width: 10%;
}
table th:nth-of-type(2){
width: 70%;
}
table th:nth-of-type(3){
width: 20%;
}
</style>

<table>
<thead>
<tr>
<th align="left">选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">第一列：10%</td>
<td>第二列：70%</td>
<td>第三列：20%</td>
</tr>
</tbody></table>
<blockquote>
<p>一个文档中出现多次，以最后一个 <code>style</code> 配置为最终效果</p>
</blockquote>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://hexo.io/zh-cn/docs/writing">Hexo Markdown 语法手册</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql 从库提升为主库，原来的其他从库成为新的主库的从库</title>
    <url>/b12589a5/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Mysql 5.7</li>
</ul>
<h3 id="场景说明"><a href="#场景说明" class="headerlink" title="场景说明"></a>场景说明</h3><p>Mysql 一主多从的情况下，主库宕机（或其他无法使用的情况），将其中一台从库提升为主库，同时将原来其他的从库配置为新的主库的从库。  </p>
<blockquote>
<p>主从恢复正常之前，数据库不应该有新的数据写入</p>
</blockquote>
<span id="more"></span>

<h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><h4 id="确保所有从库已经执行了relay-log中的全部更新"><a href="#确保所有从库已经执行了relay-log中的全部更新" class="headerlink" title="确保所有从库已经执行了relay log中的全部更新"></a>确保所有从库已经执行了relay log中的全部更新</h4><p>登录mysql从库，在每个从库上，执行<code>stop slave io_thread</code>,停止IO线程, 通过以下2个命令之一检查从库relay log的执行情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">show processlist;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_6.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">show slave status\G</span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_7.png">  </p>
<p>当输出中<code>Slave_SQL_Running_State</code> 为 <code>Slave has read all relay log; waiting for more updates</code>，表示更新都执行完毕。  </p>
<blockquote>
<ul>
<li>正常情况下，此时在每个从库上面查看slave状态(<code>show slave status\G</code>), 每个从库读取的主库的<code>Master_Log_File</code>和<code>Read_Master_Log_Pos</code>都应该是一样的，意味着所有的从库都已经更新到了主库宕机时的状态。此种情况下，可随便选择从库作为新的主库。<br><img src="https://i.csms.tech/img_8.png"></li>
<li>如果，从库上面查看slave状态，各个从库读取的主库的<code>Master_Log_File</code>和<code>Read_Master_Log_Pos</code>不一致，说明主库宕机之前各个从库和主库的主从延迟情况可能不一，导致各个从库的状态不一致，此种情况下，从数据完整性的角度考虑，应该选择position最大的一个从库，作为新选定的主库。对其他从库，应该通过从binlog中读取缺失的数据，补足数据。或者直接通过<a href="/94ee2c23/" title="备份恢复">备份恢复</a>的方式，和新选定的主库，重新建立主从连接。</li>
</ul>
</blockquote>
<h4 id="更新新的主库的配置"><a href="#更新新的主库的配置" class="headerlink" title="更新新的主库的配置"></a>更新新的主库的配置</h4><p>在新选定的主库上，配置文件(默认<code>/etc/my.cnf</code>)中开启binlog，如已配置，跳过</p>
<figure class="highlight shell"><figcaption><span>/etc/my.cnf</span></figcaption><table><tr><td class="code"><pre><span class="line">log-bin=mysql-bin</span><br></pre></td></tr></table></figure>
<p>新选定的主库上，如果配置了readonly，在配置文件(默认<code>/etc/my.cnf</code>)中取消readonly配置</p>
<figure class="highlight shell"><figcaption><span>/etc/my.cnf</span></figcaption><table><tr><td class="code"><pre><span class="line">read_only=0</span><br></pre></td></tr></table></figure>
<blockquote>
<p>更改mysql配置文件后，重启mysql生效</p>
</blockquote>
<p>在新选定的主库上，执行以下命令，重置从库配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">stop slave;  </span><br><span class="line">reset master;</span><br><span class="line">reset slave all;  </span><br></pre></td></tr></table></figure>
<p>在新选定的主库上，执行以下命令，创建具有同步权限的账号，如果已存在，跳过</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grant replication slave on *.* to &#x27;repl&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
<p>在新选定的主库上，执行以下命令，查看当前主库的master位置信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">show master status\G</span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_9.png"></p>
<blockquote>
<p>在主从重新建立之前，不应该有新的数据写入数据库，在此前提之下，多次查看master status，显示的<code>File</code>和<code>Position</code> 应该是确定不变的值，后续可根据此值，让其他从库和新选定的主库建立主从连接。  </p>
</blockquote>
<h4 id="建立新的主从"><a href="#建立新的主从" class="headerlink" title="建立新的主从"></a>建立新的主从</h4><p>在其他从库上，执行以下命令，和新选定的主库，建立主从连接，其中需要的<code>master_log_file</code>和<code>master_log_pos</code>从<a href="#%E6%9B%B4%E6%96%B0%E6%96%B0%E7%9A%84%E4%B8%BB%E5%BA%93%E7%9A%84%E9%85%8D%E7%BD%AE">上一步</a>中获得。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">stop slave;</span><br><span class="line">change master to master_host=&#x27;1.1.1.1&#x27;,master_user=&#x27;repl&#x27;,master_password=&#x27;123456&#x27;,master_port=3306,master_log_file=&#x27;mysql-bin.000982&#x27;,master_log_pos=638932979;</span><br><span class="line">start slave</span><br></pre></td></tr></table></figure>

<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3>]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Spinnaker 安装配置</title>
    <url>/202210121639/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos-7 3.10.0-1160</li>
<li>Docker Engine 19.03.15</li>
<li>Kubernetes 1.21.2</li>
</ul>
<blockquote>
<p><strong>本文档中涉及服务器的操作，都是在 Kubernetes 集群的 Master 节点上进行。如果在其他服务器启动 Halyard 容器，需要确保容器中可以访问到 Kubernetes 集群的 API Server</strong></p>
</blockquote>
<h1 id="安装部署步骤"><a href="#安装部署步骤" class="headerlink" title="安装部署步骤"></a>安装部署步骤</h1><h2 id="Install-Halyard-on-Docker-and-Choose-Cloud-Providers-Kubernetes"><a href="#Install-Halyard-on-Docker-and-Choose-Cloud-Providers-Kubernetes" class="headerlink" title="Install Halyard on Docker and Choose Cloud Providers - Kubernetes"></a>Install Halyard on Docker and Choose Cloud Providers - Kubernetes</h2><h3 id="宿主机准备容器数据目录"><a href="#宿主机准备容器数据目录" class="headerlink" title="宿主机准备容器数据目录"></a>宿主机准备容器数据目录</h3><p>宿主机创建 local Halyard config directory <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Install Halyard on Docker](https://spinnaker.io/docs/setup/install/halyard/#install-halyard-on-docker)">[1]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /root/spinnaker_data</span><br><span class="line">mkdir /root/spinnaker_data/.kube</span><br><span class="line">mkdir /root/spinnaker_data/.hal</span><br></pre></td></tr></table></figure>
<p>Spinnaker 的部署配置会写入容器目录 <code>/home/spinnaker/.hal</code>，将此配置映射到宿主机，可保证配置持久化。</p>
<p>拷贝 Kubernetes 集群管理配置文件到 <code>/root/spinnaker_data/.kube/config</code> <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[You need a Kubernetes cluster and its credentials](https://spinnaker.io/docs/setup/install/providers/kubernetes/#you-need-a-kubernetes-cluster-and-its-credentials)">[2]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /etc/kubernetes/admin.conf /root/spinnaker_data/.kube/config</span><br><span class="line">chmod 777 /root/spinnaker_data/.kube/config</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h3 id="启动-Halyard-容器"><a href="#启动-Halyard-容器" class="headerlink" title="启动 Halyard 容器"></a>启动 Halyard 容器</h3><p>启动 Halyard 容器，并挂载 Halyard 本地配置目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run  \</span><br><span class="line">    --name halyard --rm \</span><br><span class="line">    -v /root/spinnaker_data/.hal:/home/spinnaker/.hal \</span><br><span class="line">    -v /root/spinnaker_data/.kube:/home/spinnaker/.kube \</span><br><span class="line">    -it \</span><br><span class="line">    us-docker.pkg.dev/spinnaker-community/docker/halyard:stable</span><br></pre></td></tr></table></figure>

<h3 id="配置-Spinnaker-关联-Kubernetes-集群"><a href="#配置-Spinnaker-关联-Kubernetes-集群" class="headerlink" title="配置 Spinnaker 关联 Kubernetes 集群"></a>配置 Spinnaker 关联 Kubernetes 集群</h3><h4 id="配置并验证-Halyard-容器可以和-kubernetes-Api-Server-通信"><a href="#配置并验证-Halyard-容器可以和-kubernetes-Api-Server-通信" class="headerlink" title="配置并验证 Halyard 容器可以和 kubernetes Api Server 通信"></a>配置并验证 Halyard 容器可以和 kubernetes Api Server 通信</h4><p>进入 Halyard 容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it halyard bash</span><br></pre></td></tr></table></figure>
<p>修改 <code>/home/spinnaker/.kube/config</code>，将配置中的 Kubernetes API Server 改为正确的 IP </p>
<figure class="highlight shell"><figcaption><span>/home/spinnaker/.kube/config</span></figcaption><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">clusters:</span><br><span class="line">- cluster:</span><br><span class="line">    certificate-authority-data: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUM1ekNDQWMrZ0F3SUJBZ0lCQURBTkJna3Foa2lHOXcwQk</span><br><span class="line">    server: https://10.150.0.21:6443</span><br><span class="line">  name: kubernetes</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p>进入 Halyard 容器，验证 Halyard 容器可以和 Kubernetes API Server 通信：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">exec</span> -it halyard bash</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get nodes</span></span><br><span class="line">NAME                  STATUS   ROLES                  AGE   VERSION</span><br><span class="line">k8s-master   Ready    control-plane,master   24h   v1.21.2</span><br><span class="line">k8s-work1    Ready    &lt;none&gt;                 24h   v1.21.2</span><br><span class="line">k8s-work2    Ready    &lt;none&gt;                 24h   v1.21.2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="启用-Cloud-Provider-kubernetes"><a href="#启用-Cloud-Provider-kubernetes" class="headerlink" title="启用 Cloud Provider : kubernetes"></a>启用 Cloud Provider : kubernetes</h4><p>在 Halyard 容器中，执行以下命令，启用 Cloud Provider : kubernetes <sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Adding an account](https://spinnaker.io/docs/setup/install/providers/kubernetes-v2/#adding-an-account)">[3]</span></a></sup>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hal config provider kubernetes <span class="built_in">enable</span></span></span><br><span class="line">+ Get current deployment</span><br><span class="line">  Success</span><br><span class="line">+ Edit the kubernetes provider</span><br><span class="line">  Success</span><br><span class="line">Validation in default:</span><br><span class="line">- WARNING You have not yet selected a version of Spinnaker to</span><br><span class="line">  deploy.</span><br><span class="line">? Options include: </span><br><span class="line">  - 1.29.0</span><br><span class="line">  - 1.28.1</span><br><span class="line">  - 1.27.1</span><br><span class="line">  - 1.26.7</span><br><span class="line"></span><br><span class="line">Validation in default.provider.kubernetes:</span><br><span class="line">- WARNING Provider kubernetes is enabled, but no accounts have been</span><br><span class="line">  configured.</span><br><span class="line"></span><br><span class="line">+ Successfully enabled kubernetes</span><br></pre></td></tr></table></figure>
<h4 id="添加-kubernetes-账号"><a href="#添加-kubernetes-账号" class="headerlink" title="添加 kubernetes 账号"></a>添加 kubernetes 账号</h4><p>在 Halyard 容器中，执行以下命令，添加账号 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">CONTEXT=$(kubectl config current-context)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hal config provider kubernetes account add my-k8s-account --context <span class="variable">$CONTEXT</span></span></span><br><span class="line">+ Get current deployment</span><br><span class="line">  Success</span><br><span class="line">+ Add the my-k8s-account account</span><br><span class="line">  Success</span><br><span class="line">Validation in default:</span><br><span class="line">- WARNING You have not yet selected a version of Spinnaker to</span><br><span class="line">  deploy.</span><br><span class="line">? Options include: </span><br><span class="line">  - 1.29.0</span><br><span class="line">  - 1.28.1</span><br><span class="line">  - 1.27.1</span><br><span class="line">  - 1.26.7</span><br><span class="line"></span><br><span class="line">+ Successfully added account my-k8s-account for provider</span><br><span class="line">  kubernetes.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Choose-Environment"><a href="#Choose-Environment" class="headerlink" title="Choose Environment"></a>Choose Environment</h2><p>选择如何安装 Spinnaker，此处选择 <code>Distributed installation on Kubernetes</code> <sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Choose your Environment](https://spinnaker.io/docs/setup/install/environment/)">[4]</span></a></sup></p>
<p>在 Halyard 容器中，执行以下命令，配置 <code>Distributed installation on Kubernetes</code>，其中 <code>--account-name</code> 的值为 <a href="#%E6%B7%BB%E5%8A%A0-kubernetes-%E8%B4%A6%E5%8F%B7">添加 kubernetes 账号</a> 中指定的名称</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hal config deploy edit --<span class="built_in">type</span> distributed --account-name my-k8s-account</span></span><br><span class="line"></span><br><span class="line">+ Get current deployment</span><br><span class="line">  Success</span><br><span class="line">+ Get the deployment environment</span><br><span class="line">  Success</span><br><span class="line">+ Edit the deployment environment</span><br><span class="line">  Success</span><br><span class="line">Validation in default:</span><br><span class="line">- WARNING You have not yet selected a version of Spinnaker to</span><br><span class="line">  deploy.</span><br><span class="line">? Options include: </span><br><span class="line">  - 1.29.0</span><br><span class="line">  - 1.28.1</span><br><span class="line">  - 1.27.1</span><br><span class="line">  - 1.26.7</span><br><span class="line"></span><br><span class="line">+ Successfully updated your deployment environment.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="External-Storage"><a href="#External-Storage" class="headerlink" title="External Storage"></a>External Storage</h2><p>外部存储用来持久化 Spinnaker 的配置数据 <sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[External Storage](https://spinnaker.io/docs/setup/install/storage/)">[5]</span></a></sup></p>
<p>在 Halyard 容器中，执行以下命令，配置 AWS S3 连接信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hal config storage s3 edit \</span></span><br><span class="line"><span class="language-bash">    --access-key-id <span class="variable">$YOUR_ACCESS_KEY_ID</span> \</span></span><br><span class="line"><span class="language-bash">    --secret-access-key \</span></span><br><span class="line"><span class="language-bash">    --region <span class="variable">$REGION</span> \</span></span><br><span class="line"><span class="language-bash">    --bucket <span class="variable">$BUCKET</span></span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Your AWS Secret Key.: </span><br><span class="line">+ Get current deployment</span><br><span class="line">  Success</span><br><span class="line">+ Get persistent store</span><br><span class="line">  Success</span><br><span class="line">+ Edit persistent store</span><br><span class="line">  Success</span><br><span class="line">Validation in default.persistentStorage:</span><br><span class="line">- WARNING Your deployment will most likely fail until you configure</span><br><span class="line">  and enable a persistent store.</span><br><span class="line"></span><br><span class="line">Validation in default:</span><br><span class="line">- WARNING You have not yet selected a version of Spinnaker to</span><br><span class="line">  deploy.</span><br><span class="line">? Options include: </span><br><span class="line">  - 1.29.0</span><br><span class="line">  - 1.28.1</span><br><span class="line">  - 1.27.1</span><br><span class="line">  - 1.26.7</span><br><span class="line"></span><br><span class="line">+ Successfully edited persistent store &quot;s3&quot;.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在 Halyard 容器中，执行以下命令，配置存储源为 AWS S3</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hal config storage edit --<span class="built_in">type</span> s3</span></span><br><span class="line">+ Get current deployment</span><br><span class="line">  Success</span><br><span class="line">+ Get persistent storage settings</span><br><span class="line">  Success</span><br><span class="line">+ Edit persistent storage settings</span><br><span class="line">  Success</span><br><span class="line">Validation in default:</span><br><span class="line">- WARNING You have not yet selected a version of Spinnaker to</span><br><span class="line">  deploy.</span><br><span class="line">? Options include: </span><br><span class="line">  - 1.29.0</span><br><span class="line">  - 1.28.1</span><br><span class="line">  - 1.27.1</span><br><span class="line">  - 1.26.7</span><br><span class="line"></span><br><span class="line">+ Successfully edited persistent storage.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Deploy-Spinnaker"><a href="#Deploy-Spinnaker" class="headerlink" title="Deploy Spinnaker"></a>Deploy Spinnaker</h2><p>部署 Spinnaker，并连接 Deck <sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Deploy Spinnaker and Connect to the UI](https://spinnaker.io/docs/setup/install/deploy/)">[6]</span></a></sup></p>
<h3 id="Deploy-Spinnaker-1"><a href="#Deploy-Spinnaker-1" class="headerlink" title="Deploy Spinnaker"></a>Deploy Spinnaker</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看可用的版本</span><br><span class="line">$ hal version list</span><br><span class="line"></span><br><span class="line"># 指定要部署的版本</span><br><span class="line">$ hal config version edit --version 1.29.0</span><br><span class="line"></span><br><span class="line"># 执行部署</span><br><span class="line">$ hal deploy apply</span><br><span class="line"></span><br><span class="line">+ Get current deployment</span><br><span class="line">  Success</span><br><span class="line">+ Prep deployment</span><br><span class="line">  Success</span><br><span class="line">Validation in default.stats:</span><br><span class="line">- INFO Stats are currently ENABLED. Usage statistics are being</span><br><span class="line">  collected. Thank you! These stats inform improvements to the product, and that</span><br><span class="line">  helps the community. To disable, run `hal config stats disable`. To learn more</span><br><span class="line">  about what and how stats data is used, please see</span><br><span class="line">  https://spinnaker.io/docs/community/stay-informed/stats.</span><br><span class="line"></span><br><span class="line">Validation in default.security:</span><br><span class="line">- WARNING Your UI or API domain does not have override base URLs</span><br><span class="line">  set even though your Spinnaker deployment is a Distributed deployment on a</span><br><span class="line">  remote cloud provider. As a result, you will need to open SSH tunnels against</span><br><span class="line">  that deployment to access Spinnaker.</span><br><span class="line">? We recommend that you instead configure an authentication</span><br><span class="line">  mechanism (OAuth2, SAML2, or x509) to make it easier to access Spinnaker</span><br><span class="line">  securely, and then register the intended Domain and IP addresses that your</span><br><span class="line">  publicly facing services will be using.</span><br><span class="line"></span><br><span class="line">+ Preparation complete... deploying Spinnaker</span><br><span class="line">+ Get current deployment</span><br><span class="line">  Success</span><br><span class="line">- Apply deployment</span><br><span class="line">_ Apply deployment</span><br><span class="line">^ Apply deployment</span><br><span class="line">* Apply deployment</span><br><span class="line">_ Apply deployment</span><br><span class="line">+ Apply deployment</span><br><span class="line">  Success</span><br><span class="line">+ Deploy spin-redis</span><br><span class="line">  Success</span><br><span class="line">+ Deploy spin-clouddriver</span><br><span class="line">  Success</span><br><span class="line">+ Deploy spin-front50</span><br><span class="line">  Success</span><br><span class="line">+ Deploy spin-orca</span><br><span class="line">  Success</span><br><span class="line">+ Deploy spin-deck</span><br><span class="line">  Success</span><br><span class="line">+ Deploy spin-echo</span><br><span class="line">  Success</span><br><span class="line">+ Deploy spin-gate</span><br><span class="line">  Success</span><br><span class="line">+ Deploy spin-rosco</span><br><span class="line">  Success</span><br><span class="line">+ Run `hal deploy connect` to connect to Spinnaker.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用 kubernetes 做为 Cloud Provider，选择分布式部署后，会在 kubernetes 集群中创建命名空间：<code>spinnaker</code>，并创建相关的 <code>Deployment</code>，<code>Service</code> 等资源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get deployment,services,pods -n spinnaker</span></span><br><span class="line">NAME                               READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">deployment.apps/spin-clouddriver   1/1     1            1           33m</span><br><span class="line">deployment.apps/spin-deck          1/1     1            1           33m</span><br><span class="line">deployment.apps/spin-echo          1/1     1            1           33m</span><br><span class="line">deployment.apps/spin-front50       1/1     1            1           33m</span><br><span class="line">deployment.apps/spin-gate          1/1     1            1           33m</span><br><span class="line">deployment.apps/spin-orca          1/1     1            1           33m</span><br><span class="line">deployment.apps/spin-redis         1/1     1            1           33m</span><br><span class="line">deployment.apps/spin-rosco         1/1     1            1           33m</span><br><span class="line"></span><br><span class="line">NAME                       TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE</span><br><span class="line">service/spin-clouddriver   ClusterIP   10.103.217.2     &lt;none&gt;        7002/TCP   33m</span><br><span class="line">service/spin-deck          ClusterIP   10.100.138.37    &lt;none&gt;        9000/TCP   33m</span><br><span class="line">service/spin-echo          ClusterIP   10.109.141.10    &lt;none&gt;        8089/TCP   33m</span><br><span class="line">service/spin-front50       ClusterIP   10.97.63.108     &lt;none&gt;        8080/TCP   33m</span><br><span class="line">service/spin-gate          ClusterIP   10.107.160.202   &lt;none&gt;        8084/TCP   33m</span><br><span class="line">service/spin-orca          ClusterIP   10.101.53.110    &lt;none&gt;        8083/TCP   33m</span><br><span class="line">service/spin-redis         ClusterIP   10.97.51.27      &lt;none&gt;        6379/TCP   33m</span><br><span class="line">service/spin-rosco         ClusterIP   10.96.45.179     &lt;none&gt;        8087/TCP   33m</span><br><span class="line"></span><br><span class="line">NAME                                    READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/spin-clouddriver-7b8d55598c-cnzbz   1/1     Running   0          33m</span><br><span class="line">pod/spin-deck-64bb7f4b7-mpvpr           1/1     Running   0          33m</span><br><span class="line">pod/spin-echo-645cdd8749-l2krj          1/1     Running   0          33m</span><br><span class="line">pod/spin-front50-5d84b48775-7j462       1/1     Running   0          33m</span><br><span class="line">pod/spin-gate-64589485b-cxpkh           1/1     Running   0          33m</span><br><span class="line">pod/spin-orca-7f665ccdcb-4cnvg          1/1     Running   0          33m</span><br><span class="line">pod/spin-redis-55b7dd654c-q9d8k         1/1     Running   0          33m</span><br><span class="line">pod/spin-rosco-6458964f46-gsdqc         1/1     Running   0          33m</span><br></pre></td></tr></table></figure>

<h3 id="Connect-to-the-Spinnaker-UI"><a href="#Connect-to-the-Spinnaker-UI" class="headerlink" title="Connect to the Spinnaker UI"></a>Connect to the Spinnaker UI</h3><p>使用 kubernetes 做为 Cloud Provider，<strong>无需执行以下命令</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hal deploy connect</span><br></pre></td></tr></table></figure>
<p>为了连接 UI，需要在 kubernetes 集群中为 spin-deck 创建相应的 <code>Ingress</code> 资源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: spinnaker-deck</span><br><span class="line">  namespace: spinnaker</span><br><span class="line">spec:</span><br><span class="line">  ingressClassName: nginx</span><br><span class="line">  rules:</span><br><span class="line">  - host: deck.my.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - backend:</span><br><span class="line">          service:</span><br><span class="line">            name: spin-deck</span><br><span class="line">            port:</span><br><span class="line">              number: 9000</span><br><span class="line">        path: /</span><br><span class="line">        pathType: Prefix</span><br></pre></td></tr></table></figure>
<p>通过 Ingress 绑定的域名，可以访问到 Spinnaker UI，此时 Web UI 中会无法获取到资源，因为默认的 Gate Endpoint 为 <code>http://localhost:8084</code>，浏览器页面会报错 ： <code>Error fetching applications. Check that your gate endpoint is accessible. Further information on troubleshooting this error is available here</code>。因此需要执行以下命令配置 UI 和 Gate Api 的域名 <sup id="fnref:7"><a href="#fn:7" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[I can’t load the Applications screen](https://spinnaker.io/docs/setup/install/faq/#i-cant-load-the-applications-screen)">[7]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hal config security ui edit --override-base-url http://deck.my.com</span><br><span class="line">hal config security api edit --override-base-url http://spin-gate.my.com</span><br></pre></td></tr></table></figure>
<p>执行以下命令，使配置生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hal deploy apply</span><br></pre></td></tr></table></figure>
<p>在 kubernetes 集群中为 spin-gate 创建相应的 <code>Ingress</code> 资源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: spinnaker-gate</span><br><span class="line">  namespace: spinnaker</span><br><span class="line">spec:</span><br><span class="line">  ingressClassName: nginx</span><br><span class="line">  rules:</span><br><span class="line">  - host: spin-gate.my.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - backend:</span><br><span class="line">          service:</span><br><span class="line">            name: spin-gate</span><br><span class="line">            port:</span><br><span class="line">              number: 8084</span><br><span class="line">        path: /</span><br><span class="line">        pathType: Prefix</span><br></pre></td></tr></table></figure>
<p>重新访问 Web UI，可以看到正确的内容<br><img src="https://i.csms.tech/img_63.png"></p>
<h1 id="Spinnaker-其他配置"><a href="#Spinnaker-其他配置" class="headerlink" title="Spinnaker 其他配置"></a>Spinnaker 其他配置</h1><h2 id="添加自建的私有-docker-镜像源"><a href="#添加自建的私有-docker-镜像源" class="headerlink" title="添加自建的私有 docker 镜像源"></a>添加自建的私有 docker 镜像源</h2><p>启用 <code>docker-registry</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hal config provider docker-registry <span class="built_in">enable</span></span></span><br><span class="line">+ Get current deployment</span><br><span class="line">  Success</span><br><span class="line">+ Edit the dockerRegistry provider</span><br><span class="line">  Success</span><br><span class="line">Validation in default.provider.dockerRegistry:</span><br><span class="line">- WARNING Provider dockerRegistry is enabled, but no accounts have</span><br><span class="line">  been configured.</span><br><span class="line"></span><br><span class="line">+ Successfully enabled dockerRegistry</span><br></pre></td></tr></table></figure>
<p>配置认证信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hal config provider docker-registry account add my-docker-registry \</span></span><br><span class="line"><span class="language-bash">                                --address http://54.236.1.2:5000 \</span></span><br><span class="line"><span class="language-bash">                                --username <span class="variable">$USER</span> \</span></span><br><span class="line"><span class="language-bash">                                --password <span class="variable">$PASSWD</span></span></span><br><span class="line"></span><br><span class="line">+ Get current deployment</span><br><span class="line">  Success</span><br><span class="line">+ Add the my-docker-registry account</span><br><span class="line">  Success</span><br><span class="line">+ Successfully added account my-docker-registry for provider</span><br><span class="line">  dockerRegistry.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="配置-Jenkins-信息"><a href="#配置-Jenkins-信息" class="headerlink" title="配置 Jenkins 信息"></a>配置 Jenkins 信息</h2><p>启用 Jenkins</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hal config ci jenkins enable</span><br></pre></td></tr></table></figure>
<p>配置 Jenkins 认证信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hal config ci jenkins master add my-jenkins-master-01 \ </span><br><span class="line">                 --address http://34.150.227.175:8080 \ </span><br><span class="line">                 --username admin \ </span><br><span class="line">                 --password 32366490694c4af4</span><br></pre></td></tr></table></figure>
<p>启用 csrf</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hal config ci jenkins master edit my-jenkins-master-01 --csrf true</span><br></pre></td></tr></table></figure>

<h2 id="配置-LDAP-认证"><a href="#配置-LDAP-认证" class="headerlink" title="配置 LDAP 认证"></a>配置 LDAP 认证</h2><p>先配置 ldap 服务相关信息，再启用 ldap 认证，否则会报错： <code>! ERROR LDAP url missing.</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hal config security authn ldap edit \</span><br><span class="line">--user-search-base &#x27;dc=example,dc=org&#x27; \</span><br><span class="line">--url &#x27;ldap://10.4.7.12:389&#x27; \</span><br><span class="line">--user-search-filter &#x27;cn=&#123;0&#125;&#x27; \</span><br><span class="line">--manager-dn &#x27;cn=admin,dc=example,dc=org&#x27; \</span><br><span class="line">--manager-password &#x27;admin&#x27;</span><br></pre></td></tr></table></figure>

<p>启用 ldap 认证</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hal config security authn ldap enable</span><br></pre></td></tr></table></figure>
<p>重新部署，以使配置生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hal deploy apply</span><br></pre></td></tr></table></figure>

<h2 id="使用-Nginx-反代-Spinnaker"><a href="#使用-Nginx-反代-Spinnaker" class="headerlink" title="使用 Nginx 反代 Spinnaker"></a>使用 Nginx 反代 Spinnaker</h2><p>Spinnaker 部署于 Kubernetes 集群中，为了让集群中的服务不直接接收外部流量，需要使用 Nginx 反代访问 Spinnaker 服务。本示例中 Spinnaker 为配置 https，为 http 服务。使用的 Nginx 配置如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">upstream ingress-nginx-controller-https &#123;</span><br><span class="line">    server 172.31.22.9:443;</span><br><span class="line">    server 172.31.16.4:443;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">upstream ingress-nginx-controller-http &#123;</span><br><span class="line">    server 172.31.22.9:80;</span><br><span class="line">    server 172.31.16.4:80;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用来对 用户 ip 进行映射，以便后面做访问控制</span></span><br><span class="line">map $clientRealIp $k8s_admin_access &#123;</span><br><span class="line">         default false;</span><br><span class="line">         include k8s_admin_access.list;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name deck.test.com spin-gate.test.com;</span><br><span class="line">    access_log /home/logs/nginx/access/spinnaker.access.log main;</span><br><span class="line">    error_log /home/logs/nginx/error/spinnaker.error.log;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">                if ($k8s_admin_access = false) &#123;</span><br><span class="line">                    return 403;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        proxy_pass http://ingress-nginx-controller-http;     # 此处需要使用 http，不能使用 https</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header REMOTE-HOST $remote_addr;</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">        proxy_set_header Connection $connection_upgrade;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><h2 id="Spinnaker-无法自动读取到-Kubernetes-中的命名空间"><a href="#Spinnaker-无法自动读取到-Kubernetes-中的命名空间" class="headerlink" title="Spinnaker 无法自动读取到 Kubernetes 中的命名空间"></a>Spinnaker 无法自动读取到 Kubernetes 中的命名空间</h2><p>登陆 Spinnaker 后，查看 <code>Applications</code> 中的内容，无任何 <code>Applications</code> 显示，手动添加应用后，pipeline 部署失败，返回以下错误</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Exception ( Deploy Manifest )</span><br><span class="line">deployKubernetesManifest.deployKubernetesManifest.deployment.Error reading kind [deployment]. Please check connectivity and access permissions to the cluster</span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_108.png"></p>
<p>检查 <code>spin-clouddriver</code> 的日志，日志中显示无法连接到 <code>kube-api-server</code> ，解决 <code>spin-clouddriver</code> 到 <code>kube-api-server</code> 的通信异常，问题解决。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://spinnaker.io/docs/setup/install/">Install and Configure Spinnaker</a></p>
<p><a href="https://spinnaker.io/docs/setup/install/faq/">Halyard FAQ</a></p>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://spinnaker.io/docs/setup/install/halyard/#install-halyard-on-docker">Install Halyard on Docker</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://spinnaker.io/docs/setup/install/providers/kubernetes/#you-need-a-kubernetes-cluster-and-its-credentials">You need a Kubernetes cluster and its credentials</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://spinnaker.io/docs/setup/install/providers/kubernetes-v2/#adding-an-account">Adding an account</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://spinnaker.io/docs/setup/install/environment/">Choose your Environment</a><a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://spinnaker.io/docs/setup/install/storage/">External Storage</a><a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://spinnaker.io/docs/setup/install/deploy/">Deploy Spinnaker and Connect to the UI</a><a href="#fnref:6" rev="footnote"> ↩</a></span></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://spinnaker.io/docs/setup/install/faq/#i-cant-load-the-applications-screen">I can’t load the Applications screen</a><a href="#fnref:7" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>Spinnaker</tag>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP 协议</title>
    <url>/202211251549/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="TCP-协议抓包分析"><a href="#TCP-协议抓包分析" class="headerlink" title="TCP 协议抓包分析"></a>TCP 协议抓包分析</h1><h2 id="TCP-通信过程中-seq-和-ACK-值说明"><a href="#TCP-通信过程中-seq-和-ACK-值说明" class="headerlink" title="TCP 通信过程中 seq 和 ACK 值说明"></a>TCP 通信过程中 seq 和 ACK 值说明</h2><p><img src="https://i.csms.tech/img_96.png"></p>
<ul>
<li><p>TCP 连接通信过程中，client 和 server 端各自维护自己的 <code>seq</code>。后面一个数据包的 <code>seq</code> 是前面一个数据包的 <code>seq</code> 加上前面一个数据包的大小。表示发送的字节位置。 </p>
<p>  假如当前连接中，之前一个包 <code>seq = 100</code>，其发送数据包大小为 0，则当前要发送的数据包的 <code>seq = 0</code></p>
<p>  假如当前连接中，之前一个包 <code>seq = 100</code>，其发送数据包大小为 20，则当前要发送的数据包的 <code>seq = 120</code></p>
</li>
<li><p>TCP 连接通信过程中，client 和 server 端要发送给对方的包的 <code>ACK</code> 的值为：收到的包的 <code>seq</code> + 收到的包的 <code>Len</code>，此值告知发送方，接收方希望接收到的下一个包的序列号。</p>
<p>  假如接收方接收到了 <code>seq = 100</code> ，<code>Len = 0</code> 的包，接收方需要发送的 <code>ACK = 100 + 1</code></p>
<p>  假如接收方接收到了 <code>seq = 100</code> ，<code>Len = 20</code> 的包，接收方需要发送的 <code>ACK = 100 + 20</code></p>
</li>
</ul>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://xiaolincoding.com/network/3_tcp/tcp_tcpdump.html#%E6%98%BE%E5%BD%A2-%E4%B8%8D%E5%8F%AF%E8%A7%81-%E7%9A%84%E7%BD%91%E7%BB%9C%E5%8C%85">TCP 实战抓包分析</a></p>
<p><a href="https://www.cnblogs.com/163yun/p/9552368.html">wireshark抓包分析——TCP&#x2F;IP协议</a></p>
]]></content>
      <categories>
        <category>TCPIP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>akamai cdn api 使用</title>
    <url>/202302011153/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="https://techdocs.akamai.com/developer/docs/make-your-first-api-call">Akamai CDN API 说明文档</a>，调用 API 之前需要先根据官方文档说明 <code>Create API Client</code></p>
<h1 id="Python-SDK-使用"><a href="#Python-SDK-使用" class="headerlink" title="Python SDK 使用"></a>Python SDK 使用</h1><p>根据官方文档说明安装 <code>edgegrid-python</code>，并配置 <code>Create API Client Key</code> 信息 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Create a basic API client](https://techdocs.akamai.com/developer/docs/make-your-first-api-call)">[1]</span></a></sup>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install edgegrid-python</span><br></pre></td></tr></table></figure>

<p><a href="https://techdocs.akamai.com/developer/docs/python">Python SDK 使用官方示例</a></p>
<h2 id="获取账号信息"><a href="#获取账号信息" class="headerlink" title="获取账号信息"></a>获取账号信息</h2><p>大多数 API 使用都需要提供 <code>groupId</code>，<code>accountId</code>，<code>contractIds</code>，通过以下接口获取这些信息 <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[List groups](https://techdocs.akamai.com/property-mgr/reference/get-groups)">[2]</span></a></sup></p>
<figure class="highlight shell"><figcaption><span>python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import requests</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from akamai.edgegrid import EdgeGridAuth, EdgeRc</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from urllib.parse import urljoin</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; edgerc = EdgeRc(<span class="string">&#x27;~/.edgerc&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; section = <span class="string">&#x27;default&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; baseurl = <span class="string">&#x27;https://%s&#x27;</span> % edgerc.get(section, <span class="string">&#x27;host&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; s = requests.Session()</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; s.auth = EdgeGridAuth.from_edgerc(edgerc, section)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; result = s.get(urljoin(baseurl, <span class="string">&#x27;/papi/v1/groups&#x27;</span>))</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; result.json()</span></span><br><span class="line">&#123;&#x27;accountId&#x27;: &#x27;act_F-AC-488298736&#x27;, &#x27;accountName&#x27;: &#x27;Guangzhou kl Network Technology Co., Ltd&#x27;, &#x27;groups&#x27;: &#123;&#x27;items&#x27;: [&#123;&#x27;groupName&#x27;: &#x27;Guangzhou extreme-G-8HGkt-DSA&#x27;, &#x27;groupId&#x27;: &#x27;grp_186987767&#x27;, &#x27;contractIds&#x27;: [&#x27;ctr_G-3JDoujhh&#x27;]&#125;]&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果 <code>Property</code> 中存在分组，每个分组都有一个独立的 <code>groupId</code></p>
</blockquote>
<span id="more"></span>
<h2 id="获取-CPCode"><a href="#获取-CPCode" class="headerlink" title="获取 CPCode"></a>获取 CPCode</h2><p>通过以下接口及参数获取 CPCode <sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[List CP codes](https://techdocs.akamai.com/property-mgr/reference/get-cpcodes)">[3]</span></a></sup></p>
<figure class="highlight shell"><figcaption><span>python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import requests</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from akamai.edgegrid import EdgeGridAuth, EdgeRc</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from urllib.parse import urljoin</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; edgerc = EdgeRc(<span class="string">&#x27;~/.edgerc&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; section = <span class="string">&#x27;default&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; baseurl = <span class="string">&#x27;https://%s&#x27;</span> % edgerc.get(section, <span class="string">&#x27;host&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; s = requests.Session()</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; s.auth = EdgeGridAuth.from_edgerc(edgerc, section)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; result = s.get(urljoin(baseurl, <span class="string">&#x27;/papi/v1/cpcodes&#x27;</span>), params=&#123;<span class="string">&#x27;contractId&#x27;</span>: <span class="string">&#x27;ctr_G-ctr_G-3JDoujhh&#x27;</span>, <span class="string">&#x27;groupId&#x27;</span>: <span class="string">&#x27;grp_186987767&#x27;</span>&#125;, headers=&#123;<span class="string">&#x27;PAPI-Use-Prefixes&#x27;</span>: <span class="string">&#x27;True&#x27;</span>&#125;)</span></span><br></pre></td></tr></table></figure>

<h2 id="获取指定-CPCode-的流量信息"><a href="#获取指定-CPCode-的流量信息" class="headerlink" title="获取指定 CPCode 的流量信息"></a>获取指定 CPCode 的流量信息</h2><p>此处主要演示获取指标 <code>edgeBytes</code> 的流量，具体 API 使用方式可参考官方文档 <sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[bytes-by-cpcode](https://techdocs.akamai.com/reporting/reference/bytes-by-cpcode)">[4]</span></a></sup></p>
<h3 id="查询所有-CPCode-的流量"><a href="#查询所有-CPCode-的流量" class="headerlink" title="查询所有 CPCode 的流量"></a>查询所有 CPCode 的流量</h3><figure class="highlight shell"><figcaption><span>python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import requests</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from akamai.edgegrid import EdgeGridAuth, EdgeRc</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from urllib.parse import urljoin</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; edgerc = EdgeRc(<span class="string">&#x27;~/.edgerc&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; section = <span class="string">&#x27;default&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; baseurl = <span class="string">&#x27;https://%s&#x27;</span> % edgerc.get(section, <span class="string">&#x27;host&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; s = requests.Session()</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; s.auth = EdgeGridAuth.from_edgerc(edgerc, section)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; params = &#123;<span class="string">&#x27;start&#x27;</span>: <span class="string">&#x27;2022-12-31T00:00:00Z&#x27;</span>, <span class="string">&#x27;end&#x27;</span>: <span class="string">&#x27;2023-01-01T00:00:00Z&#x27;</span>, <span class="string">&#x27;allObjectIds&#x27;</span>: True, <span class="string">&#x27;metrics&#x27;</span>: <span class="string">&#x27;edgeBytes&#x27;</span>&#125;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; result = s.get(urljoin(baseurl, <span class="string">&#x27;/reporting-api/v1/reports/bytes-by-cpcode/versions/1/report-data&#x27;</span>), params=params)</span></span><br></pre></td></tr></table></figure>

<h3 id="获取指定-CPCode-的流量信息-1"><a href="#获取指定-CPCode-的流量信息-1" class="headerlink" title="获取指定 CPCode 的流量信息"></a>获取指定 CPCode 的流量信息</h3><figure class="highlight shell"><figcaption><span>python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; s = requests.Session()</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; s.auth = EdgeGridAuth.from_edgerc(edgerc, section)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; params = &#123;<span class="string">&#x27;start&#x27;</span>: <span class="string">&#x27;2022-12-01T00:00:00Z&#x27;</span>, <span class="string">&#x27;end&#x27;</span>: <span class="string">&#x27;2023-01-01T00:00:00Z&#x27;</span>, <span class="string">&#x27;objectIds&#x27;</span>: <span class="string">&#x27;1335489&#x27;</span>, <span class="string">&#x27;metrics&#x27;</span>: <span class="string">&#x27;edgeBytes&#x27;</span>&#125;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; result = s.get(urljoin(baseurl, <span class="string">&#x27;/reporting-api/v1/reports/bytes-by-cpcode/versions/1/report-data&#x27;</span>), params=params)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://techdocs.akamai.com/developer/docs/make-your-first-api-call">Create a basic API client</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://techdocs.akamai.com/property-mgr/reference/get-groups">List groups</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://techdocs.akamai.com/property-mgr/reference/get-cpcodes">List CP codes</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://techdocs.akamai.com/reporting/reference/bytes-by-cpcode">bytes-by-cpcode</a><a href="#fnref:4" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>云平台</category>
        <category>Akamai</category>
      </categories>
      <tags>
        <tag>云平台</tag>
      </tags>
  </entry>
  <entry>
    <title>Alpine linux apk 命令使用</title>
    <url>/202210201436/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="更新索引"><a href="#更新索引" class="headerlink" title="更新索引"></a>更新索引</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">apk update</span></span><br><span class="line"></span><br><span class="line">fetch https://dl-cdn.alpinelinux.org/alpine/v3.14/main/x86_64/APKINDEX.tar.gz</span><br><span class="line">fetch https://dl-cdn.alpinelinux.org/alpine/v3.14/community/x86_64/APKINDEX.tar.gz</span><br><span class="line">fetch http://nl.alpinelinux.org/alpine/edge/main/x86_64/APKINDEX.tar.gz</span><br><span class="line">fetch http://nl.alpinelinux.org/alpine/edge/testing/x86_64/APKINDEX.tar.gz</span><br><span class="line">fetch http://nl.alpinelinux.org/alpine/edge/community/x86_64/APKINDEX.tar.gz</span><br><span class="line">v3.14.8-65-g0f3285f2cf [https://dl-cdn.alpinelinux.org/alpine/v3.14/main]</span><br><span class="line">v3.14.8-66-ge9853dea68 [https://dl-cdn.alpinelinux.org/alpine/v3.14/community]</span><br><span class="line">v20220809-6223-gb7f2956912 [http://nl.alpinelinux.org/alpine/edge/main]</span><br><span class="line">v20220809-6223-gb7f2956912 [http://nl.alpinelinux.org/alpine/edge/testing]</span><br><span class="line">v20220809-6223-gb7f2956912 [http://nl.alpinelinux.org/alpine/edge/community]</span><br><span class="line">OK: 38705 distinct packages available</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从远程镜像源中更新本地镜像源索引，<code>update</code> 命令会从各个镜像源列表下载 <code>APKINDEX.tar.gz</code> 并存储到本地缓存，一般在 <code>/var/cache/apk/</code> (Alpine 在该目录下)</p>
<span id="more"></span>

<h2 id="安装软件包"><a href="#安装软件包" class="headerlink" title="安装软件包"></a>安装软件包</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apk add vim openssh</span><br><span class="line"></span><br><span class="line">apk add --no-cache mysql-client</span><br><span class="line"></span><br><span class="line">apk add docker --update-cache \</span><br><span class="line">           --repository http://mirrors.ustc.edu.cn/alpine/v3.4/main/ --allow-untrusted</span><br></pre></td></tr></table></figure>

<p>安装指定版本软件包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apk add asterisk=1.6.0.21-r0</span><br><span class="line"></span><br><span class="line">apk add &#x27;asterisk&lt;1.6.1&#x27;</span><br><span class="line"></span><br><span class="line">apk add &#x27;asterisk&gt;1.6.1</span><br></pre></td></tr></table></figure>

<h2 id="卸载软件包"><a href="#卸载软件包" class="headerlink" title="卸载软件包"></a>卸载软件包</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apk del openssh openntp vim</span><br></pre></td></tr></table></figure>

<h2 id="搜索软件包"><a href="#搜索软件包" class="headerlink" title="搜索软件包"></a>搜索软件包</h2><p>搜索所有可用软件包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apk search</span><br><span class="line">apk search -v</span><br></pre></td></tr></table></figure>
<p>通过软件包名称搜索</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apk search -v &#x27;acf*&#x27;</span><br></pre></td></tr></table></figure>
<p>通过描述文件查找特定的软件包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apk search -v -d &#x27;docker&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="查看包信息"><a href="#查看包信息" class="headerlink" title="查看包信息"></a>查看包信息</h2><p>列出所有已安装的软件包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apk info </span><br></pre></td></tr></table></figure>
<p>显示完整的软件包信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apk info -a zlib</span><br></pre></td></tr></table></figure>
<p>显示指定文件属于的包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apk info --who-owns /sbin/lbu</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
        <category>Alpine</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Alpine</tag>
      </tags>
  </entry>
  <entry>
    <title>Apollo 配置中心服务使用说明</title>
    <url>/202211021332/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos 7 kernel 5.4</li>
<li>Apollo 2.0.1</li>
<li>Mysql 5.7</li>
<li>Java 1.8</li>
</ul>
<h1 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h1><h2 id="分布式部署"><a href="#分布式部署" class="headerlink" title="分布式部署"></a>分布式部署</h2><h3 id="部署服务器信息说明"><a href="#部署服务器信息说明" class="headerlink" title="部署服务器信息说明"></a>部署服务器信息说明</h3><table>
<thead>
<tr>
<th>环境</th>
<th>服务器</th>
<th>服务</th>
<th>端口</th>
</tr>
</thead>
<tbody><tr>
<td><code>pro</code></td>
<td>172.31.88.1</td>
<td>apollo-portal</td>
<td>8070</td>
</tr>
<tr>
<td><code>pro</code></td>
<td>172.31.88.1</td>
<td>数据库 ApolloPortalDB</td>
<td>3306</td>
</tr>
<tr>
<td><code>pro</code></td>
<td>172.31.88.1</td>
<td>apollo-configservice</td>
<td>8080</td>
</tr>
<tr>
<td><code>pro</code></td>
<td>172.31.88.1</td>
<td>apollo-adminservice</td>
<td>8090</td>
</tr>
<tr>
<td><code>pro</code></td>
<td>172.31.88.1</td>
<td>数据库ApolloConfigDB</td>
<td>3306</td>
</tr>
<tr>
<td><code>pro</code></td>
<td>172.31.82.2</td>
<td>apollo-configservice</td>
<td>8080</td>
</tr>
<tr>
<td><code>pro</code></td>
<td>172.31.82.2</td>
<td>apollo-adminservice</td>
<td>8090</td>
</tr>
<tr>
<td><code>uat</code></td>
<td>172.31.83.3</td>
<td>apollo-configservice</td>
<td>8080</td>
</tr>
<tr>
<td><code>uat</code></td>
<td>172.31.83.3</td>
<td>apollo-adminservice</td>
<td>8090</td>
</tr>
<tr>
<td><code>uat</code></td>
<td>172.31.83.3</td>
<td>数据库ApolloConfigDB</td>
<td>3306</td>
</tr>
</tbody></table>
<p>其中 <code>172.31.88.1</code>、<code>172.31.82.2</code> 为 <code>pro</code> 环境的高可用节点。<code>172.31.83.3</code> 为 <code>uat</code> 环境的单节点。</p>
<p><code>apollo-portal</code> 和 <code>ApolloPortalDB</code> 部署在 <code>pro</code> 环境，<code>uat</code> 环境共用 <code>apollo-portal</code> 和 <code>ApolloPortalDB</code>。</p>
<span id="more"></span>
<h3 id="安装-Java"><a href="#安装-Java" class="headerlink" title="安装 Java"></a>安装 Java</h3><p>在所有节点上安装 java-1.8.0</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y java-1.8.0-openjdk</span><br></pre></td></tr></table></figure>
<p>验证 java 安装成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java -version</span></span><br><span class="line">openjdk version &quot;1.8.0_352&quot;</span><br><span class="line">OpenJDK Runtime Environment (build 1.8.0_352-b08)</span><br><span class="line">OpenJDK 64-Bit Server VM (build 25.352-b08, mixed mode)</span><br></pre></td></tr></table></figure>

<h3 id="下载-Apollo-源码包"><a href="#下载-Apollo-源码包" class="headerlink" title="下载 Apollo 源码包"></a>下载 Apollo 源码包</h3><p><a href="https://github.com/apolloconfig/apollo/releases/tag/v2.0.1">下载地址</a>，<code>apollo-portal</code> 只需要在 portal 服务器下载，<code>apollo-adminservice</code> 和 <code>apollo-configservice</code> 需要在所有节点上下载<br><img src="https://i.csms.tech/img_79.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://github.com/apolloconfig/apollo/releases/download/v2.0.1/apollo-adminservice-2.0.1-github.zip </span><br><span class="line">wget https://github.com/apolloconfig/apollo/releases/download/v2.0.1/apollo-configservice-2.0.1-github.zip</span><br><span class="line">wget https://github.com/apolloconfig/apollo/releases/download/v2.0.1/apollo-portal-2.0.1-github.zip</span><br></pre></td></tr></table></figure>

<p>解压源码包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unzip apollo-adminservice-2.0.1-github.zip -d apollo-adminservice-2.0.1</span><br><span class="line">unzip apollo-configservice-2.0.1-github.zip -d apollo-configservice-2.0.1</span><br><span class="line">unzip apollo-portal-2.0.1-github.zip -d apollo-portal-2.0.1</span><br></pre></td></tr></table></figure>


<h3 id="准备数据库"><a href="#准备数据库" class="headerlink" title="准备数据库"></a>准备数据库</h3><p>Apollo 服务端共需要两个数据库：<code>ApolloPortalDB</code> 和 <code>ApolloConfigDB</code> <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[创建数据库](https://www.apolloconfig.com/#/zh/deployment/distributed-deployment-guide?id=_21-%e5%88%9b%e5%bb%ba%e6%95%b0%e6%8d%ae%e5%ba%93)">[1]</span></a></sup></p>
<p>需要注意的是 <code>ApolloPortalDB</code> 只需要在 <code>pro</code> 环境部署一个即可，而 <code>ApolloConfigDB</code> 需要在每个环境部署一套，如 <code>fat</code>、<code>uat</code> 和 <code>pro</code> 分别部署 3 套 <code>ApolloConfigDB</code>。</p>
<p>在 <code>pro</code> 环境的数据库服务器上下载 <code>apolloportaldb.sql</code> 并导入数据库 </p>
<p>在 <code>pro</code> 环境的数据库服务器上下载 <code>apolloconfigdb.sql</code> 并导入数据库 <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[apolloportaldb.sql](https://www.apolloconfig.com/#/zh/deployment/distributed-deployment-guide?id=_21-%e5%88%9b%e5%bb%ba%e6%95%b0%e6%8d%ae%e5%ba%93)
">[2]</span></a></sup></p>
<p>在 <code>uat</code> 环境的数据库服务器上下载 <code>apolloconfigdb.sql</code> 并导入数据库</p>
<p>调整 <code>ApolloPortalDB.ServerConfig</code> 表的数据，<code>portal</code> 默认支持的环境是 <code>DEV</code>，若需要支持其它环境，需要修改 <code>apollo.portal.envs</code> 的值，默认值是 <code>DEV</code>，修改为以下值，表示支持 <code>UAT</code>、<code>PRO</code><br><img src="https://i.csms.tech/img_80.png"></p>
<p>因为 <code>PRO</code> 环境有多个节点，需要调整 <code>PRO</code> 环境的数据库表 <code>ApolloConfigDB.ServerConfig</code>，修改 <code>eureka.service.url</code> 的值为当前 <code>PRO</code> 环境的 <code>apollo-configservice</code> 的地址和端口，注意多个地址之间用英文逗号隔开。<br><img src="https://i.csms.tech/img_81.png"><br><code>UAT</code> 环境只有一个节点，<code>eureka.service.url</code> 使用默认的 <code>localhost</code> 即可。 </p>
<h3 id="部署-Apollo"><a href="#部署-Apollo" class="headerlink" title="部署 Apollo"></a>部署 Apollo</h3><h4 id="部署-apollo-configservice"><a href="#部署-apollo-configservice" class="headerlink" title="部署 apollo-configservice"></a>部署 apollo-configservice</h4><h5 id="配置数据库连接"><a href="#配置数据库连接" class="headerlink" title="配置数据库连接"></a>配置数据库连接</h5><p>修改各节点上的 <code>apollo-configservice-2.0.1/config/application-github.properties</code> 文件，修改其中的数据库连接为当前环境的数据库信息。</p>
<figure class="highlight shell"><figcaption><span>apollo-configservice-2.0.1/config/application-github.properties</span></figcaption><table><tr><td class="code"><pre><span class="line">spring.datasource.url = jdbc:mysql://apollo.mysql:3306/ApolloConfigDB?characterEncoding=utf8</span><br><span class="line">spring.datasource.username = root</span><br><span class="line">spring.datasource.password = WayWb+5Pw==</span><br></pre></td></tr></table></figure>

<h5 id="启动-apollo-configservice"><a href="#启动-apollo-configservice" class="headerlink" title="启动 apollo-configservice"></a>启动 apollo-configservice</h5><p>默认的启动端口是 <code>8080</code>，若要修改，则将 <code>scripts/startup.sh</code> 中的 <code>SERVER_PORT=$&#123;SERVER_PORT:=8080&#125;</code> 的 <code>8080</code> 改成指定的端口即可。</p>
<p>执行 <code>scripts/startup.sh</code> 启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./scripts/startup.sh</span></span><br><span class="line">Thu Nov  3 09:56:08 CST 2022 ==== Starting ==== </span><br><span class="line">Application is running as root (UID 0). This is considered insecure.</span><br><span class="line">Started [22197]</span><br><span class="line">Waiting for server startup...</span><br><span class="line">Thu Nov  3 09:56:23 CST 2022 Server started in 15 seconds!</span><br></pre></td></tr></table></figure>

<p>启动之后检查端口 <code>8080</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">netstat -anutp | grep LIST</span></span><br><span class="line">tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN      612/rpcbind         </span><br><span class="line">tcp        0      0 0.0.0.0:30000           0.0.0.0:*               LISTEN      2595/sshd           </span><br><span class="line">tcp6       0      0 :::3306                 :::*                    LISTEN      21960/mysqld        </span><br><span class="line">tcp6       0      0 :::111                  :::*                    LISTEN      612/rpcbind         </span><br><span class="line">tcp6       0      0 :::8080                 :::*                    LISTEN      22197/java          </span><br><span class="line">tcp6       0      0 :::30000                :::*                    LISTEN      2595/sshd</span><br></pre></td></tr></table></figure>

<h4 id="部署-apollo-adminservice"><a href="#部署-apollo-adminservice" class="headerlink" title="部署 apollo-adminservice"></a>部署 apollo-adminservice</h4><h5 id="配置数据库连接-1"><a href="#配置数据库连接-1" class="headerlink" title="配置数据库连接"></a>配置数据库连接</h5><p>修改各节点上的 <code>apollo-adminservice-2.0.1/config/application-github.properties</code>，修改其中的数据库连接为当前环境的数据库信息。</p>
<figure class="highlight shell"><figcaption><span>apollo-adminservice-2.0.1/config/application-github.properties</span></figcaption><table><tr><td class="code"><pre><span class="line">spring.datasource.url = jdbc:mysql://apollo.mysql:3306/ApolloConfigDB?characterEncoding=utf8</span><br><span class="line">spring.datasource.username = root</span><br><span class="line">spring.datasource.password = 1roAYNg==</span><br></pre></td></tr></table></figure>
<h5 id="启动-apollo-adminservice"><a href="#启动-apollo-adminservice" class="headerlink" title="启动 apollo-adminservice"></a>启动 apollo-adminservice</h5><p>默认的启动端口是 <code>8090</code>，若要修改，则将 <code>scripts/startup.sh</code> 中的 <code>SERVER_PORT=$&#123;SERVER_PORT:=8090&#125;</code> 的 <code>8090</code> 改成指定的端口即可。</p>
<p>执行 <code>scripts/startup.sh</code> 启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./scripts/startup.sh</span></span><br><span class="line">Thu Nov  3 10:06:05 CST 2022 ==== Starting ==== </span><br><span class="line">Application is running as root (UID 0). This is considered insecure.</span><br><span class="line">Started [22818]</span><br><span class="line">Waiting for server startup...</span><br><span class="line">Thu Nov  3 10:06:21 CST 2022 Server started in 15 seconds!</span><br></pre></td></tr></table></figure>

<h4 id="部署-apollo-portal"><a href="#部署-apollo-portal" class="headerlink" title="部署 apollo-portal"></a>部署 apollo-portal</h4><h5 id="配置数据库连接-2"><a href="#配置数据库连接-2" class="headerlink" title="配置数据库连接"></a>配置数据库连接</h5><p>修改 <code>apollo-portal</code> 节点上的 <code>apollo-portal-2.0.1/config/application-github.properties</code>，修改其中的数据库连接为 <code>ApolloPortalDB</code> 的数据库信息。</p>
<figure class="highlight shell"><figcaption><span>apollo-portal-2.0.1/config/application-github.properties</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">DataSource</span></span><br><span class="line">spring.datasource.url = jdbc:mysql://pro.env.apollo.mysql:3306/ApolloPortalDB?characterEncoding=utf8</span><br><span class="line">spring.datasource.username = root</span><br><span class="line">spring.datasource.password = WayWwRDNEb+5Pw==</span><br></pre></td></tr></table></figure>

<h5 id="配置-meta-service-信息"><a href="#配置-meta-service-信息" class="headerlink" title="配置 meta service 信息"></a>配置 meta service 信息</h5><p><code>meta service</code> 的地址和端口，默认就是 <code>apollo-configservice</code> 的地址和端口。</p>
<p>修改 <code>apollo-portal-2.0.1/config/apollo-env.properties</code>，填写当前的 <code>apollo-portal</code> 要管理的环境的 <code>apollo-configservice</code> 的地址和端口，多个地址之间用英文逗号隔开</p>
<figure class="highlight shell"><figcaption><span>apollo-portal-2.0.1/config/apollo-env.properties</span></figcaption><table><tr><td class="code"><pre><span class="line">pro.meta=http://172.31.81.1:8080,http://172.31.82.2:8080</span><br><span class="line">uat.meta=http://172.31.83.3:8080</span><br></pre></td></tr></table></figure>

<h5 id="启动-apollo-portal"><a href="#启动-apollo-portal" class="headerlink" title="启动 apollo-portal"></a>启动 apollo-portal</h5><p>默认的启动端口是 <code>8070</code> ，若要修改，则将 <code>scripts/startup.sh</code> 中的 <code>SERVER_PORT=$&#123;SERVER_PORT:=8070&#125;</code> 的 <code>8070</code> 改成指定的端口即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./scripts/startup.sh</span> </span><br><span class="line">Thu Nov  3 10:23:32 CST 2022 ==== Starting ==== </span><br><span class="line">Application is running as root (UID 0). This is considered insecure.</span><br><span class="line">Started [23044]</span><br><span class="line">Waiting for server startup...</span><br><span class="line">Thu Nov  3 10:23:47 CST 2022 Server started in 15 seconds!</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="部署后检查是否成功"><a href="#部署后检查是否成功" class="headerlink" title="部署后检查是否成功"></a>部署后检查是否成功</h3><h4 id="apollo-configservice-和-apollo-adminservice-检查"><a href="#apollo-configservice-和-apollo-adminservice-检查" class="headerlink" title="apollo-configservice 和 apollo-adminservice 检查"></a>apollo-configservice 和 apollo-adminservice 检查</h4><ol>
<li><p>在浏览器上登录当前环境的其中一个 <code>apollo-configservice</code> 的 <code>http://ip:port</code></p>
</li>
<li><p>查看该环境的 <code>apollo-configservice</code> 和 <code>apollo-adminservice</code> 的节点数是否正常。<br> 比如 <code>PRO</code> 环境有 2 个节点，输出中正常情况下会显示 2 个正常的节点<br> <img src="https://i.csms.tech/img_82.png"></p>
</li>
</ol>
<h4 id="apollo-portal-检查"><a href="#apollo-portal-检查" class="headerlink" title="apollo-portal 检查"></a>apollo-portal 检查</h4><ol>
<li>浏览器登录 <code>apollo-portal</code> 的 <code>http://ip:port</code>，默认账号 <code>apollo</code>，密码 <code>admin</code>。</li>
</ol>
<h1 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h1><h2 id="修改默认管理员-apollo-的密码"><a href="#修改默认管理员-apollo-的密码" class="headerlink" title="修改默认管理员 apollo 的密码"></a>修改默认管理员 apollo 的密码</h2><p>默认管理员 <code>apollo</code> 的密码为 <code>admin</code>，要修改此密码，在 <code>管理员工具</code> -&gt; <code>用户管理</code> 中输入用户名和密码，如果用户已存在，更新用户信息，用户不存在，则创建新用户。</p>
<h2 id="创建部门"><a href="#创建部门" class="headerlink" title="创建部门"></a>创建部门</h2><p>只有管理员才能创建部门，在 <code>管理员工具</code> -&gt; <code>系统参数</code> 中查询 <code>organizations</code>，会输出当前的部门信息<br><img src="https://i.csms.tech/img_83.png"><br>修改此参数并保存，即可更新部门信息。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.apolloconfig.com/#/zh/design/apollo-introduction">Apollo 配置中心介绍</a></p>
<p><a href="https://blog.csdn.net/werewolf2017/article/details/109120336">Apollo分布式配置中心集群部署</a></p>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.apolloconfig.com/#/zh/deployment/distributed-deployment-guide?id=_21-%e5%88%9b%e5%bb%ba%e6%95%b0%e6%8d%ae%e5%ba%93">创建数据库</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.apolloconfig.com/#/zh/deployment/distributed-deployment-guide?id=_21-%e5%88%9b%e5%bb%ba%e6%95%b0%e6%8d%ae%e5%ba%93">apolloportaldb.sql</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Apollo</tag>
      </tags>
  </entry>
  <entry>
    <title>awk 使用示例</title>
    <url>/202208031132/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>awk 是一种编程语言，用于在linux&#x2F;unix下对文本和数据进行处理。数据可以来自标准输入(stdin)、一个或多个文件，或其它命令的输出。它支持用户自定义函数和动态正则表达式等先进功能，是linux&#x2F;unix下的一个强大编程工具。它在命令行中使用，但更多是作为脚本来使用。awk有很多内建的功能，比如数组、函数等，这是它和C语言的相同之处，灵活性是awk最大的优势。  </p>
<span id="more"></span>

<h3 id="awk-脚本基本结构"><a href="#awk-脚本基本结构" class="headerlink" title="awk 脚本基本结构"></a>awk 脚本基本结构</h3><p><code>awk &#39;BEGIN&#123; commands &#125; pattern&#123; commands &#125; END&#123; commands &#125;&#39;</code>  </p>
<p>一个awk脚本通常由：<strong>BEGIN语句块</strong>、<strong>能够使用模式匹配的通用语句块</strong>、<strong>END语句块</strong> 3部分组成，这三个部分是可选的。任意一个部分都可以不出现在脚本中，脚本通常是被放置在 <strong>单引号</strong> 中  </p>
<h3 id="awk-的工作原理"><a href="#awk-的工作原理" class="headerlink" title="awk 的工作原理"></a>awk 的工作原理</h3><ol>
<li>执行 <code>BEGIN&#123; commands &#125;</code> 语句块中的语句；  </li>
<li>从文件或标准输入(stdin)读取一行，然后执行 <code>pattern&#123; commands &#125;</code> 语句块，它逐行扫描文件，从第一行到最后一行重复这个过程，直到文件全部被读取完毕。  </li>
<li>当读至输入流末尾时，执行 <code>END&#123; commands &#125;</code> 语句块。</li>
</ol>
<p><code>BEGIN语句块</code> 在awk开始从输入流中读取行 <strong>之前</strong> 被执行，这是一个可选的语句块，比如变量初始化、打印输出表格的表头等语句通常可以写在BEGIN语句块中  </p>
<p><code>END语句块</code> 在awk从输入流中读取完所有的行 <strong>之后</strong> 即被执行，比如打印所有行的分析结果这类信息汇总都是在END语句块中完成，它也是一个可选语句块。  </p>
<p><code>pattern语句块</code> 中的通用命令是最重要的部分，它也是可选的。如果没有提供<code>pattern语句块</code>，则默认执行 <code>&#123; print &#125;</code>，即打印每一个读取到的行，<strong>awk读取的每一行都会执行该语句块</strong>。 </p>
<h3 id="awk-内置变量（预定义变量）"><a href="#awk-内置变量（预定义变量）" class="headerlink" title="awk 内置变量（预定义变量）"></a>awk 内置变量（预定义变量）</h3><table>
<thead>
<tr>
<th align="left">变量</th>
<th align="left">说明</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$0</td>
<td align="left">当前行的整行内容</td>
<td align="left"><code>&#39;&#123;print $0&#125;&#39;</code> 打印出当前处理行的整行内容</td>
</tr>
<tr>
<td align="left">$n</td>
<td align="left">当前记录（行）的第n个字段</td>
<td align="left"><code>&#39;&#123;print $1&#125;&#39;</code> 打印出当前行的第1个字段</td>
</tr>
<tr>
<td align="left">NR</td>
<td align="left">当前处理行的行号（第多少行）</td>
<td align="left"><code>&#39;&#123;print NR,$1&#125;&#39; END&#123;print NR&#125;</code> 打印出当前处理行的行号和第1列，最后打印出总的行号</td>
</tr>
<tr>
<td align="left">FNR</td>
<td align="left">当前处理行在当前处理文件中的行号，只有1个输入文件时，NR&#x3D;FNR</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">NF</td>
<td align="left">当前行的字段数</td>
<td align="left"><code>&#39;&#123;print NF,$NF,$(NF-1)&#125;&#39;</code>  输出当前行的字段数，最后一个字段 ,倒数第2个字段</td>
</tr>
<tr>
<td align="left">FILENAME</td>
<td align="left">当前输入文件的文件名，<code>-</code>表示stdin</td>
<td align="left"><code>&#39;&#123;print FILENAME,FNR&#125;&#39;</code> 打印当前处理的文件名及当前行号</td>
</tr>
<tr>
<td align="left">FS</td>
<td align="left">输入字段分隔符，等同于选项 <code>-F</code> ,默认为空格</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">OFS</td>
<td align="left">输出字段的分隔符，默认为空格</td>
<td align="left"><code>&#39;BEGIN&#123;OFS=&quot;|&quot;&#125; &#123;print FILENAME,FS,NR,NF,$2,$NF&#125;&#39;</code> 输出结果将会以 <code>|</code> 分割</td>
</tr>
<tr>
<td align="left">RS</td>
<td align="left">输入记录分隔符（行分隔符），默认为换行</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">ORS</td>
<td align="left">输出记录分隔符（行分隔符），默认为换行</td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="awk-常用选项"><a href="#awk-常用选项" class="headerlink" title="awk 常用选项"></a>awk 常用选项</h3><table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>-F&quot;sep&quot;</code><br/><code>-F&quot;[,.]&quot;</code></td>
<td>等同于内置变量 <code>FS</code>，有2种格式：<br/><code>-F&quot;sep&quot;</code> 使用 <code>sep</code> 整体作为字段分隔符<br/> <code>-F[,.]</code>  <code>[]</code>其中的每个字符都可以作为分隔符<br/>等同于<code>BEGIN</code>预定义变量<code>FS</code></td>
<td></td>
</tr>
<tr>
<td><code>-v var=1</code></td>
<td>传递用户自定义变量给awk</td>
<td><code>awk -va=1 -vb=2 &#39;&#123;print a+b&#125;&#39;</code></td>
</tr>
</tbody></table>
<h3 id="awk-常用运算符"><a href="#awk-常用运算符" class="headerlink" title="awk 常用运算符"></a>awk 常用运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;<br/>+&#x3D;<br/> -&#x3D;<br/> *&#x3D;<br/> &#x2F;&#x3D;<br/> %&#x3D;<br/> ^&#x3D;<br/> **&#x3D;</td>
<td>赋值</td>
<td></td>
</tr>
<tr>
<td><code>~</code><br/><code>!~</code></td>
<td>匹配正则表达式<br/>不匹配正则表达式</td>
<td><code>awk &#39;$2 ~ /th/ &#123;print $2,$4&#125;&#39; log.txt</code> 第2列中包含’th’，则输出第2,4列<br/><code>awk &#39;BEGIN&#123;IGNORECASE=1&#125; /this/&#39; log.txt</code>    忽略大小写匹配 <br/><code>awk &#39;$2 !~ /th/ &#123;print $2,$4&#125;&#39; log.txt</code> 不匹配正则表达式</td>
</tr>
<tr>
<td>&lt; <br/>&lt;&#x3D;<br/> &gt;<br/> &gt;&#x3D;<br/> !&#x3D; <br/>&#x3D;&#x3D;</td>
<td>关系运算符</td>
<td><code>awk &#39;$1&gt;2&#39; log.txt</code>  第1列的值大于2，输出整行<br/><code>awk &#39;$1==2 &#123;print $1,$3&#125;&#39; log.txt</code> 第1列的值等于2，则输出第1,3列</td>
</tr>
<tr>
<td>+<br/>-<br/>*<br/>&#x2F;<br/>%<br/></td>
<td>加，减，乘，除与求余</td>
<td></td>
</tr>
<tr>
<td>+ <br/>- <br/>!</td>
<td>一元加，减和逻辑非</td>
<td></td>
</tr>
<tr>
<td>| |</td>
<td>逻辑或</td>
<td></td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>逻辑与</td>
<td><code>awk &#39;$1&gt;2 &amp;&amp; $2==&quot;Are&quot; &#123;print $1,$2,$3&#125;&#39; log.txt </code>  第1列大于2，并且第2列等于”Are”,则输出第1,2,3列</td>
</tr>
</tbody></table>
<h3 id="awk-常用用法示例"><a href="#awk-常用用法示例" class="headerlink" title="awk 常用用法示例"></a>awk 常用用法示例</h3><h4 id="每一行中第个字段值累加"><a href="#每一行中第个字段值累加" class="headerlink" title="每一行中第个字段值累加"></a>每一行中第个字段值累加</h4><figure class="highlight shell"><figcaption><span>awk</span></figcaption><table><tr><td class="code"><pre><span class="line">seq 1 10 | awk &#x27;BEGIN&#123;sum=0;print &quot;第1列求和&quot;&#125;&#123;sum+=$1&#125;END&#123;print &quot;sum=&quot;sum&#125;&#x27;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第1列求和<br>sum&#x3D;55</p>
</blockquote>
<h4 id="判断2列的内容是否相同"><a href="#判断2列的内容是否相同" class="headerlink" title="判断2列的内容是否相同"></a>判断2列的内容是否相同</h4><figure class="highlight shell"><figcaption><span>awk</span></figcaption><table><tr><td class="code"><pre><span class="line">awk &#x27;&#123;if($1==$2)&#123;print $1&#125;&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="找出字段数-列数-大于3的行"><a href="#找出字段数-列数-大于3的行" class="headerlink" title="找出字段数(列数)大于3的行"></a>找出字段数(列数)大于3的行</h4><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;NF&gt;3&#123;print $0&#125;&#x27;</span> </span><br></pre></td></tr></table></figure>

<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://wangchujiang.com/linux-command/c/awk.html">参考文章</a></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>awk</tag>
      </tags>
  </entry>
  <entry>
    <title>aws cli 命令用法</title>
    <url>/202301171752/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>aws-cli&#x2F;2.9.15</li>
</ul>
<p><a href="https://docs.aws.amazon.com/zh_cn/cli/latest/userguide/getting-started-install.html">aws cli 安装更新说明</a></p>
<p><a href="https://docs.aws.amazon.com/zh_cn/cli/latest/userguide/cli-configure-quickstart.html">aws cli 基础配置及说明</a></p>
<h1 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h1><p>查看 <code>aws</code> 帮助信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">aws help</span><br></pre></td></tr></table></figure>
<p>查看子命令帮助信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">aws ec2 help</span><br></pre></td></tr></table></figure>

<p><code>aws</code> 命令常用选项</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>--region</code></td>
<td>指定区域，<a href="https://docs.aws.amazon.com/zh_cn/general/latest/gr/rande.html">aws 区域列表</a></td>
<td><code>aws --region ap-east-1 ec2 describe-instances</code></td>
</tr>
</tbody></table>
<span id="more"></span>
<h2 id="EC2"><a href="#EC2" class="headerlink" title="EC2"></a>EC2</h2><h3 id="获取实例信息"><a href="#获取实例信息" class="headerlink" title="获取实例信息"></a>获取实例信息</h3><p>此操作至少需要以下权限：</p>
<ul>
<li><code>EC2.DescribeInstances</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">aws --region ap-east-1 ec2 describe-instances</span><br></pre></td></tr></table></figure>

<p>筛选输出，只获取 <code>instance-id</code>，使用 <code>--query</code> 选项可能造成部分机器无法被包含在输出中，导致统计机器缺失，最好使用 <code>aws --region ap-east-1 ec2 describe-instances</code> 获取指定区域的所有机器后手动进行筛选。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">aws ec2 describe-instances --region ap-east-1 --query Reservations[*].Instances[*].InstanceId --output text</span><br></pre></td></tr></table></figure>

<p>通过选项 <code>--query</code> 可以对输出进行筛选，只输出指定内容。<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[aws cli 输出结果筛选](https://docs.aws.amazon.com/zh_cn/cli/latest/userguide/cli-usage-filter.html)">[2]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">aws ec2 describe-instances --region ap-east-1 \</span></span><br><span class="line"><span class="language-bash">        --query Reservations[*].Instances[*].[InstanceId,InstanceType,KeyName,PublicIpAddress] --output text</span></span><br><span class="line">i-0904c5ba08     c5.large        t1  16.162.77.1</span><br><span class="line">i-09f7765e86     c5.large        t2  16.162.181.4</span><br><span class="line">i-0bc892a5b0     c5.xlarge       t3  16.162.229.5 </span><br></pre></td></tr></table></figure>

<p>通过选项 <code>--query</code> 获取实例 Name</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">aws ec2 describe-instances --region ap-east-1 \</span></span><br><span class="line"><span class="language-bash">             --query Reservations[*].Instances[*].[InstanceId,Tags[*],PublicIpAddress,BlockDeviceMappings[*].Ebs.VolumeId][0] --output json</span></span><br><span class="line">             </span><br><span class="line">[</span><br><span class="line">    [</span><br><span class="line">        &quot;i-0904c5ba087f0b07c&quot;,</span><br><span class="line">        [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Key&quot;: &quot;name&quot;,</span><br><span class="line">                &quot;Value&quot;: &quot;t1&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Key&quot;: &quot;Name&quot;,</span><br><span class="line">                &quot;Value&quot;: &quot;test1&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;16.162.77.243&quot;,</span><br><span class="line">        [</span><br><span class="line">            &quot;vol-05940c72f51db924c&quot;</span><br><span class="line">        ]</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        &quot;i-09f7765e863bbc0f0&quot;,</span><br><span class="line">        [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Key&quot;: &quot;Name&quot;,</span><br><span class="line">                &quot;Value&quot;: &quot;t2&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Key&quot;: &quot;luodiye1&quot;,</span><br><span class="line">                &quot;Value&quot;: &quot;test2&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;16.162.181.48&quot;,</span><br><span class="line">        [</span><br><span class="line">            &quot;vol-09ac77986ac07cbfb&quot;</span><br><span class="line">        ]</span><br><span class="line">    ],</span><br><span class="line">]         </span><br></pre></td></tr></table></figure>

<h3 id="获取-EC2-实例的存储-Volume-信息"><a href="#获取-EC2-实例的存储-Volume-信息" class="headerlink" title="获取 EC2 实例的存储 (Volume) 信息"></a>获取 EC2 实例的存储 (Volume) 信息</h3><p>此操作至少需要以下权限：</p>
<ul>
<li><code>EC2.DescribeInstances</code></li>
<li><code>EC2.DescribeVolumes</code></li>
</ul>
<p>根据已知的 <code>volume-id</code>，查询卷的详细信息，比如磁盘类型和大小</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">aws ec2 describe-volumes --region ap-east-1 \</span></span><br><span class="line"><span class="language-bash">          --volume-ids vol-03f727ba5534b23f1 \</span></span><br><span class="line"><span class="language-bash">          --query Volumes[*].[VolumeType,Size] --output text</span></span><br><span class="line">gp2     500</span><br></pre></td></tr></table></figure>
<h2 id="cloudwatch"><a href="#cloudwatch" class="headerlink" title="cloudwatch"></a>cloudwatch</h2><h3 id="获取指定实例的网卡流出流量"><a href="#获取指定实例的网卡流出流量" class="headerlink" title="获取指定实例的网卡流出流量"></a>获取指定实例的网卡流出流量</h3><p>此操作至少需要以下权限：</p>
<ul>
<li><code>Cloudwatch.CloudWatchReadOnlyAccess</code></li>
<li><code>EC2.DescribeInstances</code></li>
</ul>
<p>通过 cloudwatch 获取 ec2 实例的监控数据 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[aws cloudwatch 命令说明](https://awscli.amazonaws.com/v2/documentation/api/latest/reference/cloudwatch/get-metric-statistics.html)">[1]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">aws cloudwatch get-metric-statistics</span> </span><br><span class="line">               --metric-name NetworkOut \</span><br><span class="line">               --start-time &quot;2023-01-01T00:00:00.000Z&quot; \</span><br><span class="line">               --end-time &quot;2023-01-10T00:00:00.000Z&quot; \</span><br><span class="line">               --period 86400 \</span><br><span class="line">               --namespace AWS/EC2 \</span><br><span class="line">               --statistics Sum \</span><br><span class="line">               --dimensions Name=InstanceId,Value=i-0904c5ba087f0b07c \</span><br><span class="line">               --region ap-east-1 --output text</span><br><span class="line">NetworkOut</span><br><span class="line">DATAPOINTS      4437779515.0    2023-01-05T00:00:00+00:00       Bytes</span><br><span class="line">DATAPOINTS      4289284683.0    2023-01-08T00:00:00+00:00       Bytes</span><br><span class="line">DATAPOINTS      4771646359.0    2023-01-01T00:00:00+00:00       Bytes</span><br><span class="line">DATAPOINTS      4634477427.0    2023-01-04T00:00:00+00:00       Bytes</span><br><span class="line">DATAPOINTS      4794193904.0    2023-01-07T00:00:00+00:00       Bytes</span><br><span class="line">DATAPOINTS      4403050407.0    2023-01-03T00:00:00+00:00       Bytes</span><br><span class="line">DATAPOINTS      4802329953.0    2023-01-06T00:00:00+00:00       Bytes</span><br><span class="line">DATAPOINTS      4527451078.0    2023-01-09T00:00:00+00:00       Bytes</span><br><span class="line">DATAPOINTS      4179191429.0    2023-01-02T00:00:00+00:00       Bytes</span><br></pre></td></tr></table></figure>

<h3 id="获取-cloudFront-CDN-域名的流量信息"><a href="#获取-cloudFront-CDN-域名的流量信息" class="headerlink" title="获取 cloudFront (CDN) 域名的流量信息"></a>获取 cloudFront (CDN) 域名的流量信息</h3><p>此操作至少需要以下权限：</p>
<ul>
<li><code>Cloudwatch.CloudWatchReadOnlyAccess</code></li>
<li><code>CloudFrontReadOnlyAccess</code></li>
</ul>
<p>通过以下命令列出所有的 <code>distributions</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">aws cloudfront list-distributions</span><br></pre></td></tr></table></figure>

<p>通过以下命令可查询指定的 CloudFront 中的 distribution 的流量统计信息，区域必须使用美国东部（弗吉尼亚北部）区域 (<code>us-east-1</code>)，<code>--dimensions Name=DistributionId,Value=E5MHZ8YUS8CUR Name=Region,Value=Global</code> 中同时需要指定 CloudFront 的 Region 为 <code>Global</code> <sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[使用 CloudWatch API 获取指标](https://docs.aws.amazon.com/zh_cn/AmazonCloudFront/latest/DeveloperGuide/programming-cloudwatch-metrics.html)">[3]</span></a></sup> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">aws cloudwatch get-metric-statistics --region us-east-1 --metric-name BytesDownloaded \</span></span><br><span class="line"><span class="language-bash">                                       --start-time 2023-01-01T00:00:00.000Z --end-time 2023-01-31T23:59:59.000Z --period 86400 \</span></span><br><span class="line"><span class="language-bash">                                       --namespace AWS/CloudFront --statistics Sum \ </span></span><br><span class="line">                                       --dimensions Name=DistributionId,Value=E5MHZ8YUS8CUR Name=Region,Value=Global \</span><br><span class="line">                                       --output json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;Label&quot;: &quot;BytesDownloaded&quot;,</span><br><span class="line">    &quot;Datapoints&quot;: []</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><h2 id="Errno-2-No-such-file-or-directory-‘less’"><a href="#Errno-2-No-such-file-or-directory-‘less’" class="headerlink" title="[Errno 2] No such file or directory: ‘less’"></a>[Errno 2] No such file or directory: ‘less’</h2><p>使用命令报错：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">aws --region ap-east-1 ec2 describe-instances</span></span><br><span class="line"></span><br><span class="line">Unable to redirect output to pager. Received the following error when opening pager:</span><br><span class="line">[Errno 2] No such file or directory: &#x27;less&#x27;</span><br><span class="line"></span><br><span class="line">Learn more about configuring the output pager by running &quot;aws help config-vars&quot;.</span><br></pre></td></tr></table></figure>
<p><strong>错误原因</strong>:</p>
<p>系统未安装 <code>less</code> 命令，安装 <code>less</code> 命令 (<code>yum install -y less</code>) 后正常。</p>
<h2 id="An-error-occurred-InvalidClientTokenId-when-calling-the-GetMetricStatistics-operation-The-security-token-included-in-the-request-is-invalid"><a href="#An-error-occurred-InvalidClientTokenId-when-calling-the-GetMetricStatistics-operation-The-security-token-included-in-the-request-is-invalid" class="headerlink" title="An error occurred (InvalidClientTokenId) when calling the GetMetricStatistics operation: The security token included in the request is invalid."></a>An error occurred (InvalidClientTokenId) when calling the GetMetricStatistics operation: The security token included in the request is invalid.</h2><p>使用命令报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">aws cloudwatch get-metric-statistics --metric-name Requests --start-time <span class="string">&#x27;2022-12-01T00:00:00.000Z&#x27;</span> --end-time <span class="string">&#x27;2022-12-31T23:59:59.000Z&#x27;</span> --period 2678400 \</span></span><br><span class="line"><span class="language-bash">                                       --namespace AWS/CloudFront --statistics Sum --dimensions Name=DistributionId,Value=E15 --output json</span></span><br><span class="line">                                       </span><br><span class="line">An error occurred (InvalidClientTokenId) when calling the GetMetricStatistics operation: The security token included in the request is invalid.                           </span><br></pre></td></tr></table></figure>
<p><strong>错误原因</strong></p>
<p>通过 CloudWatch 调用 CloudFront 的统计数据时，区域必须指定为 <code>美国东部（弗吉尼亚北部）区域 (us-east-1)</code>，使用选项 <code>--region us-east-1</code></p>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://awscli.amazonaws.com/v2/documentation/api/latest/reference/cloudwatch/get-metric-statistics.html">aws cloudwatch 命令说明</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://docs.aws.amazon.com/zh_cn/cli/latest/userguide/cli-usage-filter.html">aws cli 输出结果筛选</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://docs.aws.amazon.com/zh_cn/AmazonCloudFront/latest/DeveloperGuide/programming-cloudwatch-metrics.html">使用 CloudWatch API 获取指标</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>云平台</category>
        <category>Aws</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Aws</tag>
      </tags>
  </entry>
  <entry>
    <title>aws python sdk 常用操作</title>
    <url>/202207251345/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>centos 7</li>
<li>Python3.10</li>
<li>boto3 1.23.2 <blockquote>
<p>(<code>pip3 install boto3</code>)</p>
</blockquote>
</li>
</ul>
<span id="more"></span>

<h1 id="S3-相关操作"><a href="#S3-相关操作" class="headerlink" title="S3 相关操作"></a>S3 相关操作</h1><h2 id="获取-s3-中文件大小"><a href="#获取-s3-中文件大小" class="headerlink" title="获取 s3 中文件大小"></a>获取 s3 中文件大小</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> boto3.session <span class="keyword">import</span> Session</span><br><span class="line"></span><br><span class="line">ak = <span class="string">&#x27;XXXXXXX&#x27;</span></span><br><span class="line">sk = <span class="string">&#x27;XXXXXXXXXX&#x27;</span></span><br><span class="line">region = <span class="string">&#x27;us-west-1&#x27;</span></span><br><span class="line">bucketName = <span class="string">&#x27;testBucket&#x27;</span></span><br><span class="line"></span><br><span class="line">session = Session(aws_access_key_id=ak, aws_secret_access_key=sk, region_name=region)</span><br><span class="line">s3 = session.resource(<span class="string">&#x27;s3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">bucket = s3.Bucket(bucketName)</span><br><span class="line">obj = bucket.objects.<span class="built_in">filter</span>(Prefix=<span class="string">&#x27;filename&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> obj:</span><br><span class="line">    <span class="keyword">if</span> i.size:</span><br><span class="line">        <span class="keyword">return</span> i.size</span><br></pre></td></tr></table></figure>

<h1 id="EC2-相关操作"><a href="#EC2-相关操作" class="headerlink" title="EC2 相关操作"></a>EC2 相关操作</h1><h2 id="获取-EC2-instances"><a href="#获取-EC2-instances" class="headerlink" title="获取 EC2 instances"></a>获取 EC2 instances</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">import boto3</span><br><span class="line"></span><br><span class="line">client = boto3.client(&#x27;ec2&#x27;,region_name=&#x27;ap-east-1&#x27;,aws_access_key_id=&#x27;AK&#x27;,aws_secret_access_key=&#x27;ty&#x27;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出所有 Instances</span></span><br><span class="line">client.describe_instances()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>云平台</category>
        <category>Aws</category>
      </categories>
      <tags>
        <tag>云平台</tag>
        <tag>Aws</tag>
      </tags>
  </entry>
  <entry>
    <title>Awvs 破解版14.6.211213163 安装破解</title>
    <url>/2207221019/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Acunetix Web Vulnerability Scanner（简称AWVS）是一款知名的网络漏洞扫描工具，它通过网络爬虫测试你的网站安全，检测流行安全漏洞。  </p>
<span id="more"></span>

<h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Windows Server 2016 Datacenter</li>
<li>14.6.211213163</li>
</ul>
<h3 id="AWVS-安装激活"><a href="#AWVS-安装激活" class="headerlink" title="AWVS 安装激活"></a>AWVS 安装激活</h3><p>官方版本需要License才能下载，可通过如下链接下载破解版及补丁<br><a href="https://yzzpan.com/#sharefile=Nh2pQnaW_22930">www.ddosi.org下载入口</a><br><a href="https://yzzpan.com/#sharefile=DXt5k9dh_22034">www.ddosi.org破解工具下载入口</a></p>
<blockquote>
<p>解压密码均为: <a href="http://www.ddosi.org/">www.ddosi.org</a></p>
</blockquote>
<p><a href="https://s.csms.tech/file/acunetix_14.6.211213163.exe.rar">其他下载地址</a><br><a href="https://s.csms.tech/file/awvs_crack.rar">其他下载地址-破解工具</a> </p>
<p>下载后，双击文件 <code>acunetix_14.6.211213163.exe</code> 进行安装，按照提示，一直点击<code>下一步</code>，直到安装完成。<br>安装完成，打开登录后，处于未激活状态，显示如下图：<br><img src="https://i.csms.tech/img_14.png">  </p>
<p>复制 <code>awvs_crack</code> 目录下的文件 <code>license_info.json</code> 和 <code>wa_data.dat</code> </p>
<p><img src="https://i.csms.tech/img_15.png"> </p>
<p>覆盖目录 <code>C:\ProgramData\Acunetix\shared\license</code> 下的文件</p>
<p>修改hosts文件(<code>C:\Windows\System32\drivers\etc</code>), 添加以下内容：</p>
<figure class="highlight plaintext"><figcaption><span>C:\Windows\System32\drivers\etc</span></figcaption><table><tr><td class="code"><pre><span class="line">127.0.0.1 updates.acunetix.com</span><br><span class="line">127.0.0.1 erp.acunetix.com</span><br></pre></td></tr></table></figure>

<p>返回页面刷新，即可激活成功<br><img src="https://i.csms.tech/img_16.png"> </p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.ddosi.org/awvs-14-6/">Awvs破解版14.6.211213163|可扫Log4j RCE漏洞</a><br><a href="https://www.ddosi.org/awvs-14-5-2/">Awvs破解版14.5.211115146 Windows+Linux+Mac cracked</a></p>
]]></content>
      <categories>
        <category>安全</category>
        <category>Awvs</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>Awvs</tag>
        <tag>Acunetix</tag>
      </tags>
  </entry>
  <entry>
    <title>cdn7 api 使用</title>
    <url>/202302011016/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文档示例使用 Python3 调用 CDN77 API 的常用方法，CDN77 目前未提供 SDK，只有 REST API。 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[CDN77 api 官网说明文档](https://client.cdn77.com/support/api-reference/v3/introduction)">[1]</span></a></sup></p>
<h1 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h1><h2 id="创建调用-API-时需要的-API-Token"><a href="#创建调用-API-时需要的-API-Token" class="headerlink" title="创建调用 API 时需要的 API Token"></a>创建调用 API 时需要的 API Token</h2><p><a href="https://client.cdn77.com/support/api-reference/v3/introduction">参考文档创建 API Token</a></p>
<h2 id="读取-CDN-resources-列表"><a href="#读取-CDN-resources-列表" class="headerlink" title="读取 CDN resources 列表"></a>读取 CDN resources 列表</h2><figure class="highlight shell"><figcaption><span>python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; api_token = <span class="string">&#x27;sliJJYTUikbdg9798384Kbbj0kj&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; r = requests.get(<span class="string">&#x27;https://api.cdn77.com/v3/cdn&#x27;</span>, headers=&#123;<span class="string">&#x27;Authorization&#x27;</span>: f<span class="string">&#x27;Bearer &#123;api_token&#125;&#x27;</span>&#125;)</span></span><br></pre></td></tr></table></figure>

<h2 id="根据-cdn-resource-id-获取流量统计数据"><a href="#根据-cdn-resource-id-获取流量统计数据" class="headerlink" title="根据 cdn resource id 获取流量统计数据"></a>根据 cdn resource id 获取流量统计数据</h2><figure class="highlight shell"><figcaption><span>python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; url = <span class="string">&#x27;https://api.cdn77.com/v3/stats/cdns/traffic&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; headers = &#123;<span class="string">&#x27;Authorization&#x27;</span>: f<span class="string">&#x27;Bearer &#123;api_token&#125;&#x27;</span>&#125;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; data = json.dumps(&#123;<span class="string">&quot;cdn_ids&quot;</span>: [1991249093], <span class="string">&quot;aggregation&quot;</span>: <span class="string">&quot;1-month&quot;</span>, <span class="string">&quot;from&quot;</span>: 1669824000, <span class="string">&quot;to&quot;</span>: 1672502400&#125;)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; r = requests.post(url, headers=headers, data=data)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; r.json()</span></span><br><span class="line">&#123;&#x27;1991249093&#x27;: &#123;&#x27;1667260800&#x27;: &#123;&#x27;sizeCached&#x27;: 83745364388, &#x27;sizeNonCached&#x27;: 899336049&#125;, &#x27;1669852800&#x27;: &#123;&#x27;sizeCached&#x27;: 76503199334, &#x27;sizeNonCached&#x27;: 758547845&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>


<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://client.cdn77.com/support/api-reference/v3/introduction">CDN77 api 官网说明文档</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>云平台</category>
        <category>cdn77</category>
      </categories>
      <tags>
        <tag>云平台</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos 7 升级内核</title>
    <url>/202209140931/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Centos 7 内核版本由 3.10 升级到 5.4.212-1</p>
<h3 id="环境息息"><a href="#环境息息" class="headerlink" title="环境息息"></a>环境息息</h3><ul>
<li>Centos7 3.10.0-1062.9.1.el7.x86_64</li>
</ul>
<h3 id="升级步骤"><a href="#升级步骤" class="headerlink" title="升级步骤"></a>升级步骤</h3><h4 id="安装-elrepo-源"><a href="#安装-elrepo-源" class="headerlink" title="安装 elrepo 源"></a>安装 elrepo 源</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</span><br><span class="line">rpm -Uvh https://www.elrepo.org/elrepo-release-7.el7.elrepo.noarch.rpm</span><br><span class="line">yum --disablerepo=&quot;*&quot; --enablerepo=&quot;elrepo-kernel&quot; repolist</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h4 id="安装新版本内核"><a href="#安装新版本内核" class="headerlink" title="安装新版本内核"></a>安装新版本内核</h4><p>查看可用的内核版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum --disablerepo=<span class="string">&quot;*&quot;</span> --enablerepo=<span class="string">&quot;elrepo-kernel&quot;</span> list available</span></span><br><span class="line">Available Packages</span><br><span class="line">kernel-lt-doc.noarch                                      5.4.212-1.el7.elrepo                          elrepo-kernel</span><br><span class="line">kernel-lt-headers.x86_64                                  5.4.212-1.el7.elrepo                          elrepo-kernel</span><br><span class="line">kernel-lt-tools.x86_64                                    5.4.212-1.el7.elrepo                          elrepo-kernel</span><br><span class="line">kernel-lt-tools-libs.x86_64                               5.4.212-1.el7.elrepo                          elrepo-kernel</span><br><span class="line">kernel-lt-tools-libs-devel.x86_64                         5.4.212-1.el7.elrepo                          elrepo-kernel</span><br><span class="line">kernel-ml.x86_64                                          5.19.8-1.el7.elrepo                           elrepo-kernel</span><br><span class="line">kernel-ml-devel.x86_64                                    5.19.8-1.el7.elrepo                           elrepo-kernel</span><br><span class="line">kernel-ml-doc.noarch                                      5.19.8-1.el7.elrepo                           elrepo-kernel</span><br><span class="line">kernel-ml-headers.x86_64                                  5.19.8-1.el7.elrepo                           elrepo-kernel</span><br><span class="line">kernel-ml-tools.x86_64                                    5.19.8-1.el7.elrepo                           elrepo-kernel</span><br><span class="line">kernel-ml-tools-libs.x86_64                               5.19.8-1.el7.elrepo                           elrepo-kernel</span><br><span class="line">kernel-ml-tools-libs-devel.x86_64                         5.19.8-1.el7.elrepo                           elrepo-kernel</span><br><span class="line">perf.x86_64                                               5.19.8-1.el7.elrepo                           elrepo-kernel</span><br><span class="line">python-perf.x86_64                                        5.19.8-1.el7.elrepo                           elrepo-kernel</span><br></pre></td></tr></table></figure>
<blockquote>
<p>kernel-lt 和 kernel-ml 二者的区别：  </p>
<ul>
<li>kernel-ml 软件包是根据 Linux Kernel Archives 的主线稳定分支提供的源构建的。 内核配置基于默认的 RHEL-7 配置，并根据需要启用了添加的功能。 这些软件包有意命名为 kernel-ml，以免与 RHEL-7 内核发生冲突，因此，它们可以与常规内核一起安装和更新。  </li>
<li>kernel-lt 包是从 Linux Kernel Archives 提供的源代码构建的，就像 kernel-ml 软件包一样。 不同之处在于 kernel-lt 基于长期支持分支，而 kernel-ml 基于主线稳定分支。</li>
</ul>
<p>在 ELRepo 中有两个内核选项，一个是 kernel-lt（长期支持版），一个是 kernel-ml（主线最新版本），采用长期支持版本（kernel-lt），更加稳定一些。</p>
</blockquote>
<p>安装最新的长期支持版</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum --disablerepo=&quot;*&quot; --enablerepo=&quot;elrepo-kernel&quot; install kernel-lt kernel-lt-devel</span><br></pre></td></tr></table></figure>

<p>查看系统上可用的内核</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk -F\<span class="string">&#x27; &#x27;</span><span class="variable">$1</span>==<span class="string">&quot;menuentry &quot;</span> &#123;<span class="built_in">print</span> <span class="variable">$2</span>&#125;<span class="string">&#x27; /etc/grub2.cfg</span></span></span><br><span class="line">CentOS Linux (5.4.212-1.el7.elrepo.x86_64) 7 (Core)</span><br><span class="line">CentOS Linux (3.10.0-1062.9.1.el7.x86_64) 7 (Core)</span><br><span class="line">CentOS Linux (0-rescue-ed7b5ef29925468cbc59b47c142c26b8) 7 (Core)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="设置开机从新内核启动"><a href="#设置开机从新内核启动" class="headerlink" title="设置开机从新内核启动"></a>设置开机从新内核启动</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grub2-set-default 0</span><br></pre></td></tr></table></figure>

<h4 id="生成grub-配置文件"><a href="#生成grub-配置文件" class="headerlink" title="生成grub 配置文件"></a>生成grub 配置文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grub2-mkconfig -o /boot/grub2/grub.cfg</span></span><br><span class="line"></span><br><span class="line">Generating grub configuration file ...</span><br><span class="line">Found linux image: /boot/vmlinuz-5.4.212-1.el7.elrepo.x86_64</span><br><span class="line">Found initrd image: /boot/initramfs-5.4.212-1.el7.elrepo.x86_64.img</span><br><span class="line">Found linux image: /boot/vmlinuz-3.10.0-1062.9.1.el7.x86_64</span><br><span class="line">Found initrd image: /boot/initramfs-3.10.0-1062.9.1.el7.x86_64.img</span><br><span class="line">Found linux image: /boot/vmlinuz-0-rescue-ed7b5ef29925468cbc59b47c142c26b8</span><br><span class="line">Found initrd image: /boot/initramfs-0-rescue-ed7b5ef29925468cbc59b47c142c26b8.img</span><br><span class="line">done</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="重启系统并验证"><a href="#重启系统并验证" class="headerlink" title="重启系统并验证"></a>重启系统并验证</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">reboot</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者</span></span><br><span class="line">shutdown -r now</span><br></pre></td></tr></table></figure>
<p>重启后查看内核版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">uname</span> -r</span></span><br><span class="line">5.4.212-1.el7.elrepo.x86_64</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="查看系统中已安装的内核"><a href="#查看系统中已安装的内核" class="headerlink" title="查看系统中已安装的内核"></a>查看系统中已安装的内核</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rpm -qa | grep kernel</span></span><br><span class="line">kernel-lt-5.4.212-1.el7.elrepo.x86_64</span><br><span class="line">kernel-tools-libs-3.10.0-1062.9.1.el7.x86_64</span><br><span class="line">kernel-lt-devel-5.4.212-1.el7.elrepo.x86_64</span><br><span class="line">kernel-3.10.0-1062.9.1.el7.x86_64</span><br><span class="line">kernel-headers-3.10.0-1160.76.1.el7.x86_64</span><br><span class="line">kernel-tools-3.10.0-1062.9.1.el7.x86_64</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="删除旧内核，这一步是可选的"><a href="#删除旧内核，这一步是可选的" class="headerlink" title="删除旧内核，这一步是可选的"></a>删除旧内核，这一步是可选的</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum remove -y  kernel-devel-3.10.0   kernel-3.10.0  kernel-headers-3.10.0 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看已安装内核</span></span><br><span class="line">rpm -qa | grep kernel</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">也可以安装 yum-utils 工具，当系统安装的内核大于3个时，会自动删除旧的内核版本</span></span><br><span class="line">yum install -y  yum-utils</span><br></pre></td></tr></table></figure>

<h4 id="升级内核工具包"><a href="#升级内核工具包" class="headerlink" title="升级内核工具包"></a>升级内核工具包</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除旧版本工具包--可选</span></span><br><span class="line">yum remove kernel-tools-libs.x86_64 kernel-tools.x86_64</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装新版本工具包</span></span><br><span class="line">yum --disablerepo=&quot;*&quot; --enablerepo=elrepo-kernel install -y kernel-lt-tools.x86_64</span><br></pre></td></tr></table></figure>
<p>查看已安装内核</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ rpm -qa | grep kernel</span><br><span class="line"></span><br><span class="line">kernel-lt-5.4.212-1.el7.elrepo.x86_64</span><br><span class="line">kernel-lt-devel-5.4.212-1.el7.elrepo.x86_64</span><br><span class="line">kernel-lt-tools-libs-5.4.212-1.el7.elrepo.x86_64</span><br><span class="line">kernel-lt-tools-5.4.212-1.el7.elrepo.x86_64</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>内核升级完成后可再次重启系统进行验证</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.cnblogs.com/yanjieli/p/14839445.html">CentOS7 内核升级</a><br><a href="https://zhuanlan.zhihu.com/p/368879345">CentOS7 内核升级</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Centos</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos VNC server 配置</title>
    <url>/202208191637/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Centos 7</li>
</ul>
<p><code>VNC</code> 是一个图形桌面共享系统，可以通过远程连接的方式连接到服务器的图形系统以控制操作系统<br><code>VNC</code> 包括以下四个部分 ： <code>vncserver</code>，<code>vncviewer</code>，<code>vncpassword</code> 及 <code>vncconnect</code>。<br><code>VNC client</code> 端通过 <code>VNC</code> 协议远程连接到 <code>vnc server</code> 端，进行桌面共享及交互；  </p>
<h3 id="安装-tigervnc"><a href="#安装-tigervnc" class="headerlink" title="安装 tigervnc"></a>安装 tigervnc</h3><p>安装之前首先要确保系统已安装图形系统，本文以 <code>GNOME Desktop</code> 为图形桌面系统，执行以下命令检查是否已安装 <code>GNOME Desktop</code>，如果未安装，使用命令 <code>yum groupinstall &quot;GNOME Desktop&quot;</code> 安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum grouplist</span></span><br><span class="line">Loaded plugins: fastestmirror, langpacks</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line">Installed Environment Groups:</span><br><span class="line">   GNOME Desktop</span><br><span class="line">Available Environment Groups:</span><br><span class="line">   Minimal Install</span><br><span class="line">   Compute Node</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>桌面系统安装后，使用以下命令，安装 <code>tigervnc</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y tigervnc-server</span><br></pre></td></tr></table></figure>

<p>可以参考 <code>/lib/systemd/system/vncserver@.service</code> 中的指示，生成服务配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /lib/systemd/system/vncserver@.service /etc/systemd/system/vncserver@:1.service</span><br><span class="line">vim /etc/systemd/system/vncserver@\:1.service</span><br></pre></td></tr></table></figure>
<p>修改以下行，将其中的 <code>&lt;USER&gt;</code> 改为要远程登录的用户名，例如 <code>root</code></p>
<figure class="highlight shell"><figcaption><span>/etc/systemd/system/vncserver@\:1.service</span></figcaption><table><tr><td class="code"><pre><span class="line">ExecStart=/usr/bin/vncserver_wrapper root %i</span><br></pre></td></tr></table></figure>

<p>如果有多个用户需要远程连接，可以重复以上步骤，建立多个配置文件，如 <code>/etc/systemd/system/vncserver@:2.service</code>，各个服务之间互不影响，关闭一个服务，不影响其他的 <code>vnc</code> 服务 (如关闭： <code>vncserver@:2.service</code>，<code>vncserver@:1.service</code>的 <code>vnc</code> 远程依旧可以使用)  </p>
<p>修改服务文件后，使用以下命令重新加载服务启动脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure>

<p>启动服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start vncserver@:1.service</span><br></pre></td></tr></table></figure>
<p>服务启动后，会监听 5901 端口，如果有第二个服务，会监听在 5902 端口，以此类推，防火墙需要放通此端口<br><img src="https://i.csms.tech/img_41.png"></p>
<p>切换到需要 vnc 远程登录的用户，使用以下命令配置 <code>vnc</code> 远程登录用户的密码(只是 vnc 登录时使用的密码，非系统用户密码)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# su - USER</span><br><span class="line">[USER@localhost ~]$ vncpasswd</span><br></pre></td></tr></table></figure>
<p>设置 <code>vncpasswd</code> 密码后，在账号的家目录里就会自动建立 .vnc 文件，其中包括对应用户的 <code>vnc</code> 相关的日志</p>
<p>配置完成后，<a href="https://www.realvnc.com/en/connect/download/viewer/">下载客户端</a> 进行远程登录</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>tigervnc</tag>
      </tags>
  </entry>
  <entry>
    <title>SSL 证书格式说明</title>
    <url>/202210211124/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>常见的 SSL 证书格式主要有：</p>
<ul>
<li><code>.DER</code>  <code>.CER</code> - 文件是二进制格式，只保存证书，不保存私钥。</li>
<li><code>.PEM</code> - 一般是文本格式，可保存证书，可保存私钥。</li>
<li><code>.CRT</code> - 可以是二进制格式，可以是文本格式，一般均为文本格式，与 <code>.DER</code> 格式相同，不保存私钥。</li>
<li><code>.PFX</code>  <code>.P12</code> - 二进制格式，同时包含证书和私钥，一般有密码保护。</li>
<li><code>.JK</code> - 二进制格式，同时包含证书和私钥，一般有密码保护。</li>
</ul>
<h1 id="证书格式说明"><a href="#证书格式说明" class="headerlink" title="证书格式说明"></a>证书格式说明</h1><h2 id="DER-和-CER"><a href="#DER-和-CER" class="headerlink" title="DER 和 CER"></a>DER 和 CER</h2><p>该格式是二进制文件内容，Java 和 Windows 服务器偏向于使用这种编码格式。只含有证书信息，不包含私钥</p>
<p>OpenSSL 查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl x509 -in certificate.der -inform der -text -noout</span><br></pre></td></tr></table></figure>
<p>转换为 PEM：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl x509 -in cert.crt -inform der -outform pem -out cert.pem</span><br></pre></td></tr></table></figure>

<h2 id="PEM"><a href="#PEM" class="headerlink" title="PEM"></a>PEM</h2><p>Privacy Enhanced Mail，一般为文本格式，以 <code>-----BEGIN...</code> 开头，以 <code>-----END...</code> 结尾。中间的内容是 BASE64 编码。这种格式可以保存证书和私钥，有时我们也把 PEM 格式的私钥的后缀改为 <code>.key</code> 以区别证书与私钥。</p>
<p>这种格式常用于 Apache 和 Nginx 服务器。</p>
<p>OpenSSL 查看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl x509 -in certificate.pem -text -noout</span><br></pre></td></tr></table></figure>
<p>转换为 DER：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl x509 -in cert.crt -outform der -out cert.der</span><br></pre></td></tr></table></figure>

<h2 id="CRT"><a href="#CRT" class="headerlink" title="CRT"></a>CRT</h2><p>Certificate 的简称，有可能是 PEM 编码格式，也有可能是 DER 编码格式。如何查看请参考前两种格式。</p>
<h2 id="PFX"><a href="#PFX" class="headerlink" title="PFX"></a>PFX</h2><p>Predecessor of PKCS#12，这种格式是二进制格式，且证书和私钥存在一个 PFX 文件中。一般用于 Windows 上的 IIS 服务器。该格式的文件一般会有一个密码用于保证私钥的安全。</p>
<p>OpenSSL 查看：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl pkcs12 -in for-iis.pfx</span><br></pre></td></tr></table></figure>

<p>转换为 PEM：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl pkcs12 -in for-iis.pfx -out for-iis.pem -nodes</span><br></pre></td></tr></table></figure>

<h2 id="JKS"><a href="#JKS" class="headerlink" title="JKS"></a>JKS</h2><p>Java Key Storage，很容易知道这是 JAVA 的专属格式，利用 JAVA 的一个叫 keytool 的工具可以进行格式转换。一般用于 Tomcat 服务器。</p>
<p>可以到这里进行 <a href="https://myssl.com/cert_convert.html">格式转换</a></p>
<span id="more"></span>

<h1 id="证书格式转换"><a href="#证书格式转换" class="headerlink" title="证书格式转换"></a>证书格式转换</h1><p>以下证书格式之间是可以互相转换的<br><img src="https://i.csms.tech/img_65.png"></p>
<h2 id="将-JKS-格式证书转换成-PFX-格式"><a href="#将-JKS-格式证书转换成-PFX-格式" class="headerlink" title="将 JKS 格式证书转换成 PFX 格式"></a>将 JKS 格式证书转换成 PFX 格式</h2><p>使用 JDK 中自带的 Keytool 工具，将 JKS 格式证书文件转换成 PFX 格式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">keytool -v -importkeystore -srckeystore D:\apk\Helloworld.jks -srcstoretype jks -srcstorepass 18738892937lyj \</span><br><span class="line">           -destkeystore Helloworld.pfx -deststoretype pkcs12 -deststorepass 18738892937lyj -destkeypass 18738892937lyj</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="将-PFX-格式证书转换为-JKS-格式"><a href="#将-PFX-格式证书转换为-JKS-格式" class="headerlink" title="将 PFX 格式证书转换为 JKS 格式"></a>将 PFX 格式证书转换为 JKS 格式</h2><p>使用 JDK 中自带的 Keytool 工具，将 PFX 格式证书文件转换成 JKS 格式。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">keytool -importkeystore -srckeystore xxx.pfx \</span><br><span class="line">        -destkeystore xxx.jks -srcstoretype PKCS12 -deststoretype JKS</span><br></pre></td></tr></table></figure>

<h2 id="将-PEM-x2F-KEY-x2F-CRT-格式证书转换为-PFX-格式"><a href="#将-PEM-x2F-KEY-x2F-CRT-格式证书转换为-PFX-格式" class="headerlink" title="将 PEM&#x2F;KEY&#x2F;CRT 格式证书转换为 PFX 格式"></a>将 PEM&#x2F;KEY&#x2F;CRT 格式证书转换为 PFX 格式</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl pkcs12 -export -out server.pfx -inkey server.key -in server.crt</span><br></pre></td></tr></table></figure>

<h2 id="将PFX转换为PEM-x2F-KEY-x2F-CRT"><a href="#将PFX转换为PEM-x2F-KEY-x2F-CRT" class="headerlink" title="将PFX转换为PEM&#x2F;KEY&#x2F;CRT"></a>将PFX转换为PEM&#x2F;KEY&#x2F;CRT</h2><p>可以使用 OpenSSL工具，将 PFX 格式证书文件转化为 KEY 格式密钥文件和 CRT 格式公钥文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl pkcs12 -in server.pfx -nodes -out server.pem</span><br><span class="line">openssl rsa -in server.pem -out server.key</span><br><span class="line">openssl x509 -in server.pem -out server.crt</span><br></pre></td></tr></table></figure>

<h1 id="openssl-命令说明"><a href="#openssl-命令说明" class="headerlink" title="openssl 命令说明"></a>openssl 命令说明</h1><p>常用命令选项</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>-in</code></td>
<td>输入文件</td>
<td></td>
</tr>
<tr>
<td><code>-out</code></td>
<td>输出文件，默认为 <code>stdout</code></td>
<td></td>
</tr>
<tr>
<td><code>-inform</code></td>
<td>输入文件格式</td>
<td><code>DER</code> or <code>PEM</code></td>
</tr>
<tr>
<td><code>-outform</code></td>
<td>输出文件格式</td>
<td><code>DER</code> or <code>PEM</code></td>
</tr>
<tr>
<td><code>-keyform</code></td>
<td><code>key</code> 的格式，默认为 <code>PEM</code></td>
<td></td>
</tr>
<tr>
<td><code>-text</code></td>
<td>输出文本格式的内容</td>
<td><code>openssl x509  -text -in sverver.crt</code> 打印证书文本内容</td>
</tr>
<tr>
<td><code>-noout</code></td>
<td>不输出 REQ</td>
<td><code>openssl x509 -noout -text -in sverver.crt</code> <br/>打印证书文本格式的详情，不包括证书内容</td>
</tr>
</tbody></table>
<h2 id="查看证书内容"><a href="#查看证书内容" class="headerlink" title="查看证书内容"></a>查看证书内容</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl x509 -text -noout -in server.crt</span><br></pre></td></tr></table></figure>

<h2 id="使用-openssl-生成随机密码"><a href="#使用-openssl-生成随机密码" class="headerlink" title="使用 openssl 生成随机密码"></a>使用 openssl 生成随机密码</h2><p>几乎所有 Linux 发行版都包含 openssl。我们可以利用它的随机功能来生成可以用作密码的随机字母字符串。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl rand -base64 8</span><br></pre></td></tr></table></figure>
<p><code>openssl rand </code> 命令帮助信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">openssl rand</span> </span><br><span class="line">Usage: rand [options] num</span><br><span class="line">where options are</span><br><span class="line">-out file             - write to file</span><br><span class="line">-engine e             - use engine e, possibly a hardware device.</span><br><span class="line">-rand file:file:... - seed PRNG from files</span><br><span class="line">-base64               - base64 encode output</span><br><span class="line">-hex                  - hex encode output</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>SSL</tag>
        <tag>openssl</tag>
      </tags>
  </entry>
  <entry>
    <title>常见错误集锦</title>
    <url>/202211100923/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="nginx-php-fpm-返回状态码-500"><a href="#nginx-php-fpm-返回状态码-500" class="headerlink" title="nginx + php-fpm 返回状态码 500"></a>nginx + php-fpm 返回状态码 500</h1><h2 id="错误场景"><a href="#错误场景" class="headerlink" title="错误场景"></a>错误场景</h2><p><code>nginx</code> 反代 <code>php-fpm</code> 的场景下，客户端请求 <code>php</code> 类型文件，服务端返回 500 错误</p>
<h2 id="排查思路"><a href="#排查思路" class="headerlink" title="排查思路"></a>排查思路</h2><p>在 <code>nginx</code> 和 <code>php-fpm</code> 无足够日志的情况下，可以执行以下命令跟踪 <code>php-fpm</code> 的执行情况，并根据返回结果进行相应处理</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">strace $(pidof <span class="string">&#x27;php-fpm&#x27;</span>|sed <span class="string">&#x27;s/\([0-9]*\)/-p \1/g&#x27;</span>) -e write -e <span class="built_in">read</span> -s 1024</span></span><br><span class="line">read(14, &quot;\0fscf\0&quot;, 1023)              = 6</span><br><span class="line">read(14, 0x7fff9a885940, 1023)          = -1 EAGAIN (Resource temporarily unavailable)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="nginx-php-fpm-返回状态码-404"><a href="#nginx-php-fpm-返回状态码-404" class="headerlink" title="nginx + php-fpm 返回状态码 404"></a>nginx + php-fpm 返回状态码 404</h1><h2 id="错误场景-1"><a href="#错误场景-1" class="headerlink" title="错误场景"></a>错误场景</h2><p>Kubernetes(K8S) 场景下，Pod 中包含 <code>nginx</code> 容器和 <code>php-fpm</code> 容器</p>
<p><code>nginx</code> 配置文件如下，其中代码路径为 <code>root   /var/www/public;</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  _;</span><br><span class="line"></span><br><span class="line">    root   /var/www/public;</span><br><span class="line">    index  index.html index.htm index.php;</span><br><span class="line">    location / &#123;</span><br><span class="line">        try_files $uri $uri/ /index.php?$query_string;</span><br><span class="line">    &#125;</span><br><span class="line">    location ~ [^/]\.php(/|$) &#123;</span><br><span class="line">        fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        fastcgi_param  SCRIPT_FILENAME    $document_root$fastcgi_script_name;</span><br><span class="line">        fastcgi_index  index.php;</span><br><span class="line">        include        fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>php</code> 代码路径为 <code>/home/www/</code></p>
<h3 id="可能原因-1"><a href="#可能原因-1" class="headerlink" title="可能原因 1"></a>可能原因 1</h3><p><code>nginx</code> 配置中的代码路径（root   &#x2F;var&#x2F;www&#x2F;public;）和 <code>php</code> 代码的路径（<code>/home/www/</code>）不一致，导致 <code>nginx</code> 接收到 <code>php</code> 类型的请求时，根据配置（<code>fastcgi_param  SCRIPT_FILENAME    $document_root$fastcgi_script_name;</code>），将请求转发到 <code>php</code> 代码 <code>/var/www/public/$fastcgi_script_name</code>，而 <code>php</code> 代码其实位于 <code>/home/www/public/$fastcgi_script_name</code>，因此返回 404 错误（文件不存在）</p>
<h4 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法 1"></a>解决方法 1</h4><p>修改 <code>nginx</code> 配置文件，将代码目录配置为和 <code>php</code> 代码路径一致（<code>root   /home/www/public;</code>）</p>
<h4 id="解救方法-2"><a href="#解救方法-2" class="headerlink" title="解救方法 2"></a>解救方法 2</h4><p>修改 <code>nginx</code> 配置文件，为 <code>php</code> 类型的代码指明路径，修改如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">location ~ [^/]\.php(/|$) &#123;</span><br><span class="line">    root /home/www/public;</span><br><span class="line">    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">    fastcgi_param  SCRIPT_FILENAME    $document_root$fastcgi_script_name;</span><br><span class="line">    fastcgi_index  index.php;</span><br><span class="line">    include        fastcgi_params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，当 <code>nginx</code> 将 <code>php</code> 类型的代码转发到 <code>php-fpm</code> 进程时，会根据 <code>location</code> 中配置的 <code>root</code> 路径（覆盖 <code>server</code> 中的 <code>root</code>）寻找 <code>php</code> 代码 (<code>/home/www/public/$fastcgi_script_name</code>)</p>
]]></content>
      <tags>
        <tag>错误集锦</tag>
      </tags>
  </entry>
  <entry>
    <title>Confluence 常用基本操作</title>
    <url>/202208250937/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Confluence 是一个专业的企业知识管理与协同软件，也可以用于构建企业 <a href="https://zh.m.wikipedia.org/zh/Wiki"><code>wiki</code></a>。通过它可以实现团队成员之间的协作和知识共享。在这里，团队成员齐心协力，各擅其能，协同地编写文档和管理项目。从此打破不同团队、不同部门以及个人之间信息孤岛的僵局，Confluence 真正实现了组织资源共享。Confluence 使用简单，但它强大的编辑和站点管理特征能够帮助团队成员之间共享信息、文档协作、集体讨论。</p>
<span id="more"></span>

<h3 id="根据标题生成文章目录"><a href="#根据标题生成文章目录" class="headerlink" title="根据标题生成文章目录"></a>根据标题生成文章目录</h3><p>在 confluence 中编写文章时，可以根据不同级别的 <code>标题</code> 对文章内容进行分层，如下图所示    </p>
<p><img src="https://i.csms.tech/img_44.png"></p>
<p>在此情况之下，可以根据文章中的标题，生成文章目录，在文章内容过长或过多的情况下，可以根据目录轻松快速的定位到需要的内容章节，操作过长如下：<br>编辑需要生成目录的文章，按照下图所示的位置选择 <code>插入目录宏</code>  </p>
<p><img src="https://i.csms.tech/img_45.png"></p>
<p>在弹出的 <code>编辑‘目录’宏</code> 页面中配置相关参数，配置完成后，点击 <code>保存</code>，将会在页面中生成文章目录<br><img src="https://i.csms.tech/img_46.png"><br><img src="https://i.csms.tech/img_47.png"></p>
<p>如果要在特点的地方显示文章目录，可以使用 <code>页面布局</code> 操作，比如选择 <code>页面布局</code> 中的 <code>包含侧边栏的两列节</code> 并将目录放置在右边的侧边栏，示例及效果如下图<br><img src="https://i.csms.tech/img_48.png"><br><img src="https://i.csms.tech/img_49.png"></p>
<h3 id="链接到文章内的锚点"><a href="#链接到文章内的锚点" class="headerlink" title="链接到文章内的锚点"></a>链接到文章内的锚点</h3><h4 id="创建锚点"><a href="#创建锚点" class="headerlink" title="创建锚点"></a>创建锚点</h4><p>在需要创建 <code>锚点</code> 的地方，选择 <code>插入 ‘锚’ 宏</code>，输入 <code>锚名称</code>，插入后产生对应 <code>锚点</code><br><img src="https://i.csms.tech/img_50.png"></p>
<h4 id="链接到同一文章内锚点"><a href="#链接到同一文章内锚点" class="headerlink" title="链接到同一文章内锚点"></a>链接到同一文章内锚点</h4><p>在需要链接 <code>锚点</code> 的地方，选择 <code>插入链接</code>，链接中 <code>锚点</code> 使用 <code>#锚点名称</code> 进行链接<br><img src="https://i.csms.tech/img_51.png"></p>
<h4 id="链接到其他文章内的锚点"><a href="#链接到其他文章内的锚点" class="headerlink" title="链接到其他文章内的锚点"></a>链接到其他文章内的锚点</h4><p><code>confluence</code> 的同一个空间内不允许存在同名的页面（文章），因此所有页面（文章）名具有独一性，当需要链接到其他页面中的锚点时，可以参照以下配置。比如要链接到页面 <code>cs</code> 中的 <code>test</code> 锚点，按照以下配置，在需要链接的地方插入链接<br><img src="https://i.csms.tech/img_52.png"></p>
<blockquote>
<p>这种方式下，锚点所在的页面改名，锚点依然生效，使用锚点的链接中页面名也会随之改变  </p>
</blockquote>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Confluence</tag>
      </tags>
  </entry>
  <entry>
    <title>containerd 使用方法</title>
    <url>/202212011355/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos 7</li>
<li>containerd.io-1.4.13-3</li>
</ul>
<h1 id="containerd-相关配置"><a href="#containerd-相关配置" class="headerlink" title="containerd 相关配置"></a>containerd 相关配置</h1><h2 id="默认配置文件"><a href="#默认配置文件" class="headerlink" title="默认配置文件"></a>默认配置文件</h2><p><code>containerd</code> 服务默认配置文件为 <code>/etc/containerd/config.toml</code></p>
<figure class="highlight shell"><figcaption><span>/etc/containerd/config.toml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">root = <span class="string">&quot;/var/lib/containerd&quot;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">state = <span class="string">&quot;/run/containerd&quot;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">subreaper = <span class="literal">true</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">oom_score = 0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Containerd 有两个不同的存储路径，一个用来保存持久化数据，一个用来保存运行时状态。 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Containerd 的前世今生和保姆级入门教程](https://blog.51cto.com/u_15127639/3256557)">[1]</span></a></sup></p>
<figure class="highlight shell"><figcaption><span>/etc/containerd/config.toml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">root = <span class="string">&quot;/var/lib/containerd&quot;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">state = <span class="string">&quot;/run/containerd&quot;</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>root</code> - 用来保存持久化数据，包括 Snapshots, Content, Metadata 以及各种插件的数据。每一个插件都有自己单独的目录，Containerd 本身不存储任何数据，它的所有功能都来自于已加载的插件。</li>
<li><code>state</code> - 用来保存临时数据，包括 <code>sockets</code>、<code>pid</code>、<code>挂载点</code>、<code>运行时状态</code> 以及不需要持久化保存的插件数据。</li>
</ul>
<figure class="highlight shell"><figcaption><span>/etc/containerd/config.toml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">oom_score = 0</span></span><br></pre></td></tr></table></figure>
<p>Containerd 是容器的守护者，一旦发生内存不足的情况，理想的情况应该是先杀死容器，而不是杀死 Containerd。所以需要调整 Containerd 的 OOM 权重，减少其被 OOM Kill 的几率。<code>oom_score</code> 其取值范围为 <code>-1000</code> 到 <code>1000</code>，如果将该值设置为 <code>-1000</code>，则进程永远不会被杀死，建议 Containerd 将该值设置为 <code>-999</code> 到 <code>0</code> 之间。如果作为 Kubernetes 的 Worker 节点，可以考虑设置为 <code>-999</code>。</p>
<h2 id="containerd-服务配置文件"><a href="#containerd-服务配置文件" class="headerlink" title="containerd 服务配置文件"></a>containerd 服务配置文件</h2><p>默认的 <code>containerd</code> 服务的配置为 <code>/usr/lib/systemd/system/containerd.service</code></p>
<figure class="highlight shell"><figcaption><span>/usr/lib/systemd/system/containerd.service</span></figcaption><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=containerd container runtime</span><br><span class="line">Documentation=https://containerd.io</span><br><span class="line">After=network.target local-fs.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStartPre=-/sbin/modprobe overlay</span><br><span class="line">ExecStart=/usr/bin/containerd</span><br><span class="line"></span><br><span class="line">Type=notify</span><br><span class="line">Delegate=yes</span><br><span class="line">KillMode=process</span><br><span class="line">Restart=always</span><br><span class="line">RestartSec=5</span><br><span class="line"></span><br><span class="line">LimitNPROC=infinity</span><br><span class="line">LimitCORE=infinity</span><br><span class="line">LimitNOFILE=1048576</span><br><span class="line"></span><br><span class="line">TasksMax=infinity</span><br><span class="line">OOMScoreAdjust=-999</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong><code>Delegate</code></strong> - 这个选项允许 Containerd 以及运行时自己管理自己创建的容器的 cgroups。如果不设置这个选项，<code>systemd</code> 就会将进程移到自己的 cgroups 中，从而导致 Containerd 无法正确获取容器的资源使用情况。</p>
</li>
<li><p><strong><code>KillMode</code></strong> - 这个选项用来处理 Containerd 进程被杀死的方式。默认情况下，<code>systemd</code> 会在进程的 cgroup 中查找并杀死 Containerd 的所有子进程，这肯定不是我们想要的。<code>KillMode</code> 字段可以设置的值如下:</p>
<ul>
<li><strong><code>control-group</code></strong> -（默认值）当前控制组里面的所有子进程，都会被杀掉</li>
<li><strong><code>process</code></strong> - 只杀主进程。</li>
<li><strong><code>mixed</code></strong> - 主进程将收到 <code>SIGTERM</code> 信号，子进程收到 <code>SIGKILL</code> 信号</li>
<li><strong><code>none</code></strong> - 没有进程会被杀掉，只是执行服务的 stop 命令。</li>
</ul>
<p>  需要将 <code>KillMode</code> 的值设置为<code> process</code>，这样可以确保升级或重启 Containerd 时不杀死现有的容器。</p>
</li>
</ul>
<h1 id="客户端工具-ctr-使用"><a href="#客户端工具-ctr-使用" class="headerlink" title="客户端工具 ctr 使用"></a>客户端工具 ctr 使用</h1><h2 id="ctr-管理镜像"><a href="#ctr-管理镜像" class="headerlink" title="ctr 管理镜像"></a>ctr 管理镜像</h2><h3 id="镜像下载"><a href="#镜像下载" class="headerlink" title="镜像下载"></a>镜像下载</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ctr image pull docker.io/library/nginx:alpine</span><br></pre></td></tr></table></figure>

<h3 id="列出本地镜像"><a href="#列出本地镜像" class="headerlink" title="列出本地镜像"></a>列出本地镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ctr image <span class="built_in">ls</span></span></span><br><span class="line">REF                            TYPE                                                      DIGEST                                                                  SIZE    PLATFORMS                                                                                LABELS </span><br><span class="line">docker.io/library/nginx:alpine application/vnd.docker.distribution.manifest.list.v2+json sha256:455c39afebd4d98ef26dd70284aa86e6810b0485af5f4f222b19b89758cabf1e 9.8 MiB linux/386,linux/amd64,linux/arm/v6,linux/arm/v7,linux/arm64/v8,linux/ppc64le,linux/s390x -</span><br></pre></td></tr></table></figure>
<h3 id="将镜像挂载到本地目录"><a href="#将镜像挂载到本地目录" class="headerlink" title="将镜像挂载到本地目录"></a>将镜像挂载到本地目录</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ctr image mount docker.io/library/nginx:alpine /mnt</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> /mnt</span></span><br><span class="line">bin  docker-entrypoint.d   etc   lib    mnt  proc  run   srv  tmp  var</span><br><span class="line">dev  docker-entrypoint.sh  home  media  opt  root  sbin  sys  usr</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>卸载已挂载的镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ctr image unmount /mnt</span><br></pre></td></tr></table></figure>

<h2 id="ctr-管理-容器"><a href="#ctr-管理-容器" class="headerlink" title="ctr 管理 容器"></a>ctr 管理 容器</h2><h3 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ctr container create docker.io/library/nginx:alpine nginx</span><br></pre></td></tr></table></figure>
<p>容器创建后，并没有开始运行，只是分配了容器运行所需的资源及配置的数据结构，这意味着 <code>namespaces</code>、<code>rootfs</code> 和容器的配置都已经初始化成功了，只是用户进程(这里是 <code>nginx</code>)还没有启动，容器（进程）状态的变化由 <code>Task</code> 对象实现，通过命令 <code>ctr task</code> 来管理。</p>
<p>启动 <code>ctr container create</code> 创建的容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ctr task start nginx</span><br></pre></td></tr></table></figure>
<p>以上命令启动之前创建的容器 <code>nginx</code>，未指定其他参数时，容器中的进程在系统前台运行，如需后台运行，可以使用选项 <code>-d</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ctr task start nginx -d</span><br></pre></td></tr></table></figure>

<p>也可以直接使用 <code>run</code> 命令，创建并启动容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ctr run --rm -d docker.io/library/nginx:alpine nginx1</span><br></pre></td></tr></table></figure>

<h3 id="列出容器"><a href="#列出容器" class="headerlink" title="列出容器"></a>列出容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ctr container ls</span><br></pre></td></tr></table></figure>

<p>查看容器中进程的状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ctr task <span class="built_in">ls</span></span></span><br><span class="line">TASK      PID     STATUS    </span><br><span class="line">nginx1    5495    RUNNING</span><br></pre></td></tr></table></figure>
<p>查看容器中运行的所有的进程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ctr task ps nginx1</span></span><br><span class="line">PID     INFO</span><br><span class="line">5495    -</span><br><span class="line">5531    -</span><br><span class="line">5532    -</span><br><span class="line">5533    -</span><br><span class="line">5534    -</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>这里的 PID 是宿主机看到的 PID，不是容器中看到的 PID。</strong></p>
<h3 id="查看容器详细信息"><a href="#查看容器详细信息" class="headerlink" title="查看容器详细信息"></a>查看容器详细信息</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ctr container info nginx</span><br></pre></td></tr></table></figure>

<h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p>停止&#x2F;删除容器中的进程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ctr task delete nginx -f</span><br><span class="line"></span><br><span class="line">ctr task pause nginx</span><br></pre></td></tr></table></figure>
<p>以上命令<strong>删除&#x2F;停止容器中的进程，但是并不删除容器</strong>，执行以上命令后再执行以下命令，可删除容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ctr container delete nginx</span><br></pre></td></tr></table></figure>
<p><strong>ctr 没有 stop 容器的功能，只能暂停或者杀死容器。</strong></p>
<h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ctr task exec -t --exec-id 1 nginx1 sh</span><br></pre></td></tr></table></figure>
<p>执行 <code>ctr task exec</code> 进入容器，必须制定 <code>--exec-id</code>，值可以随便指定。</p>
<h3 id="namespace-管理"><a href="#namespace-管理" class="headerlink" title="namespace 管理"></a>namespace 管理</h3><p>Containerd 相比于 Docker ，多了 Namespace 的概念，使用以下命令，查看所有的 Namespace</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ctr ns <span class="built_in">ls</span></span></span><br><span class="line">NAME    LABELS </span><br><span class="line">default        </span><br><span class="line">moby     </span><br></pre></td></tr></table></figure>
<p><code>docker</code> 默认使用 <code>moby</code> 的 Namespace，要使用 <code>ctr</code> 命令查看 <code>docker</code> 创建的容器，需要使用选项 <code>-n moby</code> 指定命名空间，否则 <code>ctr</code> 默认使用 <code>default</code> 命名空间，无法看到 <code>moby</code> 命名空间中的资源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ctr -n moby container ls</span><br><span class="line">CONTAINER                                                           IMAGE    RUNTIME                           </span><br><span class="line">17b16c3699cdb88a1ff80d8a7c84724eff393c42186775b58418c90bd178600f    -        io.containerd.runtime.v1.linux    </span><br><span class="line">27fc19226baa91251d63a375a7b1309122334cfb5ceb39aeb67ab1701b708464    -        io.containerd.runtime.v1.linux</span><br></pre></td></tr></table></figure>

<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://blog.51cto.com/u_15127639/3256557">Containerd 的前世今生和保姆级入门教程</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>containerd</tag>
      </tags>
  </entry>
  <entry>
    <title>Django admin 配置</title>
    <url>/202209021312/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Django 自带的 <code>Admin Site</code> 管理页面可以方便用户快速构建一个简单的后台管理系统，少量代码即可快速实现对数据库中的数据进行展示、修改、保存的可视化页面和功能。当需要对后台展示的数据进行配置时，只需要在 <code>app</code> 的代码文件 <code>admin.py</code> 中进行相应配置即可。</p>
<h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>centos 7</li>
<li>python 3.10</li>
<li>django 4.0</li>
</ul>
<h1 id="配置登录页面和-web-页面中显示的-title"><a href="#配置登录页面和-web-页面中显示的-title" class="headerlink" title="配置登录页面和 web 页面中显示的 title"></a>配置登录页面和 web 页面中显示的 title</h1><figure class="highlight shell"><figcaption><span>admin.py</span></figcaption><table><tr><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line"></span><br><span class="line">admin.site.site_header = &quot;My Admin Site&quot;</span><br><span class="line">admin.site.site_title = &quot;My Admin Site&quot;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_53.png"></p>
<h1 id="为-model-配置-admin-管理页面"><a href="#为-model-配置-admin-管理页面" class="headerlink" title="为 model 配置 admin 管理页面"></a>为 model 配置 admin 管理页面</h1><p>要为 model 启用 admin 管理接口，<a href="https://csms.tech/202301191014/#model-注册到后台">参考配置</a></p>
<span id="more"></span>
<h2 id="常用配置说明"><a href="#常用配置说明" class="headerlink" title="常用配置说明"></a>常用配置说明</h2><p>admin 中的配置大多来自 <code>ModelAdmin</code> 对象的选项 <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[ModelAdmin 对象](https://docs.djangoproject.com/zh-hans/4.1/ref/contrib/admin/#modeladmin-options)">[2]</span></a></sup></p>
<figure class="highlight shell"><figcaption><span>admin.py</span></figcaption><table><tr><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">假如 app 为 servers，导入 models</span></span><br><span class="line">from servers import models</span><br><span class="line"></span><br><span class="line">@admin.register(models.Servers)</span><br><span class="line">class ServersAdmin(admin.ModelAdmin):</span><br><span class="line">    # list_display 定义model 中要显示的列</span><br><span class="line">    # list_display_links 定义了哪些列可以点击(链接)跳转到对象的修改页面</span><br><span class="line">    list_display = (&#x27;inVender&#x27;, &#x27;contacter&#x27;, &#x27;name&#x27;, &#x27;ip&#x27;, &#x27;type&#x27;, &#x27;zone&#x27;, &#x27;diskSize&#x27;, &#x27;diskType&#x27;, &#x27;dataTransfer&#x27;)</span><br><span class="line">    list_display_links = (&#x27;inVender&#x27;, &#x27;name&#x27;, &#x27;ip&#x27;)</span><br><span class="line"></span><br><span class="line">    # fields 定义修改页面中显示哪些修改项, 未出现在此的列,添加或修改对象时不显示.</span><br><span class="line">    # fieldsets 对要编辑的部分进行分组显示, &#x27;classes&#x27;: (&#x27;collapse&#x27;,) 为 CSS 格式定义隐藏和显示</span><br><span class="line">    fields = (&#x27;inVender&#x27;, )</span><br><span class="line">    </span><br><span class="line">    fieldsets = (</span><br><span class="line">        [&#x27;Main&#x27;,&#123;</span><br><span class="line">            &#x27;fields&#x27;:(&#x27;name&#x27;,&#x27;ip&#x27;),</span><br><span class="line">        &#125;],</span><br><span class="line">        [&#x27;Advance&#x27;,&#123;</span><br><span class="line">            &#x27;classes&#x27;: (&#x27;collapse&#x27;,), # CSS</span><br><span class="line">            &#x27;fields&#x27;: (&#x27;inVender&#x27;,),</span><br><span class="line">        &#125;]</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    # search_fields  定义哪些列可以被搜索</span><br><span class="line">    search_fields = (&#x27;name&#x27;,)</span><br><span class="line">    </span><br><span class="line">    # actions 要在变更列表页上提供的动作列表</span><br><span class="line">    actions = [&#x27;startCheck&#x27;]</span><br><span class="line">    </span><br><span class="line">    # actions_on_top actions_on_bottom 定义控制动作栏在页面的哪个位置出现，默认在顶部</span><br><span class="line">    actions_on_top = True</span><br><span class="line">    actions_on_bottom = False</span><br><span class="line">    </span><br><span class="line">    # readonly_fields 定义只读列，此处里面的项不可编辑，不在此列表中的项可以编辑</span><br><span class="line">    # 同时存在于 readonly_fields 和 fields/fieldsets 中的列，不可编辑</span><br><span class="line">    readonly_fields = (&#x27;name&#x27;,)</span><br><span class="line">    </span><br><span class="line">    # 控制每个分页的管理变更列表页面上出现多少个项目。默认情况下，设置为 100</span><br><span class="line">    list_per_page = 100</span><br></pre></td></tr></table></figure>

<h3 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h3><p><code>actions</code> 定义要在变更列表页上提供的动作列表 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[管理 actions](https://docs.djangoproject.com/zh-hans/4.1/ref/contrib/admin/actions/#admin-actions)">[1]</span></a></sup> </p>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://docs.djangoproject.com/zh-hans/4.1/ref/contrib/admin/actions/#admin-actions">管理 actions</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://docs.djangoproject.com/zh-hans/4.1/ref/contrib/admin/#modeladmin-options">ModelAdmin 对象</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>django 定时任务</title>
    <url>/202208170917/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>centos 7</li>
<li>python 3.10</li>
<li>django 4.0</li>
<li>django-crontab</li>
</ul>
<p><code>django-crontab</code> 依赖 <code>Linux</code> 系统中的 <code>crontab</code>，因此只能在 <code>Linux</code> 系统中使用</p>
<span id="more"></span>

<h3 id="安装-django-crontab"><a href="#安装-django-crontab" class="headerlink" title="安装 django-crontab"></a>安装 django-crontab</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install django-crontab</span><br></pre></td></tr></table></figure>

<p><code>django-crontab</code> 插件是以 <code>app</code> 的方式存在， 将 <code>django-crontab</code> 添加到 <code>django</code> 工程配置文件 <code>settings.py</code> 中的 <code>INSTALLED_APPS</code></p>
<figure class="highlight shell"><figcaption><span>settings.py</span></figcaption><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    &#x27;django.contrib.admin&#x27;,</span><br><span class="line">    &#x27;django.contrib.auth&#x27;,</span><br><span class="line">    &#x27;django.contrib.contenttypes&#x27;,</span><br><span class="line">    &#x27;django.contrib.sessions&#x27;,</span><br><span class="line">    &#x27;django.contrib.messages&#x27;,</span><br><span class="line">    &#x27;django.contrib.staticfiles&#x27;,</span><br><span class="line">    ...</span><br><span class="line">    &#x27;django_crontab&#x27;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="配置定时任务"><a href="#配置定时任务" class="headerlink" title="配置定时任务"></a>配置定时任务</h3><p>假设定时任务路径为 <code>myapp.cron.scheduled_job</code><br>编写好定时任务后，要启用定时任务，需要在 <code>django</code> 工程配置文件 <code>settings.py</code> 中配置以下内容</p>
<figure class="highlight shell"><figcaption><span>settings.py</span></figcaption><table><tr><td class="code"><pre><span class="line">CRONJOBS = [</span><br><span class="line">    (&#x27;* * * * *&#x27;, &#x27;myapp.cron.scheduled_job&#x27;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>如果定时任务需要参数，可以使用如下格式</p>
<figure class="highlight shell"><figcaption><span>settings.py</span></figcaption><table><tr><td class="code"><pre><span class="line">CRONJOBS = [</span><br><span class="line">    (&#x27;* * * * *&#x27;, &#x27;myapp.cron.scheduled_job&#x27;, &#x27;&gt;&gt; run.log 2&gt;&amp;1&#x27;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>以上定时任务，会将任务执行过程中的标准输出和标准错误输出写入到文件 <code>run.log</code></p>
<p>也可以使用列表参数</p>
<figure class="highlight shell"><figcaption><span>settings.py</span></figcaption><table><tr><td class="code"><pre><span class="line">CRONJOBS = [</span><br><span class="line">    (&#x27;* * * * *&#x27;, &#x27;myapp.cron.scheduled_job&#x27;, [&#x27;list_args1&#x27;, &#x27;list_args2&#x27;], &#123;&#x27;dict_args1&#x27;: v1, &#x27;dict_args2&#x27;: v2&#125;),</span><br><span class="line">    (&#x27;* * * * *&#x27;, &#x27;myapp.cron.scheduled_job&#x27;, [&#x27;list_args1&#x27;])</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>其中，定时任务的第一部分（<code>* * * * *</code>），语法和 <code>Linux</code> 系统 <code>crontab</code> 一致，具体语法可参考： <a href="https://www.runoob.com/linux/linux-comm-crontab.html">linux crontab 语法</a></p>
<p>配置好定时任务之后，执行以下命令添加定时任务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 manage.py crontab add</span><br></pre></td></tr></table></figure>


<p>运行定时任务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 manage.py crontab run </span><br></pre></td></tr></table></figure>
<p>运行定时任务后，会在系统 <code>crontab</code> 中追加一个定时任务，可使用 <code>crontab -l</code> 命令查看定时任务  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">crontab -l</span></span><br><span class="line">* * * * * python3 /django/project/manage.py crontab run b4564bdabd9dcb16a9b69d79a612430f &gt;&gt; run.log 2&gt;&amp;1   # django-cronjobs for project</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>显示定时任务列表</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 manage.py crontab show</span><br></pre></td></tr></table></figure>
<p>删除定时任务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 manage.py crontab remove b4564bdabd9dc</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意事项</strong>： <code>CRONJOBS</code> 中配置的定时任务及所有参数不能有变量值，比如以下配置，在第二天时，不会再执行。</p>
<figure class="highlight shell"><figcaption><span>settings.py</span></figcaption><table><tr><td class="code"><pre><span class="line">CRONJOBS = [</span><br><span class="line">(&#x27;0 7 * * *&#x27;, &#x27;myapp.cron.scheduled_job&#x27;, &#x27;&gt;&gt; %s&#x27; time.time())</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>因为，<code>CRONJOBS</code> 生成任务时，会生成对应的哈希值（hashes），标识每个任务。所以，当文件名变更时，<code>CRONJOBS</code> 中的值每天都在变化，导致不同的定时任务哈希值（hashes）。而系统 <code>crontab</code> 定时任务中的任务哈希值还是第一次执行 <code>python3 manage.py crontab add</code> 时的值</p>
</blockquote>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://cloud.tencent.com/developer/article/1599968">django 定时任务 django-crontab 的使用</a><br><a href="https://www.runoob.com/linux/linux-comm-crontab.html">Linux crontab 命令</a></p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>django logging 模块</title>
    <url>/202208151622/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>python 3.10</li>
<li>django 4.0</li>
</ul>
<h3 id="Python-logging-模块说明"><a href="#Python-logging-模块说明" class="headerlink" title="Python logging 模块说明"></a>Python logging 模块说明</h3><p><code>Django</code> 使用 <code>Python</code> 内置的 <code>logging</code> 模块处理系统日志，一份 <code>Python logging</code> 配置由下面四个部分组成：</p>
<ul>
<li>Loggers</li>
<li>Handlers</li>
<li>Filters</li>
<li>Formatters</li>
</ul>
<h4 id="Loggers"><a href="#Loggers" class="headerlink" title="Loggers"></a>Loggers</h4><p><code>logger</code> 是日志系统的入口。每个 <code>logger</code> 都是命名了的 <code>bucket</code>， 消息写入 <code>bucket</code> 以便进一步处理<br><code>logger</code> 可以配置 <code>日志级别</code>。日志级别描述了由该 <code>logger</code> 处理的消息的严重性。<code>Python</code> 定义了下面几种日志级别：</p>
<ul>
<li><code>DEBUG</code>：排查故障时使用的低级别系统信息</li>
<li><code>INFO</code>：一般的系统信息</li>
<li><code>WARNING</code>：描述系统发生了一些小问题的信息</li>
<li><code>ERROR</code>：描述系统发生了大问题的信息</li>
<li><code>CRITICAL</code>：描述系统发生严重问题的信息</li>
</ul>
<p>每一条写入 <code>logger</code> 的消息都是一条 <code>日志记录</code>。每一条日志记录也包含 <code>日志级别</code>，代表对应消息的严重程度。日志记录还包含有用的元数据，来描述被记录了日志的事件细节，例如堆栈跟踪或者错误码。  </p>
<p>当 <code>logger</code> 处理一条消息时，会将自己的 <code>日志级别</code> 和这条消息的 <code>日志级别</code> 做对比。如果消息的日志级别匹配或者高于 <code>logger</code> 的日志级别，它就会被进一步处理。否则这条消息就会被忽略掉。  </p>
<p>当 <code>logger</code> 确定了一条消息需要处理之后，会把它传给 <code>Handler</code>。</p>
<span id="more"></span>

<h4 id="Handlers"><a href="#Handlers" class="headerlink" title="Handlers"></a>Handlers</h4><p><code>Handler</code> 是决定如何处理 <code>logger</code> 中每一条消息的引擎。它描述特定的日志行为，比如把消息输出到<code>屏幕(stdout)</code>、<code>文件</code>或<code>网络 socket</code>。<br>和 <code>logger</code> 一样，<code>handler</code> 也有 <code>日志级别</code> 的概念。如果一条日志记录的级别不匹配或者低于 <code>handler</code> 的日志级别，对应的消息会被 <code>handler</code> 忽略。</p>
<p>一个 <code>logger</code> 可以有多个 <code>handler</code>，每一个 <code>handler</code> 可以有不同的日志级别。这样就可以根据消息的重要性不同，来提供不同格式的输出。例如，你可以添加一个 <code>handler</code> 把 <code>ERROR</code> 和 <code>CRITICAL</code> 消息发送短消息，再添加另一个 <code>handler</code> 把所有的消息（包括 <code>ERROR</code> 和 <code>CRITICAL</code> 消息）保存到文件里以便日后分析。</p>
<h4 id="Filters"><a href="#Filters" class="headerlink" title="Filters"></a>Filters</h4><p>在日志记录从 <code>logger</code> 传到 <code>handler</code> 的过程中，使用 <code>Filter</code> 来做额外的控制。<br>默认情况下，只要级别匹配，任何日志消息都会被处理。不过，也可以通过添加 <code>filter</code> 来给日志处理的过程增加额外条件。例如，可以添加一个 <code>filter</code> 只允许某个特定来源的 <code>ERROR</code> 消息输出。  </p>
<p><code>Filter</code> 还被用来在日志输出之前对日志记录做修改。例如，可以写一个 <code>filter</code>，当满足一定条件时，把日志记录从 <code>ERROR</code> 降到 <code>WARNING</code> 级别。  </p>
<p><code>Filter</code> 在 <code>logger</code> 和 <code>handler</code> 中都可以添加；多个 <code>filter</code> 可以链接起来使用，来做多重过滤操作。</p>
<h4 id="Formatters"><a href="#Formatters" class="headerlink" title="Formatters"></a>Formatters</h4><p>日志记录最终是需要以文本来呈现的。<code>Formatter</code> 描述了文本的格式。一个 <code>formatter</code> 通常由包含 <a href="https://docs.python.org/3/library/logging.html#logrecord-attributes"><code>LogRecord attributes</code></a> 的 <code>Python 格式化字符串</code> 组成，不过你也可以为特定的格式来配置自定义的 formatter。</p>
<h3 id="Python-logging-模块使用方式介绍"><a href="#Python-logging-模块使用方式介绍" class="headerlink" title="Python logging 模块使用方式介绍"></a>Python logging 模块使用方式介绍</h3><p><code>logging</code> 模块提供了两种记录日志的方式：</p>
<ul>
<li>第一种方式是使用 <code>logging</code> 提供的模块级别的方法</li>
<li>第二种方式是使用 <code>Logging</code> 日志系统的四大组件</li>
</ul>
<h4 id="logging-模块级别方法使用说明"><a href="#logging-模块级别方法使用说明" class="headerlink" title="logging 模块级别方法使用说明"></a>logging 模块级别方法使用说明</h4><p><code>logging</code> 提供的模块级别常用方法有：  </p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>logging.basicConfig(**kwargs)</code></td>
<td>对 <code>root logger</code> 进行一次性配置</td>
<td></td>
</tr>
<tr>
<td><code>logging.debug(msg, args, *kwargs)</code></td>
<td>记录级别为 <code>DEBUG</code> 的日志</td>
<td><code>logging.debug(&#39;debug msg&#39;)</code></td>
</tr>
<tr>
<td><code>logging.info(msg, args, *kwargs)</code></td>
<td>记录级别为 <code>INFO</code> 的日志</td>
<td></td>
</tr>
<tr>
<td><code>logging.warning(msg, args, *kwargs)	</code></td>
<td>记录级别为 <code>WARNING</code> 的日志</td>
<td></td>
</tr>
<tr>
<td><code>logging.error(msg, args, *kwargs)	</code></td>
<td>记录级别为 <code>ERROR</code> 的日志</td>
<td></td>
</tr>
<tr>
<td><code>logging.critical(msg, args, *kwargs)	</code></td>
<td>记录级别为 <code>CRITICAL</code> 的日志</td>
<td></td>
</tr>
<tr>
<td><code>logging.log(level, args, *kwargs)	</code></td>
<td>记录级别为 <code>level</code> 的日志</td>
<td><code>logging.log(logging.DEBUG, &#39;debug msg&#39;)</code></td>
</tr>
</tbody></table>
<h5 id="logging-basicConfig-方法说明"><a href="#logging-basicConfig-方法说明" class="headerlink" title="logging.basicConfig() 方法说明"></a>logging.basicConfig() 方法说明</h5><p>该方法用于为 <code>logging</code> 日志系统做一些基本配置，<code>logging.basicConfig()</code> 函数是一个一次性的简单配置工具使，也就是说只有在第一次调用该函数时会起作用，后续再次调用该函数时完全不会产生任何操作的，多次调用的设置并不是累加操作。方法定义如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">logging.basicConfig(**kwargs)</span><br></pre></td></tr></table></figure>

<p>该方法可接收的关键字参数如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>filename</code></td>
<td>写入日志的文件名</td>
</tr>
<tr>
<td><code>filemode</code></td>
<td>打开日志文件的模式，默认为 <code>a</code>，该选项在 <code>filename</code> 指定时才生效</td>
</tr>
<tr>
<td><code>format</code></td>
<td>日志格式字符串, 指定日志输出时所包含的字段信息以及它们的顺序</td>
</tr>
<tr>
<td><code>datefmt</code></td>
<td>指定日期&#x2F;时间格式。该选项要在 <code>format</code> 中包含时间字段 <code>%(asctime)s</code> 时才有效</td>
</tr>
<tr>
<td><code>level</code></td>
<td>指定日志级别</td>
</tr>
<tr>
<td><code>stream</code></td>
<td>指定日志输出目标 stream，如 <code>sys.stdout</code>、<code>sys.stderr</code>以及 <code>网络stream</code>。需要说明的是，<code>stream</code> 和 <code>filename </code>不能同时提供，否则会引发 <code>ValueError</code> 异常</td>
</tr>
<tr>
<td><code>style</code></td>
<td><code>Python 3.2</code> 中新添加的配置项。指定 <code>format</code> 格式字符串的风格，可取值为 <code>%</code>、<code>&#123;</code> 和 <code>$</code>，默认为 <code>%</code></td>
</tr>
<tr>
<td><code>handlers</code></td>
<td><code>Python 3.3</code> 中新添加的配置项。该选项如果被指定，它应该是一个创建了多个 <code>Handler</code> 的可迭代对象，这些 <code>handler</code> 将会被添加到 <code>root logger</code> 。需要说明的是：<code>filename</code>、s<code>tream</code> 和 <code>handlers</code> 这三个配置项只能有一个存在，不能同时出现2个或3个，否则会引发 <code>ValueError</code> 异常。</td>
</tr>
</tbody></table>
<p><code>logging</code> 模块中定义好的可以用于 <code>format</code> 日志格式字符串的字段主要有  </p>
<table>
<thead>
<tr>
<th>字段名称</th>
<th>使用格式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>asctime</code></td>
<td><code>%(asctime)s</code></td>
<td>日志事件发生的时间(可读时间)，如：2003-07-08 16:49:45,896</td>
</tr>
<tr>
<td><code>created</code></td>
<td><code>%(created)f	</code></td>
<td>日志事件发生的时间(时间戳)</td>
</tr>
<tr>
<td><code>levelname</code></td>
<td><code>%(levelname)s</code></td>
<td>日志级别</td>
</tr>
<tr>
<td><code>levelno</code></td>
<td><code>%(levelno)s	</code></td>
<td>日志记录的数字形式的日志级别（10, 20, 30, 40, 50）</td>
</tr>
<tr>
<td><code>name</code></td>
<td><code>%(name)s	</code></td>
<td>所使用的日志器名称，默认是 <code>root</code>，因为默认使用的是 <code>rootLogger</code></td>
</tr>
<tr>
<td><code>message</code></td>
<td><code>%(message)s	</code></td>
<td>日志记录的文本内容</td>
</tr>
<tr>
<td><code>pathname</code></td>
<td><code>%(pathname)s	</code></td>
<td>调用日志记录方法的源码文件的全路径</td>
</tr>
<tr>
<td><code>filename</code></td>
<td><code>%(filename)s	</code></td>
<td><code>pathname</code> 的文件名部分，包含文件后缀</td>
</tr>
<tr>
<td><code>module</code></td>
<td><code>%(module)s	</code></td>
<td>filename的名称部分，不包含后缀</td>
</tr>
<tr>
<td><code>lineno</code></td>
<td><code>%(lineno)d	</code></td>
<td>调用日志记录方法的源代码所在的行号</td>
</tr>
<tr>
<td><code>funcName</code></td>
<td><code>%(funcName)s	</code></td>
<td>调用日志记录方法的函数名</td>
</tr>
<tr>
<td><code>process</code></td>
<td><code>%(process)d	</code></td>
<td>进程ID</td>
</tr>
<tr>
<td><code>processName</code></td>
<td><code>%(processName)s	</code></td>
<td>进程名称，Python 3.1新增</td>
</tr>
<tr>
<td><code>thread</code></td>
<td><code>%(thread)d	</code></td>
<td>线程ID</td>
</tr>
<tr>
<td><code>threadName</code></td>
<td><code>%(thread)s	</code></td>
<td>线程名称</td>
</tr>
</tbody></table>
<h5 id="logging-模块级别方法中的-kwargs-参数说明"><a href="#logging-模块级别方法中的-kwargs-参数说明" class="headerlink" title="logging 模块级别方法中的 kwargs 参数说明"></a>logging 模块级别方法中的 kwargs 参数说明</h5><p><code>logging.debug()</code>, <code>logging.info()</code> 等方法的定义中，除了 <code>msg</code> 和 <code>args</code> 参数外，还有一个 <code>**kwargs</code> 参数。它们支持3个关键字参数: <code>exc_info</code>, <code>stack_info</code>, <code>extra</code></p>
<ul>
<li><code>exc_info</code> : 布尔值，如果该参数的值设置为 <code>True</code>，则会将异常异常信息添加到日志消息中。如果没有异常信息则添加 <code>None</code> 到日志信息中。</li>
<li><code>stack_info</code> : 布尔值，默认值为 <code>False</code>。如果该参数的值设置为 <code>True</code>，栈信息将会被添加到日志信息中。</li>
<li><code>extra</code> : 这是一个字典（<code>dict</code>）参数，它可以用来自定义消息格式中所包含的字段，但是它的 <code>key</code> 不能与 <code>logging</code> 模块定义的字段冲突</li>
</ul>
<p><code>exc_info</code> 使用示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="number">1</span> / <span class="number">0</span></span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span>:</span><br><span class="line"><span class="meta">... </span>    logging.error(<span class="string">&#x27;except occor&#x27;</span>, exc_info=<span class="literal">True</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">ERROR:root:<span class="keyword">except</span> occor</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ZeroDivisionError: division by zero</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>stack_info</code> 使用示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="number">1</span> / <span class="number">0</span></span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span>:</span><br><span class="line"><span class="meta">... </span>    logging.error(<span class="string">&#x27;except&#x27;</span>, stack_info=<span class="literal">True</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">ERROR:root:<span class="keyword">except</span></span><br><span class="line">Stack (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">4</span>, <span class="keyword">in</span> &lt;module&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Django-配置-logging"><a href="#Django-配置-logging" class="headerlink" title="Django 配置 logging"></a>Django 配置 logging</h3><p>在 <code>Django</code> 配置文件( <code>settings.py</code> ) 中添加以下配置  </p>
<figure class="highlight django"><figcaption><span>settings.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="language-xml">LOGGING = &#123;</span></span><br><span class="line"><span class="language-xml">    &#x27;version&#x27;: 1,</span></span><br><span class="line"><span class="language-xml">    &#x27;disable_existing_loggers&#x27;: False,</span></span><br><span class="line"><span class="language-xml">    &#x27;formatters&#x27;: &#123;</span></span><br><span class="line"><span class="language-xml">        &#x27;verbose&#x27;: &#123;</span></span><br><span class="line"><span class="language-xml">            &#x27;format&#x27;: &#x27;[%(asctime)s][%(levelname)s][%(pathname)s %(module)s %(lineno)s %(process)d %(thread)d] %(message)s&#x27;</span></span><br><span class="line"><span class="language-xml">        &#125;</span></span><br><span class="line"><span class="language-xml">    &#125;,</span></span><br><span class="line"><span class="language-xml">    &#x27;handlers&#x27;: &#123;</span></span><br><span class="line"><span class="language-xml">        &#x27;file&#x27;: &#123;</span></span><br><span class="line"><span class="language-xml">            &#x27;level&#x27;: &#x27;INFO&#x27;,</span></span><br><span class="line"><span class="language-xml">            &#x27;class&#x27;: &#x27;logging.handlers.RotatingFileHandler&#x27;,</span></span><br><span class="line"><span class="language-xml">            &#x27;filename&#x27;: &#x27;default.log&#x27;,</span></span><br><span class="line"><span class="language-xml">            &#x27;maxBytes&#x27;: 1024 * 1024 * 5,</span></span><br><span class="line"><span class="language-xml">            &#x27;backupCount&#x27;: 5,</span></span><br><span class="line"><span class="language-xml">            &#x27;formatter&#x27;: &#x27;verbose&#x27;,</span></span><br><span class="line"><span class="language-xml">        &#125;,</span></span><br><span class="line"><span class="language-xml">        &#x27;console&#x27;: &#123;</span></span><br><span class="line"><span class="language-xml">            &#x27;class&#x27;: &#x27;logging.StreamHandler&#x27;,</span></span><br><span class="line"><span class="language-xml">            &#x27;formatter&#x27;: &#x27;verbose&#x27;,</span></span><br><span class="line"><span class="language-xml">        &#125;,</span></span><br><span class="line"><span class="language-xml">        &#x27;django.server&#x27;: &#123;</span></span><br><span class="line"><span class="language-xml">            &#x27;level&#x27;: &#x27;INFO&#x27;,</span></span><br><span class="line"><span class="language-xml">            &#x27;class&#x27;: &#x27;logging.StreamHandler&#x27;,</span></span><br><span class="line"><span class="language-xml">            &#x27;formatter&#x27;: &#x27;verbose&#x27;,</span></span><br><span class="line"><span class="language-xml">        &#125;,</span></span><br><span class="line"><span class="language-xml">    &#125;,</span></span><br><span class="line"><span class="language-xml">    &#x27;loggers&#x27;: &#123;</span></span><br><span class="line"><span class="language-xml">        &#x27;django&#x27;: &#123;</span></span><br><span class="line"><span class="language-xml">            &#x27;handlers&#x27;: [&#x27;console&#x27;, &#x27;file&#x27;],</span></span><br><span class="line"><span class="language-xml">            &#x27;level&#x27;: &#x27;INFO&#x27;,</span></span><br><span class="line"><span class="language-xml">        &#125;,</span></span><br><span class="line"><span class="language-xml">        &#x27;django.server&#x27;: &#123;</span></span><br><span class="line"><span class="language-xml">            &#x27;handlers&#x27;: [&#x27;django.server&#x27;],</span></span><br><span class="line"><span class="language-xml">            &#x27;level&#x27;: &#x27;INFO&#x27;,</span></span><br><span class="line"><span class="language-xml">            &#x27;propagate&#x27;: False,</span></span><br><span class="line"><span class="language-xml">        &#125;,</span></span><br><span class="line"><span class="language-xml">    &#125;</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br></pre></td></tr></table></figure>

<p>代码中可以通过以下方式写入日志到对应 <code>logger</code>:  </p>
<figure class="highlight python"><figcaption><span>views.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logger = logging.getLogger(`django.server`)</span><br><span class="line">logger.info(<span class="string">&#x27;aaa&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p> <code>loggers</code> 类型 为 <code>django</code> 将处理所有类型的日志</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://docs.djangoproject.com/zh-hans/4.0/topics/logging/">django logging 模块官网说明</a></p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Django model 使用</title>
    <url>/202301191014/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Python 3.10</li>
<li>Django 4.1</li>
</ul>
<p>在 Project&#x2F;App 的 <code>models.py</code> 文件中创建 <code>model</code>，当 model 定义完成，Django 会自动生产一个后台管理接口，允许认证用户添加、更改和删除对象，只需在管理站点上注册模型即可 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[设计模型](https://docs.djangoproject.com/zh-hans/4.1/intro/overview/#design-your-model)">[1]</span></a></sup></p>
<h1 id="创建-model"><a href="#创建-model" class="headerlink" title="创建 model"></a>创建 model</h1><p>在 Project&#x2F;App 的 <code>models.py</code> 文件中创建 <code>model</code></p>
<figure class="highlight shell"><figcaption><span>models.py</span></figcaption><table><tr><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">###公司部门</span></span></span><br><span class="line">class Department(models.Model):</span><br><span class="line">    name = models.CharField(max_length=24, unique=True, help_text=&quot;部门名称&quot;,verbose_name=&#x27;名称&#x27;)</span><br><span class="line">    shortName = models.CharField(max_length=8, unique=True, help_text=&quot;部门名称简称&quot;,verbose_name=&#x27;简称&#x27;)</span><br><span class="line">    manager = models.ForeignKey(&#x27;Emplyee&#x27;, on_delete=models.CASCADE, help_text=&quot;部门老大&quot;)</span><br><span class="line">    comment = models.CharField(max_length=256, blank=True, help_text=&quot;备注信息&quot;,verbose_name=&#x27;备注&#x27;)</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.shortName</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        # 管理后台显示的 model 名，最后面没有 &#x27;s&#x27;</span><br><span class="line">        verbose_name_plural = &quot;部门&quot;</span><br><span class="line">        </span><br><span class="line">        # 管理后台显示的 model 名，最后面有 &#x27;s&#x27;，显示为 &#x27;部门s&#x27;</span><br><span class="line">        verbose_name = &quot;部门&quot;</span><br><span class="line">        </span><br><span class="line">        # 数据库中生成的表名称 默认 app名称 + 下划线 + 类名</span><br><span class="line">        db_table = &quot;table_name&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对修改后的 <code>model</code> 进行 <code>migrate</code>，以使在数据库中变更更改。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python manage.py makemigrations</span><br><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure>
<h1 id="model-注册到后台"><a href="#model-注册到后台" class="headerlink" title="model 注册到后台"></a>model 注册到后台</h1><p>在 Project&#x2F;App 的 <code>admin.py</code> 文件中注册 <code>model</code></p>
<figure class="highlight shell"><figcaption><span>admin.py</span></figcaption><table><tr><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">假如 app 为 servers，导入 models</span></span><br><span class="line">from servers import models</span><br><span class="line"></span><br><span class="line">admin.site.site_header = &quot;My Admin&quot;</span><br><span class="line">admin.site.site_title = &quot;My Admin&quot;</span><br><span class="line"></span><br><span class="line">@admin.register(models.Department)</span><br><span class="line">class DepartmentAdmin(admin.ModelAdmin):</span><br><span class="line">    list_display = (&#x27;id&#x27;,&#x27;name&#x27;,&#x27;shortName&#x27;,&#x27;manager&#x27;,&#x27;comment&#x27;)</span><br><span class="line">    list_display_links = (&#x27;id&#x27;,&#x27;name&#x27;,&#x27;shortName&#x27;,&#x27;manager&#x27;,&#x27;comment&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>更多有关 admin 配置方法，请参考 <a href="/202209021312/" title="Django admin 配置">Django admin 配置</a></p>
<span id="more"></span>

<h1 id="model-基本操作"><a href="#model-基本操作" class="headerlink" title="model 基本操作"></a>model 基本操作</h1><h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><p>假设 model 为 <code>Publish</code>，新增数据 <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[执行查询](https://docs.djangoproject.com/zh-hans/4.1/topics/db/queries/)">[2]</span></a></sup></p>
<h3 id="create-方式新增数据"><a href="#create-方式新增数据" class="headerlink" title="create 方式新增数据"></a>create 方式新增数据</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Publish.objects.create(&quot;name&quot;=&quot;人民出版社&quot;,city=&quot;北京&quot;)</span><br><span class="line">Publish.objects.create(**&#123;&quot;name&quot;:&quot;文艺出版社&quot;,&quot;city&quot;:&quot;上海&quot;&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="save-方式新增数据"><a href="#save-方式新增数据" class="headerlink" title="save 方式新增数据"></a>save 方式新增数据</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">book1=Book(title=&quot;python&quot;,price=&quot;88&quot;,publish_id=&quot;1&quot;,publication_date=&quot;2017-06-18&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="存在-Foreignkey-的表新增数据"><a href="#存在-Foreignkey-的表新增数据" class="headerlink" title="存在 Foreignkey 的表新增数据"></a>存在 Foreignkey 的表新增数据</h3><h4 id="通过绑定对象的方式新增"><a href="#通过绑定对象的方式新增" class="headerlink" title="通过绑定对象的方式新增"></a>通过绑定对象的方式新增</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">获取出版社对象</span></span><br><span class="line">publish_obj=Publish.objects.get(id=4)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将出版社的对象绑定到书籍的记录中</span></span><br><span class="line">Book.objects.create(</span><br><span class="line">    title=&quot;python&quot;,</span><br><span class="line">    price=48.00,</span><br><span class="line">    publication_date=&quot;2017-07-12&quot;,</span><br><span class="line">    publish=publish_obj,</span><br><span class="line">)   </span><br></pre></td></tr></table></figure>

<h4 id="直接通过-Foreignkey-对应记录的-id-号新增数据"><a href="#直接通过-Foreignkey-对应记录的-id-号新增数据" class="headerlink" title="直接通过 Foreignkey 对应记录的 id 号新增数据"></a>直接通过 Foreignkey 对应记录的 id 号新增数据</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">直接把出版社的<span class="built_in">id</span>号插入到书籍的记录中</span></span><br><span class="line">Book.objects.create(</span><br><span class="line">    title=&quot;python&quot;,</span><br><span class="line">    price=48.00,</span><br><span class="line">    publish_id=2,</span><br><span class="line">    publication_date=&quot;2017-06-18&quot;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="ManyToManyField-的表新增数据"><a href="#ManyToManyField-的表新增数据" class="headerlink" title="ManyToManyField 的表新增数据"></a>ManyToManyField 的表新增数据</h3><p>为一本书添加多个作者</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">author1=Author.objects.get(id=1)              # 获取id号为1的作者对象</span><br><span class="line">author2=Author.objects.filter(name=&quot;a&quot;)       # 获取名字为&quot;tom&quot;的作者对象</span><br><span class="line">book1=Book.objects.get(id=2)                  # 获取id号为2的书籍对象</span><br><span class="line">book1.authors.add(author1,author2)            # 为书籍对象添加多个作者对象</span><br></pre></td></tr></table></figure>
<p>也可以使用以下方法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">book1.authors.add(*[author1,author2])             # 为书籍对象添加作者对象的列表</span><br><span class="line">book1.authors.remove(*[author1,author2])          # 删除指定书籍的所有作者</span><br></pre></td></tr></table></figure>

<p>为一个作者添加多本书</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">author_obj = Author.objects.filter(name=&quot;jerry&quot;)        # 获取名字为&quot;jerry&quot;的作者对象</span><br><span class="line">book_obj=Book.objects.filter(id__gt=3)                  # 获取id大于3的书籍对象集合</span><br><span class="line">author_obj.book_set.add(*book_obj)                      # 为作者对象添加书籍对象集合</span><br><span class="line">author_obj.book_set.remove(*book_obj)                   # 删除指定作者对象所有的书籍</span><br></pre></td></tr></table></figure>
<h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Book.objects.filter(id=1).delete()</span><br></pre></td></tr></table></figure>

<h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><h3 id="使用-save-方法将所有属性重新设定一遍-效率较低"><a href="#使用-save-方法将所有属性重新设定一遍-效率较低" class="headerlink" title="使用 save 方法将所有属性重新设定一遍,效率较低"></a>使用 save 方法将所有属性重新设定一遍,效率较低</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">author1=Author.objects.get(id=3)           # 获取id为3的作者对象</span><br><span class="line"></span><br><span class="line">author1.name=&quot;jobs&quot;                        # 修改作者对象的名字</span><br><span class="line"></span><br><span class="line">author1.save()                             # 把更改写入数据库</span><br></pre></td></tr></table></figure>

<h3 id="使用-update-方法直接设置对应的属性"><a href="#使用-update-方法直接设置对应的属性" class="headerlink" title="使用 update 方法直接设置对应的属性"></a>使用 update 方法直接设置对应的属性</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Publish.objects.filter(id=2).update(name=&quot;北京出版社&quot;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>update()</code> 是 <code>QuerySet</code> 对象的一个方法,<code>get</code> 返回的是一个 model 对象,其没有 <code>update</code> 方法</p>
</blockquote>
<h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><p>查询数据使用 <code>QuerySet</code> API。 <code>QuerySet</code> 是惰性执行的，创建 <code>Query Set</code> 不会访问数据库，只有在访问具体查询结果的时候才会访问数据库。</p>
<p>查询方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>方法说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td><code>filter(**kwargs)</code></td>
<td>包含了与所给筛选条件相匹配的对象，返回   <code>QuerySet</code>   ，相当于 SQL 中的 <code>WHERE</code></td>
<td></td>
</tr>
<tr>
<td><code>all() </code></td>
<td>查询所有结果     ，等同于 SQL 语句 <code>SELECT * FROM</code></td>
<td></td>
</tr>
<tr>
<td><code>get(**kwargs)</code></td>
<td>返回与所给筛选条件相匹配的对象,返回结果有且只有一个,如果符合筛选条件的对象超过一个或者没有都是报错</td>
<td></td>
</tr>
<tr>
<td><code>values(*field)</code></td>
<td>只取指定列 ，返回 <code>QuerySet</code>，此列表由字典 <code>&#123;&#39;列名&#39;： &#39;列值&#39;&#125;</code> 组成</td>
<td><code>models.AwsZoneInfo.objects.all().values(&#39;code&#39;)</code></td>
</tr>
<tr>
<td><code>exclude(**kwargs)</code></td>
<td>包含了与所给的筛选条件不匹配的对象</td>
<td></td>
</tr>
<tr>
<td><code>order by(*field) </code></td>
<td>对查询结果排序</td>
<td></td>
</tr>
<tr>
<td><code>reverse()  </code></td>
<td>对查询结果反向排序</td>
<td></td>
</tr>
<tr>
<td><code>distinct()  </code></td>
<td>从返回结果中剔除重复记录</td>
<td></td>
</tr>
<tr>
<td><code>values_list(*field)</code></td>
<td>与 <code>values()</code> 非常相似,返回一个元组序列,<code>values</code> 返回一个字典序列</td>
<td></td>
</tr>
<tr>
<td><code>count()</code></td>
<td>返回数据库中匹配的记录的数量</td>
<td></td>
</tr>
<tr>
<td><code>first() </code></td>
<td>返回数据库中匹配的对象的第一个对象</td>
<td></td>
</tr>
<tr>
<td><code>last()</code></td>
<td>返回数据库中匹配的对象的最后一个对象</td>
<td></td>
</tr>
<tr>
<td><code>exists() </code></td>
<td>判断一个对象集合中是否包含指定对象,包含返回 <code>True</code>,不包含返回 <code>False </code></td>
<td></td>
</tr>
<tr>
<td><code>exclude()</code></td>
<td>排除满足条件的对象</td>
<td></td>
</tr>
<tr>
<td><code>annotate()</code></td>
<td>使用聚合函数</td>
<td></td>
</tr>
<tr>
<td><code>dates() </code></td>
<td>根据日期获取查询集</td>
<td></td>
</tr>
<tr>
<td><code>datetimes()</code></td>
<td>根据时间获取查询集</td>
<td></td>
</tr>
<tr>
<td><code>none()  </code></td>
<td>创建空的查询集</td>
<td></td>
</tr>
<tr>
<td><code>union() </code></td>
<td>并集</td>
<td></td>
</tr>
<tr>
<td><code>intersection()</code></td>
<td>交集</td>
<td></td>
</tr>
<tr>
<td><code>difference() </code></td>
<td>差集</td>
<td></td>
</tr>
<tr>
<td>&#96;select_related()</td>
<td>附带查询关联对象</td>
<td></td>
</tr>
<tr>
<td><code>prefetch_related()</code></td>
<td>预先查询</td>
<td></td>
</tr>
<tr>
<td><code>extra()  </code></td>
<td>附加 SQL 查询</td>
<td></td>
</tr>
<tr>
<td><code>defer() </code></td>
<td>不加载指定字段</td>
<td></td>
</tr>
<tr>
<td><code>only() </code></td>
<td>只加载指定的字段</td>
<td></td>
</tr>
<tr>
<td><code>using()</code></td>
<td>选择数据库</td>
<td></td>
</tr>
<tr>
<td><code>select_for_update()</code></td>
<td>锁住选择的对象，直到事务结束。</td>
<td></td>
</tr>
<tr>
<td><code>raw()</code></td>
<td>接收一个原始的 SQL 查询</td>
<td></td>
</tr>
</tbody></table>
<h3 id="values-field-和-values-list-field-使用示例"><a href="#values-field-和-values-list-field-使用示例" class="headerlink" title="values(*field) 和 values_list(*field) 使用示例"></a>values(*field) 和 values_list(*field) 使用示例</h3><p><code>values(*field)</code> 获取 QuerySet 中指定列的值，会返回一个由<strong>字典</strong> <code>&#123;&#39;列名1&#39;: &#39;列值1&#39;, &#39;列名2&#39;: &#39;列值2&#39;, ...&#125;</code> 组成的 QuerySet </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; models.AwsZoneInfo.objects.all().values(<span class="string">&#x27;code&#x27;</span>)</span></span><br><span class="line">&lt;QuerySet [&#123;&#x27;code&#x27;: &#x27;af-south-1&#x27;&#125;, &#123;&#x27;code&#x27;: &#x27;ap-east-1&#x27;&#125;, &#123;&#x27;code&#x27;: &#x27;ap-northeast-1&#x27;&#125;, &#123;&#x27;code&#x27;: &#x27;ap-south-1&#x27;&#125;, &#123;&#x27;code&#x27;: &#x27;ap-southeast-3&#x27;&#125;]&gt;</span><br><span class="line"></span><br><span class="line">models.AwsZoneInfo.objects.all().values(&#x27;code&#x27;,&#x27;name&#x27;)</span><br><span class="line">&lt;QuerySet [&#123;&#x27;code&#x27;: &#x27;ap-east-1&#x27;, &#x27;name&#x27;: &#x27;Asia Pacific (Hong Kong)&#x27;&#125;, &#123;&#x27;code&#x27;: &#x27;us-east-1&#x27;, &#x27;name&#x27;: &#x27;美国东部（弗吉尼亚北部）&#x27;]&gt;</span><br></pre></td></tr></table></figure>
<p><code>values_list(*field)</code> 获取 QuerySet 中指定列的值，会返回一个由<strong>元组</strong> <code>(&#39;列值1&#39;, &#39;列值2&#39;, ...)</code> 组成的 QuerySet</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; models.AwsZoneInfo.objects.all().values_list(<span class="string">&#x27;code&#x27;</span>,<span class="string">&#x27;name&#x27;</span>)</span></span><br><span class="line">&lt;QuerySet [(&#x27;us-east-2&#x27;, &#x27;美国东部（俄亥俄）&#x27;), (&#x27;ap-east-1&#x27;, &#x27;Asia Pacific (Hong Kong)&#x27;), (&#x27;us-east-1&#x27;, &#x27;美国东部（弗吉尼亚北部）&#x27;)]&gt;</span><br></pre></td></tr></table></figure>

<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://docs.djangoproject.com/zh-hans/4.1/intro/overview/#design-your-model">设计模型</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://docs.djangoproject.com/zh-hans/4.1/topics/db/queries/">执行查询</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>django 接收 post 请求中的 json 数据</title>
    <url>/202209161740/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Python3.10</li>
<li>Django 4.0</li>
</ul>
<h3 id="接收-post-中的-json-数据"><a href="#接收-post-中的-json-数据" class="headerlink" title="接收 post 中的 json 数据"></a>接收 post 中的 json 数据</h3><p>示例通过 <code>curl</code> 命令模拟 post 请求，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -v -H &quot;Accept: application/json&quot; -H &quot;Content-type: application/json&quot; -X POST \</span><br><span class="line">      -d &#x27;&#123;&quot;id&quot; : &quot;yTP7PSsRxz53tJ56VVG&quot;, &quot;type&quot; : 5&#125;&#x27; 127.0.0.1:8000/csapi</span><br></pre></td></tr></table></figure>

<p>Django 处理程序示例：</p>
<figure class="highlight shell"><figcaption><span>views.py</span></figcaption><table><tr><td class="code"><pre><span class="line">from django.http import HttpResponse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def csapi(request):</span><br><span class="line">    post_body = request.body</span><br><span class="line">    print(f&#x27;****** POST body: &#123;post_body&#125;, type : &#123;type(post_body)&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">    # </span><br><span class="line">    data = eval(post_body)</span><br><span class="line"></span><br><span class="line">    print(f&#x27;****** data : &#123;data&#125; , type : &#123;type(data)&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">    return HttpResponse(&#x27;ok&#x27;)</span><br></pre></td></tr></table></figure>

<p>Console 输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">****** POST body: b&#x27;&#123;&quot;id&quot; : &quot;yTP7PSsRxz53tJ56VVG&quot;, &quot;type&quot; : 5&#125;&#x27;, type : &lt;class &#x27;bytes&#x27;&gt;</span><br><span class="line">****** data : &#123;&#x27;id&#x27;: &#x27;yTP7PSsRxz53tJ56VVG&#x27;, &#x27;type&#x27;: 5&#125; , type : &lt;class &#x27;dict&#x27;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上输出可以看到，<code>request.body</code> 中的类型为 <code>bytes</code></p>
<p>使用 <code>eval</code> 转换后类型变为 <code>dict</code></p>
<p>使用 <code>json.loads</code> 将 <code>request.body</code> 转换为 <code>dict</code> 时，可能会报以下错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">json.decoder.JSONDecodeError: Expecting property name enclosed in double quotes: line 1 column 2 (char 1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可能原因 <a href="https://www.jianshu.com/p/3a7dbd17e7b9">参考</a></p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django 常用配置</title>
    <url>/202301181649/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Python 3.10</li>
<li>Django 4.1</li>
</ul>
<h1 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h1><h2 id="创建项目及-app"><a href="#创建项目及-app" class="headerlink" title="创建项目及 app"></a>创建项目及 app</h2><p>开始使用 Django 时，需要初始化配置，执行以下命令生成初始化的工程环境 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[创建项目](https://docs.djangoproject.com/zh-hans/4.1/intro/tutorial01/#creating-a-project)">[1]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">django-admin startproject mysite</span><br></pre></td></tr></table></figure>
<p>创建 Project 成功后，会生成以 Project 命名的根目录(此处为 <code>mysite</code>)，根目录只是你项目的容器， 根目录名称对 Django 没有影响，你可以将它重命名为任何你喜欢的名称。以下为目录结构 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[创建项目](https://docs.djangoproject.com/zh-hans/4.1/intro/tutorial01/#creating-a-project)">[1]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysite/</span><br><span class="line">    manage.py</span><br><span class="line">    mysite/</span><br><span class="line">        __init__.py</span><br><span class="line">        settings.py</span><br><span class="line">        urls.py</span><br><span class="line">        asgi.py</span><br><span class="line">        wsgi.py</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>mysite/mysite/settings.py</code> 为项目配置文件，包括配置 app，数据库等。</li>
</ul>
<p>创建 App</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python manage.py startapp myapp</span><br></pre></td></tr></table></figure>
<p>创建 app 后，会在项目根目录下生成 app 命名的目录。创建 app 后，需要将 app 添加到项目配置文件 <code>settings.py</code> 中的 <code>INSTALLED_APPS</code></p>
<h2 id="项目配置文件-settings-py-常用配置说明"><a href="#项目配置文件-settings-py-常用配置说明" class="headerlink" title="项目配置文件 settings.py 常用配置说明"></a>项目配置文件 <code>settings.py</code> 常用配置说明</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ALLOWED_HOSTS = [&#x27;*&#x27;]</span><br></pre></td></tr></table></figure>
<p>访问控制，默认只允许从本地访问 Django Server，如果需要远程访问，需要配置远程主机地址，<code>*</code> 可以配置允许任一客户端访问。</p>
<h3 id="配置-mysql-数据库"><a href="#配置-mysql-数据库" class="headerlink" title="配置 mysql 数据库"></a>配置 mysql 数据库</h3><p>要为项目配置使用 Mysql 数据库，可以使用以下配置。</p>
<figure class="highlight shell"><figcaption><span>settings.py</span></figcaption><table><tr><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    &#x27;default&#x27;: &#123;</span><br><span class="line">        &#x27;ENGINE&#x27;: &#x27;django.db.backends.mysql&#x27;,</span><br><span class="line">        &#x27;NAME&#x27;: &quot;vb&quot;,</span><br><span class="line">        &#x27;USER&#x27;: &quot;root&quot;,</span><br><span class="line">        &quot;PASSWORD&quot;: &quot;dBVgcKGnn0&quot;,</span><br><span class="line">        &#x27;HOST&#x27;: &quot;127.0.0.1&quot;,</span><br><span class="line">        &quot;PORT&quot;: &#x27;3306&#x27;,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Django-管理后台配置"><a href="#Django-管理后台配置" class="headerlink" title="Django 管理后台配置"></a>Django 管理后台配置</h2><ol>
<li>创建 project 后，要使用 Django 管理后台，需要首先初始化数据库并创建 superuser <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python manage.py makemigrations</span><br><span class="line">python manage.py migrate</span><br><span class="line">python manage.py createsuperuser</span><br></pre></td></tr></table></figure></li>
<li>为 admin 添加路由<br> 在项目目录中的 <code>urls.py</code> 文件中配置以下内容 <figure class="highlight shell"><figcaption><span>urls.py</span></figcaption><table><tr><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line">from django.urls import path</span><br><span class="line">from .views import index</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&#x27;admin/&#x27;, admin.site.urls),</span><br><span class="line">    path(&#x27;&#x27;, index)</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
如果要在访问项目 <code>/</code> 时，重定向到管理后台，可以在项目的 <code>views.py</code> 文件中添加以下内容，将 <code>/</code> 重定向到 <code>/admin/</code><figure class="highlight shell"><figcaption><span>views.py</span></figcaption><table><tr><td class="code"><pre><span class="line">from django.shortcuts import redirect</span><br><span class="line"></span><br><span class="line">def index(request):</span><br><span class="line">    return redirect(&#x27;admin/&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
访问项目 url，此时可以看到登陆后台页面。</li>
</ol>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://docs.djangoproject.com/zh-hans/4.1/intro/tutorial01/#creating-a-project">创建项目</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>docker daemon 常用配置</title>
    <url>/202211241005/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos 7</li>
<li>Docker 19.03.15</li>
</ul>
<h1 id="docker-配置容器日志-rotate"><a href="#docker-配置容器日志-rotate" class="headerlink" title="docker 配置容器日志 rotate"></a>docker 配置容器日志 rotate</h1><h2 id="docker-daemon-方式配置容器日志-rotate"><a href="#docker-daemon-方式配置容器日志-rotate" class="headerlink" title="docker daemon 方式配置容器日志 rotate"></a>docker daemon 方式配置容器日志 rotate</h2><p>编辑 docker daemon 配置文件 <code>/etc/docker/daemon.json</code> (若不存在则新建)，添加以下内容，用来配置 docker containers 的日志轮转</p>
<figure class="highlight shell"><figcaption><span>/etc/docker/daemon.json</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;log-driver&quot;: &quot;json-file&quot;,</span><br><span class="line">  &quot;log-opts&quot;: &#123;</span><br><span class="line">    &quot;max-size&quot;: &quot;100m&quot;,</span><br><span class="line">    &quot;max-file&quot;: &quot;3&quot;    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重启 docker 服务生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>
<p>根据以上配置，当容器日志大小达到 <code>100m</code>，即对其进行 rotate，并保留最多 3 个日志文件。 </p>
<h2 id="使用-OS-系统服务-logrotate-进行容器日志-rotate"><a href="#使用-OS-系统服务-logrotate-进行容器日志-rotate" class="headerlink" title="使用 OS 系统服务 logrotate 进行容器日志 rotate"></a>使用 OS 系统服务 logrotate 进行容器日志 rotate</h2><p>Linux 系统中有专门用来做日志 rotate 的 <a href="!--swig%EF%BF%BC3--">服务 <code>logrotate</code></a>，可直接使用此服务做 log rotate</p>
<p>配置针对 docker 的 <code>logrotate</code> 配置</p>
<figure class="highlight shell"><figcaption><span>/etc/logrotate.d/docker</span></figcaption><table><tr><td class="code"><pre><span class="line">/var/lib/docker/containers/*/*.log &#123;</span><br><span class="line">    daily</span><br><span class="line">    rotate 5</span><br><span class="line">    copytruncate</span><br><span class="line">    missingok</span><br><span class="line">    compress</span><br><span class="line">    delaycompress</span><br><span class="line">    maxsize 100M</span><br><span class="line">    minsize 1024k</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>copytruncate</code> 的方式做日志 totate 时，会先拷贝日志文件为 totate 日志文件，然后 <code>truncate</code> 日志，确保 totate 过程中，日志文件不变并一直保持打开状态。</p>
<span id="more"></span>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker 容器中安装常见工具</title>
    <url>/202209051507/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="常用工具安装"><a href="#常用工具安装" class="headerlink" title="常用工具安装"></a>常用工具安装</h3><p>查找 <code>netstat</code> 命令由哪个安装包提供</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum whatprovides /bin/netstat</span></span><br><span class="line">net-tools-2.0-0.25.20131004git.el7.x86_64 : Basic networking tools</span><br><span class="line">Repo        : base</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : /bin/netstat</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>安装 <code>net-tools</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y net-tools</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install -y net-tools</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>安装 <code>ping</code> 命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum whatprovides /bin/ping</span></span><br><span class="line">iputils-20160308-10.el7.x86_64 : Network monitoring tools including ping</span><br><span class="line">Repo        : base</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : /bin/ping</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">apt-cache search iputils</span></span><br><span class="line">iputils-arping - Tool to send ICMP echo requests to an ARP address</span><br><span class="line">iputils-clockdiff - Measure the time difference between networked computers</span><br><span class="line">iputils-ping - Tools to test the reachability of network hosts</span><br><span class="line">iputils-tracepath - Tools to trace the network path to a remote host</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install -y iputils-ping</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>安装 <code>ps</code> 命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install procps</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker compose 命令</title>
    <url>/202208311004/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>对于 <code>Compose</code> 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。  </p>
<p>执行 <code>docker compose [COMMAND] --help</code>  可以查看具体某个命令的使用格式。  </p>
<p><code>docker compose</code> 命令的基本的使用格式是  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...]</span><br></pre></td></tr></table></figure>
<p>常用选项  </p>
<ul>
<li><code>-f, --file FILE</code>  指定使用的 Compose 模板文件，默认为 <code>docker-compose.yml</code>，可以多次指定。  </li>
<li><code>-p, --project-name NAME</code> 指定项目名称，默认将使用所在目录名称作为项目名。</li>
</ul>
<span id="more"></span>

<h3 id="build"><a href="#build" class="headerlink" title="build"></a>build</h3><p>格式为 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker compose build [options] [SERVICE...]</span><br></pre></td></tr></table></figure>
<p>构建（重新构建）项目中的服务容器。  </p>
<p>服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db。<br>可以随时在项目目录下运行 <code>docker compose build</code> 来重新构建服务。<br>常用选项包括：</p>
<ul>
<li><code>--no-cache</code>  构建镜像过程中不使用 cache（这将加长构建过程）。</li>
<li><code>--pull</code>  始终尝试通过 <code>pull</code> 来获取更新版本的镜像。</li>
<li><code>-q, --quiet</code>  不输出任何内容到 STDOUT</li>
</ul>
<h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker compose config</span><br></pre></td></tr></table></figure>
<p>验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因。</p>
<h3 id="up"><a href="#up" class="headerlink" title="up"></a>up</h3><p>格式为 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker compose up [options] [SERVICE...]</span><br></pre></td></tr></table></figure>
<p>该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。  </p>
<p>链接的服务都将会被自动启动，除非已经处于运行状态。</p>
<p>可以说，大部分时候都可以直接通过该命令来启动一个项目。</p>
<p>默认情况，<code>docker compose up</code> 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。</p>
<p>当通过 <code>Ctrl-C</code> 停止命令时，所有容器将会停止。</p>
<p>如果使用 <code>docker compose up -d</code>，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。</p>
<p>默认情况，如果服务容器已经存在，<code>docker compose up</code> 将会尝试停止容器，然后重新创建（保持使用 volumes-from 挂载的卷），以保证新启动的服务匹配 <code>docker-compose.yml</code> 文件的最新内容。如果用户不希望容器被停止并重新创建，可以使用 <code>docker compose up --no-recreate</code>。这样将只会启动处于停止状态的容器，而忽略已经运行的服务。如果用户只想重新部署某个服务，可以使用 <code>docker compose up --no-deps -d &lt;SERVICE_NAME&gt;</code> 来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。</p>
<p>常用选项说明：  </p>
<ul>
<li><code>-d, --detach</code> 在后台运行服务容器</li>
<li><code>--no-color</code> 不使用颜色来区分不同的服务的控制台输出</li>
<li><code>--no-deps</code> 不启动服务所链接的容器。</li>
<li><code>--force-recreate</code> 强制重新创建容器，不能与 <code>--no-recreate</code> 同时使用</li>
<li><code>--no-recreate</code> 如果容器已经存在了，则不重新创建，不能与 <code>--force-recreate</code> 同时使用。</li>
<li><code>--no-build</code> 不自动构建缺失的服务镜像</li>
<li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）时间。</li>
<li><code>--no-start</code> 创建服务但是不启动服务</li>
<li><code>--build</code>  启动容器之前，重新构建容器</li>
</ul>
<h3 id="down"><a href="#down" class="headerlink" title="down"></a>down</h3><p>此命令将会停止 <code>up</code> 命令所启动的容器，并移除网络</p>
<h3 id="start"><a href="#start" class="headerlink" title="start"></a>start</h3><p>启动已经存在的服务容器。</p>
<h3 id="pause"><a href="#pause" class="headerlink" title="pause"></a>pause</h3><p>暂停一个服务容器。</p>
<h3 id="unpause"><a href="#unpause" class="headerlink" title="unpause"></a>unpause</h3><p>恢复处于暂停状态中的服务。</p>
<h3 id="restart"><a href="#restart" class="headerlink" title="restart"></a>restart</h3><p>重启项目中的服务。</p>
<h3 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h3><p>停止已经处于运行状态的容器，但不删除它。通过 <code>docker compose start</code> 可以再次启动这些容器。</p>
<h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>列出项目中目前的所有容器。</p>
<h3 id="port"><a href="#port" class="headerlink" title="port"></a>port</h3><p>格式为 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker compose port [options] SERVICE PRIVATE_PORT</span><br></pre></td></tr></table></figure>
<p>打印某个容器端口所映射的公共端口  </p>
<p>常用选项  </p>
<ul>
<li><code>--protocol=proto</code> 指定端口协议，tcp（默认值）或者 udp。</li>
<li><code>--index=index</code> 如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1）</li>
</ul>
<h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><p>进入指定的容器。</p>
<h3 id="images"><a href="#images" class="headerlink" title="images"></a>images</h3><p>列出 Compose 文件中包含的镜像。</p>
<h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>格式为 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker compose kill [options] [SERVICE...]</span><br></pre></td></tr></table></figure>
<p>通过发送 SIGKILL 信号来强制停止服务容器。</p>
<p>支持通过 <code>-s</code> 参数来指定发送的信号，例如通过如下指令发送 SIGINT 信号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker compose kill -s SIGINT</span><br></pre></td></tr></table></figure>

<h3 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h3><p>格式为 </p>
<pre><code>docker compose logs [options] [SERVICE...]
</code></pre>
<p>查看服务容器的输出。默认情况下，<code>docker compose</code> 将对不同的服务输出使用不同的颜色来区分。可以通过 <code>--no-color</code> 来关闭颜色。<br>该命令在调试问题的时候十分有用。</p>
<h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>查看各个服务容器内运行的进程。</p>
<h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p>删除所有（停止状态的）服务容器。推荐先执行 <code>docker compose stop</code> 命令来停止容器。<br>选项：</p>
<ul>
<li><code>-f, --force</code> 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。</li>
<li><code>-v</code> 删除容器所挂载的数据卷。</li>
</ul>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://yeasy.gitbook.io/docker_practice/compose/commands">docker compose 命令说明</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker compose 简介</title>
    <url>/202208301738/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><code>Compose</code> 项目是 <code>Docker</code> 官方的开源项目，负责实现对 <code>Docker 容器集群</code> 的快速编排。</p>
<p><code>Compose</code> 定位是 <strong>「定义和运行多个 <code>Docker</code> 容器的应用（Defining and running multi-container Docker applications）」</strong>，其前身是开源项目 <code>Fig</code>。</p>
<p>使用一个 <a href="/202208050928/" title="Dockerfile">Dockerfile</a> 模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。  </p>
<p><code>Compose</code> 恰好满足了这样的需求。它允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件（<code>YAML</code> 格式）来定义一组相关联的应用容器为一个项目（<code>project</code>）。<br><code>Compose</code> 中有两个重要的概念：</p>
<ul>
<li><code>服务 (service)</code> ： 一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。  </li>
<li><code>项目 (project)</code> ： 由一组关联的应用容器组成的一个完整业务单元，在 <code>docker-compose.yml</code> 文件中定义。</li>
</ul>
<p><code>Compose</code> 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。<br><code>Compose</code> 项目由 <code>Python</code> 编写，实现上调用了 <code>Docker</code> 服务提供的 <code>API</code> 来对容器进行管理。因此，只要所操作的平台支持 <code>Docker API</code>，就可以在其上利用 <code>Compose</code> 来进行编排管理。</p>
<span id="more"></span>
<h3 id="Compose-v2"><a href="#Compose-v2" class="headerlink" title="Compose v2"></a>Compose v2</h3><p>目前 <code>Docker</code> 官方用 <code>GO 语言</code> 重写 了 <code>Docker Compose</code>，并将其作为了 <code>docker cli</code> 的子命令，称为 <code>Compose V2</code>。你可以参照官方文档安装，然后将熟悉的 <code>docker-compose</code> 命令替换为 <a href="/202208311004/" title="docker compose">docker compose</a>，即可使用 <code>Docker Compose</code>。</p>
<h3 id="Compose-模板文件"><a href="#Compose-模板文件" class="headerlink" title="Compose 模板文件"></a>Compose 模板文件</h3><p>模板文件是使用 Compose 的核心，里面大部分指令跟 <code>docker run</code> 相关参数的含义类似。  </p>
<p>默认的模板文件名称为 <code>docker-compose.yml</code>，格式为 YAML 格式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  webapp:</span><br><span class="line">    image: examples/web</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:80&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;/data&quot;</span><br></pre></td></tr></table></figure>

<p>每个服务都必须通过 <code>image</code> 指令指定镜像或 <code>build</code> 指令（需要 <a href="/202208050928/" title="Dockerfile">Dockerfile</a>）等来自动构建生成镜像。  </p>
<p>如果使用 <code>build</code> 指令，在 <code>Dockerfile</code> 中设置的选项(例如：<code>CMD</code>, <code>EXPOSE</code>, <code>VOLUME</code>, <code>ENV</code> 等) 将会自动被获取，无需在 <code>docker-compose.yml</code> 中重复设置。</p>
<p>下面分别介绍各个指令的用法。</p>
<h3 id="docker-compose-yml-中的常用指令"><a href="#docker-compose-yml-中的常用指令" class="headerlink" title="docker-compose.yml 中的常用指令"></a>docker-compose.yml 中的常用指令</h3><h4 id="build"><a href="#build" class="headerlink" title="build"></a>build</h4><p>指定 <code>Dockerfile</code> 所在文件夹的路径（可以是绝对路径，或者相对 <code>docker-compose.yml</code> 文件的路径）。 Compose 将会利用它自动构建这个镜像，然后使用这个镜像。  </p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  webapp:</span><br><span class="line">    build: ./dir</span><br></pre></td></tr></table></figure>
<p>也可以使用 <code>context</code> 指令指定 <code>Dockerfile</code> 所在文件夹的路径。<br>使用 <code>dockerfile</code> 指令指定 <code>Dockerfile</code> 文件名。<br>使用 <code>arg</code> 指令指定构建镜像时的变量。  </p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  webapp:</span><br><span class="line">    build:</span><br><span class="line">      context: ./dir</span><br><span class="line">      dockerfile: Dockerfile-alternate</span><br><span class="line">      args:</span><br><span class="line">        buildno: 1</span><br></pre></td></tr></table></figure>

<h4 id="image"><a href="#image" class="headerlink" title="image"></a>image</h4><p>指定为镜像名称或镜像 ID。如果镜像在本地不存在，Compose 将会尝试拉取这个镜像。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">image: ubuntu</span><br><span class="line">image: orchardup/postgresql</span><br><span class="line">image: a4bc65fd</span><br></pre></td></tr></table></figure>

<h4 id="command"><a href="#command" class="headerlink" title="command"></a>command</h4><p>覆盖容器启动后默认执行的命令  </p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">command: echo &quot;hello world&quot;</span><br></pre></td></tr></table></figure>

<h4 id="entrypoint"><a href="#entrypoint" class="headerlink" title="entrypoint"></a>entrypoint</h4><p>指定服务容器启动后执行的入口文件。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">entrypoint: /code/entrypoint.sh</span><br></pre></td></tr></table></figure>

<h4 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a>container_name</h4><p>指定容器名称。默认将会使用 项目名称_服务名称_序号 这样的格式。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">container_name: docker-web-container</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。</strong></p>
</blockquote>
<h4 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a>depends_on</h4><p>解决容器的依赖、启动先后的问题。以下例子中会先启动 redis db 再启动 web  </p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">      - redis</span><br><span class="line"></span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line"></span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：web 服务不会等待 redis db 「完全启动」之后才启动。</p>
</blockquote>
<h4 id="dns"><a href="#dns" class="headerlink" title="dns"></a>dns</h4><p>自定义 DNS 服务器。可以是一个值，也可以是一个列表。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">dns: 8.8.8.8</span><br><span class="line"></span><br><span class="line">dns:</span><br><span class="line">  - 8.8.8.8</span><br><span class="line">  - 114.114.114.114</span><br></pre></td></tr></table></figure>

<h4 id="dns-search"><a href="#dns-search" class="headerlink" title="dns_search"></a>dns_search</h4><p>配置 DNS 搜索域。可以是一个值，也可以是一个列表。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">dns_search: example.com</span><br><span class="line"></span><br><span class="line">dns_search:</span><br><span class="line">  - domain1.example.com</span><br><span class="line">  - domain2.example.com</span><br></pre></td></tr></table></figure>

<h4 id="extra-hosts"><a href="#extra-hosts" class="headerlink" title="extra_hosts"></a>extra_hosts</h4><p>类似 Docker 中的 <code>--add-host</code> 参数，指定额外的 host 名称映射信息。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">extra_hosts:</span><br><span class="line"> - &quot;googledns:8.8.8.8&quot;</span><br><span class="line"> - &quot;dockerhub:52.1.157.61&quot;</span><br></pre></td></tr></table></figure>
<p>会在启动后的服务容器中 <code>/etc/hosts</code> 文件中添加如下两条条目</p>
<figure class="highlight shell"><figcaption><span>/etc/hosts</span></figcaption><table><tr><td class="code"><pre><span class="line">8.8.8.8 googledns</span><br><span class="line">52.1.157.61 dockerhub</span><br></pre></td></tr></table></figure>

<h4 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h4><p>设置环境变量。可以使用数组或字典两种格式  </p>
<p>只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。  </p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">environment:</span><br><span class="line">  RACK_ENV: development</span><br><span class="line">  SESSION_SECRET:</span><br><span class="line"></span><br><span class="line">environment:</span><br><span class="line">  - RACK_ENV=development</span><br><span class="line">  - SESSION_SECRET</span><br></pre></td></tr></table></figure>

<p>如果变量名称或者值中用到 <code>true</code>|<code>false</code>，<code>yes</code>|<code>no</code> 等表达 布尔 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF</span><br></pre></td></tr></table></figure>

<h4 id="env-file"><a href="#env-file" class="headerlink" title="env_file"></a>env_file</h4><p>从文件中获取环境变量，可以为单独的文件路径或列表。  </p>
<p>如果通过 <code>docker compose -f FILE</code> 方式来指定 Compose 模板文件，则 <code>env_file</code> 中变量的路径会基于模板文件路径。<br>如果有变量名称与 <a href="#environment"><code>environment</code></a> 指令冲突，则按照惯例，以后者为准。  </p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">env_file: .env</span><br><span class="line"></span><br><span class="line">env_file:</span><br><span class="line">  - ./common.env</span><br><span class="line">  - ./apps/web.env</span><br><span class="line">  - /opt/secrets.env</span><br></pre></td></tr></table></figure>
<p>环境变量文件中每一行必须符合格式，支持 # 开头的注释行。</p>
<figure class="highlight shell"><figcaption><span>.env</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">common.env: Set development environment</span></span><br><span class="line">PROG_ENV=development</span><br></pre></td></tr></table></figure>

<h4 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h4><p>暴露端口，但不映射到宿主机，只被连接的服务访问。<br>仅可以指定内部端口为参数</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">expose:</span><br><span class="line"> - &quot;3000&quot;</span><br><span class="line"> - &quot;8000&quot;</span><br></pre></td></tr></table></figure>

<h4 id="healthcheck"><a href="#healthcheck" class="headerlink" title="healthcheck"></a>healthcheck</h4><p>通过命令检查容器是否健康运行</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">healthcheck:</span><br><span class="line">  test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost&quot;]</span><br><span class="line">  interval: 1m30s</span><br><span class="line">  timeout: 10s</span><br><span class="line">  retries: 3</span><br></pre></td></tr></table></figure>

<h4 id="labels"><a href="#labels" class="headerlink" title="labels"></a>labels</h4><p>为容器添加 Docker 元数据（metadata）信息。例如可以为容器添加辅助说明信息。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">labels:</span><br><span class="line">  com.startupteam.description: &quot;webapp for a startup team&quot;</span><br><span class="line">  com.startupteam.department: &quot;devops department&quot;</span><br><span class="line">  com.startupteam.release: &quot;rc3 for v1.0&quot;</span><br></pre></td></tr></table></figure>

<h4 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h4><p>配置日志选项。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">logging:</span><br><span class="line">  driver: syslog</span><br><span class="line">  options:</span><br><span class="line">    syslog-address: &quot;tcp://192.168.0.42:123&quot;</span><br></pre></td></tr></table></figure>
<p>目前支持三种日志驱动类型。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">driver: &quot;json-file&quot;</span><br><span class="line">driver: &quot;syslog&quot;</span><br><span class="line">driver: &quot;none&quot;</span><br></pre></td></tr></table></figure>
<p>options 配置日志驱动的相关参数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">options:</span><br><span class="line">  max-size: &quot;200k&quot;</span><br><span class="line">  max-file: &quot;10&quot;</span><br></pre></td></tr></table></figure>

<h4 id="networks"><a href="#networks" class="headerlink" title="networks"></a>networks</h4><p>配置容器连接的网络。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  some-service:</span><br><span class="line">    networks:</span><br><span class="line">     - some-network</span><br><span class="line">     - other-network</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  some-network:</span><br><span class="line">  other-network:</span><br></pre></td></tr></table></figure>

<h4 id="ports"><a href="#ports" class="headerlink" title="ports"></a>ports</h4><p>暴露端口信息。<br>使用 <code>宿主端口：容器端口 (HOST:CONTAINER)</code> 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">ports:</span><br><span class="line"> - &quot;3000&quot;</span><br><span class="line"> - &quot;8000:8000&quot;</span><br><span class="line"> - &quot;49100:22&quot;</span><br><span class="line"> - &quot;127.0.0.1:8001:8001&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当使用 <code>HOST:CONTAINER</code> 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 YAML 会自动解析 <code>xx:yy</code> 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。</p>
</blockquote>
<h4 id="sysctls"><a href="#sysctls" class="headerlink" title="sysctls"></a>sysctls</h4><p>配置容器内核参数。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">sysctls:</span><br><span class="line">  net.core.somaxconn: 1024</span><br><span class="line">  net.ipv4.tcp_syncookies: 0</span><br><span class="line"></span><br><span class="line">sysctls:</span><br><span class="line">  - net.core.somaxconn=1024</span><br><span class="line">  - net.ipv4.tcp_syncookies=0</span><br></pre></td></tr></table></figure>

<h4 id="ulimits"><a href="#ulimits" class="headerlink" title="ulimits"></a>ulimits</h4><p>指定容器的 ulimits 限制值。<br>例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">ulimits:</span><br><span class="line">  nproc: 65535</span><br><span class="line">  nofile:</span><br><span class="line">    soft: 20000</span><br><span class="line">    hard: 40000</span><br></pre></td></tr></table></figure>

<h4 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a>volumes</h4><p>数据卷所挂载路径设置。可以设置为宿主机路径 (<code>HOST:CONTAINER</code>) 或者数据卷名称( <code>VOLUME:CONTAINER</code> )，并且可以设置访问模式 （ <code>HOST:CONTAINER:ro</code> ）。<br>该指令中路径支持相对路径。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">volumes:</span><br><span class="line"> - /var/lib/mysql</span><br><span class="line"> - cache/:/tmp/cache</span><br><span class="line"> - ~/configs:/etc/configs/:ro</span><br></pre></td></tr></table></figure>
<p>如果路径为数据卷名称，必须在文件中配置数据卷。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  my_src:</span><br><span class="line">    image: mysql:8.0</span><br><span class="line">    volumes:</span><br><span class="line">      - mysql_data:/var/lib/mysql</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  mysql_data:  </span><br></pre></td></tr></table></figure>

<h4 id="user"><a href="#user" class="headerlink" title="user"></a>user</h4><p>指定容器中运行应用的用户名。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">user: nginx</span><br></pre></td></tr></table></figure>
<h4 id="hostname"><a href="#hostname" class="headerlink" title="hostname"></a>hostname</h4><p>指定容器中主机名</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">hostname: test</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="working-dir"><a href="#working-dir" class="headerlink" title="working_dir"></a>working_dir</h4><p>指定容器中工作目录。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">working_dir: /code</span><br></pre></td></tr></table></figure>

<h4 id="restart"><a href="#restart" class="headerlink" title="restart"></a>restart</h4><p>指定容器退出后的重启策略为始终重启。该命令对保持服务始终运行十分有效，在生产环境中推荐配置为 <code>always</code> 或者 <code>unless-stopped</code>。  </p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">restart: always</span><br></pre></td></tr></table></figure>

<h4 id="read-only"><a href="#read-only" class="headerlink" title="read_only"></a>read_only</h4><p>以只读模式挂载容器的 root 文件系统，意味着不能对容器内容进行修改。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">read_only: true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="读取变量"><a href="#读取变量" class="headerlink" title="读取变量"></a>读取变量</h3><p>Compose 模板文件支持动态读取主机的系统环境变量和当前目录下的 <code>.env</code> 文件中的变量。  </p>
<p>例如，下面的 Compose 文件将从运行它的环境中读取变量 ${MONGO_VERSION} 的值，并写入执行的指令中。 </p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">db:</span><br><span class="line">  image: &quot;mongo:$&#123;MONGO_VERSION&#125;&quot;</span><br></pre></td></tr></table></figure>

<p>如果执行 <code>MONGO_VERSION=3.2 ; docker compose up</code> 则会启动一个 <code>mongo:3.2</code> 镜像的容器；<br>如果执行 <code>MONGO_VERSION=2.8 ; docker compose up</code> 则会启动一个 <code>mongo:2.8</code> 镜像的容器  </p>
<p>若当前目录存在 <code>.env</code> 文件，执行 <code>docker compose</code> 命令时将从该文件中读取变量。  </p>
<p>在当前目录新建 <code>.env</code> 文件并写入以下内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 支持 # 号注释</span><br><span class="line">MONGO_VERSION=3.6</span><br></pre></td></tr></table></figure>
<p>执行 <code>docker compose up</code> 则会启动一个 <code>mongo:3.6</code> 镜像的容器。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://docs.docker.com/compose/">Compose V2 beta</a><br><a href="https://yeasy.gitbook.io/docker_practice/compose/v2">Docker 从入门到实践</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker compose 配置 django mysql 站点</title>
    <url>/202209051137/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文主要记录使用 <code>docker compose</code> 配置 Django + Mysql 的 web 站点的过程。</p>
<h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Centos7</li>
<li>Docker version 20.10.17</li>
</ul>
<h3 id="目录结构及说明"><a href="#目录结构及说明" class="headerlink" title="目录结构及说明"></a>目录结构及说明</h3><p>项目目录结构及简要说明如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── compose</span><br><span class="line">│   └── mysql</span><br><span class="line">│       └── my.cnf</span><br><span class="line">├── django_project</span><br><span class="line">│   ├── db.sqlite3</span><br><span class="line">│   ├── django_app</span><br><span class="line">│   │   ├── admin.py</span><br><span class="line">│   │   ├── apps.py</span><br><span class="line">│   │   ├── __init__.py</span><br><span class="line">│   │   ├── migrations</span><br><span class="line">│   │   ├── models.py</span><br><span class="line">│   │   ├── tests.py</span><br><span class="line">│   │   └── views.py</span><br><span class="line">│   ├── django_project</span><br><span class="line">│   │   ├── asgi.py</span><br><span class="line">│   │   ├── __init__.py</span><br><span class="line">│   │   ├── __pycache__</span><br><span class="line">│   │   ├── settings.py</span><br><span class="line">│   │   ├── urls.py</span><br><span class="line">│   │   └── wsgi.py</span><br><span class="line">│   ├── Dockerfile</span><br><span class="line">│   ├── manage.py</span><br><span class="line">│   └── requirements.txt</span><br><span class="line">├── docker-compose.yml</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><code>compose</code> : 存放应用配置文件，如 mysql 配置文件 <code>compose/mysql/my.cnf</code></li>
<li><code>django_project</code> : Django project 项目目录， <code>django-admin startproject django_project</code> 生成</li>
<li><code>django_project/django_app</code> : Django project 项目下的 app 目录，<code>django-admin startapp django_app</code> 生成</li>
<li><code>docker-compose.yml</code> : 项目的 compose 文件</li>
</ul>
<span id="more"></span>

<h3 id="编写-django-运行镜像的-Dockerfile"><a href="#编写-django-运行镜像的-Dockerfile" class="headerlink" title="编写 django 运行镜像的 Dockerfile"></a>编写 django 运行镜像的 Dockerfile</h3><p>编写构建 django 镜像的 Dockerfile，文件位置 <code>django_project/Dockerfile</code></p>
<figure class="highlight shell"><figcaption><span>django_project/Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">FROM python:3.10</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将上下文环境中(django_project/)的 requirements.txt 拷贝到镜像的 /code 目录</span></span><br><span class="line">COPY requirements.txt /code/</span><br><span class="line"></span><br><span class="line">WORKDIR /code/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 python 项目依赖</span></span><br><span class="line">RUN pip install -r requirements.txt &amp;&amp; rm -rf requirements.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解决 django 无法加载 MySQLdb 模块的问题</span></span><br><span class="line">RUN echo &quot;import pymysql&quot; &gt; /usr/local/lib/python3.10/site-packages/django/db/backends/mysql/__init__.py &amp;&amp; \</span><br><span class="line">    echo &quot;pymysql.install_as_MySQLdb()&quot; &gt;&gt; /usr/local/lib/python3.10/site-packages/django/db/backends/mysql/__init__.py</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装常用工具，方便容器启动后的调试</span></span><br><span class="line">RUN apt-get update &amp;&amp; apt install -y netcat &amp;&amp; apt install -y vim &amp;&amp; \</span><br><span class="line">    apt-get install -y iputils-ping &amp;&amp; \</span><br><span class="line">    apt-get install -y net-tools</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">健康检查，环境变量 <span class="variable">$&#123;DJANGO_SERVER_PORT&#125;</span> 来自 docker-compose.yml 文件</span></span><br><span class="line">HEALTHCHECK CMD curl -fs http://localhost:$&#123;DJANGO_SERVER_PORT&#125;/ || exit 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>构建镜像时，只将构建镜像所需的文件（<code>requirements.txt</code>）拷贝进镜像，使用完成后删除，容器运行时需要的代码文件，通过 <code>docker-compose.yml</code> 中的 <code>volumes</code> 命令进行挂载，这样更新代码时，只需要在宿主机上面更新代码，不用再对镜像进行变更，只有需要更新运行环境时才需要更新镜像  </p>
<p>django 镜像构建文件的 <code>Dockerfile</code> 中先不写 <code>CMD</code> 或者 <code>ENTRYPOINT</code> 启动 web 服务器，因为数据库还没启动，配置 <code>CMD</code> 启动 django 服务会报错（无法连接数据库）</p>
<p>修改 django 工程配置文件 <code>django_project/django_project/settings.py</code>，提前配置好 mysql 配置：</p>
<figure class="highlight shell"><figcaption><span>django_project/django_project/settings.py</span></figcaption><table><tr><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    &#x27;default&#x27;: &#123;</span><br><span class="line">        &#x27;ENGINE&#x27;: &#x27;django.db.backends.mysql&#x27;,</span><br><span class="line">        # 此处 &#x27;HOST&#x27; 配置的主机地址，要和 docker-compose.yml 中配置的 mysql 服务名称一致</span><br><span class="line">        &#x27;HOST&#x27;: &quot;db&quot;,</span><br><span class="line">        &#x27;NAME&#x27;: &quot;ops&quot;,</span><br><span class="line">        &#x27;USER&#x27;: &quot;root&quot;,</span><br><span class="line">        &quot;PASSWORD&quot;: &quot;123456&quot;,</span><br><span class="line">        &quot;PORT&quot;: &#x27;3306&#x27;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编写项目的-docker-compose-yml"><a href="#编写项目的-docker-compose-yml" class="headerlink" title="编写项目的 docker-compose.yml"></a>编写项目的 docker-compose.yml</h3><p>项目的 <code>docker-compose.yml</code> 文件内容及说明如下</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  mysql_data_vol:   # mysql datadir 需要挂载的数据卷</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  django_network:    # 本项目使用的 network ，方便项目中的服务容器之间互相通信，直接使用服务名</span><br><span class="line">    </span><br><span class="line">services:</span><br><span class="line">  db:   #  mysql 服务名</span><br><span class="line">    image: mysql:5.7</span><br><span class="line">    env_file:</span><br><span class="line">      - .env   # 服务要加载的环境变量文件，路径为相对于 docker-compose.yml 的路径</span><br><span class="line">    networks:</span><br><span class="line">      - django_network</span><br><span class="line">    volumes:</span><br><span class="line">      - mysql_data_vol:/var/lib/mysql:rw</span><br><span class="line">      - ./compose/mysql/my.cnf:/etc/my.cnf</span><br><span class="line"></span><br><span class="line">    ports:</span><br><span class="line">        - &quot;3307:3306&quot;</span><br><span class="line">    restart: always</span><br><span class="line"></span><br><span class="line">  django_server:</span><br><span class="line">    build: ./django_project/      # 使用 ./django_project/Dockerfile 构建镜像</span><br><span class="line">    env_file:</span><br><span class="line">      - .env  # 加载环境变量，其中的变量可以在 docker-compose.yml 和 Dockerfile 中使用</span><br><span class="line">      </span><br><span class="line">    volumes:</span><br><span class="line">      - ./django_project/：/code/</span><br><span class="line">    # command ： 容器要运行的命令</span><br><span class="line">    command: python manage.py runserver 0.0.0.0:$&#123;DJANGO_SERVER_PORT&#125;</span><br><span class="line">    networks:</span><br><span class="line">      - django_network</span><br><span class="line">    ports:</span><br><span class="line">      - &#x27;$&#123;DJANGO_SERVER_PORT&#125;:$&#123;DJANGO_SERVER_PORT&#125;&#x27;</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">    restart: always</span><br></pre></td></tr></table></figure>

<p>其中使用的 <code>.env</code> 文件内容如下：</p>
<figure class="highlight shell"><figcaption><span>.env</span></figcaption><table><tr><td class="code"><pre><span class="line">MYSQL_ROOT_PASSWORD=123456</span><br><span class="line"></span><br><span class="line">DJANGO_SERVER_PORT=8081</span><br></pre></td></tr></table></figure>

<h3 id="启动-docker-compose-项目"><a href="#启动-docker-compose-项目" class="headerlink" title="启动 docker compose 项目"></a>启动 docker compose 项目</h3><p>使用 <code>docker compose build</code> 之前，可以先检查一下配置，确保配置无误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker compose config</span></span><br><span class="line">name: dockerproject</span><br><span class="line">services:</span><br><span class="line">  db:</span><br><span class="line">    environment:</span><br><span class="line">      DJANGO_SERVER_PORT: &quot;8081&quot;</span><br><span class="line">      MYSQL_ROOT_PASSWORD: 123456</span><br><span class="line">    image: mysql:5.7</span><br><span class="line">    networks:</span><br><span class="line">      django_network: null</span><br><span class="line">    ports:</span><br><span class="line">    - mode: ingress</span><br><span class="line">      target: 3306</span><br><span class="line">      published: &quot;3307&quot;</span><br><span class="line">      protocol: tcp</span><br><span class="line">    restart: always</span><br><span class="line">    volumes:</span><br><span class="line">    - type: volume</span><br><span class="line">      source: mysql_data_vol</span><br><span class="line">      target: /var/lib/mysql</span><br><span class="line">      volume: &#123;&#125;</span><br><span class="line">    - type: bind</span><br><span class="line">      source: /root/dockerProject/compose/mysql/my.cnf</span><br><span class="line">      target: /etc/my.cnf</span><br><span class="line">      bind:</span><br><span class="line">        create_host_path: true</span><br><span class="line">  django_server:</span><br><span class="line">    build:</span><br><span class="line">      context: /root/dockerProject/django_project</span><br><span class="line">      dockerfile: Dockerfile</span><br><span class="line">    command:</span><br><span class="line">    - python</span><br><span class="line">    - manage.py</span><br><span class="line">    - runserver</span><br><span class="line">    - 0.0.0.0:8081</span><br><span class="line">    depends_on:</span><br><span class="line">      db:</span><br><span class="line">        condition: service_started</span><br><span class="line">    environment:</span><br><span class="line">      DJANGO_SERVER_PORT: &quot;8081&quot;</span><br><span class="line">      MYSQL_ROOT_PASSWORD: 123456</span><br><span class="line">    networks:</span><br><span class="line">      django_network: null</span><br><span class="line">    ports:</span><br><span class="line">    - mode: ingress</span><br><span class="line">      target: 8081</span><br><span class="line">      published: &quot;8081&quot;</span><br><span class="line">      protocol: tcp</span><br><span class="line">    restart: always</span><br><span class="line">networks:</span><br><span class="line">  django_network:</span><br><span class="line">    name: dockerproject_django_network</span><br><span class="line">volumes:</span><br><span class="line">  mysql_data_vol:</span><br><span class="line">    name: dockerproject_mysql_data_vol</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>配置无误，<code>docker compose config</code> 命令会输出配置，有错误会显示错误，<a href="/202208311004/" title="docker compose 其他常用命令参考">docker compose 其他常用命令参考</a></p>
<p>使用 <code>docker compose build</code> 命令构建镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker compose build</span></span><br><span class="line">[+] Building 0.1s (11/11) FINISHED                                                                                   </span><br><span class="line"> =&gt; [internal] load build definition from Dockerfile                                                            0.0s</span><br><span class="line"> =&gt; =&gt; transferring dockerfile: 32B                                                                             0.0s</span><br><span class="line"> =&gt; [internal] load .dockerignore                                                                               0.0s</span><br><span class="line"> =&gt; =&gt; transferring context: 2B                                                                                 0.0s</span><br><span class="line"> =&gt; [internal] load metadata for docker.io/library/python:3.10                                                  0.0s</span><br><span class="line"> =&gt; [internal] load build context                                                                               0.0s</span><br><span class="line"> =&gt; =&gt; transferring context: 982B                                                                               0.0s</span><br><span class="line"> =&gt; [1/6] FROM docker.io/library/python:3.10                                                                    0.0s</span><br><span class="line"> =&gt; CACHED [2/6] COPY . /code                                                                                   0.0s</span><br><span class="line"> =&gt; CACHED [3/6] WORKDIR /code                                                                                  0.0s</span><br><span class="line"> =&gt; CACHED [4/6] RUN pip install -r requirements.txt                                                            0.0s</span><br><span class="line"> =&gt; CACHED [5/6] RUN echo &quot;import pymysql&quot; &gt; /usr/local/lib/python3.10/site-packages/django/db/backends/mysql/  0.0s</span><br><span class="line"> =&gt; CACHED [6/6] RUN apt-get update &amp;&amp; apt install -y netcat &amp;&amp; apt install -y vim                              0.0s</span><br><span class="line"> =&gt; exporting to image                                                                                          0.0s</span><br><span class="line"> =&gt; =&gt; exporting layers                                                                                         0.0s</span><br><span class="line"> =&gt; =&gt; writing image sha256:9da868de3de9538931f9d60a7fd40d6197c332f4aadc03c8b8ca8446df7cee23                    0.0s</span><br><span class="line"> =&gt; =&gt; naming to docker.io/library/dockerproject_django_server                                                  0.0s</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也可以直接使用 <code>docker compose up</code>（会先构建镜像，然后启动项目中的所有服务）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker compose up</span></span><br><span class="line">[+] Running 3/2</span><br><span class="line"> ⠿ Network dockerproject_django_network     Created                                                             0.1s</span><br><span class="line"> ⠿ Container dockerproject-db-1             Created                                                             0.0s</span><br><span class="line"> ⠿ Container dockerproject-django_server-1  Created                                                             0.0s</span><br><span class="line">Attaching to dockerproject-db-1, dockerproject-django_server-1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看 compose 项目的状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker compose <span class="built_in">ls</span></span></span><br><span class="line">NAME                STATUS              CONFIG FILES</span><br><span class="line">dockerproject       running(2)          /root/dockerProject/docker-compose.yml</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看 compose 项目中的容器情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker compose ps</span></span><br><span class="line">NAME                            COMMAND                  SERVICE             STATUS              PORTS</span><br><span class="line">dockerproject-db-1              &quot;docker-entrypoint.s…&quot;   db                  running             0.0.0.0:3307-&gt;3306/tcp, :::3307-&gt;3306/tcp</span><br><span class="line">dockerproject-django_server-1   &quot;python manage.py ru…&quot;   django_server       running (healthy)   0.0.0.0:8081-&gt;8081/tcp, :::8081-&gt;8081/tcp</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看 compose 项目中的镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker compose images</span></span><br><span class="line">Container                       Repository                    Tag                 Image Id            Size</span><br><span class="line">dockerproject-db-1              mysql                         5.7                 daff57b7d2d1        430MB</span><br><span class="line">dockerproject-django_server-1   dockerproject_django_server   latest              9da868de3de9        1.02GB</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://csms.tech/categories/Docker/">docker compose 说明</a><br><a href="https://csms.tech/202208311004/">docker compose 常用命令</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>compose</tag>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 私有镜像仓库 Harbor 安装及使用</title>
    <url>/202210191515/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h2><ul>
<li>Centos 7</li>
<li>docker-ce-19.03.15</li>
<li>harbor v2.6.1</li>
</ul>
<h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><p><a href="https://goharbor.io/docs/2.6.0/install-config/">官网安装参考链接</a></p>
<h3 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://github.com/goharbor/harbor/releases/download/v2.6.1/harbor-offline-installer-v2.6.1.tgz</span><br><span class="line">tar -xf harbor-offline-installer-v2.6.1.tgz</span><br><span class="line">cd harbor</span><br></pre></td></tr></table></figure>

<h3 id="准备证书"><a href="#准备证书" class="headerlink" title="准备证书"></a>准备证书</h3><p>将申请好的证书上传到服务器，将 <code>harbor.crt</code> 转换为 <code>harbor.cert</code>  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl x509 -inform PEM -in harbor.crt -out harbor.cert </span><br></pre></td></tr></table></figure>

<p>将转换好的证书和私钥拷贝到 Docker 的证书目录 <code>/etc/docker/certs.d/yourdomain.com/</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp yourdomain.com.cert /etc/docker/certs.d/yourdomain.com/</span><br><span class="line">cp yourdomain.com.key /etc/docker/certs.d/yourdomain.com/</span><br><span class="line">cp ca.crt /etc/docker/certs.d/yourdomain.com/</span><br></pre></td></tr></table></figure>

<p>重启 Docker</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<h3 id="配置-Harbor-安装配置文件"><a href="#配置-Harbor-安装配置文件" class="headerlink" title="配置 Harbor 安装配置文件"></a>配置 Harbor 安装配置文件</h3><p>执行 <code>install.sh</code> 命令安装 Harbor 时，会使用配置文件 <code>harbor.yml</code>（需要拷贝安装包中的 <code>harbor.yml.tmpl</code> 为 <code>harbor.yml</code>）。</p>
<p>修改配置中的 <code>hostname</code> 选项，配置访问 Harbor 的域名。<strong>此为必须修改的参数</strong>。</p>
<p>修改配置中的 <code>https.certificate</code> 和 <code>https.private_key</code>，配置证书（<code>harbor.crt</code>）和私钥的路径，<strong>使用 HTTPS 时必须配置</strong>。</p>
<p>修改配置中的 <code>data_volume</code>，指定持久化数据卷的路径。默认为 <code>data_volume: /data</code></p>
<span id="more"></span>
<h3 id="执行安装脚本"><a href="#执行安装脚本" class="headerlink" title="执行安装脚本"></a>执行安装脚本</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ./install.sh</span><br></pre></td></tr></table></figure>

<p>安装成功后，使用浏览器登陆 WEB，初始密码为部署配置文件中配置，默认为 <code>Harbor12345</code></p>
<figure class="highlight shell"><figcaption><span>harbor.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">harbor_admin_password: Harbor12345</span><br></pre></td></tr></table></figure>

<p>执行安装脚本部署完成后，会生产 <code>docker-compose.yml</code> 文件，此文件为 Docker 编排 Harbor 的配置文件。使用 <code>docker</code> 重启 Harbor 命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker compose restart</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<a href="/202208311004/" title="更多 &#96;docker compose&#96; 命令说明">更多 &#96;docker compose&#96; 命令说明</a>

<h2 id="常用操作说明"><a href="#常用操作说明" class="headerlink" title="常用操作说明"></a>常用操作说明</h2><p>根据安装脚本生成的 <code>docker-compose.yml</code> ，可以看到各个服务的配置</p>
<ul>
<li>日志路径： <code>/var/log/harbor/</code>。各个服务的日志输出到了宿主机的目录 ： <code>/var/log/harbor/</code></li>
<li><code>registry</code> 服务使用本地存储时，默认路径为 ： <code>/data/registry</code></li>
<li><code>postgresql</code> 数据库目录 ： <code>/data/database</code></li>
</ul>
<h3 id="使用-docker-登陆并-push-镜像"><a href="#使用-docker-登陆并-push-镜像" class="headerlink" title="使用 docker 登陆并 push 镜像"></a>使用 docker 登陆并 push 镜像</h3><p>登陆 Harbor</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker login harbor.xxx.com</span></span><br><span class="line">sername: admin</span><br><span class="line">Password: </span><br><span class="line">WARNING! Your password will be stored unencrypted in /root/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</span><br><span class="line"></span><br><span class="line">Login Succeeded</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>push</code> 镜像步骤</p>
<ol>
<li>为要推送的镜像打上标签，其中 <code>common</code> 为项目名称 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker tag netshoot:my harbor.xxx.com/common/netshoot:my</span><br></pre></td></tr></table></figure></li>
<li><code>push</code> 镜像 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker push harbor.8be939d.com/common/netshoot:my</span><br></pre></td></tr></table></figure></li>
<li>Harbor potal 中检查推送是否成功<br> <img src="https://i.csms.tech/img_64.png"></li>
</ol>
<h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p>除了系统管理员 <code>admin</code>（拥有最大权限），Harbor 用户分还有以下几种角色<br><img src="https://i.csms.tech/img_72.png"></p>
<ul>
<li><p><code>Project Admin</code></p>
<p>  当系统管理员（<code>admin</code>）给某个用户 <code>项目管理员</code> 的角色后，该用户即可以 <code>项目管理员</code> 的身份管理该项目，其它未分配的项目无权限，<code>项目管理员</code> 有 <strong>镜像上传&#x2F;拉取</strong>、<strong>添加&#x2F;删除成员</strong>、<strong>Helm Chart 上传&#x2F;下载</strong>、<strong>配置管理</strong> 等权限。该角色在实际的业务场景通常是分配给某个项目的负责人。</p>
</li>
<li><p><code>Maintainer</code></p>
<p>  <code>维护者</code> 拥有超越<code>开发者</code> 的权限，包括 <strong>扫描镜像</strong>、<strong>查看复制任务</strong> 以及 <strong>删除镜像</strong> 和 <strong>Helm Chart上传&#x2F;下载、删除</strong> 的能力。</p>
</li>
<li><p><code>Developer</code></p>
<p>  <code>开发者</code> 拥有项目的读写权限，即 <strong>上传镜像</strong> 到该项目和从该项目 <strong>拉取镜像</strong>、<strong>上传&#x2F;下载HelmChart</strong>、<strong>查看日志</strong>，其它权限没有。</p>
</li>
<li><p><code>Guest</code></p>
<p>  <code>访客</code> 对指定项目具有 <strong>只读权限</strong>。他们可以 <strong>拉取</strong> 和重新标记图像，但 <strong>不能推送</strong>，也可以登录Harbor UI界面。</p>
</li>
<li><p><code>Limited Guest</code></p>
<p>  <code>受限访客</code> 没有项目的完全读取权限。他们可以拉取图像但不能推送，而且他们看不到日志或项目的其他成员。例如，您可以为来自不同组织的共享项目访问权限的用户创建受限访客。</p>
<p>  受限访客也可以登录 Harbor，但是只具有镜像拉取权限，无法查看日志等权限。</p>
</li>
</ul>
<h4 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h4><p>要为指定项目分配用户，必须先创建用户。只有 <code>admin</code> 用户才能创建用户。</p>
<p>要创建用户，在 <code>Administration</code> -&gt; <code>Users</code> -&gt; <code>+ NEW USER</code> 添加新用户。<br><img src="https://i.csms.tech/img_73.png"></p>
<h4 id="分配用户"><a href="#分配用户" class="headerlink" title="分配用户"></a>分配用户</h4><p><code>admin</code> 或具有 <code>Project Admin</code> 权限的用户可以在指定的项目中，为项目添加成员</p>
<p>要为项目添加成员，进入指定项目，在 <code>Members</code> -&gt; <code>+ USER</code> ，为项目分配成员<br><img src="https://i.csms.tech/img_74.png"></p>
<h2 id="配置复制"><a href="#配置复制" class="headerlink" title="配置复制"></a>配置复制</h2><p>此种复制不会复制用户信息。镜像复制到目标后，会自动更改镜像地址到目标镜像地址，可以直接使用镜像。</p>
<h3 id="配置复制到-Harbor"><a href="#配置复制到-Harbor" class="headerlink" title="配置复制到 Harbor"></a>配置复制到 Harbor</h3><p>为了对 Harbor 提供备份，可以配置复制到目标 Harbor 作为备份。</p>
<h4 id="在源-Harbor-配置-replication-endpoints"><a href="#在源-Harbor-配置-replication-endpoints" class="headerlink" title="在源 Harbor 配置 replication endpoints"></a>在源 Harbor 配置 replication endpoints</h4><p>在 <code>Administration</code> -&gt; <code>Registies</code> -&gt; <code>+ NEW ENDPOINT</code> 中，添加 <code>Endpoint</code>，除了 Harbor，还支持以下 <code>Provider</code> <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Creating Replication Endpoints](https://goharbor.io/docs/2.6.0/administration/configuring-replication/create-replication-endpoints/)">[1]</span></a></sup></p>
<ul>
<li>Docker Hub</li>
<li>Docker registry</li>
<li>AWS Elastic Container Registry</li>
<li>Azure Container Registry</li>
<li>Ali Cloud Container Registry</li>
<li>Google Container Registry</li>
<li>Huawei SWR</li>
<li>Artifact Hub</li>
<li>Gitlab</li>
<li>Quay</li>
<li>Jfrog Artifactory</li>
</ul>
<p>此处  <code>Provider</code> 选择 Harbor<br><img src="https://i.csms.tech/img_75.png"></p>
<h4 id="创建复制规则"><a href="#创建复制规则" class="headerlink" title="创建复制规则"></a>创建复制规则</h4><p>在 <code>Administration</code> -&gt; <code>Replications</code> -&gt; <code>+ NEW REPLICATION RULE</code></p>
<p>根据提示输入自定义选项</p>
<ul>
<li>如果目标 Harbor 只是用来备用或用来作为镜像下载的仓库，可以配置复制时覆盖目标中同名的镜像</li>
</ul>
<h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><h3 id="Harbar-主要的数据组成"><a href="#Harbar-主要的数据组成" class="headerlink" title="Harbar 主要的数据组成"></a>Harbar 主要的数据组成</h3><p>Harbor 安装过程中，主要依赖执行安装脚本 <a href="#%E9%85%8D%E7%BD%AE-Harbor-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">需要的配置文件 <code>harbor.yml</code></a>，安装脚本执行后，会生成 <code>docker-compose.yml</code> 文件，同时会生成其他一些临时文件，这些临时文件在 Harbor 容器启动时需要挂载到容器，这些数据通常在 Harbor 安装目录的 <code>common</code> 目录下。虽然临时数据对服务的顺利运行至关重要，但是安装程序每次都会读取 Harbor 配置文件重新生成一份临时数据，所以此处仅需备份配置文件即可</p>
<p>Harbor 容器使用的持久化数据默认保存在宿主机目录 <code>/data</code>，具体目录由安装配置文件 <code>harbor.yml</code> 配置</p>
<figure class="highlight shell"><figcaption><span>harbor.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">The default data volume</span></span><br><span class="line">data_volume: /data</span><br></pre></td></tr></table></figure>
<p><code>/data</code> 目录包含的文件夹和相应的作用如下:</p>
<ul>
<li><code>ca_download</code> - 存放用户访问Harbor时所需的 CA 证书。</li>
<li><code>database</code> - 存放数据库的目录，Harbor、Clair 和 Notary 数据库的数据都在此目录下。</li>
<li><code>job_logs</code> - 存放 JobService 的日志信息。</li>
<li><code>redis</code> - 存放 Redis 数据。</li>
<li><code>registry</code> - 存放 OCI Artifacts 数据（对于大部分用户来说是镜像数据）。</li>
<li><code>secret</code> - 存放 Harbor 内部组件通信所需的加密信息。</li>
</ul>
<p>Harbor 容器运行日志保存宿主机在 <code>/var/log/harbor</code></p>
<h3 id="备份数据"><a href="#备份数据" class="headerlink" title="备份数据"></a>备份数据</h3><ol>
<li>创建备份目录 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /HarborBackup</span><br></pre></td></tr></table></figure></li>
<li>备份 Harbor 安装目录， <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp -p -r ./harbor/ /HarborBackup/harbor</span><br></pre></td></tr></table></figure></li>
<li>备份 Harbor 持久化数据<br> 若不确定持久化数据卷的路径，可以查看安装配置文件<code>harbor.yml</code> 中的 <code>data_volume</code> 配置，默认为 <code>data_volume: /data</code> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp -p -r /data/ /HarborBackup/data</span><br></pre></td></tr></table></figure></li>
</ol>
<p>在需要恢复时，反向拷贝数据即可。需要注意，文件权限需要保持和备份之前的信息一致。</p>
<h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><h3 id="http-server-gave-HTTP-response-to-HTTPS-client"><a href="#http-server-gave-HTTP-response-to-HTTPS-client" class="headerlink" title="http: server gave HTTP response to HTTPS client"></a>http: server gave HTTP response to HTTPS client</h3><p><strong>错误原因</strong></p>
<p>docker client 和 docker registry 交互默认使用的是 HTTPS，如果镜像仓库使用的是 HTTP 服务，则与私有镜像交互时出现以上错误。</p>
<p><strong>解决方法</strong></p>
<p>修改或创建文件 <code>/etc/docker/daemon.json</code>，添加以下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123; &quot;insecure-registries&quot;:[&quot;54.236.67.117:5000&quot;] &#125;</span><br></pre></td></tr></table></figure>
<p>重启 docker</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://github.com/goharbor/harbor">官网说明</a></p>
<h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://goharbor.io/docs/2.6.0/administration/configuring-replication/create-replication-endpoints/">Creating Replication Endpoints</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://goharbor.io/docs/2.6.0/administration/configuring-replication/create-replication-rules/">Creating a Replication Rule</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Harbor</tag>
      </tags>
  </entry>
  <entry>
    <title>docker 安装及常用命令介绍</title>
    <url>/202208041317/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Centos 7.9.2009</li>
<li>docker-ce-19.03.15</li>
<li>docker-20.10.9</li>
</ul>
<h3 id="docker-yum-安装"><a href="#docker-yum-安装" class="headerlink" title="docker yum 安装"></a>docker yum 安装</h3><p>安装 yum 源，<a href="https://docs.docker.com/engine/install/centos/">docker官方 centos 安装文档</a>  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils</span><br><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<p>安装 <code>docker</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure>

<h3 id="docker-离线安装"><a href="#docker-离线安装" class="headerlink" title="docker 离线安装"></a>docker 离线安装</h3><p><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a>下载rpm安装包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-ce-19.03.15-3.el7.x86_64.rpm</span><br><span class="line">wget https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-ce-cli-19.03.15-3.el7.x86_64.rpm</span><br><span class="line">wget https://download.docker.com/linux/centos/7/x86_64/stable/Packages/containerd.io-1.4.13-3.1.el7.x86_64.rpm</span><br><span class="line">wget https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-compose-plugin-2.3.3-3.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>
<p>安装 docker</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum localinstall -y containerd.io-1.4.13-3.1.el7.x86_64.rpm \</span><br><span class="line">                    docker-ce-cli-19.03.15-3.el7.x86_64.rpm \</span><br><span class="line">                    docker-ce-19.03.15-3.el7.x86_64.rpm \</span><br><span class="line">                    docker-compose-plugin-2.3.3-3.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>

<p>以上 2 条命令可以使用以下 1 条命令完成</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum localinstall -y https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-ce-19.03.15-3.el7.x86_64.rpm \</span><br><span class="line">                    https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-ce-cli-19.03.15-3.el7.x86_64.rpm \</span><br><span class="line">                    https://download.docker.com/linux/centos/7/x86_64/stable/Packages/containerd.io-1.4.13-3.1.el7.x86_64.rpm \</span><br><span class="line">                    https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-compose-plugin-2.3.3-3.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>

<p>启动docker</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable docker --now</span><br></pre></td></tr></table></figure>

<span id="more"></span>
<h3 id="docker-ce-19-03-15-升级到-docker-ce-20-10-9"><a href="#docker-ce-19-03-15-升级到-docker-ce-20-10-9" class="headerlink" title="docker-ce-19.03.15 升级到 docker-ce-20.10.9"></a>docker-ce-19.03.15 升级到 docker-ce-20.10.9</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum update https://download.docker.com/linux/centos/7/x86_64/stable/Packages/containerd.io-1.6.9-3.1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">yum install https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-scan-plugin-0.9.0-3.el7.x86_64.rpm \</span><br><span class="line">            https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-ce-rootless-extras-20.10.9-3.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">yum update https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-ce-cli-20.10.9-3.el7.x86_64.rpm \</span><br><span class="line">           https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-ce-20.10.9-3.el7.x86_64.rpm \</span><br><span class="line">           https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-compose-plugin-2.6.0-3.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>

<h3 id="docker-镜像管理命令"><a href="#docker-镜像管理命令" class="headerlink" title="docker 镜像管理命令"></a>docker 镜像管理命令</h3><h4 id="获取（下载）镜像"><a href="#获取（下载）镜像" class="headerlink" title="获取（下载）镜像"></a>获取（下载）镜像</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span><br><span class="line">docker pull centos:centos7.9.2009</span><br></pre></td></tr></table></figure>
<blockquote>
<p>未指定地址，默认是从 <a href="https://hub.docker.com/search?q=&type=image">Docker Hub</a> 上面获取镜像，<a href="https://yeasy.gitbook.io/docker_practice/image/pull">参考说明</a><br>标签信息可从 <a href="https://hub.docker.com/search?q=&type=image">Docker Hub</a> 上面查看</p>
</blockquote>
<h4 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h4><p><a href="#%E8%8E%B7%E5%8F%96%EF%BC%88%E4%B8%8B%E8%BD%BD%EF%BC%89%E9%95%9C%E5%83%8F">获取（下载）镜像</a>后，运行镜像并运行镜像中的<code>bash</code>命令进入对应容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it --rm centos:centos7.9.2009 bash</span><br><span class="line">cat /etc/os-release</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>

<p>进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。例如执行 <code>cat /etc/os-release</code>。容器中执行<code>exit</code>命令可以退出容器</p>
<p><img src="https://i.csms.tech/img_35.png"></p>
<p><code>docker run</code> 命令常用选项说明</p>
<style>
table th:nth-of-type(1){
width: 10%;
}
table th:nth-of-type(2){
width: 70%
;
}
table th:nth-of-type(3){
width: 20%;
}

</style>

<table>
<thead>
<tr>
<th align="left">选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-i</code></td>
<td>启用交互式操作</td>
<td></td>
</tr>
<tr>
<td align="left"><code>-t</code></td>
<td>开启终端（输入输出）</td>
<td></td>
</tr>
<tr>
<td align="left"><code>--rm</code></td>
<td>容器退出(<code>exit</code>)后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。</td>
<td></td>
</tr>
<tr>
<td align="left"><code>--name</code></td>
<td>给启动的容器命名</td>
<td><code>docker run -d --name &quot;centos7&quot; centos:centos7.9.2009 bash</code></td>
</tr>
<tr>
<td align="left"><code>-d</code></td>
<td>后台运行，启动后返回容器id，并进入后台运行，容器的输出可使用 <code>docker logs CONTAINER</code> 或 <code>docker container logs CONTAINER</code> 查看</td>
<td></td>
</tr>
<tr>
<td align="left"><code>--entrypoint</code></td>
<td>覆盖（替换）镜像中<a href="https://csms.tech/202208050928/#ENTRYPOINT-容器启动程序指令">默认的<code>ENTRYPOINT</code></a></td>
<td></td>
</tr>
</tbody></table>
<h4 id="列出已下载的镜像"><a href="#列出已下载的镜像" class="headerlink" title="列出已下载的镜像"></a>列出已下载的镜像</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker image <span class="built_in">ls</span></span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE  </span><br><span class="line">centos              centos7.9.2009      eeb6ee3f44bd        10 months ago       204MB</span><br></pre></td></tr></table></figure>



<p>列表包含了 <code>仓库名</code>、<code>标签</code>、<code>镜像 ID</code>、<code>创建时间</code> 以及 <code>所占用的空间</code>。  </p>
<blockquote>
<p><code>IMAGE ID</code> 是镜像的唯一标识，同一个镜像可以有多个标签</p>
</blockquote>
<h4 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker image rm centos:centos7.9.2009</span><br><span class="line"></span><br><span class="line">docker image rm eeb6ee3f44bd</span><br></pre></td></tr></table></figure>

<p>可以用镜像名(<code>&lt;仓库名&gt;:&lt;标签&gt;</code>) ，<code>镜像 ID</code> 删除镜像</p>
<p>也可以使用 <code>镜像摘要</code> 删除镜像<br>查看 <code>镜像摘要</code>  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker image <span class="built_in">ls</span> --digests</span></span><br><span class="line">REPOSITORY          TAG                 DIGEST                      IMAGE ID            CREATED             SIZE</span><br><span class="line">centos              centos7.9.2009      sha256:c73f515d06b0fa0...   eeb6ee3f44bd        10 months ago       204MB</span><br></pre></td></tr></table></figure>


<p>使用 <code>镜像摘要</code> 删除镜像<br>命令格式 <code>docker image rm REPOSITORY@DIGEST</code>  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker image <span class="built_in">rm</span> centos@sha256:c73f515d06b0fa0...</span></span><br><span class="line">Untagged: centos@sha256:c73f515d06b0fa07bb18d8202035e739a494ce760aa73129f60f4bf2bd22b407</span><br></pre></td></tr></table></figure>


<p>删除行为分为两类，一类是 <code>Untagged</code>，另一类是 <code>Deleted</code>。<br>因为一个镜像可以对应多个标签，当我们使用上面命令删除镜像的时候，实际上是在要求删除某个标签的镜像。<br>所以首先需要做的是将满足我们要求的所有镜像标签都取消，这就是我们看到的 <code>Untagged</code> 的信息 ,因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么 <code>Delete</code> 行为就不会发生。<br>所以并非所有的 <code>docker image rm</code> 都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。<br>当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。  </p>
<h3 id="doker-容器管理命令"><a href="#doker-容器管理命令" class="headerlink" title="doker 容器管理命令"></a>doker 容器管理命令</h3><h4 id="启动已终止的容器"><a href="#启动已终止的容器" class="headerlink" title="启动已终止的容器"></a>启动已终止的容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker container start CONTAINER</span><br><span class="line">docker container restart CONTAINER</span><br><span class="line">docker start CONTAINER</span><br></pre></td></tr></table></figure>

<h4 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker attach CONTAINER</span><br><span class="line">docker exec -it CONTAINER bash</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>docker attach</code> 进入容器，如果再从这个 <code>stdin</code> 中 <code>exit</code>，会导致容器的停止<br><code>docker exec</code> 进入容器，如果再从这个 <code>stdin</code> 中 <code>exit</code>，不会导致容器的停止，推荐进入容器使用 <code>docker exec -it CONTAINER bash</code>  </p>
</blockquote>
<h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker container rm CONTAINER</span><br></pre></td></tr></table></figure>

<p><code>docker container rm</code> 可以删除已终止的容器，要强制删除运行中的容器，可以使用选项 <code>-f</code>，Docker 会发送 SIGKILL 信号给容器。  </p>
<p>用 <code>docker container ls -a</code> 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker container prune</span><br></pre></td></tr></table></figure>

<h3 id="docker-数据管理命令"><a href="#docker-数据管理命令" class="headerlink" title="docker 数据管理命令"></a>docker 数据管理命令</h3><h4 id="容器数据卷管理命令"><a href="#容器数据卷管理命令" class="headerlink" title="容器数据卷管理命令"></a>容器数据卷管理命令</h4><p><code>数据卷</code> 的使用，类似于 Linux 下对目录或文件进行 <code>mount</code> ，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。</p>
<p>创建数据卷</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker volume create DOCKERVOLUME</span><br></pre></td></tr></table></figure>

<p>查看数据卷信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker volume <span class="built_in">ls</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker volume inspect DOCKERVOLUME</span></span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;CreatedAt&quot;: &quot;2022-08-10T15:03:13+08:00&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/DOCKERVOLUME/_data&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;DOCKERVOLUME&quot;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>删除不在使用的数据卷</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker volume rm DOCKERVOLUME</span><br></pre></td></tr></table></figure>

<p>挂载使用数据卷</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -it -v DOCKERVOLUME:/data/ --name centos7 centos:centos7</span><br><span class="line">docker run -d -it --mount source=DOCKERVOLUME,target=/data, --name centos7 centos:centos7</span><br></pre></td></tr></table></figure>

<h4 id="挂载宿主机目录-文件"><a href="#挂载宿主机目录-文件" class="headerlink" title="挂载宿主机目录(文件)"></a>挂载宿主机目录(文件)</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -it -v /data/:/data/ --name centos7 centos:centos7</span><br><span class="line">docker run -d -it --mount type=bind,source=/data/,target=/data --name centos7 centos:centos7</span><br></pre></td></tr></table></figure>

<p>本地目录的路径必须是绝对路径，以前使用 <code>-v</code> 参数时如果本地目录不存在 <code>Docker</code> 会自动为你创建一个文件夹，现在使用 <code>--mount</code> 参数时如果本地目录不存在，<code>Docker</code> 会报错。  </p>
<p>挂载权限默认为 <code>rw</code> ，可以通过增加 <code>readonly</code> 指定为 只读</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -it -v /data/:/data/:ro --name centos7 centos:centos7</span><br><span class="line">docker run -d -it --mount type=bind,source=/data/,target=/data,readonly --name centos7 centos:centos7</span><br></pre></td></tr></table></figure>

<blockquote>
<p>挂载本地宿主机目录(文件)，使用选项 <code>--mount</code> 时，需要指定 <code>type=bind</code>, 否则 docker 会将源目录当做 <code>数据卷</code> 处理，可能报以下错误：<br><code>docker: Error response from daemon: create /data/: &quot;/data/&quot; includes invalid characters for a local volume name, only &quot;[a-zA-Z0-9][a-zA-Z0-9_.-]&quot; are allowed. If you intended to pass a host directory, use absolute path.</code></p>
</blockquote>
<h3 id="docker-网络管理命令"><a href="#docker-网络管理命令" class="headerlink" title="docker 网络管理命令"></a>docker 网络管理命令</h3><p>使用 <code>docker run</code> 命令的 <code>-P</code> 选项，<code>Docker</code> 会随机映射一个宿主机端口到内部容器开放的网络端口(<code>Dockerfile</code> 中 <code>EXPOSE</code> 的端口)。  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d -P nginx:alpine</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker container <span class="built_in">ls</span> -l</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                   NAMES</span><br><span class="line">fae320d08268        nginx:alpine        &quot;/docker-entrypoint.…&quot;   24 seconds ago      Up 20 seconds       0.0.0.0:32768-&gt;80/tcp   bold_mcnulty</span><br></pre></td></tr></table></figure>

<p>使用 <code>docker run</code> 命令的 <code>-p</code> 选项，则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有</p>
<ul>
<li><code>hostPort:containerPort</code>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 80:80 nginx:alpine</span><br></pre></td></tr></table></figure>
这样会绑定到宿主机所有接口上的所有 ip 地址</li>
<li><code>ip:hostPort:containerPort</code>    <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 127.0.0.1:80:80 nginx:alpine</span><br></pre></td></tr></table></figure>
此种格式可以指定映射宿主机的一个特定地址（IP），比如 <code>localhost</code> 地址 <code>127.0.0.1</code></li>
<li><code>ip::containerPort</code>    <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 127.0.0.1::80 nginx:alpine</span><br></pre></td></tr></table></figure>
使用 <code>ip::containerPort</code> 会绑定宿主机指定 ip 的任意端口到容器的指定端口，本地宿主机会自动分配一个随机端口。</li>
</ul>
<p><code>-p</code> 选项可以多次使用来绑定多个端口  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">    -p 80:80 \</span><br><span class="line">    -p 443:443 \</span><br><span class="line">    nginx:alpine</span><br></pre></td></tr></table></figure>

<p>还可以使用 <code>udp</code> 标记来指定 <code>udp</code> 端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 127.0.0.1:80:80/udp nginx:alpine</span><br></pre></td></tr></table></figure>

<p>查看容器映射的端口信息可以使用以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker port c8a91c8fafba</span></span><br><span class="line">80/tcp -&gt; 0.0.0.0:81</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker port c8a91c8fafba 80</span></span><br><span class="line">0.0.0.0:81</span><br></pre></td></tr></table></figure>


<h3 id="docker-资源状态命令"><a href="#docker-资源状态命令" class="headerlink" title="docker 资源状态命令"></a>docker 资源状态命令</h3><h4 id="查看-docker-各项功能占用的系统磁盘大小"><a href="#查看-docker-各项功能占用的系统磁盘大小" class="headerlink" title="查看 docker 各项功能占用的系统磁盘大小"></a>查看 docker 各项功能占用的系统磁盘大小</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker system <span class="built_in">df</span></span></span><br><span class="line">TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE</span><br><span class="line">Images              1                   0                   203.9MB             203.9MB (100%)</span><br><span class="line">Containers          0                   0                   0B                  0B</span><br><span class="line">Local Volumes       0                   0                   0B                  0B</span><br><span class="line">Build Cache         0                   0                   0B                  0B</span><br></pre></td></tr></table></figure>

<p>结果中包含了 <code>镜像</code>、<code>容器</code>、<code>数据卷</code> 所占用的空间</p>
<h4 id="清除-docker-中所有未使用的资源"><a href="#清除-docker-中所有未使用的资源" class="headerlink" title="清除 docker 中所有未使用的资源"></a>清除 docker 中所有未使用的资源</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker system prune</span></span><br><span class="line">WARNING! This will remove:</span><br><span class="line">  - all stopped containers</span><br><span class="line">  - all networks not used by at least one container</span><br><span class="line">  - all dangling images</span><br><span class="line">  - all dangling build cache</span><br><span class="line"></span><br><span class="line">Are you sure you want to continue? [y/N] y</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://docs.docker.com/engine/install/centos/">docker官方 centos 安装文档</a>  </p>
<p><a href="https://download.docker.com/linux/centos/">docker 官方 centos 版本下载地址</a></p>
<p><a href="https://mirrors.aliyun.com/docker-ce/linux/centos/7/x86_64/stable/Packages/">docker centos版本 阿里云下载地址</a>  </p>
<p><a href="https://yeasy.gitbook.io/docker_practice/introduction/what">什么是 Docker</a>  </p>
<p><a href="https://yeasy.gitbook.io/docker_practice/introduction/why">为什么要用 Docker</a></p>
<p><a href="https://yeasy.gitbook.io/docker_practice/">docker 从入门到实践</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 docker 运行 jenkins 的安装配置及使用</title>
    <url>/202210121455/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="版本信息"><a href="#版本信息" class="headerlink" title="版本信息"></a>版本信息</h2><ul>
<li>Centos-7 3.10.0-1160</li>
<li>Docker Engine 19.03.15</li>
<li>jenkinsci&#x2F;blueocean Jenkins 2.346.3</li>
</ul>
<h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><p><a href="https://hub.docker.com/">官方镜像仓库</a> 中搜索 <code>jenkinsci/blueocean</code>，下载最新镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull jenkinsci/blueocean</span><br></pre></td></tr></table></figure>


<h3 id="启动-jenkins-容器"><a href="#启动-jenkins-容器" class="headerlink" title="启动 jenkins 容器"></a>启动 jenkins 容器</h3><p>创建数据目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /data/JenkinsData_blueocean</span><br><span class="line">chmod 777 /data/JenkinsData_blueocean</span><br></pre></td></tr></table></figure>
<p>启动 jenkins 容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8080:8080 --name jenkins \</span><br><span class="line">          -v /var/run/docker.sock:/var/run/docker.sock  \</span><br><span class="line">          -v /data/JenkinsData_blueocean/:/var/jenkins_home/ \</span><br><span class="line">          -u root \</span><br><span class="line">          jenkinsci/blueocean</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-v /var/run/docker.sock:/var/run/docker.sock</code> - 在需要使用 Jenkins 构建 Docker 镜像时，Jenkins 容器中的 docker 客户端需要连接到宿主机的 Docker server</li>
<li><code>-v /data/JenkinsData_blueocean/:/var/jenkins_home/</code> - 数据持久化到宿主机目录</li>
<li><code>-u root</code> - 容器中使用 <code>root</code> 用户运行，要使用 Jenkins 构建 Docker 镜像时，默认的 <code>jenkins</code> 用户无权限访问 <code>/var/run/docker.sock</code></li>
</ul>
<span id="more"></span>
<h3 id="防火墙开放端口"><a href="#防火墙开放端口" class="headerlink" title="防火墙开放端口"></a>防火墙开放端口</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -I INPUT 7 -p tcp -m multiport --dports 8080 -j ACCEPT -m comment --comment &quot;Jenkins&quot;</span><br></pre></td></tr></table></figure>

<h3 id="查看初始密码"><a href="#查看初始密码" class="headerlink" title="查看初始密码"></a>查看初始密码</h3><p>初始密码会打印在日志里面</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker logs jenkins</span></span><br><span class="line">...</span><br><span class="line">*************************************************************</span><br><span class="line">*************************************************************</span><br><span class="line">*************************************************************</span><br><span class="line"></span><br><span class="line">Jenkins initial setup is required. An admin user has been created and a password generated.</span><br><span class="line">Please use the following password to proceed to installation:</span><br><span class="line"></span><br><span class="line">acafa239f38043e6a54a0fde448</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用日志中显示的密码登陆 web。</p>
<h2 id="Jenkins-pipeline-script-语法"><a href="#Jenkins-pipeline-script-语法" class="headerlink" title="Jenkins pipeline script 语法"></a>Jenkins pipeline script 语法</h2><p><code>Jenkins pipeline script</code> 基本格式如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&#x27;Build&#x27;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh &#x27;echo &quot;Hello World&quot;&#x27;</span><br><span class="line">                sh &#x27;&#x27;&#x27;</span><br><span class="line">                    echo &quot;Multiline shell steps works too&quot;</span><br><span class="line">                    ls -lah</span><br><span class="line">                &#x27;&#x27;&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage() &#123;</span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    post &#123;</span><br><span class="line">        always &#123;</span><br><span class="line">            echo &#x27;This will always run&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        success &#123;</span><br><span class="line">            echo &#x27;This will run only if successful&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        failure &#123;</span><br><span class="line">            echo &#x27;This will run only if failed&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        unstable &#123;</span><br><span class="line">            echo &#x27;This will run only if the run was marked as unstable&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        changed &#123;</span><br><span class="line">            echo &#x27;This will run only if the state of the Pipeline has changed&#x27;</span><br><span class="line">            echo &#x27;For example, if the Pipeline was previously failing but is now successful&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="agent-命令"><a href="#agent-命令" class="headerlink" title="agent 命令"></a>agent 命令</h3><p><code>agent</code> 指令告诉 Jenkins 在哪里以及如何执行 <code>Pipeline</code> 或者<code> Pipeline</code> 子集。 所有的 <code>Pipeline</code> 都需要 <code>agent</code> 指令。 <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[定义执行环境](https://www.jenkins.io/zh/doc/pipeline/tour/agents/#%E5%AE%9A%E4%B9%89%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83)">[2]</span></a></sup></p>
<p>下面的 <code>pipeline</code> 使用 <code>docker</code> 做为执行环境，并指定 <code>docker</code> 镜像，当执行 Pipelin e时，Jenkins 将会自动运行指定的容器，并执行 Pipeline 中已经定义好的步骤 <code>steps</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent &#123;</span><br><span class="line">        docker &#123; image &#x27;node:7-alpine&#x27; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&#x27;Test&#x27;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh &#x27;node --version&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>agent any</code> 指令指示 Jenkins 为整个流水线分配一个执行器 (在 Jenkins 环境中的任何可用代理&#x2F;节点上)和工作区</p>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>环境变量（<code>environment</code>）可以设置为全局的，也可以是阶段（<code>stage</code>）级别的，阶段（<code>stage</code>）级别的环境变量只能在定义变量的阶段（<code>stage</code>）使用 <sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[使用环境变量](https://www.jenkins.io/zh/doc/pipeline/tour/environment/#%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F)">[3]</span></a></sup></p>
<p>Jenkins 流水线通过全局变量 <code>env</code> 提供全局环境变量，它在 <code>Jenkinsfile</code> 文件的任何地方都可以使用。Jenkins 流水线中可访问的完整的环境变量列表记录在 <code>$&#123;YOUR_JENKINS_URL&#125;/pipeline-syntax/globals#env</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Jenkinsfile (Declarative Pipeline)</span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    environment &#123; </span><br><span class="line">        CC = &#x27;clang&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&#x27;Example&#x27;) &#123;</span><br><span class="line">            environment &#123; </span><br><span class="line">                DEBUG_FLAGS = &#x27;-g&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh &#x27;printenv&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你使用 <code>Build with Parameters</code> 选项将流水线配置为接受参数，这些参数将作为 <code>params</code> 变量的成员被访问。 <sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[处理参数](https://www.jenkins.io/zh/doc/book/pipeline/jenkinsfile/#%E5%A4%84%E7%90%86%E5%8F%82%E6%95%B0)">[5]</span></a></sup></p>
<p>假设在 Jenkinsfile 中配置了名为 <code>Greeting</code> 的字符串参数，它可以通过 <code>$&#123;params.Greeting&#125;</code> 访问该参数</p>
<p>**引用环境变量时，如果使用引号，需要使用 <code>&quot;</code>（双引号），不能使用 <code>&#39;</code>（单引号） **</p>
<h3 id="post-命令"><a href="#post-命令" class="headerlink" title="post 命令"></a>post 命令</h3><p>因为 <code>post</code> 部分保证在 <code>Pipeline</code> 结束的时候运行， 所以我们可以添加通知或者其他的步骤去完成清理、通知或者其他的 <code>Pipeline</code> 结束任务。 <sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[清理和通知](https://www.jenkins.io/zh/doc/pipeline/tour/post/#%E6%B8%85%E7%90%86%E5%92%8C%E9%80%9A%E7%9F%A5)">[4]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&#x27;No-op&#x27;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh &#x27;ls&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    post &#123;</span><br><span class="line">        always &#123;</span><br><span class="line">            echo &#x27;One way or another, I have finished&#x27;</span><br><span class="line">            deleteDir() /* clean up our workspace */</span><br><span class="line">        &#125;</span><br><span class="line">        success &#123;</span><br><span class="line">            echo &#x27;I succeeeded!&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        unstable &#123;</span><br><span class="line">            echo &#x27;I am unstable :/&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        failure &#123;</span><br><span class="line">            echo &#x27;I failed :(&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        changed &#123;</span><br><span class="line">            echo &#x27;Things were different before...&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h2><h3 id="凭证使用方法"><a href="#凭证使用方法" class="headerlink" title="凭证使用方法"></a>凭证使用方法</h3><h4 id="Usernames-and-passwords"><a href="#Usernames-and-passwords" class="headerlink" title="Usernames and passwords"></a>Usernames and passwords</h4><p>在 <code>Manage Jenkins</code> -&gt; <code>Manage Credentials</code> 中添加 <code>kind</code> 为 <code>Username with password</code> 的凭据。</p>
<p>在 Pipeline 中配置环境变量，使用方法 <code>credentials()</code> 调用已配置的凭据，需要的参数为 credentials 的 ID 信息<br><img src="https://i.csms.tech/img_70.png"></p>
<figure class="highlight shell"><figcaption><span>Jenkinsfile</span></figcaption><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">	</span><br><span class="line">	environment &#123;</span><br><span class="line">		harbor_credentials = credentials(&#x27;harbor.my.com&#x27;)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	stages &#123;</span><br><span class="line">        </span><br><span class="line">		stage(&#x27;login harbor&#x27;) &#123;</span><br><span class="line">		    steps &#123;</span><br><span class="line">				</span><br><span class="line">				sh &#x27;docker login -u $&#123;harbor_credentials_USR&#125; -p $&#123;harbor_credentials_PSW&#125; $&#123;DOCKER_REGISTRY&#125;&#x27;</span><br><span class="line">	</span><br><span class="line">			&#125;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>stages</code> 中可以通过 <code>$&#123;harbor_credentials_USR&#125;</code>，<code>$&#123;harbor_credentials_PSW&#125;</code> 分别调用 <code>username</code> 和 <code>password</code> <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[凭证使用方法](https://www.jenkins.io/doc/book/pipeline/jenkinsfile/#handling-credentials)">[1]</span></a></sup></p>
<h3 id="environment-中变量的值为其他命令的输出"><a href="#environment-中变量的值为其他命令的输出" class="headerlink" title="environment 中变量的值为其他命令的输出"></a>environment 中变量的值为其他命令的输出</h3><p>在 <code>environment</code> 中需要定义变量，变量的值为其他命令的输出，等同于 <code>shell</code> 中的如下定义</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">DATE=`date +%Y%m%d%H%M`</span><br></pre></td></tr></table></figure>
<p>在 Jenkins 的 <code>environment</code> 中需要使用以下方式</p>
<figure class="highlight shell"><figcaption><span>Jenkinsfile</span></figcaption><table><tr><td class="code"><pre><span class="line">environment &#123;</span><br><span class="line">	</span><br><span class="line">	DATE=&quot;$&#123;sh(script: &#x27;date +%Y%m%d%H%M&#x27;, returnStdout:true)&#125;&quot;.trim()</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>.trim()</code> 去除变量最后的换行。</p>
<h3 id="配置文件管理插件-Config-File-Provider"><a href="#配置文件管理插件-Config-File-Provider" class="headerlink" title="配置文件管理插件 Config File Provider"></a>配置文件管理插件 Config File Provider</h3><p>多个配置中如果有公共的配置，可以将其进行统一管理，使用 <code>Config File Provider</code> 插件，安装后管理页面（<code>Manage Jenkins</code>）会多出 <code>Managed files</code> 菜单项，进入后 <code>Add a new Config</code> 可以添加配置，同时指定 <code>id</code> 和 <code>Name</code>。<br><img src="https://i.csms.tech/img_84.png"></p>
<p>示例内容，格式为 <code>yaml</code>，调用用时可以使用 <code>readYaml  file:&quot;$&#123;CONFIG_FILE&#125;&quot;</code> 读取内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">system:</span><br><span class="line">  docker_harbor_url: https://harbor.my.com</span><br><span class="line">  docker_hub_cre_id: habor</span><br><span class="line">project:</span><br><span class="line">  - name: app-0</span><br><span class="line">    git_url: http://gitlab.my.com/app1/app.git</span><br><span class="line">    git_cre_id: git</span><br><span class="line">  - name: app-1</span><br><span class="line">    git_url: http://gitlab.my.com/app2/app.git</span><br><span class="line">    git_cre_id: git</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>调用方式 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">configFileProvider(</span><br><span class="line">        [configFile(fileId: &#x27;config-yaml&#x27;, variable: &#x27;CONFIG_FILE&#x27;)]) &#123;</span><br><span class="line">        jenkins_props = readYaml  file:&quot;$&#123;CONFIG_FILE&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    echo jenkins_props.project[0].name   / 输出内容： app-0 /</span><br><span class="line">    echo jenkins_props.project[1].git_url  / 输出内容： http://gitlab.my.com/app2/app.git /</span><br></pre></td></tr></table></figure>

<ul>
<li><code>fileId</code> - 为创建配置时的 <code>id</code></li>
<li><code>variable</code> - 将配置文件内容临时存储于指定的文件名中</li>
<li><code>targetLocation</code> - 将配置文件拷贝到 <code>$&#123;WORKSPACE&#125;/$&#123;targetLocation&#125;</code></li>
</ul>
<h3 id="脚本式-Pipeline-语法中执行-shell-命令"><a href="#脚本式-Pipeline-语法中执行-shell-命令" class="headerlink" title="脚本式 Pipeline 语法中执行 shell 命令"></a>脚本式 Pipeline 语法中执行 shell 命令</h3><p>在脚本式 Pipeline 语法中，需要执行 shell 命令及获取命令输出时，可以通过 <code>sh</code> 指令执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git_commit = sh(returnStdout: true, script: &quot;git rev-parse HEAD&quot;).trim()</span><br><span class="line">echo git_commit</span><br></pre></td></tr></table></figure>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://hub.docker.com/r/jenkinsci/blueocean">使用Docker安装Jenkins</a></p>
<h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.jenkins.io/doc/book/pipeline/jenkinsfile/#handling-credentials">凭证使用方法</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.jenkins.io/zh/doc/pipeline/tour/agents/#%E5%AE%9A%E4%B9%89%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83">定义执行环境</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.jenkins.io/zh/doc/pipeline/tour/environment/#%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">使用环境变量</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.jenkins.io/zh/doc/pipeline/tour/post/#%E6%B8%85%E7%90%86%E5%92%8C%E9%80%9A%E7%9F%A5">清理和通知</a><a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.jenkins.io/zh/doc/book/pipeline/jenkinsfile/#%E5%A4%84%E7%90%86%E5%8F%82%E6%95%B0">处理参数</a><a href="#fnref:5" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>docker 网络</title>
    <url>/202208301536/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Centos 7.9.2009</li>
<li>docker-ce-19.03.15</li>
</ul>
<h3 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h3><p>为了使容器互联，新版本建议将容器加入自定义的<code> Docker 网络</code> 来连接多个容器，而不是使用 <code>--link</code> 参数。</p>
<p>从 Docker 1.10 版本开始，docker daemon 实现了一个内嵌的 DNS server，使容器可以直接通过容器名称通信。方法很简单，只要在创建容器时使用 <code>--name</code> 为容器命名即可。但是使用 Docker DNS 有个限制：只能在 user-defined 网络中使用。也就是说，默认的 bridge 网络是无法使用 DNS 的，所以我们就需要自定义网络。</p>
<p>先创建一个新的 <code>Docker 网络</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker network create -d bridge my-net</span><br></pre></td></tr></table></figure>
<p><code>-d</code> 参数指定 Docker 网络类型，可选 <code>bridge</code> <code>overlay</code>  </p>
<span id="more"></span>
<p>查看 <code>Docker network</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker network <span class="built_in">ls</span></span></span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">1c751b3a52b9   bridge    bridge    local</span><br><span class="line">f8d9861e5797   host      host      local</span><br><span class="line">2e19366fb323   my-net    bridge    local</span><br><span class="line">4c188c59ff20   none      null      local</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>新建容器并连接到刚刚新建的 <code>Docker network</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -it --name c1 --network my-net centos</span><br><span class="line">docker run -d -it --name c2 --network my-net centos</span><br></pre></td></tr></table></figure>
<p>以上命令运行了 2 个 <code>centos</code> 最新版本的容器，并连接到了刚刚创建的网络： <code>--network my-net </code><br>登录到容器 <code>c1</code>的终端，并 <code>ping</code> 容器 <code>c2</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">exec</span> -it c1 bash</span></span><br><span class="line">[root@e520d1c8e30b /]# ping c2</span><br><span class="line">PING c2 (172.18.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from c2.my-net (172.18.0.3): icmp_seq=1 ttl=64 time=0.115 ms</span><br><span class="line">64 bytes from c2.my-net (172.18.0.3): icmp_seq=2 ttl=64 time=0.071 ms</span><br><span class="line">^C</span><br><span class="line">--- c2 ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 1000ms</span><br><span class="line">rtt min/avg/max/mdev = 0.071/0.093/0.115/0.022 ms</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，容器 <code>c1</code> 可以直接使用容器名 <code>c2</code>，来识别容器 <code>c2</code>，同理，容器 <code>c2</code> 也可以使用同样的方式识别到容器 <code>c1</code>，连接到同一个 <code>Docker network</code> 的容器 <code>c1</code>, <code>c2</code> 可以互相连接<br>使用以下命令，可以查看 <code>Docker network</code> 的详细信息，包括 ip 网段，ip 分配信息等</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker network inspect my-net</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;my-net&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;2e19366fb32312235a3571192d1a19e6ebb7adc3e6e25c1f5e6007e8c3315f08&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2022-08-30T15:44:54.241420767+08:00&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;172.18.0.0/16&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.18.0.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;4b6b1159073d3b70312f2b7e5da8c4a36133a6c00c4746fe2c58d37e81a86b12&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;c2&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;0cbe15ff760040d20cd10a04ffed5f4398e1c3c2b597a86461758606ebdc919d&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:12:00:03&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.18.0.3/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;e520d1c8e30bf97ece44fae53840d13e801648ca02899a17416a75563d3a64f6&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;c1&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;214c7596e2610208402cfa55a225fa67c0dd02d4b585c62b43a9a6c42f360147&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:12:00:02&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.18.0.2/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果容器启动时使用了自定义的 <code>Docker network</code>，并且启动过程中挂载了宿主机的 <code>/etc/resolv.conf</code>，则容器启动后无法再使用容器名和其他容器互联，比如使用以下命令启动容器 <code>c3</code>，<code>c3</code> 无法使用容器名和 <code>c1</code>,<code>c2</code> 互联，但是<code>c1</code>,<code>c2</code> 可以使用容器名 <code>c3</code> 连接到容器 <code>c3</code>  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -ti --network my-net -v /etc/resolv.conf:/etc/resolv.conf --name c3 centos</span><br></pre></td></tr></table></figure>
<p>以上示例中，如果登录 <code>c1</code> 终端后，修改 <code>/etc/resolv.conf</code> 文件，再次使用 <code>c2</code> ，会无法连接 <code>c2</code> 容器  </p>
</blockquote>
<p>如果容器启动时，需要为容器指定域名 ip 映射关系，可以使用选项 <code>--add-host host:ip</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --network my-net --add-host db:172.18.0.3 --name c3 centos</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>容器运行过程中，可以直接修改容器内的 <code>/etc/hosts</code> 文件</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 部署 OpenLDAP + phpLDAPadmin 教程</title>
    <url>/202210131557/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h2><ul>
<li>Centos7 3.10.0-1160.76.1</li>
<li>Docker Engine - Community 19.03.15</li>
</ul>
<h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><h3 id="创建自定义网络"><a href="#创建自定义网络" class="headerlink" title="创建自定义网络"></a>创建自定义网络</h3><p>为了使容器互联，新版本建议将容器加入自定义的 Docker 网络 来连接多个容器，而不是使用 <code>--link</code> 参数。</p>
<p>从 Docker 1.10 版本开始，<code>docker daemon</code> 实现了一个内嵌的 DNS server，使容器可以直接通过容器名称通信。方法很简单，只要在创建容器时使用 <code>--name</code> 为容器命名即可。但是使用 Docker DNS 有个限制：只能在 <code>user-defined</code> 网络中使用。也就是说，默认的 bridge 网络是无法使用 DNS 的，所以我们就需要自定义网络。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker network create -d bridge docker-network-for-openldap</span><br></pre></td></tr></table></figure>
<p>之后为 LDAP 创建的相关容器，都连接到此网络。</p>
<h3 id="启动-openldap-容器"><a href="#启动-openldap-容器" class="headerlink" title="启动 openldap 容器"></a>启动 openldap 容器</h3><p>为 openldap 容器创建本地持久化数据目录，容器启动时将此目录以数据卷的形式挂载使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /data/OpenLDAPData</span><br></pre></td></tr></table></figure>
<p>启动容器，挂载数据卷，使用自定义网络</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 389:389 -p 636:636 \</span><br><span class="line">           -v /data/OpenLDAPData:/usr/local/ldap \</span><br><span class="line">           --name openldap \</span><br><span class="line">           --network docker-network-for-openldap  \</span><br><span class="line">           osixia/openldap:1.3.0</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>ldap 默认配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dn     dc=example,dc=org</span><br><span class="line">admin    cn=admin,dc=example,dc=org</span><br><span class="line">password  admin</span><br></pre></td></tr></table></figure>

<p>进入容器验证</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">exec</span> -it openldap bash</span></span><br><span class="line">root@2f49810360ce:/# ldapsearch -x -H ldap://localhost:389 -b dc=example,dc=org -D &quot;cn=admin,dc=example,dc=org&quot; -w admin</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">extended LDIF</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># LDAPv3</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">base &lt;dc=example,dc=org&gt; with scope subtree</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">filter: (objectclass=*)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">requesting: ALL</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"></span><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">example.org</span></span><br><span class="line">dn: dc=example,dc=org</span><br><span class="line">objectClass: top</span><br><span class="line">objectClass: dcObject</span><br><span class="line">objectClass: organization</span><br><span class="line">o: Example Inc.</span><br><span class="line">dc: example</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">admin, example.org</span></span><br><span class="line">dn: cn=admin,dc=example,dc=org</span><br><span class="line">objectClass: simpleSecurityObject</span><br><span class="line">objectClass: organizationalRole</span><br><span class="line">cn: admin</span><br><span class="line">description: LDAP administrator</span><br><span class="line">userPassword:: e1NTSEF9NENMcFBvNEQrUlhhcFUxdDRVT1FSUm5SdU0zQnNEdnk=</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">search result</span></span><br><span class="line">search: 2</span><br><span class="line">result: 0 Success</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">numResponses: 3</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">numEntries: 2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="启动-phpLDAPadmin"><a href="#启动-phpLDAPadmin" class="headerlink" title="启动 phpLDAPadmin"></a>启动 phpLDAPadmin</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -dit -p 8081:80 --name phpLDAPadmin --network docker-network-for-openldap \</span><br><span class="line">            --env PHPLDAPADMIN_HTTPS=false \</span><br><span class="line">            --env PHPLDAPADMIN_LDAP_HOSTS=openldap \</span><br><span class="line">            --restart always \</span><br><span class="line">            osixia/phpldapadmin</span><br></pre></td></tr></table></figure>

<p>浏览器访问相应链接，可登录到 WEB 页面。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://m.studyofnet.com/news/5359.html">Docker搭建OpenLDAP+phpLDAPadmin统一用户认证的方法</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>OpenLDAP</tag>
        <tag>phpLDAPadmin</tag>
      </tags>
  </entry>
  <entry>
    <title>docker 运行 mysql</title>
    <url>/202301181604/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Docker 19.03.15</li>
<li>Mysql 5.7</li>
</ul>
<h1 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h1><h2 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull mysql:5.7.31</span><br></pre></td></tr></table></figure>

<h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><p>启动容器前先在本地创建 Mysql 数据目录以用来持久化 Mysql 数据，如果需要配置文件，可以在本地创建好配置文件挂载到容器的 <code>/etc/mysql/my.cnf</code>，无需配置文件的话，则只需要将持久化的本地数据目录挂载到容器默认的数据目录 <code>/var/lib/mysql</code>，本示例中 Mysql 本地持久化数据目录为 <code>/opt/docker_mysql_home/data/</code>。使用以下命令启动容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --name mysql -v /opt/docker_mysql_home/data/:/var/lib/mysql/ -p 3306:3306 \</span><br><span class="line">              -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7.31</span><br></pre></td></tr></table></figure>
<p><code>-e MYSQL_ROOT_PASSWORD=123456</code>  通过环境变量配置 Mysql 初始化后的密码</p>
<p>容器启动后，通过以下命令连接数据库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -h 127.0.0.1 -uroot -p</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>linux fail2ban 详解</title>
    <url>/202208171501/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Centos 7</li>
<li>iptables</li>
</ul>
<p><a href="https://www.fail2ban.org/wiki/index.php/Main_Page">Fail2ban</a> 是 Linux 上的一个著名的入侵保护的开源框架。它通过监视相应服务的日志记录文件，匹配日志记录中的错误信息（正则式匹配），然后与系统的 <code>iptables</code> 联动执行相应的屏蔽动作（一般情况下是调用防火墙屏蔽），比如：当有人在试探你的 <code>HTTP</code>、<code>SSH</code>、<code>SMTP</code>、<code>FTP</code> 密码，只要达到你预设的次数，<code>Fail2ban</code> 就会调用防火墙屏蔽这个 IP，并且可以发送 e-mail 通知系统管理员。</p>
<p>由于 <code>Fail2ban</code> 需要与系统的 <code>iptables</code>、<code>firewalld</code> 等联动来达到封禁 IP 的目的， <code>iptables</code> 使用与 <code>firewalld</code> 有少许不同。  </p>
<p>本文以 <code>iptables</code> 为例</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install epel-release</span><br><span class="line">yum install -y fail2ban</span><br><span class="line">systemctl enable fail2ban</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 Fail2ban 的状态</span></span><br><span class="line">fail2ban-client status   </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 Fai2ban 的版本</span></span><br><span class="line">fail2ban-client version   </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查 Fail2ban 是否正常运行（正常将显示 pong）</span></span><br><span class="line">fail2ban-client ping     </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动 Fail2ban</span></span><br><span class="line">systemctl start fail2ban   </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止 Fail2ban</span>  </span><br><span class="line">systemctl stop fail2ban  </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启 Fail2ban</span>  </span><br><span class="line">systemctl restart fail2ban</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打开 Fail2ban 的日志监控</span>     </span><br><span class="line">tail -f /var/log/fail2ban.log  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="主要文件说明"><a href="#主要文件说明" class="headerlink" title="主要文件说明"></a>主要文件说明</h3><table>
<thead>
<tr>
<th>文件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;etc&#x2F;fail2ban&#x2F;jail.d&#x2F;</td>
<td>配置文件夹。用于定义错误次数、封禁时长、封禁动作等</td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;fail2ban&#x2F;filter.d&#x2F;</td>
<td>条件文件夹。内含默认文件，用于定义日志文件内容的过滤规则</td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;fail2ban&#x2F;action.d</td>
<td>动作文件夹。内含默认文件，用于 iptables 以及 mail 等动作配置</td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;fail2ban&#x2F;fail2ban.conf<br/>&#x2F;etc&#x2F;fail2ban&#x2F;jail.conf</td>
<td><code>*.conf</code> 是主要（默认）配置文件，<strong>不要直接更改 <code>.conf</code> 文件</strong> ，升级后会被覆盖<br/>应该手动创建 <code>fail2ban.local</code> ,<code>jail.local</code>(或者分离 <code>.conf</code> 文件到 <code>jail.d/</code> 目录)</td>
</tr>
</tbody></table>
<h3 id="fail2ban-配置文件说明"><a href="#fail2ban-配置文件说明" class="headerlink" title="fail2ban 配置文件说明"></a>fail2ban 配置文件说明</h3><p><code>/etc/fail2ban/fail2ban.conf</code> 是主配置文件，定义了 <code>fai2ban</code> 默认的日志级别、日志位置及 sock 文件位置。<strong>不要更改此文件</strong>，要更改默认配置，可以复制 <code>fail2ban.conf</code> 成 <code>/etc/fail2ban/fail2ban.local</code> ，更改此 <code>local</code> 文件</p>
<figure class="highlight shell"><figcaption><span>/etc/fail2ban/fail2ban.local</span></figcaption><table><tr><td class="code"><pre><span class="line">[DEFAULT]</span><br><span class="line"></span><br><span class="line">loglevel = INFO</span><br><span class="line"></span><br><span class="line">logtarget = /var/log/fail2ban.log</span><br><span class="line"></span><br><span class="line">syslogsocket = auto</span><br><span class="line"></span><br><span class="line">socket = /var/run/fail2ban/fail2ban.sock</span><br><span class="line"></span><br><span class="line">pidfile = /var/run/fail2ban/fail2ban.pid</span><br><span class="line"></span><br><span class="line">dbfile = /var/lib/fail2ban/fail2ban.sqlite3</span><br><span class="line"></span><br><span class="line">dbpurgeage = 1d</span><br><span class="line"></span><br><span class="line">dbmaxmatches = 10</span><br><span class="line"></span><br><span class="line">[Definition]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Thread]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="jail-配置文件说明"><a href="#jail-配置文件说明" class="headerlink" title="jail 配置文件说明"></a>jail 配置文件说明</h3><p><code>/etc/fail2ban/jail.conf</code> 主要设置启用 <code>ban</code> 动作的服务及动作阀值。<strong>不要更改此文件</strong>，要更改此处的默认配置，可以复制 <code>jail.conf</code> 到 <code>/etc/fail2ban/jail.local</code>，更改此文件中的默认配置</p>
<figure class="highlight shell"><figcaption><span>/etc/fail2ban/jail.local</span></figcaption><table><tr><td class="code"><pre><span class="line">[DEFAULT]</span><br><span class="line">ignorecommand =</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">屏蔽时间，默认单位：秒</span></span><br><span class="line">bantime  = 10m</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这个时间段内超过 maxretry 定义的次数会被 ban 掉</span></span><br><span class="line">findtime  = 10m</span><br><span class="line">maxretry = 5</span><br><span class="line"></span><br><span class="line">maxmatches = %(maxretry)s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">日志修改检测机制(gamin、polling和auto这三种)</span></span><br><span class="line">backend = auto</span><br><span class="line"></span><br><span class="line">usedns = warn</span><br><span class="line">logencoding = auto</span><br><span class="line">enabled = false</span><br><span class="line">mode = normal</span><br><span class="line">filter = %(__name__)s[mode=%(mode)s]</span><br><span class="line">destemail = root@localhost</span><br><span class="line">sender = root@&lt;fq-hostname&gt;</span><br><span class="line">mta = sendmail</span><br><span class="line">protocol = tcp</span><br><span class="line">chain = &lt;known/chain&gt;</span><br><span class="line">port = 0:65535</span><br><span class="line">fail2ban_agent = Fail2Ban/%(fail2ban_version)s</span><br><span class="line">banaction = iptables-multiport</span><br><span class="line">banaction_allports = iptables-allports</span><br><span class="line">action_ = %(banaction)s[port=&quot;%(port)s&quot;, protocol=&quot;%(protocol)s&quot;, chain=&quot;%(chain)s&quot;]</span><br><span class="line">action_mw = %(action_)s</span><br><span class="line">            %(mta)s-whois[sender=&quot;%(sender)s&quot;, dest=&quot;%(destemail)s&quot;, protocol=&quot;%(protocol)s&quot;, chain=&quot;%(chain)s&quot;]</span><br><span class="line">action_mwl = %(action_)s</span><br><span class="line">             %(mta)s-whois-lines[sender=&quot;%(sender)s&quot;, dest=&quot;%(destemail)s&quot;, logpath=&quot;%(logpath)s&quot;, chain=&quot;%(chain)s&quot;]</span><br><span class="line">action_xarf = %(action_)s</span><br><span class="line">             xarf-login-attack[service=%(__name__)s, sender=&quot;%(sender)s&quot;, logpath=&quot;%(logpath)s&quot;, port=&quot;%(port)s&quot;]</span><br><span class="line">action_cf_mwl = cloudflare[cfuser=&quot;%(cfemail)s&quot;, cftoken=&quot;%(cfapikey)s&quot;]</span><br><span class="line">                %(mta)s-whois-lines[sender=&quot;%(sender)s&quot;, dest=&quot;%(destemail)s&quot;, logpath=&quot;%(logpath)s&quot;, chain=&quot;%(chain)s&quot;]</span><br><span class="line">action_blocklist_de  = blocklist_de[email=&quot;%(sender)s&quot;, service=&quot;%(__name__)s&quot;, apikey=&quot;%(blocklist_de_apikey)s&quot;, agent=&quot;%(fail2ban_agent)s&quot;]</span><br><span class="line">action_badips = badips.py[category=&quot;%(__name__)s&quot;, banaction=&quot;%(banaction)s&quot;, agent=&quot;%(fail2ban_agent)s&quot;]</span><br><span class="line">action_badips_report = badips[category=&quot;%(__name__)s&quot;, agent=&quot;%(fail2ban_agent)s&quot;]</span><br><span class="line">action_abuseipdb = abuseipdb</span><br><span class="line">action = %(action_)s</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中 <code>[DEFAULT]</code> 块定义了默认的配置，具体的服务配置中 (如 <code>/etc/fail2ban/jail.d/ssh.local</code>)，可以覆盖默认值。 </p>
<p>针对具体服务配置防护，以 <code>sshd</code> 为例，手动创建配置 <code>/etc/fail2ban/jail.d/sshd.local</code></p>
<figure class="highlight shell"><figcaption><span>/etc/fail2ban/jail.d/sshd.local</span></figcaption><table><tr><td class="code"><pre><span class="line">[sshd]</span><br><span class="line">enabled = true</span><br><span class="line">port = 22</span><br><span class="line">filter = sshd</span><br><span class="line">action = iptables[name=SSH, port=ssh, protocol=tcp]</span><br><span class="line">logpath = /var/log/secure</span><br><span class="line">maxretry = 3</span><br><span class="line">bantime = 43200</span><br><span class="line">findtime = 3600</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>[sshd]</code> : 名称，可以随便填写</li>
<li><code>enabled =true</code> ： 启用此配置</li>
<li><code>port = 22</code> : 服务端口</li>
<li><code>filter = sshd</code> : 应用的 <code>filter</code> 名称，对应的 <a href="#filter-%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E"><code>filter</code> 配置</a> 位于 <code>/etc/fail2ban/filter.d/sshd.conf</code></li>
<li><code>action = iptables[name=SSH, port=ssh, protocol=tcp]</code> : 执行的动作，对应 <code>/etc/fail2ban/action.d/iptables.conf</code> ，并传入 <code>name=SSH, port=ssh, protocol=tcp</code>，此处传入的端口 <code>ssh</code> 默认为 22 ，如果端口不为 22 ，需要更改为对应端口，传入的 <code>name</code> 会在定义防火墙链时被当做链名的一部分</li>
<li><code>logpath = /var/log/secure</code> : 要过滤的日志记录文件路径</li>
<li><code>maxretry = 3</code> ： 执行封禁动作前允许的错误记录数</li>
<li><code>bantime = 43200</code> ： 执行封禁的时长（秒）</li>
<li><code>findtime = 3600</code> ：此时长（秒）内达到 <code>maxretry</code> 次就执行封禁动作</li>
</ul>
<p>配置好之后，重启 <code>fail2ban</code> 使配置生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart fail2ban</span><br></pre></td></tr></table></figure>
<p>或者执行以下命令，在不重启 <code>fail2ban</code> 的情况下重新分析并加载配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fail2ban-client reload</span><br></pre></td></tr></table></figure>

<p>执行以下命令查看 <code>fail2ban</code> 的状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">fail2ban-client status</span></span><br><span class="line">Status</span><br><span class="line">|- Number of jail:	1</span><br><span class="line">`- Jail list:	sshd</span><br></pre></td></tr></table></figure>
<p>可以看到当前只启动了 <code>sshd</code> 这一个 <code>jail</code></p>
<p>执行以下命令查看 <code>sshd</code> 的防护情况，可以看到目前有哪些 ip 被封锁，以及过去总共多少 ip 被封锁</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">fail2ban-client status sshd</span></span><br><span class="line">Status for the jail: sshd</span><br><span class="line">|- Filter</span><br><span class="line">|  |- Currently failed:	0</span><br><span class="line">|  |- Total failed:	0</span><br><span class="line">|  `- Journal matches:	_SYSTEMD_UNIT=sshd.service + _COMM=sshd</span><br><span class="line">`- Actions</span><br><span class="line">   |- Currently banned:	1</span><br><span class="line">   |- Total banned:	1</span><br><span class="line">   `- Banned IP list:	54.193.188.141</span><br></pre></td></tr></table></figure>

<h3 id="filter-配置说明"><a href="#filter-配置说明" class="headerlink" title="filter 配置说明"></a>filter 配置说明</h3><p><code>fail2ban</code> 使用的各个 <code>filter</code> 位于 <code>/etc/fail2ban/filter.d/</code> 下。其中主要配置了日志的过滤规则  </p>
<p>以创建防护 <code>VNC</code> 的 <code>filter</code> 来说明。<code>VNC</code> 的日志中，如果有恶意登录，经常会出现以下日志记录：</p>
<figure class="highlight shell"><figcaption><span>/home/USER1/.vnc/USER1\:1.log</span></figcaption><table><tr><td class="code"><pre><span class="line">Sat Aug 20 10:35:27 2022</span><br><span class="line"> Connections: blacklisted: 185.170.144.226</span><br><span class="line"> Connections: blacklisted: 185.170.144.226</span><br><span class="line"></span><br><span class="line">Sat Aug 20 10:35:28 2022</span><br><span class="line"> Connections: blacklisted: 185.170.144.226</span><br><span class="line"> Connections: blacklisted: 185.170.144.226</span><br><span class="line"></span><br><span class="line">Sat Aug 20 10:35:29 2022</span><br><span class="line"> Connections: blacklisted: 185.170.144.226</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>filter</code> 的匹配规则里面，<strong>行的开头一定要先匹配到时间</strong>，时间格式可以试试系统可以识别的格式，如果开头不能匹配到时间，规则会匹配失败，因此，如果日志开头不是时间格式，需要修改日志格式，本例中，处理 <code>vnc</code> 日志时，会先在行首添加时间    </p>
</blockquote>
<p>可以根据此日志记录，创建针对 <code>VNC</code> 服务的日志过滤规则，手动创建文件 <code>/etc/fail2ban/filter.d/vnc.local</code></p>
<figure class="highlight shell"><figcaption><span>/etc/fail2ban/filter.d/vnc.local</span></figcaption><table><tr><td class="code"><pre><span class="line">[Definition]</span><br><span class="line">failregex = .*Connections: blacklisted: &lt;HOST&gt;</span><br><span class="line">ignoreregex =</span><br></pre></td></tr></table></figure>

<p>创建好配置文件，使配置生效前，一定要对 <code>filter</code> 配置文件的有效性进行测试，<code>fail2ban</code> 提供了命令 <code>fail2ban-regex</code> 用来测试 <code>filter</code> 的正则表达式，使用方法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">fail2ban-regex /home/USER1/.vnc/USER1\:1.<span class="built_in">log</span> vnc</span></span><br><span class="line"></span><br><span class="line">Running tests</span><br><span class="line">=============</span><br><span class="line"></span><br><span class="line">Use   failregex filter file : vnc, basedir: /etc/fail2ban</span><br><span class="line">Use         log file : /home/USER1/.vnc/USER1\:1.log</span><br><span class="line">Use         encoding : UTF-8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Results</span><br><span class="line">=======</span><br><span class="line"></span><br><span class="line">Failregex: 171210 total</span><br><span class="line">|-  #) [# of hits] regular expression</span><br><span class="line">|   1) [171210] .*Connections: blacklisted: &lt;HOST&gt;</span><br><span class="line">`-</span><br><span class="line"></span><br><span class="line">Ignoreregex: 0 total</span><br><span class="line"></span><br><span class="line">Date template hits:</span><br><span class="line">|- [# of hits] date format</span><br><span class="line">|  [377319] &#123;^LN-BEG&#125;(?:DAY )?MON Day %k:Minute:Second(?:\.Microseconds)?(?: ExYear)?</span><br><span class="line">`-</span><br><span class="line"></span><br><span class="line">Lines: 377319 lines, 0 ignored, 171210 matched, 206109 missed</span><br><span class="line">[processed in 23.67 sec]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以上命令使用规则 <code>vnc</code>，匹配日志文件 <code>/home/USER1/.vnc/USER1\:1.log</code>，结果中显示：<code>Lines: 377319 lines, 0 ignored, 171210 matched, 206109 missed</code>，可以说明匹配到了需要的内容  </p>
<p>也可以通过以下命令，验证具体的正则表达式是否能匹配到指定的日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">fail2ban-regex <span class="string">&#x27; Connections: blacklisted: 185.170.144.226&#x27;</span> <span class="string">&#x27;.*Connections: blacklisted: &lt;HOST&gt;&#x27;</span></span></span><br><span class="line"></span><br><span class="line">Running tests</span><br><span class="line">=============</span><br><span class="line"></span><br><span class="line">Use   failregex line : .*Connections: blacklisted: &lt;HOST&gt;</span><br><span class="line">Use      single line :  Connections: blacklisted: 185.170.144.226</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Results</span><br><span class="line">=======</span><br><span class="line"></span><br><span class="line">Failregex: 1 total</span><br><span class="line">|-  #) [# of hits] regular expression</span><br><span class="line">|   1) [1] .*Connections: blacklisted: &lt;HOST&gt;</span><br><span class="line">`-</span><br><span class="line"></span><br><span class="line">Ignoreregex: 0 total</span><br><span class="line"></span><br><span class="line">Date template hits:</span><br><span class="line"></span><br><span class="line">Lines: 1 lines, 0 ignored, 1 matched, 0 missed</span><br><span class="line">[processed in 0.03 sec]</span><br></pre></td></tr></table></figure>
<p>以上结果显示 <code>Lines: 1 lines, 0 ignored, 1 matched, 0 missed</code> , 说明日志被正则表达式匹配到了  </p>
<blockquote>
<p>以上命令中，隐含了日志开始匹配到了时间格式</p>
</blockquote>
<p>创建 <code>ban</code> 配置，手动创建配置文件 <code>/etc/fail2ban/jail.d/vnc.local</code>  </p>
<figure class="highlight shell"><figcaption><span>/etc/fail2ban/jail.d/vnc.local</span></figcaption><table><tr><td class="code"><pre><span class="line">[vnc]</span><br><span class="line">enabled = true</span><br><span class="line">port = 5901</span><br><span class="line">filter = vnc</span><br><span class="line">action = iptables[name=VNC, port=5901, protocol=tcp]</span><br><span class="line">logpath = /home/cosmos/.vnc/cosmos:1.log</span><br><span class="line">maxretry = 3</span><br><span class="line">bantime = 43200</span><br><span class="line">findtime = 3600</span><br></pre></td></tr></table></figure>

<p>配置更改完后，重启 <code>fail2ban</code> 使配置生效  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart fail2ban</span><br></pre></td></tr></table></figure>
<p>重启后，使用以下命令查看 <code>fail2ban</code> 状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">fail2ban-client status</span></span><br><span class="line">Status</span><br><span class="line">|- Number of jail:	2</span><br><span class="line">`- Jail list:	sshd, vnc</span><br></pre></td></tr></table></figure>
<p>如果输出显示 : <code>ERROR   Failed to access socket path: /var/run/fail2ban/fail2ban.sock. Is fail2ban running? </code>，说明 <code>fail2ban</code> 启动失败，可能是配置文件存在问题，比如 <code>fail2ban</code> 服务状态如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl status fail2ban -l</span></span><br><span class="line"> fail2ban.service - Fail2Ban Service</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/fail2ban.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: failed (Result: exit-code) since Sat 2022-08-20 13:33:48 CST; 24s ago</span><br><span class="line">     Docs: man:fail2ban(1)</span><br><span class="line">  Process: 2520 ExecStop=/usr/bin/fail2ban-client stop (code=exited, status=0/SUCCESS)</span><br><span class="line">  Process: 2536 ExecStart=/usr/bin/fail2ban-server -xf start (code=exited, status=255)</span><br><span class="line">  Process: 2533 ExecStartPre=/bin/mkdir -p /run/fail2ban (code=exited, status=0/SUCCESS)</span><br><span class="line"> Main PID: 2536 (code=exited, status=255)</span><br><span class="line"></span><br><span class="line">Aug 20 13:33:47 myserver-cn systemd[1]: Starting Fail2Ban Service...</span><br><span class="line">Aug 20 13:33:47 myserver-cn systemd[1]: Started Fail2Ban Service.</span><br><span class="line">Aug 20 13:33:48 myserver-cn fail2ban-server[2536]: 2022-08-20 13:33:48,058 fail2ban                </span><br><span class="line">    [2536]: ERROR   Failed during configuration: Have not found any log file for vnc jail</span><br><span class="line">Aug 20 13:33:48 myserver-cn fail2ban-server[2536]: 2022-08-20 13:33:48,060 fail2ban               </span><br><span class="line">    [2536]: ERROR   Async configuration of server failed</span><br><span class="line">Aug 20 13:33:48 myserver-cn systemd[1]: fail2ban.service: main process exited, code=exited, status=255/n/a</span><br><span class="line">Aug 20 13:33:48 myserver-cn systemd[1]: Unit fail2ban.service entered failed state.</span><br><span class="line">Aug 20 13:33:48 myserver-cn systemd[1]: fail2ban.service failed.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出中显示 <code>Failed during configuration: Have not found any log file for vnc jail</code>，说明 <code>jail.d/vnc.local</code> 中配置的日志路径或者是权限有问题，需要检查此处配置。  </p>
<blockquote>
<p>此处报错是因为 <code>jail.d/vnc.local</code> 中配置的日志路径如下： </p>
<figure class="highlight shell"><figcaption><span>jail.d/vnc.local</span></figcaption><table><tr><td class="code"><pre><span class="line">logpath = /home/cosmos/.vnc/cosmos\:1.log</span><br></pre></td></tr></table></figure>
<p>配置文件中不需要对 <code>:</code> 进行转义。</p>
</blockquote>
<p>配置无误，重启服务生效后，可以检查 <code>vnc</code> 对应的 <code>ban</code> 的状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">fail2ban-client status vnc</span></span><br><span class="line">Status for the jail: vnc</span><br><span class="line">|- Filter</span><br><span class="line">|  |- Currently failed:	22</span><br><span class="line">|  |- Total failed:	52632</span><br><span class="line">|  `- File list:	/home/cosmos/.vnc/cosmos:1.log.bak</span><br><span class="line">`- Actions</span><br><span class="line">   |- Currently banned:	18</span><br><span class="line">   |- Total banned:	18</span><br><span class="line">   `- Banned IP list:	212.80.219.226 212.80.219.175 175.211.155.52 ...</span><br></pre></td></tr></table></figure>
<p>查看防火墙状态，可以看到被封的 ip ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -L -v -n</span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_42.png"></p>
<p>如果被封禁的 ip 中有被误伤的，需要解禁，使用以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fail2ban-client set vnc  unbanip 45.33.65.249</span><br></pre></td></tr></table></figure>
<p>命令中的 <code>vnc</code> 指 <code>ban</code> 配置文件 <code>/etc/fail2ban/jail.d/vnc.local</code> 中的 <code>[vnc]</code> <a href="#jail-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E">名称</a></p>
<h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p><a href="https://www.fail2ban.org/wiki/index.php/Main_Page">fail2ban 官网</a><br><a href="https://www.fail2ban.org/wiki/index.php/MANUAL_0_8#Filters">fail2ban 配置官网说明</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>fail2ban</tag>
      </tags>
  </entry>
  <entry>
    <title>git 常见错误</title>
    <url>/202209131721/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><h4 id="error-RPC-failed-HTTP-403-curl-22-The-requested-URL-returned-error-403"><a href="#error-RPC-failed-HTTP-403-curl-22-The-requested-URL-returned-error-403" class="headerlink" title="error: RPC failed; HTTP 403 curl 22 The requested URL returned error: 403"></a>error: RPC failed; HTTP 403 curl 22 The requested URL returned error: 403</h4><p><strong>错误场景</strong> ： windows 系统中 <code>git push</code> 报错<br><img src="https://i.csms.tech/img_55.png"></p>
<p><strong>错误原因</strong> ： 大概率为用户密码错误<br><strong>排查步骤</strong> ： </p>
<ol>
<li>清除 windows 凭据管理中的 git 密码，或更改为正确的密码</li>
<li>编辑 <code>.git/config</code> 文件，对 <code>url</code> 按照如下格式配置：<figure class="highlight shell"><figcaption><span>.git/config</span></figcaption><table><tr><td class="code"><pre><span class="line">url = http://USERNAME@git.server.com/test.git</span><br></pre></td></tr></table></figure>
其中 <code>USERNAME</code> 为用户名，重新执行 <code>git push</code>，此时会要求输入用户密码，输入正确的用户密码后，可正常执行</li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>gitlab 安装配置及 git 命令使用</title>
    <url>/8db58ebc/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><a href="https://about.gitlab.com/install/#centos-7">安装步骤</a></p>
<blockquote>
<p>安装完成之后使用 <code>gitlab-ctl reconfigure</code> 启动服务<br>访问页面，默认使用 <code>root</code> 登录<br>每次重新更改配置，都需要使用 <code>reconfigure</code> 重新启动</p>
</blockquote>
<span id="more"></span>

<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p>启动所有 gitlab 组件；  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo gitlab-ctl start </span><br></pre></td></tr></table></figure>
<p>停止所有 gitlab 组件；  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo gitlab-ctl stop </span><br></pre></td></tr></table></figure>
<p>重启所有 gitlab 组件；  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo gitlab-ctl restart  </span><br></pre></td></tr></table></figure>
<p>查看服务状态；  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo gitlab-ctl status    </span><br></pre></td></tr></table></figure>
<p>启动服务；  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo gitlab-ctl reconfigure    </span><br></pre></td></tr></table></figure>
<p>修改默认的配置文件；  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/gitlab/gitlab.rb </span><br></pre></td></tr></table></figure>
<p>检查gitlab；  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gitlab-rake gitlab:check SANITIZE=true --trace  </span><br></pre></td></tr></table></figure>
<p>查看日志；  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo gitlab-ctl tail</span><br></pre></td></tr></table></figure>

<h1 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h1><h2 id="初始化空目录-通过-git-init-命令把这个目录变成-git-可以管理的仓库"><a href="#初始化空目录-通过-git-init-命令把这个目录变成-git-可以管理的仓库" class="headerlink" title="初始化空目录,通过 git init 命令把这个目录变成 git 可以管理的仓库"></a>初始化空目录,通过 <code>git init</code> 命令把这个目录变成 git 可以管理的仓库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<h2 id="已有文件的目录创建为-git-仓库"><a href="#已有文件的目录创建为-git-仓库" class="headerlink" title="已有文件的目录创建为 git 仓库"></a>已有文件的目录创建为 git 仓库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init </span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;XX&quot;</span><br><span class="line">git remote add origin https://a.com/p.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<h2 id="更改-git-仓库地址"><a href="#更改-git-仓库地址" class="headerlink" title="更改 git 仓库地址"></a>更改 git 仓库地址</h2><ol>
<li>方法1   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote set-url origin https://a.com/p.git</span><br></pre></td></tr></table></figure></li>
<li>方法2 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote rm origin</span><br><span class="line">git remote add origin https://a.com/p.git</span><br></pre></td></tr></table></figure></li>
<li>方法3<br> 编辑 <code>.git/config</code> 文件, 修改 <code>[remote “origin”]</code> 下面的url即可 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[core]</span><br><span class="line">        repositoryformatversion = 0</span><br><span class="line">        filemode = true</span><br><span class="line">        bare = false</span><br><span class="line">        logallrefupdates = true</span><br><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">        url = https://a.com/p.git</span><br><span class="line">        fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">[branch &quot;main&quot;]</span><br><span class="line">        remote = origin</span><br><span class="line">        merge = refs/heads/main</span><br><span class="line">[branch &quot;master&quot;]</span><br><span class="line">        remote = origin</span><br><span class="line">        merge = refs/heads/master</span><br><span class="line">[pull]</span><br><span class="line">        rebase = true</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h2><p>查看当前分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch </span><br></pre></td></tr></table></figure>
<p>查看所有分支，结果中 <code>*</code> 表示当前分支  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure>

<h2 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h2><p>切换到指定分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -b origin/master-dev</span><br></pre></td></tr></table></figure>
<p>切换主分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure>

<h2 id="撤销当前工作区中对指定文件的修改"><a href="#撤销当前工作区中对指定文件的修改" class="headerlink" title="撤销当前工作区中对指定文件的修改"></a>撤销当前工作区中对指定文件的修改</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout FILE</span><br><span class="line">git checkout .</span><br></pre></td></tr></table></figure>

<h2 id="查看历史记录"><a href="#查看历史记录" class="headerlink" title="查看历史记录"></a>查看历史记录</h2><p>显示当前分支的 commit 历史</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>
<p>查看 git 命令记录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reflog --date=iso</span><br></pre></td></tr></table></figure>

<p>查看指定 commit 的代码变化记录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git show 048bc53e65dda5</span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_2.png"></p>
<h2 id="git-clone-指定分支"><a href="#git-clone-指定分支" class="headerlink" title="git clone 指定分支"></a>git clone 指定分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone -b $&#123;branch&#125; https://git.com/daemo.git</span><br></pre></td></tr></table></figure>
<h2 id="gitignore-配置"><a href="#gitignore-配置" class="headerlink" title=".gitignore 配置"></a>.gitignore 配置</h2><h3 id="gitignore-语法规范"><a href="#gitignore-语法规范" class="headerlink" title=".gitignore 语法规范"></a>.gitignore 语法规范</h3><ul>
<li>空行或是以 <code>#</code> 开头的行即注释行将被忽略。</li>
<li>可以在前面添加正斜杠 <code>/</code> 来避免递归,下面的例子中可以很明白的看出来与下一条的区别。</li>
<li>可以在后面添加正斜杠 <code>/</code> 来忽略文件夹，例如 <code>build/</code> 即忽略 <code>build文件夹</code>。</li>
<li>可以使用 <code>!</code> 来否定忽略，即比如在前面用了 <code>*.apk</code>，然后使用 <code>!a.apk</code>，则这个 <code>a.apk</code> 不会被忽略。</li>
<li><code>*</code> 用来匹配零个或多个字符，如 <code>*.[oa]</code> 忽略所有以 <code>.o</code> 或 <code>.a</code> 结尾，<code>*~</code> 忽略所有以 <code>~</code> 结尾的文件（这种文件通常被许多编辑器标记为临时文件）；</li>
<li><code>[]</code> 用来匹配括号内的任一字符，如 <code>[abc]</code>，也可以在括号内加连接符，如 <code>[0-9]</code> 匹配0至9的数；</li>
<li><code>?</code> 用来匹配单个字符。</li>
</ul>
<h3 id="gitignore-示例"><a href="#gitignore-示例" class="headerlink" title=".gitignore 示例"></a>.gitignore 示例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">忽略 .a 文件</span></span><br><span class="line">*.a</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">但否定忽略 lib.a, 尽管已经在前面忽略了 .a 文件</span></span><br><span class="line">!lib.a</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">仅在当前目录下忽略 TODO 文件， 但不包括子目录下的 subdir/TODO</span></span><br><span class="line">/TODO</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">忽略 build/ 文件夹下的所有文件</span></span><br><span class="line">build/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">忽略 doc/notes.txt, 不包括 doc/server/arch.txt</span></span><br><span class="line">doc/*.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">忽略所有的 .pdf 文件 在 doc/ directory 下的</span></span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure>



<h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><blockquote>
<p>Git fatal: Unable to find remote helper for ‘https’</p>
</blockquote>
<p><strong>问题原因</strong>: 未安装curl-devel，安装curl-devel后重新编译<br><strong>解决方法</strong>： 安装curl-devel后重新编译</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title>helm 安装及使用</title>
    <url>/202210071543/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h2><ul>
<li>centos7 5.4.212-1.el7</li>
<li>kubernetes Server Version: v1.25.0</li>
<li>Helm 3.10.0</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li><p>下载 <a href="https://github.com/helm/helm/releases">需要的版本</a></p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://get.helm.sh/helm-v3.10.0-linux-amd64.tar.gz</span><br></pre></td></tr></table></figure></li>
<li><p>解压</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -xf helm-v3.10.0-linux-amd64.tar.gz</span><br></pre></td></tr></table></figure></li>
<li><p>在解压目中找到 <code>helm</code> 程序，移动到需要的目录中</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp linux-amd64/helm /usr/local/bin/</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ helm version</span><br><span class="line"> version.BuildInfo&#123;Version:&quot;v3.10.0&quot;, GitCommit:&quot;ce66412a723e4d89555dc67217607c6579ffcb21&quot;, GitTreeState:&quot;clean&quot;, GoVersion:&quot;go1.18.6&quot;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h2><h3 id="查看已安装的-release"><a href="#查看已安装的-release" class="headerlink" title="查看已安装的 release"></a>查看已安装的 release</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">helm ls</span><br><span class="line"></span><br><span class="line">helm ls -A</span><br></pre></td></tr></table></figure>

<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">helm <span class="built_in">ls</span> -A</span></span><br><span class="line">NAME        	NAMESPACE    	REVISION	UPDATED                                	STATUS	CHART                APP VERSION</span><br><span class="line">cert-manager	cert-manager 	1       	2022-11-01 09:57:11.373366484 +0800 CST	failed	cert-manager-v1.7.1  v1.7.1     </span><br><span class="line">rancher     	cattle-system	1       	2022-11-01 10:05:07.370131566 +0800 CST	failed	rancher-2.6.9        v2.6.9     </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">helm uninstall rancher -n cattle-system</span></span><br><span class="line">W1101 10:21:32.764269   11113 warnings.go:70] policy/v1beta1 PodSecurityPolicy is deprecated in v1.21+, unavailable in v1.25+</span><br><span class="line">W1101 10:21:34.043445   11113 warnings.go:70] policy/v1beta1 PodSecurityPolicy is deprecated in v1.21+, unavailable in v1.25+</span><br><span class="line">W1101 10:21:39.809766   11113 warnings.go:70] policy/v1beta1 PodSecurityPolicy is deprecated in v1.21+, unavailable in v1.25+</span><br><span class="line">release &quot;rancher&quot; uninstalled</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>helm</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo Next 添加 canvas-nest 特效</title>
    <url>/b12589273/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>os: linux 3.10.0-1160.62.1.el7.x86_64 CentOS Linux 7 (Core)</li>
<li>hexo: 6.2.0</li>
<li>hexo-cli: 4.3.0</li>
<li>node: 16.16.0</li>
<li>Next 8.12.2</li>
</ul>
<h3 id="安装-canvas-nest"><a href="#安装-canvas-nest" class="headerlink" title="安装 canvas-nest"></a>安装 canvas-nest</h3><p>参考 <a href="https://github.com/hustcc/canvas-nest.js#install">canva-nest 官网</a> 安装</p>
<figure class="highlight shell"><figcaption><span>npm</span></figcaption><table><tr><td class="code"><pre><span class="line">npm install --save canvas-nest.js</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可选操作，主要是为了生成 <code>canvas-nest.js</code> 文件</p>
</blockquote>
<h3 id="配置-Next"><a href="#配置-Next" class="headerlink" title="配置 Next"></a>配置 Next</h3><p>编辑 <code>next配置文件</code>，新增以下配置</p>
<figure class="highlight shell"><figcaption><span>_config.next.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">background settings</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">add canvas-nest effect</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">see detail from https://github.com/hustcc/canvas-nest.js</span></span><br><span class="line">canvas_nest: </span><br><span class="line">  enable: true </span><br><span class="line">  url: https://s.csms.tech/js/canvas-nest.js</span><br><span class="line">  color: 0,0,255</span><br><span class="line">  opacity: 0.7</span><br><span class="line">  zIndex: -2</span><br><span class="line">  count: 99</span><br></pre></td></tr></table></figure>

<h3 id="引入-canvas-nest-js"><a href="#引入-canvas-nest-js" class="headerlink" title="引入 canvas-nest.js"></a>引入 canvas-nest.js</h3><p>编辑文件 <code>themes/next/layout/_layout.njk</code>, 在<code>&lt;/body&gt;</code> 之前新增以下内容</p>
<figure class="highlight shell"><figcaption><span>themes/next/layout/_layout.njk</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;% if theme.canvas_nest.enable %&#125;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot; color=&quot;&#123;&#123; theme.canvas_nest.color &#125;&#125;&quot; opacity=&#x27;&#123;&#123; theme.canvas_nest.opacity &#125;&#125;&#x27; zIndex=&quot;&#123;&#123; theme.canvas_nest.zIndex &#125;&#125;&quot; count=&quot;&#123;&#123; theme.canvas_nest.count &#125;&#125;&quot; src=&quot;&#123;&#123; theme.canvas_nest.url &#125;&#125;&quot;&gt;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>canvas-nest</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>Huawei 云 SDK 使用</title>
    <url>/202301270909/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Python 3.10</li>
<li>huaweicloudsdk 3.1.23</li>
</ul>
<h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><p><a href="https://console.huaweicloud.com/apiexplorer/#/sdkcenter/ECS?lang=Python">华为云 Python SDK 安装方法官网说明</a></p>
<h2 id="获取云服务器-ECS-实例信息"><a href="#获取云服务器-ECS-实例信息" class="headerlink" title="获取云服务器 (ECS) 实例信息"></a>获取云服务器 (ECS) 实例信息</h2><p>通过华为云提供的 Python SDK 获取云服务器实例信息 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[查询云服务器详情列表](https://console.huaweicloud.com/apiexplorer/#/apidebug/ECS/sdk?api=ListServersDetails)">[1]</span></a></sup></p>
<figure class="highlight shell"><figcaption><span>python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from huaweicloudsdkcore.auth.credentials import BasicCredentials</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from huaweicloudsdkecs.v2.region.ecs_region import EcsRegion</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from huaweicloudsdkcore.exceptions import exceptions</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from huaweicloudsdkecs.v2 import *</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; ak = <span class="string">&#x27;QONOKCeljdngdsEGSAM&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; sk = <span class="string">&#x27;uD4ndlLqP5xDGSrgRRRPJGF8hg^HGkGl2&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; credentials = BasicCredentials(ak, sk)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; client = EcsClient.new_builder().with_credentials(credentials).with_region(EcsRegion.value_of(<span class="string">&quot;cn-east-2&quot;</span>)).build()</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; request = ListServersDetailsRequest()</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; response = client.list_servers_details(request)</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>response</code> 返回一个 <code>huaweicloudsdkecs.v2.model.list_servers_details_response.ListServersDetailsResponse</code> 对象，其中包含了服务器数量和服务器详情列表，要转换为 Python 字典对象，可以通过以下方法</p>
<figure class="highlight shell"><figcaption><span>python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import json</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; server_info = json.loads(str(response))</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">type</span>(server_info)</span></span><br><span class="line">&lt;class &#x27;dict&#x27;&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 获取查询出的机器数量</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; server_info[<span class="string">&#x27;count&#x27;</span>]</span></span><br><span class="line">2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 云服务器列表 list[dict]</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; server_info[<span class="string">&#x27;servers&#x27;</span>]</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 获取云服务器的名称及 id</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; server_info[<span class="string">&#x27;servers&#x27;</span>][0][<span class="string">&#x27;name&#x27;</span>]</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; server_info[<span class="string">&#x27;servers&#x27;</span>][0][<span class="string">&#x27;id&#x27;</span>]</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 获取云服务器的配置规格信息</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; server_info[<span class="string">&#x27;servers&#x27;</span>][0][<span class="string">&#x27;flavor&#x27;</span>]</span></span><br><span class="line">&#123;&#x27;id&#x27;: &#x27;c3.xlarge.2&#x27;, &#x27;name&#x27;: &#x27;c3.xlarge.2&#x27;, &#x27;disk&#x27;: &#x27;0&#x27;, &#x27;vcpus&#x27;: &#x27;4&#x27;, &#x27;ram&#x27;: &#x27;8192&#x27;&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 获取云服务器挂载的磁盘id</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; server_info[<span class="string">&#x27;servers&#x27;</span>][0][<span class="string">&#x27;os-extended-volumes:volumes_attached&#x27;</span>]</span></span><br><span class="line">[&#123;&#x27;id&#x27;: &#x27;1fd566f2-82bb-49d3-95d1-7452a5868f80&#x27;, &#x27;delete_on_termination&#x27;: &#x27;false&#x27;, &#x27;device&#x27;: &#x27;/dev/vdb&#x27;&#125;, &#123;&#x27;id&#x27;: &#x27;2deefa5c-e92b-4ec5-9914-10af9919c121&#x27;, &#x27;delete_on_termination&#x27;: &#x27;false&#x27;, &#x27;bootIndex&#x27;: &#x27;0&#x27;, &#x27;device&#x27;: &#x27;/dev/vda&#x27;&#125;]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 获取云服务器 IP 信息</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 首先在 &#x27;metadata&#x27; 中获取云服务器的 VPC id 信息，根据 VPC id 获取对应的 ip 信息</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; server_info[<span class="string">&#x27;servers&#x27;</span>][0][<span class="string">&#x27;metadata&#x27;</span>]</span></span><br><span class="line">&#123;&#x27;lockScene&#x27;: &#x27;&#x27;, &#x27;charging_mode&#x27;: &#x27;1&#x27;, &#x27;vpc_id&#x27;: &#x27;6827d6f5-4614-42a5-9762-15d3d173411c&#x27;, &#x27;metering.product_id&#x27;: &#x27;00301-15033-0--0&#x27;, &#x27;lockSource&#x27;: &#x27;&#x27;, &#x27;lockSourceId&#x27;: &#x27;&#x27;, &#x27;metering.imagetype&#x27;: &#x27;gold&#x27;, &#x27;metering.order_id&#x27;: &#x27;CS23010203413KRGB&#x27;, &#x27;image_name&#x27;: &#x27;Windows Server 2016 Standard 64bit&#x27;, &#x27;metering.resourcespeccode&#x27;: &#x27;c3.xlarge.2.win&#x27;, &#x27;os_type&#x27;: &#x27;Windows&#x27;, &#x27;metering.resourcetype&#x27;: &#x27;1&#x27;, &#x27;metering.image_id&#x27;: &#x27;dd714f2c-f470-43b6-afc8-34d8ec689516&#x27;, &#x27;os_bit&#x27;: &#x27;64&#x27;, &#x27;EcmResStatus&#x27;: &#x27;&#x27;, &#x27;lockCheckEndpoint&#x27;: &#x27;&#x27;, &#x27;cascaded.instance_extrainfo&#x27;: &#x27;clock_adjustment:28800,pcibridge:1&#x27;&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; server_info[<span class="string">&#x27;servers&#x27;</span>][0][<span class="string">&#x27;metadata&#x27;</span>][<span class="string">&#x27;vpc_id&#x27;</span>]</span></span><br><span class="line">&#x27;6827d6f5-4614-42a5-9762-15d3d173411c&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 其中 &#123;&#x27;OS-EXT-IPS:type&#x27;: &#x27;floating&#x27;&#125; 表示公网 IP</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; server_info[<span class="string">&#x27;servers&#x27;</span>][0][<span class="string">&#x27;addresses&#x27;</span>][<span class="string">&#x27;6827d6f5-4614-42a5-9762-15d3d173411c&#x27;</span>]</span></span><br><span class="line">[&#123;&#x27;version&#x27;: &#x27;4&#x27;, &#x27;addr&#x27;: &#x27;192.168.0.65&#x27;, &#x27;OS-EXT-IPS:type&#x27;: &#x27;fixed&#x27;, &#x27;OS-EXT-IPS-MAC:mac_addr&#x27;: &#x27;fa:16:3e:00:76:2a&#x27;, &#x27;OS-EXT-IPS:port_id&#x27;: &#x27;c1ec2783-6d3c-4d8a-9c55-abb59c2c648d&#x27;&#125;, &#123;&#x27;version&#x27;: &#x27;4&#x27;, &#x27;addr&#x27;: &#x27;159.138.38.203&#x27;, &#x27;OS-EXT-IPS:type&#x27;: &#x27;floating&#x27;, &#x27;OS-EXT-IPS-MAC:mac_addr&#x27;: &#x27;fa:16:3e:00:76:2a&#x27;, &#x27;OS-EXT-IPS:port_id&#x27;: &#x27;c1ec2783-6d3c-4d8a-9c55-abb59c2c648d&#x27;&#125;]</span><br></pre></td></tr></table></figure>

<p>根据云服务器 id，查询云服务器挂载的磁盘信息 <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[查询弹性云服务器磁盘信息](https://console.huaweicloud.com/apiexplorer/#/apidebug/EVS/sdk?api=ListVolumes)">[2]</span></a></sup></p>
<figure class="highlight shell"><figcaption><span>python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; request = ListServerBlockDevicesRequest(server_id=<span class="string">&#x27;a7dd4502-cb3e-4754-b7b7-73bcb5696a1c&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; response = client.list_server_block_devices(request)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; response</span></span><br><span class="line">&#123;&quot;attachableQuantity&quot;: &#123;&quot;free_scsi&quot;: 58, &quot;free_blk&quot;: 22, &quot;free_disk&quot;: 58&#125;, \</span><br><span class="line"> &quot;volumeAttachments&quot;: [&#123;&quot;bootIndex&quot;: 0, &quot;pciAddress&quot;: &quot;0000:02:01.0&quot;, &quot;volumeId&quot;: &quot;2deefa5c-e92b-4ec5-9914-10af9919c121&quot;, &quot;device&quot;: &quot;/dev/vda&quot;, &quot;serverId&quot;: &quot;a7dd4502-cb3e-4754-b7b7-73bcb5696a1c&quot;, \</span><br><span class="line">                        &quot;id&quot;: &quot;2deefa5c-e92b-4ec5-9914-10af9919c121&quot;, &quot;size&quot;: 100, &quot;bus&quot;: &quot;virtio&quot;&#125;, \</span><br><span class="line">                        &#123;&quot;pciAddress&quot;: &quot;0000:02:02.0&quot;, &quot;volumeId&quot;: &quot;1fd566f2-82bb-49d3-95d1-7452a5868f80&quot;, \</span><br><span class="line">                        &quot;device&quot;: &quot;/dev/vdb&quot;, &quot;serverId&quot;: &quot;a7dd4502-cb3e-4754-b7b7-73bcb5696a1c&quot;, &quot;id&quot;: &quot;1fd566f2-82bb-49d3-95d1-7452a5868f80&quot;, &quot;size&quot;: 100, &quot;bus&quot;: &quot;virtio&quot;&#125;]&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="CDN-数据统计"><a href="#CDN-数据统计" class="headerlink" title="CDN 数据统计"></a>CDN 数据统计</h2><p>获取 CDN 域名统计数据 <sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[查询加速域名](https://apiexplorer.developer.intl.huaweicloud.com/apiexplorer/sdk?product=CDN&version=v1&api=ListDomains)">[3]</span></a></sup> </p>
<figure class="highlight shell"><figcaption><span>python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from huaweicloudsdkcore.auth.credentials import GlobalCredentials</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from huaweicloudsdkcdn.v1.region.cdn_region import CdnRegion</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from huaweicloudsdkcore.exceptions import exceptions</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from huaweicloudsdkcdn.v1 import *</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; ak = <span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; sk = <span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; credentials = GlobalCredentials(ak, sk)</span> </span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; client = CdnClient.new_builder() \</span></span><br><span class="line"><span class="language-bash">...         .with_credentials(credentials) \</span></span><br><span class="line"><span class="language-bash">...         .with_region(CdnRegion.value_of(<span class="string">&quot;cn-north-1&quot;</span>)) \</span></span><br><span class="line"><span class="language-bash">...         .build()</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; request = ListDomainsRequest()</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; response = client.list_domains(request)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">response 数据转换为 Python 数据格式</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; response = json.loads(str(response))</span></span><br></pre></td></tr></table></figure>
<p>输出中包含已经配置在 CDN 上面的域名列表。</p>
<p>查询 CDN 加速域名的流量 <sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[查询域名统计数据-区域运营商](https://apiexplorer.developer.intl.huaweicloud.com/apiexplorer/sdk?product=CDN&version=v1&api=ShowDomainLocationStats)">[4]</span></a></sup></p>
<figure class="highlight shell"><figcaption><span>python</span></figcaption><table><tr><td class="code"><pre><span class="line">request = ShowDomainLocationStatsRequest(action=&#x27;location_summary&#x27;, interval=86400, \</span><br><span class="line">                                         start_time=1669852800000, end_time=1672531200000, \</span><br><span class="line">                                         domain_name=&quot;test.a.com&quot;, stat_type=&quot;flux&quot;)</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; response = client.show_domain_location_stats(request)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; response</span></span><br><span class="line">&#123;&quot;result&quot;: &#123;&quot;flux&quot;: 1050601&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="获取-EIP-信息及统计-IP-流量"><a href="#获取-EIP-信息及统计-IP-流量" class="headerlink" title="获取 EIP 信息及统计 IP 流量"></a>获取 EIP 信息及统计 IP 流量</h2><p>本示例演示获取到指定账号和区域的所有 EIP 信息，并根据 EIP ID 统计对应 IP 的公网出口流量。<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[查询弹性公网IP列表](https://apiexplorer.developer.intl.huaweicloud.com/apiexplorer/sdk?product=EIP&version=v2&api=ListPublicips)">[5]</span></a></sup> </p>
<figure class="highlight shell"><figcaption><span>python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from huaweicloudsdkcore.auth.credentials import BasicCredentials</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from huaweicloudsdkeip.v2.region.eip_region import EipRegion</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from huaweicloudsdkcore.exceptions import exceptions</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from huaweicloudsdkeip.v2 import *</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import json</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; zone = <span class="string">&#x27;ap-southeast-1&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; credentials = BasicCredentials(ak, sk)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; client = EipClient.new_builder() \</span></span><br><span class="line"><span class="language-bash">...         .with_credentials(credentials) \</span></span><br><span class="line"><span class="language-bash">...         .with_region(EipRegion.value_of(zone)) \</span></span><br><span class="line"><span class="language-bash">...         .build()</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; request = ListPublicipsRequest()</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; response = client.list_publicips(request)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; r = json.loads(str(response))</span></span><br></pre></td></tr></table></figure>
<p>输出中包含了此区域内的所有 EIP 信息，查询 IP 的流量统计信息需要 EIP ID，以下输出 EIP ID</p>
<figure class="highlight shell"><figcaption><span>python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; r[<span class="string">&#x27;publicips&#x27;</span>][0][<span class="string">&#x27;id&#x27;</span>]</span></span><br><span class="line">&#x27;3fda9feb-b8e3-440d-8fda-16b5728a6e1f&#x27;</span><br></pre></td></tr></table></figure>

<p>根据 EIP ID 信息获取 IP 公网流量统计数据，<code>ShowMetricDataRequest</code> 方法的帮助信息可以通过 <code>help(ShowMetricDataRequest)</code> 查看 <sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[查询监控数据](https://apiexplorer.developer.intl.huaweicloud.com/apiexplorer/doc?product=CES&version=v1&api=ShowMetricData)">[6]</span></a></sup></p>
<figure class="highlight shell"><figcaption><span>python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from huaweicloudsdkcore.auth.credentials import BasicCredentials</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from huaweicloudsdkces.v1.region.ces_region import CesRegion</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from huaweicloudsdkcore.exceptions import exceptions</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from huaweicloudsdkces.v1 import *</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; name_space = <span class="string">&quot;SYS.VPC&quot;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; metric_name = <span class="string">&quot;up_stream&quot;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; dim_01 = <span class="string">&quot;publicip_id,f0304346-2388-4c9b-a9d0-6f321238f2be&quot;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; credentials = BasicCredentials(ak, sk)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span> </span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; client = CesClient.new_builder() \</span></span><br><span class="line"><span class="language-bash">...         .with_credentials(credentials) \</span></span><br><span class="line"><span class="language-bash">...         .with_region(CesRegion.value_of(zone)) \</span></span><br><span class="line"><span class="language-bash">...         .build()</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; request = ShowMetricDataRequest()</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; request.namespace = name_space</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; request.metric_name = metric_name</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; request.dim_0 = dim_01</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; request.filter = <span class="string">&#x27;sum&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; request.period = 86400</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; request._from = start_timestamp</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; request.to = end_timestamp</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; response = client.show_metric_data(request)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; r  = json.loads(str(response))</span></span><br></pre></td></tr></table></figure>
<p>输出中包含了按天分割的流量数据</p>
<figure class="highlight shell"><figcaption><span>python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; r</span></span><br><span class="line">&#123;&#x27;datapoints&#x27;: [&#123;&#x27;sum&#x27;: 4768802.0, &#x27;timestamp&#x27;: 1672531200000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 1331712163.0, &#x27;timestamp&#x27;: 1672617600000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 12761506.0, &#x27;timestamp&#x27;: 1672704000000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 17119425.0, &#x27;timestamp&#x27;: 1672790400000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 16735886.0, &#x27;timestamp&#x27;: 1672876800000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 186881526.0, &#x27;timestamp&#x27;: 1672963200000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 22091616.0, &#x27;timestamp&#x27;: 1673049600000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 9926109.0, &#x27;timestamp&#x27;: 1673136000000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 14668113.0, &#x27;timestamp&#x27;: 1673222400000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 4655251.0, &#x27;timestamp&#x27;: 1673308800000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 151734721.0, &#x27;timestamp&#x27;: 1673395200000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 65481126.0, &#x27;timestamp&#x27;: 1673481600000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 1236561691.0, &#x27;timestamp&#x27;: 1673568000000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 47856976.0, &#x27;timestamp&#x27;: 1673654400000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 1352841.0, &#x27;timestamp&#x27;: 1673740800000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 265917499.0, &#x27;timestamp&#x27;: 1673827200000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 35810298.0, &#x27;timestamp&#x27;: 1673913600000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 23425333.0, &#x27;timestamp&#x27;: 1674000000000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 20177091.0, &#x27;timestamp&#x27;: 1674086400000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 18610343.0, &#x27;timestamp&#x27;: 1674172800000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 8464183.0, &#x27;timestamp&#x27;: 1674259200000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 4749783.0, &#x27;timestamp&#x27;: 1674345600000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 12750334.0, &#x27;timestamp&#x27;: 1674432000000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 12662461.0, &#x27;timestamp&#x27;: 1674518400000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 15664751.0, &#x27;timestamp&#x27;: 1674604800000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 16539739.0, &#x27;timestamp&#x27;: 1674691200000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 27175842.0, &#x27;timestamp&#x27;: 1674777600000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 784220244.0, &#x27;timestamp&#x27;: 1674864000000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 23921455.0, &#x27;timestamp&#x27;: 1674950400000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 30317158.0, &#x27;timestamp&#x27;: 1675036800000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 141162735.0, &#x27;timestamp&#x27;: 1675123200000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 309507524.0, &#x27;timestamp&#x27;: 1675209600000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;], &#x27;metric_name&#x27;: &#x27;up_stream&#x27;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://console.huaweicloud.com/apiexplorer/#/apidebug/ECS/sdk?api=ListServersDetails">查询云服务器详情列表</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://console.huaweicloud.com/apiexplorer/#/apidebug/EVS/sdk?api=ListVolumes">查询弹性云服务器磁盘信息</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://apiexplorer.developer.intl.huaweicloud.com/apiexplorer/sdk?product=CDN&amp;version=v1&amp;api=ListDomains">查询加速域名</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://apiexplorer.developer.intl.huaweicloud.com/apiexplorer/sdk?product=CDN&amp;version=v1&amp;api=ShowDomainLocationStats">查询域名统计数据-区域运营商</a><a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://apiexplorer.developer.intl.huaweicloud.com/apiexplorer/sdk?product=EIP&amp;version=v2&amp;api=ListPublicips">查询弹性公网IP列表</a><a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://apiexplorer.developer.intl.huaweicloud.com/apiexplorer/doc?product=CES&amp;version=v1&amp;api=ShowMetricData">查询监控数据</a><a href="#fnref:6" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>云平台</category>
        <category>Huawei</category>
      </categories>
      <tags>
        <tag>Huawei</tag>
      </tags>
  </entry>
  <entry>
    <title>inotify安装使用</title>
    <url>/512c7c5/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul>
<li><p>使用系统软件包管理器安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y inotify-tools</span><br></pre></td></tr></table></figure>
<p>安装后包含2个命令： <code>inotifywait </code>, <code>inotifywatch</code>,较为常用的命令是<code>inotifywait</code></p>
</li>
<li><p>编译安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://github.com/downloads/rvoicilas/inotify-tools/inotify-tools-3.14.tar.gz</span><br><span class="line">tar zxvf inotify-tools-3.14.tar.gz  </span><br><span class="line">cd inotify-tools-3.14</span><br><span class="line">./configure --prefix=/usr/local/inotify </span><br><span class="line">make</span><br><span class="line">make install  </span><br></pre></td></tr></table></figure></li>
</ul>
<span id="more"></span>

<h3 id="inotifywait-参数说明"><a href="#inotifywait-参数说明" class="headerlink" title="inotifywait 参数说明"></a>inotifywait 参数说明</h3><p>语法：<br>inotifywait [-hcmrq] [-e modify,access…] [-t ] [–format ] [–timefmt ] [ … ]</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@</span><br><span class="line">排除不需要监视的文件，可以是相对路径，也可以是绝对路径。</span><br><span class="line"></span><br><span class="line">--fromfile</span><br><span class="line">从文件读取需要监视的文件或排除的文件，一个文件一行，排除的文件以@开头。</span><br><span class="line"></span><br><span class="line">-m|--monitor</span><br><span class="line">接收到一个事情而不退出，无限期地执行。默认的行为是接收到一个事情后立即退出。</span><br><span class="line"></span><br><span class="line">-d|--daemon</span><br><span class="line">跟–monitor一样，除了是在后台运行，需要指定-–outfile把事情输出到一个文件。也意味着使用了–-syslog。</span><br><span class="line"></span><br><span class="line">-o|--outfile</span><br><span class="line">输出事情到一个文件而不是标准输出。</span><br><span class="line"></span><br><span class="line">-s|--syslog</span><br><span class="line">输出错误信息到系统日志</span><br><span class="line"></span><br><span class="line">-r|--recursive</span><br><span class="line">监视一个目录下的所有子目录。</span><br><span class="line"></span><br><span class="line">-q|--quiet</span><br><span class="line">指定一次，不会输出详细信息，指定二次，除了致命错误，不会输出任何信息。</span><br><span class="line"></span><br><span class="line">--exclude</span><br><span class="line">正则匹配需要排除的文件，大小写敏感。</span><br><span class="line"></span><br><span class="line">--excludei</span><br><span class="line">正则匹配需要排除的文件，忽略大小写。</span><br><span class="line"></span><br><span class="line">-t|--timeout</span><br><span class="line">设置超时时间，如果为0，则无限期地执行下去。</span><br><span class="line"></span><br><span class="line">-e|--event</span><br><span class="line">指定监视的事件。</span><br><span class="line"></span><br><span class="line">-c|--csv </span><br><span class="line">输出csv格式。</span><br><span class="line"></span><br><span class="line">--timefmt </span><br><span class="line">指定时间格式，用于–-format选项中的%T格式。</span><br><span class="line"></span><br><span class="line">--format</span><br><span class="line">指定输出格式。</span><br><span class="line">    %w 表示发生事件的目录</span><br><span class="line">    %f 表示发生事件的文件</span><br><span class="line">    %e 表示发生的事件</span><br><span class="line">    %Xe 事件以“X”分隔</span><br><span class="line">    %T 使用由--timefmt 定义的时间格式</span><br></pre></td></tr></table></figure>

<h3 id="可监听事件列表"><a href="#可监听事件列表" class="headerlink" title="可监听事件列表"></a>可监听事件列表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">access	文件读取</span><br><span class="line">modify	文件更改。</span><br><span class="line">attrib	文件属性更改，如权限，时间戳等。</span><br><span class="line">close_write	以可写模式打开的文件被关闭，不代表此文件一定已经写入数据。</span><br><span class="line">close_nowrite	以只读模式打开的文件被关闭。</span><br><span class="line">close	文件被关闭，不管它是如何打开的。</span><br><span class="line">open	文件打开。</span><br><span class="line">moved_to	一个文件或目录移动到监听的目录，即使是在同一目录内移动，此事件也触发。</span><br><span class="line">moved_from	一个文件或目录移出监听的目录，即使是在同一目录内移动，此事件也触发。</span><br><span class="line">move	包括moved_to和 moved_from</span><br><span class="line">move_self	文件或目录被移除，之后不再监听此文件或目录。</span><br><span class="line">create	文件或目录创建</span><br><span class="line">delete	文件或目录删除</span><br><span class="line">delete_self	文件或目录移除，之后不再监听此文件或目录</span><br><span class="line">unmount	文件系统取消挂载，之后不再监听此文件系统。</span><br></pre></td></tr></table></figure>

<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">inotifywait -m -r -e modify /source/ | while read dir action filename</span><br><span class="line">do </span><br><span class="line">  echo $&#123;dir&#125;</span><br><span class="line">  echo $&#123;action&#125;</span><br><span class="line">  echo $&#123;filename&#125;</span><br><span class="line">  rsync -a -u /source/ /dest/</span><br><span class="line">done</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>inotify</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins + gitlab 自动构建</title>
    <url>/202210261456/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Jenkins jenkinsci&#x2F;blueocean:2.346.3</li>
<li>GitLab Community Edition 13.9.6</li>
<li>Docker 19.03.15</li>
</ul>
<p>本文档记录 GitLab 上面的代码更新时，使用 Jenkins 自动构建 Docker 镜像的过程。 </p>
<h1 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h1><h2 id="使用-docker-启动-Jenkins-容器"><a href="#使用-docker-启动-Jenkins-容器" class="headerlink" title="使用 docker 启动 Jenkins 容器"></a>使用 docker 启动 Jenkins 容器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8080:8080 --name jenkins \</span><br><span class="line">          -v /var/run/docker.sock:/var/run/docker.sock  \</span><br><span class="line">          -v /data/JenkinsData_blueocean/:/var/jenkins_home/ \</span><br><span class="line">          -u root \</span><br><span class="line">          jenkinsci/blueocean</span><br></pre></td></tr></table></figure>

<h2 id="Jenkins-配置"><a href="#Jenkins-配置" class="headerlink" title="Jenkins 配置"></a>Jenkins 配置</h2><p>以下分别记录使用 <code>freestyle</code> 和 <code>Pipeline</code> 类型的构建镜像的配置过程</p>
<h3 id="创建-freestyle-类型的-Item-构建镜像"><a href="#创建-freestyle-类型的-Item-构建镜像" class="headerlink" title="创建 freestyle 类型的 Item 构建镜像"></a>创建 <code>freestyle</code> 类型的 Item 构建镜像</h3><p>在 <code>源码管理（Source Code Management）</code> 中配置 git 地址，并配置认证</p>
<blockquote>
<p>默认情况下，在构建时，Jenkins 会先从配置的 Git 地址拉取代码到 Jenkins 目录： <code>/var/jenkins_home/workspace/$&#123;PROJECT_NAME&#125;</code></p>
</blockquote>
<p>在 <code>构建（Build）</code> 中 <code>Add build step</code> ，选择构建类型为 <code>Execute shell</code>，此处构建的示例项目代码结构如下，其中 Dockerfile 路径为 <code>k8s/server/Dockerfile</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.:</span><br><span class="line">index.html	k8s</span><br><span class="line"></span><br><span class="line">./k8s:</span><br><span class="line">server</span><br><span class="line"></span><br><span class="line">./k8s/server:</span><br><span class="line">Dockerfile</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用如下 shell 脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">DATA=`date +%Y%m%d%H%M`</span><br><span class="line"></span><br><span class="line">DIR=&#x27;.&#x27;</span><br><span class="line"></span><br><span class="line">LOG=$&#123;DIR&#125;/docker_build_result.log</span><br><span class="line"></span><br><span class="line">DOCKER_REGISTRY=&#x27;harbor.a.com&#x27;</span><br><span class="line"></span><br><span class="line">DOCKER_REGISTRY_PROJECT=&#x27;test&#x27;</span><br><span class="line"></span><br><span class="line">PROJECT=&#x27;test_project&#x27;</span><br><span class="line">ENV=&#x27;uat&#x27;</span><br><span class="line"></span><br><span class="line">docker build -t $&#123;PROJECT&#125;-$&#123;ENV&#125;-$&#123;Branch&#125;:$&#123;DATA&#125; -f k8s/server/Dockerfile $&#123;DIR&#125; | tee $&#123;LOG&#125;</span><br><span class="line"></span><br><span class="line">docker tag $&#123;PROJECT&#125;-$&#123;ENV&#125;-$&#123;Branch&#125;:$&#123;DATA&#125; $&#123;DOCKER_REGISTRY&#125;/$&#123;DOCKER_REGISTRY_PROJECT&#125;/$&#123;PROJECT&#125;-$&#123;ENV&#125;-$&#123;Branch&#125;:$&#123;DATA&#125;</span><br><span class="line"></span><br><span class="line">docker login -u admin -p Harbor12345 $&#123;DOCKER_REGISTRY&#125;</span><br><span class="line"></span><br><span class="line">docker push $&#123;DOCKER_REGISTRY&#125;/$&#123;DOCKER_REGISTRY_PROJECT&#125;/$&#123;PROJECT&#125;-$&#123;ENV&#125;-$&#123;Branch&#125;:$&#123;DATA&#125;</span><br><span class="line"></span><br><span class="line">RESULT=`cat $&#123;LOG&#125; | tail -n 1`</span><br><span class="line"></span><br><span class="line">grep &quot;Successfully tagged &quot; $&#123;LOG&#125;</span><br><span class="line"></span><br><span class="line">exit $?</span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_71.png"></p>
<blockquote>
<p>其中的 <code>$&#123;Branch&#125;</code> 来自 <strong>参数化的构建</strong><br><img src="https://i.csms.tech/img_69.png"></p>
</blockquote>
<span id="more"></span>

<h3 id="使用-Jenkins-Pipeline-构建镜像"><a href="#使用-Jenkins-Pipeline-构建镜像" class="headerlink" title="使用 Jenkins Pipeline 构建镜像"></a>使用 Jenkins Pipeline 构建镜像</h3><p>创建 <code>Pipeline</code> 类型的工程</p>
<p><code>Advanced Project Options</code> 中选择 <code>Pipeline from SCM</code>，并配置 Git 的 url 及认证信息。<code>Script Path</code> 默认为 <code>Jenkinsfile</code>(位于代码根目录)</p>
<p><code>Jenkinsfile</code> 内容如下：</p>
<figure class="highlight shell"><figcaption><span>Jenkinsfile</span></figcaption><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    environment &#123;</span><br><span class="line">        PROJECT=&#x27;test_admin&#x27;</span><br><span class="line">        </span><br><span class="line">        HARBOR_CREDENTIALS = credentials(&#x27;habor&#x27;)</span><br><span class="line">		GIT_CREDENTIALS = credentials(&#x27;git&#x27;)</span><br><span class="line">		</span><br><span class="line">        GIT_URL = &quot;http://$&#123;GIT_CREDENTIALS_USR&#125;:$&#123;GIT_CREDENTIALS_PSW&#125;@git.wkctrlsys.com:18081/jiafeimao/api.git&quot;</span><br><span class="line">        </span><br><span class="line">        DATA=&quot;$&#123;sh(script: &#x27;date +%Y%m%d%H%M&#x27;, returnStdout:true)&#125;&quot;</span><br><span class="line">        LOG=&#x27;./docker_build_result.log&#x27;</span><br><span class="line">        </span><br><span class="line">        DOCKER_REGISTRY=&#x27;harbor.my.com&#x27;</span><br><span class="line">        DOCKER_REGISTRY_PROJECT=&#x27;test&#x27;</span><br><span class="line">        </span><br><span class="line">        BRANCH = &quot;$&#123;params.Branch&#125;&quot;</span><br><span class="line">        </span><br><span class="line">        DIR = &#x27;.&#x27;</span><br><span class="line">		</span><br><span class="line">		TAG = &quot;$&#123;PROJECT&#125;-$&#123;BRANCH&#125;:$&#123;DATA&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&#x27;CHECKOUT&#x27;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                // 清空 workspace</span><br><span class="line">                sh &quot;rm -rf $&#123;env.WORKSPACE&#125;/*&quot;</span><br><span class="line">                sh &quot;rm -rf $&#123;env.WORKSPACE&#125;/.git&quot;</span><br><span class="line">                sh &quot;git clone -b $&#123;BRANCH&#125; $&#123;GIT_URL&#125; .&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(&#x27;BUILD&#x27;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh &#x27;docker build -t $&#123;TAG&#125; -f k8s/server/Dockerfile $&#123;DIR&#125; | tee $&#123;LOG&#125;&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(&#x27;PUSH&#x27;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh &#x27;docker tag $&#123;TAG&#125; $&#123;DOCKER_REGISTRY&#125;/$&#123;DOCKER_REGISTRY_PROJECT&#125;/$&#123;TAG&#125;&#x27;</span><br><span class="line">                </span><br><span class="line">                sh &#x27;docker login -u $&#123;HARBOR_CREDENTIALS_USR&#125; -p $&#123;HARBOR_CREDENTIALS_PSW&#125; $&#123;DOCKER_REGISTRY&#125;&#x27;</span><br><span class="line">                </span><br><span class="line">                sh &#x27;docker push $&#123;DOCKER_REGISTRY&#125;/$&#123;DOCKER_REGISTRY_PROJECT&#125;/$&#123;TAG&#125;&#x27;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">		</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><h2 id="Cannot-connect-to-the-Docker-daemon-at-unix-x2F-x2F-x2F-var-x2F-run-x2F-docker-sock-Is-the-docker-daemon-running"><a href="#Cannot-connect-to-the-Docker-daemon-at-unix-x2F-x2F-x2F-var-x2F-run-x2F-docker-sock-Is-the-docker-daemon-running" class="headerlink" title="Cannot connect to the Docker daemon at unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock. Is the docker daemon running?"></a>Cannot connect to the Docker daemon at unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock. Is the docker daemon running?</h2><p><strong>错误场景</strong></p>
<p>使用 Docker 部署的 Jenkins，在构建 Docker 镜像时，Jenkins 中的 docker 为客户端，使用的 Server 端是宿主机的 Docker Daemon，默认情况下，docker 客户端是通过 <code>unix:///var/run/docker.sock</code> 连接 Docker 服务端，此文件在 Jenkins 容器中不能直接访问，所以导致出现上述错误。</p>
<p><strong>解决思路</strong></p>
<p>针对此种情况，需要让 docker 客户端可以正确的连接到 docker 服务端</p>
<p><strong>解救方法</strong></p>
<p>为 docker 客户端指定 docker 服务端，可以采取以下方法</p>
<ul>
<li>将宿主机的 <code>/var/run/docker.sock</code> 挂载到 Jenkins 容器<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8080:8080 --name jenkins -v /var/run/docker.sock:/var/run/docker.sock  jenkinsci/blueocean</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Got-permission-denied-while-trying-to-connect-to-the-Docker-daemon-socket-at-unix-x2F-x2F-x2F-var-x2F-run-x2F-docker-sock"><a href="#Got-permission-denied-while-trying-to-connect-to-the-Docker-daemon-socket-at-unix-x2F-x2F-x2F-var-x2F-run-x2F-docker-sock" class="headerlink" title="Got permission denied while trying to connect to the Docker daemon socket at unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock"></a>Got permission denied while trying to connect to the Docker daemon socket at unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock</h2><p><strong>错误场景</strong></p>
<p>使用 Docker 部署的 Jenkins，默认情况下，容器中使用 <code>jenkins</code> 用户运行，无权限访问 <code>/var/run/docker.sock</code>，可以使用如下命令，在启动容器时使用 <code>root</code> 用户运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8080:8080 --name jenkins \</span><br><span class="line">          -v /var/run/docker.sock:/var/run/docker.sock  \</span><br><span class="line">          -v /data/JenkinsData_blueocean/:/var/jenkins_home/ \</span><br><span class="line">          -u root \</span><br><span class="line">          jenkinsci/blueocean</span><br></pre></td></tr></table></figure>

<h2 id="WorkflowScript-3-Invalid-agent-type-“docker”-specified-Must-be-one-of-any-label-none"><a href="#WorkflowScript-3-Invalid-agent-type-“docker”-specified-Must-be-one-of-any-label-none" class="headerlink" title="WorkflowScript: 3: Invalid agent type “docker” specified. Must be one of [any, label, none]"></a>WorkflowScript: 3: Invalid agent type “docker” specified. Must be one of [any, label, none]</h2><p><strong>错误原因</strong></p>
<p>没有 docker 相关的插件导致，安装插件 <code>Docker Pipeline</code></p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
        <tag>gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes 上部署 cert-manager 及使用</title>
    <url>/202301050935/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Kubernetes 1.24</li>
<li>cert-manager v1.7.1</li>
</ul>
<p>随着 HTTPS 不断普及，越来越多的网站都在从 HTTP 升级到 HTTPS，使用 HTTPS 就需要向权威机构申请证书，需要付出一定的成本，如果需求数量多，也是一笔不小的开支。cert-manager 是 Kubernetes 上的全能证书管理工具，如果对安全级别和证书功能要求不高，可以利用 cert-manager 基于 ACME 协议与 Let’s Encrypt 来签发免费证书并自动续期，实现永久免费使用证书。</p>
<h1 id="cert-manager-工作原理"><a href="#cert-manager-工作原理" class="headerlink" title="cert-manager 工作原理"></a>cert-manager 工作原理</h1><p>cert-manager 部署到 Kubernetes 集群后，它会 watch 它所支持的 CRD 资源，我们通过创建 CRD 资源来指示 cert-manager 为我们签发证书并自动续期: <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[cert-manager 工作原理](https://imroc.cc/k8s/trick/sign-free-certs-with-cert-manager/#cert-manager-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86)">[1]</span></a></sup><br><img src="https://i.csms.tech/img_111.png"></p>
<p>解释下几个关键的资源:</p>
<ul>
<li><code>Issuer/ClusterIssuer</code>: 用于指示 cert-manager 用什么方式签发证书，本文主要讲解签发免费证书的 ACME 方式。<code>ClusterIssuer</code> 与 <code>Issuer</code> 的唯一区别就是 <code>Issuer</code> 只能用来签发自己所在 <code>namespace</code> 下的证书，<code>ClusterIssuer</code> 可以签发任意 <code>namespace</code> 下的证书。</li>
<li><code>Certificate</code>: 用于告诉 cert-manager 我们想要什么域名的证书以及签发证书所需要的一些配置，包括对 <code>Issuer/ClusterIssuer</code> 的引用。</li>
</ul>
<span id="more"></span>

<h1 id="免费证书签发原理"><a href="#免费证书签发原理" class="headerlink" title="免费证书签发原理"></a>免费证书签发原理</h1><p>Let’s Encrypt 利用 ACME 协议来校验域名是否真的属于你，校验成功后就可以自动颁发免费证书，证书有效期只有 90 天，在到期前需要再校验一次来实现续期，幸运的是 cert-manager 可以自动续期，这样就可以使用永久免费的证书了。如何校验这个域名是否属于你呢？主流的两种校验方式是 HTTP-01 和 DNS-01，详细校验原理可参考 Let’s Encrypt 的运作方式，下面将简单描述下。</p>
<h2 id="HTTP-01-校验原理"><a href="#HTTP-01-校验原理" class="headerlink" title="HTTP-01 校验原理"></a>HTTP-01 校验原理</h2><p>HTTP-01 的校验原理是给你域名指向的 HTTP 服务增加一个临时 location ，Let’s Encrypt 会发送 http 请求到 http:&#x2F;&#x2F;<YOUR_DOMAIN>&#x2F;.well-known&#x2F;acme-challenge&#x2F;<TOKEN>，YOUR_DOMAIN 就是被校验的域名，TOKEN 是 ACME 协议的客户端负责放置的文件，在这里 ACME 客户端就是 cert-manager，它通过修改或创建 Ingress 规则来增加这个临时校验路径并指向提供 TOKEN 的服务。Let’s Encrypt 会对比 TOKEN 是否符合预期，校验成功后就会颁发证书。此方法仅适用于给使用 Ingress 暴露流量的服务颁发证书，并且不支持泛域名证书。</p>
<h2 id="DNS-01-校验原理"><a href="#DNS-01-校验原理" class="headerlink" title="DNS-01 校验原理"></a>DNS-01 校验原理</h2><p>DNS-01 的校验原理是利用 DNS 提供商的 API Key 拿到你的 DNS 控制权限， 在 Let’s Encrypt 为 ACME 客户端提供令牌后，ACME 客户端 (cert-manager) 将创建从该令牌和您的帐户密钥派生的 TXT 记录，并将该记录放在 _acme-challenge.<YOUR_DOMAIN>。 然后 Let’s Encrypt 将向 DNS 系统查询该记录，如果找到匹配项，就可以颁发证书。此方法不需要你的服务使用 Ingress，并且支持泛域名证书。</p>
<h2 id="校验方式对比"><a href="#校验方式对比" class="headerlink" title="校验方式对比"></a>校验方式对比</h2><p>HTTP-01 的校验方式的优点是: 配置简单通用，不管使用哪个 DNS 提供商都可以使用相同的配置方法；缺点是：需要依赖 Ingress，如果你的服务不是用 Ingress 暴露流量的就不适用，而且不支持泛域名证书。</p>
<p>DNS-01 的校验方式的优点是没有 HTTP-01 校验方式缺点，不依赖 Ingress，也支持泛域名；缺点就是不同 DNS 提供商的配置方式不一样，而且 DNS 提供商有很多，cert-manager 的 Issuer 不可能每个都去支持，不过有一些可以通过部署实现了 cert-manager 的 Webhook 的服务来扩展 Issuer 进行支持，比如 DNSPod 和 阿里 DNS，详细 Webhook 列表请参考: <a href="https://cert-manager.io/docs/configuration/acme/dns01/#webhook">https://cert-manager.io/docs/configuration/acme/dns01/#webhook</a></p>
<p>选择哪种方式呢？条件允许的话，建议是尽量用 DNS-01 的方式，限制更少，功能更全。 <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[免费证书签发原理](https://imroc.cc/k8s/trick/sign-free-certs-with-cert-manager/#%E5%85%8D%E8%B4%B9%E8%AF%81%E4%B9%A6%E7%AD%BE%E5%8F%91%E5%8E%9F%E7%90%86)">[2]</span></a></sup></p>
<h1 id="cert-manager-部署"><a href="#cert-manager-部署" class="headerlink" title="cert-manager 部署"></a>cert-manager 部署</h1><p><a href="https://csms.tech/202210071716/#安装-cert-manager">安装参考文档</a></p>
<h1 id="cert-manager-使用"><a href="#cert-manager-使用" class="headerlink" title="cert-manager 使用"></a>cert-manager 使用</h1><h2 id="DNS-01-校验方式签发证书"><a href="#DNS-01-校验方式签发证书" class="headerlink" title="DNS-01 校验方式签发证书"></a>DNS-01 校验方式签发证书</h2><p>下面以 cloudflare 为例来签发证书：</p>
<ol>
<li><p>登录 cloudflare，点到 My Profile &gt; API Tokens &gt; Create Token 来创建 Token:<br><img src="https://i.csms.tech/img_112.png"><br>复制 Token 并妥善保管:<br><img src="https://i.csms.tech/img_113.png"></p>
</li>
<li><p>将 Token 保存到 Secret 中:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  name: cloudflare-api-token-secret</span><br><span class="line">  namespace: cert-manager</span><br><span class="line">type: Opaque</span><br><span class="line">stringData:</span><br><span class="line">  api-token: &lt;API Token&gt; # 粘贴 Token 到这里，不需要 base64 加密。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果是要创建 ClusterIssuer，Secret 需要创建在 cert-manager 所在命名空间中，如果是 Issuer，那就创建在 Issuer 所在命名空间中。 <sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[DNS-01 校验方式签发证书](https://imroc.cc/k8s/trick/sign-free-certs-with-cert-manager/#dns-01-%E6%A0%A1%E9%AA%8C%E6%96%B9%E5%BC%8F%E7%AD%BE%E5%8F%91%E8%AF%81%E4%B9%A6)">[3]</span></a></sup></p>
</blockquote>
</li>
<li><p>创建 ClusterIssuer:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: cert-manager.io/v1</span><br><span class="line">kind: ClusterIssuer</span><br><span class="line">metadata:</span><br><span class="line">  name: letsencrypt-dns01</span><br><span class="line">spec:</span><br><span class="line">  acme:</span><br><span class="line">    privateKeySecretRef:</span><br><span class="line">      name: letsencrypt-dns01     # 用于储存 ACME Account 私钥的 Secret</span><br><span class="line">    email: my-cloudflare-acc@example.com</span><br><span class="line">    server: https://acme-v02.api.letsencrypt.org/directory</span><br><span class="line">    solvers:</span><br><span class="line">    - dns01:</span><br><span class="line">        cloudflare:</span><br><span class="line">          email: my-cloudflare-acc@example.com # 替换成你的 cloudflare 邮箱账号，API Token 方式认证非必需，API Keys 认证是必需</span><br><span class="line">          apiTokenSecretRef:</span><br><span class="line">            key: api-token               # 引用 secret 中的配置数据，key 为 secret 中配置的名称</span><br><span class="line">            name: cloudflare-api-token-secret    # 引用保存 cloudflare 认证信息的 Secret</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建 Certificate:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: cert-manager.io/v1</span><br><span class="line">kind: Certificate</span><br><span class="line">metadata:</span><br><span class="line">  name: test-mydomain-com</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  dnsNames:</span><br><span class="line">  - test.mydomain.com # 要签发证书的域名</span><br><span class="line">  - &quot;*.mydomain.com&quot; </span><br><span class="line">  issuerRef:</span><br><span class="line">    kind: ClusterIssuer</span><br><span class="line">    name: letsencrypt-dns01 # 引用 ClusterIssuer，指示采用 dns01 方式进行校验</span><br><span class="line">  secretName: test-mydomain-com-tls # 最终签发出来的证书会保存在这个 Secret 里面</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取和使用证书</p>
<p>创建好 Certificate 后，等一小会儿，我们可以 kubectl 查看是否签发成功:</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ kubectl get certificate -n prod</span><br><span class="line"> NAME                READY   SECRET                  AGE</span><br><span class="line"> test-mydomain-com   True    test-mydomain-com-tls   1m</span><br></pre></td></tr></table></figure>
<p> 如果 READY 为 <code>False</code> 表示失败，可以通过 <code>describe</code> 查看 <code>event</code> 来排查失败原因:</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ kubectl describe certificate test-mydomain-com -n prod</span><br></pre></td></tr></table></figure>
<p> 如果为 <code>True</code> 表示签发成功，证书就保存在我们所指定的 <code>Secret 中</code> (上面的例子是 <code>default/test-mydomain-com-tls</code>)，可以通过 <code>kubectl</code> 查看:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ kubectl get secret test-mydomain-com-tls -n default</span><br><span class="line"> ...</span><br><span class="line"> data:</span><br><span class="line">   tls.crt: &lt;cert&gt;</span><br><span class="line">   tls.key: &lt;private key&gt;</span><br></pre></td></tr></table></figure>
<p> 其中 <code>tls.crt</code> 就是证书，<code>tls.key</code> 是密钥。</p>
<p> 你可以将它们挂载到你需要证书的应用中，或者使用 Ingress，可以直接在 Ingress 中引用 <code>secret</code>，示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1beta1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: test-ingress</span><br><span class="line">  annotations:</span><br><span class="line">    kubernetes.io/Ingress.class: nginx</span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">  - host: test.mydomain.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path: /web</span><br><span class="line">        backend:</span><br><span class="line">          serviceName: web</span><br><span class="line">          servicePort: 80</span><br><span class="line">  tls:</span><br><span class="line">    hosts:</span><br><span class="line">    - test.mydomain.com</span><br><span class="line">    secretName: test-mydomain-com-tls</span><br></pre></td></tr></table></figure>
<p>签发证书异常，可以检查 cert-manager 的 pod 的日志，查看报错信息。</p>
<p>nginx 使用 cert-manager 颁发的证书，可以将 cert 和 key 文件内容追加到同一个文件中(pem)，Nginx 配置证书和 key 都使用此文件。</p>
</li>
</ol>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://imroc.cc/k8s/trick/sign-free-certs-with-cert-manager/#cert-manager-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">cert-manager 工作原理</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://imroc.cc/k8s/trick/sign-free-certs-with-cert-manager/#%E5%85%8D%E8%B4%B9%E8%AF%81%E4%B9%A6%E7%AD%BE%E5%8F%91%E5%8E%9F%E7%90%86">免费证书签发原理</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://imroc.cc/k8s/trick/sign-free-certs-with-cert-manager/#dns-01-%E6%A0%A1%E9%AA%8C%E6%96%B9%E5%BC%8F%E7%AD%BE%E5%8F%91%E8%AF%81%E4%B9%A6">DNS-01 校验方式签发证书</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>cert-manager</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes 常用命令示例</title>
    <url>/202209131536/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Centos-7 3.10.0-1062.9.1</li>
<li>Docker 19.03.15</li>
<li>containerd.io-1.4.13</li>
<li>kubectl-1.25.0</li>
<li>kubeadm-1.25.0</li>
<li>kubelet-1.25.0</li>
</ul>
<h3 id="kubeadm-常用命令"><a href="#kubeadm-常用命令" class="headerlink" title="kubeadm 常用命令"></a>kubeadm 常用命令</h3><h4 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm init --pod-network-cidr=10.244.0.0/16 --cri-socket=unix:///var/run/cri-dockerd.sock</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>--pod-network-cidr</code></td>
<td>指定 pod 的 cidr</td>
<td></td>
</tr>
<tr>
<td><code>--cri-socket</code></td>
<td>配置集群使用的 CRI，不指定时系统会扫描主机，如果有多个可用 CRI，会出现提示</td>
<td></td>
</tr>
</tbody></table>
<h4 id="添加节点到集群"><a href="#添加节点到集群" class="headerlink" title="添加节点到集群"></a>添加节点到集群</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm join 172.31.10.19:6443 --token 8ca35s.butdpihinkdczvqb --discovery-token-ca-cert-hash sha256:b2793f9a6bea44a64640f99042f11c4ff6 \ </span><br><span class="line">        --cri-socket=unix:///var/run/cri-dockerd.sock</span><br></pre></td></tr></table></figure>
<p>其中的 <code>token</code> 可以在 master 上使用以下命令查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubeadm token list</span></span><br><span class="line">TOKEN                     TTL         EXPIRES                USAGES                   DESCRIPTION                                                EXTRA GROUPS</span><br><span class="line">8ca35s.butdpihinkdczvqb   19h         2022-09-14T02:54:55Z   authentication,signing   The default bootstrap token generated by &#x27;kubeadm init&#x27;.   system:bootstrappers:kubeadm:default-node-token</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>默认情况下，令牌会在 24 小时后过期。如果要在当前令牌过期后将节点加入集群， 则可以通过在控制平面节点上运行以下命令来创建新令牌：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm token create</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果你没有 <code>--discovery-token-ca-cert-hash</code> 的值，则可以通过在控制平面节点上执行以下命令链来获取它<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[使用 kubeadm 创建集群](https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#join-nodes)">[1]</span></a></sup>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | \</span><br><span class="line">   openssl dgst -sha256 -hex | sed &#x27;s/^.* //&#x27;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="kubectl-常用命令"><a href="#kubectl-常用命令" class="headerlink" title="kubectl 常用命令"></a>kubectl 常用命令</h3><p>kubectl 常用选项</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>-n, --namespace=&#39;&#39;</code></td>
<td>指定操作的 namespace</td>
<td></td>
</tr>
</tbody></table>
<h4 id="查看-node-信息"><a href="#查看-node-信息" class="headerlink" title="查看 node 信息"></a>查看 node 信息</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get nodes</span></span><br><span class="line">NAME              STATUS   ROLES           AGE     VERSION</span><br><span class="line">ops-kubernetes1   Ready    control-plane   5h31m   v1.25.0</span><br><span class="line">ops-kubernetes2   Ready    &lt;none&gt;          3h6m    v1.25.0</span><br><span class="line">ops-kubernetes3   Ready    &lt;none&gt;          179m    v1.25.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看指定节点的状态及其他详细信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl describe node &lt;节点名称&gt;</span><br></pre></td></tr></table></figure>

<h4 id="标记-node-为不可调度"><a href="#标记-node-为不可调度" class="headerlink" title="标记 node 为不可调度"></a>标记 node 为不可调度</h4><p>如果标记节点为不可调度（unschedulable），将阻止新 Pod 调度到该 Node 之上， 但不会影响任何已经在其上的 Pod。 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl cordon $NODENAME</span><br></pre></td></tr></table></figure>

<h4 id="查看-pod"><a href="#查看-pod" class="headerlink" title="查看 pod"></a>查看 pod</h4><p>列出所有 pod</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods -A</span></span><br><span class="line">NAMESPACE      NAME                                      READY   STATUS              RESTARTS         AGE</span><br><span class="line">kube-flannel   kube-flannel-ds-7q2hp                     0/1     CrashLoopBackOff    52 (86s ago)     4h3m</span><br><span class="line">kube-flannel   kube-flannel-ds-k8wd6                     0/1     CrashLoopBackOff    47 (16s ago)     135m</span><br><span class="line">kube-flannel   kube-flannel-ds-x6ck2                     0/1     CrashLoopBackOff    29 (3m57s ago)   128m</span><br><span class="line">kube-system    coredns-565d847f94-b4sgn                  0/1     ContainerCreating   0                4h39m</span><br><span class="line">kube-system    coredns-565d847f94-ml6k5                  0/1     ContainerCreating   0                4h39m</span><br><span class="line">kube-system    etcd-ops-kubernetes1                      1/1     Running             0                4h39m</span><br><span class="line">kube-system    kube-apiserver-ops-kubernetes1            1/1     Running             0                4h39m</span><br><span class="line">kube-system    kube-controller-manager-ops-kubernetes1   1/1     Running             0                4h39m</span><br><span class="line">kube-system    kube-proxy-9vwxl                          1/1     Running             0                135m</span><br><span class="line">kube-system    kube-proxy-qxsc7                          1/1     Running             0                128m</span><br><span class="line">kube-system    kube-proxy-v5msf                          1/1     Running             0                4h39m</span><br><span class="line">kube-system    kube-scheduler-ops-kubernetes1            1/1     Running             0                4h39m</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>-A, --all-namespaces</code></td>
<td>列出所有的 pod</td>
<td></td>
</tr>
</tbody></table>
<h4 id="查看集群中可用的资源"><a href="#查看集群中可用的资源" class="headerlink" title="查看集群中可用的资源"></a>查看集群中可用的资源</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl api-resources</span></span><br><span class="line"> NAME                              SHORTNAMES   APIVERSION                             NAMESPACED   KIND</span><br><span class="line">bindings                                       v1                                     true         Binding</span><br><span class="line">endpoints                         ep           v1                                     true         Endpoints</span><br><span class="line">events                            ev           v1                                     true         Event</span><br><span class="line">namespaces                        ns           v1                                     false        Namespace</span><br><span class="line">nodes                             no           v1                                     false        Node</span><br><span class="line">pods                              po           v1                                     true         Pod</span><br><span class="line">podtemplates                                   v1                                     true         PodTemplate</span><br><span class="line">secrets                                        v1                                     true         Secret</span><br><span class="line">serviceaccounts                   sa           v1                                     true         ServiceAccount</span><br><span class="line">services                          svc          v1                                     true         Service</span><br><span class="line">apiservices                                    apiregistration.k8s.io/v1              false        APIService</span><br><span class="line">controllerrevisions                            apps/v1                                true         ControllerRevision</span><br><span class="line">deployments                       deploy       apps/v1                                true         Deployment</span><br><span class="line">replicasets                       rs           apps/v1                                true         ReplicaSet</span><br><span class="line">jobs                                           batch/v1                               true         Job</span><br><span class="line">endpointslices                                 discovery.k8s.io/v1                    true         EndpointSlice</span><br><span class="line">events                            ev           events.k8s.io/v1                       true         Event</span><br><span class="line">ingresses                         ing          networking.k8s.io/v1                   true         Ingress</span><br><span class="line">networkpolicies                   netpol       networking.k8s.io/v1                   true         NetworkPolicy</span><br><span class="line">runtimeclasses                                 node.k8s.io/v1                         false        RuntimeClass</span><br><span class="line">clusterrolebindings                            rbac.authorization.k8s.io/v1           false        ClusterRoleBinding</span><br><span class="line">clusterroles                                   rbac.authorization.k8s.io/v1           false        ClusterRole</span><br><span class="line">rolebindings                                   rbac.authorization.k8s.io/v1           true         RoleBinding</span><br><span class="line">roles                                          rbac.authorization.k8s.io/v1           true         Role</span><br><span class="line">csidrivers                                     storage.k8s.io/v1                      false        CSIDriver</span><br><span class="line">csinodes                                       storage.k8s.io/v1                      false        CSINode</span><br><span class="line">storageclasses                    sc           storage.k8s.io/v1                      false        StorageClass</span><br><span class="line">volumeattachments                              storage.k8s.io/v1                      false        VolumeAttachment</span><br></pre></td></tr></table></figure>
<p>以下命令可以分别查看在 namespace 中的资源和不在 namespace 中的资源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">位于名字空间中的资源</span></span><br><span class="line">kubectl api-resources --namespaced=true</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不在名字空间中的资源</span></span><br><span class="line">kubectl api-resources --namespaced=false</span><br></pre></td></tr></table></figure>

<h4 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h4><p>查看指定 namespace 中的指定 pod 的日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl logs kube-flannel-ds-7q2hp -n kube-flannel</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="使用-kubectl-重启-pod"><a href="#使用-kubectl-重启-pod" class="headerlink" title="使用 kubectl 重启 pod"></a>使用 kubectl 重启 pod</h4><p>以下命令重启 kubernetes-dashboard</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get pod kubernetes-dashboard -n kubernetes-dashboard -o yaml | kubectl replace --force -f -</span><br></pre></td></tr></table></figure>

<p>这条命令的意思是 <code>get</code> 当前运行的 pod 的 yaml 声明，并管道重定向输出到 <code>kubectl replace</code> 命令的标准输入，从而达到重启的目的。</p>
<h4 id="删除-namespace"><a href="#删除-namespace" class="headerlink" title="删除 namespace"></a>删除 namespace</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl delete ns kubernetes-dashboard</span><br></pre></td></tr></table></figure>

<h4 id="连接容器"><a href="#连接容器" class="headerlink" title="连接容器"></a>连接容器</h4><p><a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#exec">命令格式参考</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl <span class="built_in">exec</span> test-nginx-deployment-59d795fbf6-bjgcz -it -n default -- bash</span></span><br><span class="line">root@test-nginx-deployment-59d795fbf6-bjgcz:/#</span><br></pre></td></tr></table></figure>
<p>使用 root 用户登陆容器。分别使用以下命令查询 POD 所在的节点和 容器 ID</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods -n spinnaker -o wide</span></span><br><span class="line">NAME                                READY   STATUS    RESTARTS   AGE     IP            NODE        NOMINATED NODE   READINESS GATES</span><br><span class="line">spin-clouddriver-85d4985d4c-5rj4d   1/1     Running   0          6d20h   10.244.1.29   k8s-work1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl describe pod -n spinnaker spin-clouddriver-85d4985d4c-5rj4d</span></span><br><span class="line">...</span><br><span class="line">Containers:</span><br><span class="line">  clouddriver:</span><br><span class="line">    Container ID:   docker://010226eaa372bab53c30f82af6a5918ebc46f158ecc6e379ed44f9e2994ed432</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如上命令可以查到所在节点和容器 ID （<code>010226eaa372bab53c30f82af6a5918ebc46f158ecc6e379ed44f9e2994ed432</code>），登陆到对应节点，使用 <code>docker</code> 命令以 <code>root</code> 用户登陆容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it -u root 010226eaa372bab53c bash</span><br></pre></td></tr></table></figure>

<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands"><code>kubectl</code> 命令参考</a></p>
<h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#join-nodes">使用 kubeadm 创建集群</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes 常见错误总结</title>
    <url>/202209281614/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos7 5.4.212-1</li>
<li>Docker 20.10.18</li>
<li>containerd.io-1.6.8</li>
<li>kubectl-1.25.0</li>
<li>kubeadm-1.25.0</li>
<li>kubelet-1.25.0</li>
</ul>
<h1 id="POD-状态异常"><a href="#POD-状态异常" class="headerlink" title="POD 状态异常"></a>POD 状态异常</h1><h2 id="CrashLoopBackOff"><a href="#CrashLoopBackOff" class="headerlink" title="CrashLoopBackOff"></a>CrashLoopBackOff</h2><p><strong>错误场景</strong> ： </p>
<p><code>Pod</code> 状态显示 <code>CrashLoopBackOff</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods</span></span><br><span class="line">NAME                                     READY   STATUS             RESTARTS       AGE</span><br><span class="line">test-centos7-7cc5dc6987-jz486            0/1     CrashLoopBackOff   8 (111s ago)   17m</span><br></pre></td></tr></table></figure>
<p>查看 <code>Pod</code> 详细信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl describe pod test-centos7-7cc5dc6987-jz486</span></span><br><span class="line">...</span><br><span class="line">Events:</span><br><span class="line">  Type     Reason     Age                  From               Message</span><br><span class="line">  ----     ------     ----                 ----               -------</span><br><span class="line">  Normal   Scheduled  18m                  default-scheduler  Successfully assigned default/test-centos7-7cc5dc6987-jz486 to ops-kubernetes3</span><br><span class="line">  Normal   Pulled     16m (x5 over 18m)    kubelet            Container image &quot;centos:centos7.9.2009&quot; already present on machine</span><br><span class="line">  Normal   Created    16m (x5 over 18m)    kubelet            Created container centos7</span><br><span class="line">  Normal   Started    16m (x5 over 18m)    kubelet            Started container centos7</span><br><span class="line">  Warning  BackOff    3m3s (x71 over 18m)  kubelet            Back-off restarting failed container</span><br></pre></td></tr></table></figure>
<p>结果显示，<code>Reason</code> 为 <code>BackOff</code>，<code>Message</code> 显示 <code>Back-off restarting failed container</code></p>
<p><strong>可能原因</strong> ：</p>
<p><code>Back-off restarting failed container</code> 的原因，通常是因为，容器内 PID 为 1 的进程退出导致（通常用户在构建镜像执行 <code>CMD</code> 时，启动的程序，均是 PID 为1）<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Back-off restarting failed container 怎么办](https://cloud.tencent.com/developer/article/1931089)">[1]</span></a></sup></p>
<p>容器进程退出（命令执行结束或者进程异常结束），则容器生命周期结束。kubernetes 控制器检查到容器退出，会持续重启容器。针对此种情况，需要检查镜像，是否不存在常驻进程，或者常驻进程异常。</p>
<p>针对此种情况，可以单独使用 <code>docker</code> 客户端部署镜像，查看镜像的运行情况，如果部署后，容器中的进程立马结束或退出，则容器也会随之结束。</p>
<span id="more"></span>
<h2 id="POD-状态为-InvalidImageName"><a href="#POD-状态为-InvalidImageName" class="headerlink" title="POD 状态为 InvalidImageName"></a>POD 状态为 InvalidImageName</h2><p><strong>错误场景</strong> ： </p>
<p><code>Pod</code> 状态显示 <code>InvalidImageName</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get pods -n cs</span><br><span class="line">NAME               READY   STATUS              RESTARTS   AGE</span><br><span class="line">54fdc56754-qrlt6   0/2     InvalidImageName    0          14s</span><br><span class="line">8486f49b89-zp25b   0/2     Init:ErrImagePull   0          7s</span><br></pre></td></tr></table></figure>

<p><strong>可能原因</strong> ：</p>
<p>镜像的 url 地址中，以 <code>http://</code> 或 <code>https://</code> 开头。配置中镜像的 url 地址中无需指定协议（<code>http://</code> 或 <code>https://</code>） </p>
<h2 id="Pod-状态为-Error"><a href="#Pod-状态为-Error" class="headerlink" title="Pod 状态为 Error"></a>Pod 状态为 Error</h2><h3 id="The-node-was-low-on-resource-ephemeral-storage"><a href="#The-node-was-low-on-resource-ephemeral-storage" class="headerlink" title="The node was low on resource: ephemeral-storage"></a>The node was low on resource: ephemeral-storage</h3><p><strong>错误场景</strong>：</p>
<p>查看 Pod 状态，显示 Error</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods</span></span><br><span class="line">NAME                     READY   STATUS                   RESTARTS   AGE</span><br><span class="line">front-7df8ccc4c7-xhp6s    0/1     Error                    0          5h42m</span><br></pre></td></tr></table></figure>
<p>检查 Pod 的具体信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl describe pod front-7df8ccc4c7-xhp6s</span></span><br><span class="line">...</span><br><span class="line">Status:       Failed</span><br><span class="line">Reason:       Evicted</span><br><span class="line">Message:      The node was low on resource: ephemeral-storage. Container php was using 394, which exceeds its request of 0. </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>其中包含异常的关键信息：<code>Status:       Failed</code>，<code>Reason:       Evicted</code>，具体原因为 <code>The node was low on resource: ephemeral-storage</code></p>
<p>检查节点上的 Kuberlet 日志，搜索关键字 <code>evicte</code> 或者 <code>disk</code> ，也可以看到系统上文件系统空间使用率超过了阈值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">journalctl -u kubelet  | grep -i -e disk -e evict</span></span><br><span class="line"> image_gc_manager.go:310] &quot;Dis usage on image filesystem is over the high threshold, trying to free bytes down to the low threshold&quot; usage=85 highThreshold=85 amountToFree=5122092236 lowThreshold=80</span><br><span class="line"> eviction_manager.go:349] &quot;Eviction manager: must evict pod(s) to reclaim&quot; resourceName=&quot;ephemeral-storage&quot;</span><br><span class="line"> eviction_manager.go:338] &quot;Eviction manager: attempting to reclaim&quot; resourceName=&quot;ephemeral-storage&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>可能原因</strong> ：</p>
<p>根据以上信息，可知 Pod 异常是因为 <code>The node was low on resource: ephemeral-storage</code>，表示 <strong>临时存储资源</strong> 不足导致节点处于 <code>Tainted</code> ，其上的 Pod 被驱逐(<code>Evicted</code>)</p>
<p><strong><a href="https://kubernetes.io/zh-cn/docs/concepts/configuration/manage-resources-containers/#local-ephemeral-storage">本地临时存储说明</a></strong></p>
<p>针对此种情况，如果某 Pod 的临时存储用量超出了你所允许的范围，kubelet 会向其发出逐出（<code>eviction</code>）信号，触发该 Pod 被逐出所在节点。</p>
<p>如果用于可写入容器镜像层、节点层面日志或者 <code>emptyDir</code> 卷的文件系统中可用空间太少， 节点会为自身设置本地存储不足的污点(<code>Tainted</code>)标签。 这一污点会触发对那些无法容忍该污点的 Pod 的逐出操作。</p>
<p><strong>解决方法</strong> ：</p>
<ul>
<li><p>增加磁盘空间</p>
</li>
<li><p>调整 <code>kubelet</code> 的 <code>nodefs.available</code> 的 threshold 值</p>
<p>  修改节点上的 <code>kubelet</code> 的启动配置文件 <code>/usr/lib/systemd/system/kubelet.service.d/10-kubeadm.conf</code>，添加以下启动参数，主要为定义环境变量 <code>KUBELET_EVICT_NODEFS_THRESHOLD_ARGS</code>，并将其添加到启动参数中</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Environment=&quot;KUBELET_EVICT_NODEFS_THRESHOLD_ARGS=--eviction-hard=nodefs.available&lt;5%&quot;</span><br><span class="line">ExecStart=/usr/bin/kubelet $KUBELET_KUBECONFIG_ARGS $KUBELET_CONFIG_ARGS $KUBELET_KUBEADM_ARGS $KUBELET_EXTRA_ARGS $KUBELET_EVICT_NODEFS_THRESHOLD_ARGS</span><br></pre></td></tr></table></figure>
<p>  修改之后重启 <code>kubelet</code> 服务，并通过日志查看 <code>nodefs.available</code> 的新值是否生效</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ systemctl daemon-reload</span><br><span class="line">$ systemctl restart kubelet</span><br><span class="line"></span><br><span class="line">$ journalctl -u kubelet | grep -i nodefs</span><br><span class="line">17604 container_manager_linux.go:267] &quot;Creating Container Manager object based on Node Config&quot; nodeConfig=&#123;RuntimeCgroupsName: SystemCgroupsName: KubeletCgroupsName: KubeletOOMScoreAdj:-999 ContainerRuntime: CgroupsPerQOS:true CgroupRoot:/ CgroupDriver:systemd KubeletRootDir:/var/lib/kubelet ProtectKernelDefaults:false NodeAllocatableConfig:&#123;KubeReservedCgroupName: SystemReservedCgroupName: ReservedSystemCPUs: EnforceNodeAllocatable:map[pods:&#123;&#125;] KubeReserved:map[] SystemReserved:map[] HardEvictionThresholds:[&#123;Signal:nodefs.available Operator:LessThan Value:&#123;Quantity:&lt;nil&gt; Percentage:0.05&#125; GracePeriod:0s MinReclaim:&lt;nil&gt;&#125;]&#125; QOSReserved:map[] ExperimentalCPUManagerPolicy:none ExperimentalCPUManagerPolicyOptions:map[] ExperimentalTopologyManagerScope:container ExperimentalCPUManagerReconcilePeriod:10s ExperimentalMemoryManagerPolicy:None ExperimentalMemoryManagerReservedMemory:[] ExperimentalPodPidsLimit:-1 EnforceCPULimits:true CPUCFSQuotaPeriod:100ms ExperimentalTopologyManagerPolicy:none&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>日志中看到 <code>Signal:nodefs.available Operator:LessThan Value:&#123;Quantity:&lt;nil&gt; Percentage:0.05</code>，表明更改生效。<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[ephemeral-storage 问题](https://tonybai.com/2017/10/16/out-of-node-resource-handling-in-kubernetes-cluster/)">[2]</span></a></sup></p>
</li>
</ul>
<h2 id="Pod-状态为-Init"><a href="#Pod-状态为-Init" class="headerlink" title="Pod 状态为 Init"></a>Pod 状态为 Init</h2><h3 id="Unable-to-attach-or-mount-volumes"><a href="#Unable-to-attach-or-mount-volumes" class="headerlink" title="Unable to attach or mount volumes"></a>Unable to attach or mount volumes</h3><p>Pod 启动异常，查看 Pod 状态为 <code>Init:0/1</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods -n agmjys</span></span><br><span class="line">NAME                          READY   STATUS     RESTARTS   AGE</span><br><span class="line">admin-cbb479556-j9qg2    0/1     Init:0/1   0          3m37s</span><br></pre></td></tr></table></figure>
<p>查看 Pod 的详细描述信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl describe pod admin-cbb479556-j9qg2</span></span><br><span class="line">Events:</span><br><span class="line">  Type     Reason       Age    From               Message</span><br><span class="line">  ----     ------       ----   ----               -------</span><br><span class="line">  Normal   Scheduled    3m41s  default-scheduler  Successfully assigned admin-cbb479556-j9qg2 to k8s-work2</span><br><span class="line">  Warning  FailedMount  99s    kubelet            Unable to attach or mount volumes: unmounted volumes=[logs], unattached volumes=[wwwroot kube-api-access-z8745 logs]: timed out waiting for the condition</span><br><span class="line">  Warning  FailedMount  42s    kubelet            MountVolume.SetUp failed for volume &quot;uat-nfs-pv&quot; : mount failed: exit status 32</span><br><span class="line">Mounting command: mount</span><br><span class="line">Mounting arguments: -t nfs 34.230.1.1:/data/NFSDataHome /var/lib/kubelet/pods/9d9a4807-706c-4369-b8be-b5727ee6aa8f/volumes/kubernetes.io~nfs/uat-nfs-pv</span><br><span class="line">Output: mount.nfs: Connection timed out</span><br></pre></td></tr></table></figure>

<p>根据 <code>Events</code> 中输出的信息，<code>MountVolume.SetUp failed for volume &quot;uat-nfs-pv&quot; : mount failed: exit status 32</code>，显示挂载卷失败，输出中包含了挂载卷时使用的命令和参数（<code>mount -t nfs 34.230.1.1:/data/NFSDataHome /var/lib/kubelet/pods/9d9a4807-706c-4369-b8be-b5727ee6aa8f/volumes/kubernetes.io~nfs/uat-nfs-pv</code>）及命令失败后的返回结果（<code>mount.nfs: Connection timed out</code>）</p>
<p>根据 <code>Events</code> 中的信息，查看配置，发现此卷为 NFS 类型的 PV，根据报错排查，此例原因为 NFS 的服务器地址填写错误，更新 PV 配置中的 NFS Server 的地址后，Pod 正常启动。</p>
<h1 id="网络问题"><a href="#网络问题" class="headerlink" title="网络问题"></a>网络问题</h1><h2 id="同一个节点上的-Pod-之间网络不通"><a href="#同一个节点上的-Pod-之间网络不通" class="headerlink" title="同一个节点上的 Pod 之间网络不通"></a>同一个节点上的 Pod 之间网络不通</h2><p><strong>问题现象</strong>：</p>
<p>同一个节点上的 <code>Pod</code> 之间网络不通</p>
<p><strong>排查思路</strong>：</p>
<ul>
<li>检查系统内核配置是否开启转发 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sysctl -a | grep net.ipv4.ip_forward</span></span><br><span class="line">net.ipv4.ip_forward = 1</span><br></pre></td></tr></table></figure></li>
<li>检查 <code>iptables</code> 是否禁止转发，<a href="https://csms.tech/202209121102/#集群中所有计算机之间具有完全的网络连接"><code>iptables</code> 防火墙配置参考</a>)</li>
<li>为了定位是否为 <code>iptables</code> 影响，开关闭 <code>iptables</code> 再进行测试，如果关闭防火墙后可以通信，可以确定是防火墙规则导致，需要检查防火墙规则。</li>
<li>更深入的排查，可以部署 <a href="https://hub.docker.com/r/antrea/netshoot/tags"><code>netshoot</code> 容器</a> 进行抓包定位，</li>
</ul>
<h2 id="Pod-无法访问到外部-Internet-网络"><a href="#Pod-无法访问到外部-Internet-网络" class="headerlink" title="Pod 无法访问到外部 Internet 网络"></a>Pod 无法访问到外部 Internet 网络</h2><p>某个节点上，Pod 无法外部主机的服务（端口 6603&#x2F;tcp）。分别在 Pod ，节点 <code>cni0</code> 网卡，节点出口网卡 <code>eth0</code> ，目标服务网卡上抓包。此例中 Pod IP 为 <code>10.244.4.173</code>，目标服务的 IP 地址为 <code>50.18.6.225</code></p>
<p>查看 Pod 抓包结果</p>
<p><img src="https://i.csms.tech/img_102.png"></p>
<p>可以看到源 IP 为 Pod 地址，目标为服务 IP 的 <code>6603/tcp</code> 的请求发送后，未收到 TCP 连接建立的响应。查看 节点 <code>cni0</code> 网卡 的抓包</p>
<p><img src="https://i.csms.tech/img_103.png"></p>
<p>可以看到源 IP 为 Pod 地址，目标为服务 IP 的 <code>6603/tcp</code> 的请求发送后，未收到 TCP 连接建立的响应。查看节点出口网卡 <code>eth0</code> 的抓包。</p>
<p><img src="https://i.csms.tech/img_104.png"></p>
<p><strong>此处看到的源 IP 依然是  Pod 的 IP 地址，此处存在问题</strong>。在云主机的场景中，如果数据包以这种结构发送出去，数据包到了 Internet 网关将拒绝它，因为网关 NAT（将 VM 的 IP 转换为公网 IP） 只了解连接到 VM 的 IP 地址。</p>
<p>正常情况下，Pod 的流量到节点的出口网卡之前，是应该经过 <code>iptables</code> 执行源 NAT - <strong>更改数据包源，使数据包看起来来自 VM 而不是 Pod</strong>。有了正确的源 IP，数据包才可以离开 VM 进入 Internet</p>
<p>此种情况下，数据包可以从节点的出口网卡发送出去，但是到了 Internet 网关将会被丢弃，因此目标服务无法接收到请求，查看目标服务器上的抓包，确实未收到来自此 Pod 的请求。</p>
<p>此处的 <strong>源 NAT</strong> 是由 <code>iptables</code>  负责执行，流入节点出口网卡的数据包未被正确的 <strong>源 NAT</strong>，有可能是因为 <code>kube-proxy</code> 维护的网络规则错误，或者因为 <code>iptables</code> 规则配置错误。可以通过重启 <code>kube-proxy</code> （由服务 <code>kubelet</code> 管理）和 <code>iptables</code> 服务尝试恢复。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart kubelet</span><br><span class="line">systemctl restart iptables</span><br></pre></td></tr></table></figure>
<p>本示例中，重启这 2 个服务后，Pod 恢复正常。</p>
<h2 id="Pod-间歇性无法连接外部数据库"><a href="#Pod-间歇性无法连接外部数据库" class="headerlink" title="Pod 间歇性无法连接外部数据库"></a>Pod 间歇性无法连接外部数据库</h2><p>集群中的 Pod 出现连接集群之外的数据库服务超时，且出现频率较高</p>
<p><a href="https://blog.csdn.net/qq_42684642/article/details/105775436">参考文章</a></p>
<h1 id="集群状态异常"><a href="#集群状态异常" class="headerlink" title="集群状态异常"></a>集群状态异常</h1><h2 id="节点状态-NotReady"><a href="#节点状态-NotReady" class="headerlink" title="节点状态 NotReady"></a>节点状态 NotReady</h2><h3 id="PLEG-is-not-healthy-pleg-was-last-seen-active-10m13-755045415s-ago"><a href="#PLEG-is-not-healthy-pleg-was-last-seen-active-10m13-755045415s-ago" class="headerlink" title="PLEG is not healthy: pleg was last seen active 10m13.755045415s ago"></a>PLEG is not healthy: pleg was last seen active 10m13.755045415s ago</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get nodes</span></span><br><span class="line">NAME          STATUS     ROLES           AGE   VERSION</span><br><span class="line">k8s-master1   Ready      control-plane   14d   v1.24.7</span><br><span class="line">k8s-master2   Ready      control-plane   14d   v1.24.7</span><br><span class="line">k8s-master3   Ready      control-plane   14d   v1.24.7</span><br><span class="line">k8s-work1     NotReady   &lt;none&gt;          14d   v1.24.7</span><br><span class="line">k8s-work2     Ready      &lt;none&gt;          14d   v1.24.7</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看节点详细信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl describe node k8s-work1</span></span><br><span class="line">...</span><br><span class="line">Conditions:</span><br><span class="line">  Ready                False   Tue, 15 Nov 2022 10:14:49 +0800   Tue, 15 Nov 2022 10:07:39 +0800   KubeletNotReady              PLEG is not healthy: pleg was last seen active 10m13.755045415s ago; threshold is 3m0s</span><br></pre></td></tr></table></figure>

<h4 id="异常原因"><a href="#异常原因" class="headerlink" title="异常原因"></a>异常原因</h4><p>集群因为此原因（<code>PLEG is not healthy: pleg was last seen active ***h**m***s ago;</code>）状态变为 <code>NotReady</code>，通常是因为节点超负载。</p>
<h3 id="container-runtime-is-down-container-runtime-not-ready"><a href="#container-runtime-is-down-container-runtime-not-ready" class="headerlink" title="container runtime is down, container runtime not ready"></a>container runtime is down, container runtime not ready</h3><p><strong>排查过程</strong>：</p>
<p>检查集群中的 Pod 分布情况时，发现某一节点上几乎所有的 Pod 都被调度去了其他节点，当前检查时此节点的状态已经是 <code>Ready</code>，针对此情况进行分析。</p>
<ol>
<li><p>确定问题发生的大概时间段</p>
<p> 根据 Pod 在其他节点上面被启动的时间，可以大概确定节点异常的时间，根据此时间段可以缩小排查的时间范围。此示例中问题发生的时间大概在 <code>Nov 25 04:49:00</code> 前后。</p>
</li>
<li><p>检查 <code>kubelet</code> 日志</p>
<p> 根据已经推断出的时间段，在 <strong>问题节点</strong> 上，检查 <code>kubelet</code> 日志</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ journalctl -u kubelet --since &quot;2022-11-25 4:40&quot; | grep -v -e &quot;failed to get fsstats&quot; -e &quot;invalid bearer token&quot; | more</span><br><span class="line">Nov 25 04:49:00 k8s-work2 kubelet[17604]: E1125 04:49:00.153132   17604 generic.go:205] &quot;GenericPLEG: Unable to retrieve pods&quot; err=&quot;rpc error: code = Unknown desc = operation timeout: context deadline exceeded&quot;</span><br><span class="line">Nov 25 04:49:00 k8s-work2 kubelet[17604]: E1125 04:49:00.375524   17604 remote_runtime.go:356] &quot;ListPodSandbox with filter from runtime service failed&quot; err=&quot;rpc error: code = Unknown desc = operation timeout: context deadline exceeded&quot; filter=&quot;&amp;PodSandboxFilter&#123;Id:,State:&amp;PodSandboxStateValue&#123;State:SANDBOX_READY,&#125;,LabelSelector:map[string]string&#123;&#125;,&#125;&quot;</span><br><span class="line">Nov 25 04:49:00 k8s-work2 kubelet[17604]: E1125 04:49:00.375559   17604 kuberuntime_sandbox.go:292] &quot;Failed to list pod sandboxes&quot; err=&quot;rpc error: code = Unknown desc = operation timeout: context deadline exceeded&quot;</span><br><span class="line">Nov 25 04:49:00 k8s-work2 kubelet[17604]: E1125 04:49:00.375578   17604 kubelet_pods.go:1153] &quot;Error listing containers&quot; err=&quot;rpc error: code = Unknown desc = operation timeout: context deadline exceeded&quot;</span><br><span class="line">Nov 25 04:49:00 k8s-work2 kubelet[17604]: E1125 04:49:00.375589   17604 kubelet.go:2162] &quot;Failed cleaning pods&quot; err=&quot;rpc error: code = Unknown desc = operation timeout: context deadline exceeded&quot;</span><br><span class="line">Nov 25 04:49:00 k8s-work2 kubelet[17604]: E1125 04:49:00.375603   17604 kubelet.go:2166] &quot;Housekeeping took longer than 15s&quot; err=&quot;housekeeping took too long&quot; seconds=119.005290203</span><br><span class="line">Nov 25 04:49:00 k8s-work2 kubelet[17604]: E1125 04:49:00.476011   17604 kubelet.go:2010] &quot;Skipping pod synchronization&quot; err=&quot;container runtime is down&quot;</span><br><span class="line">Nov 25 04:49:00 k8s-work2 kubelet[17604]: E1125 04:49:00.507861   17604 remote_runtime.go:680] &quot;ExecSync cmd from runtime service failed&quot; err=&quot;rpc error: code = Unknown desc = operation timeout: context deadline exceeded&quot; containerID=&quot;5cd867ce2a52311e79a20a113c7cedd2a233b3a52b556065b479f2dd11a14eac&quot; cmd=[wget --no-check-certificate --spider -q http://localhost:8088/health]</span><br><span class="line">Nov 25 04:49:00 k8s-work2 kubelet[17604]: E1125 04:49:00.676271   17604 kubelet.go:2010] &quot;Skipping pod synchronization&quot; err=&quot;container runtime is down&quot;</span><br><span class="line"></span><br><span class="line">Nov 25 04:49:01 k8s-work2 kubelet[17604]: E1125 04:49:01.076918   17604 kubelet.go:2010] &quot;Skipping pod synchronization&quot; err=&quot;container runtime is down&quot;</span><br><span class="line">Nov 25 04:49:01 k8s-work2 kubelet[17604]: E1125 04:49:01.178942   17604 kubelet.go:2359] &quot;Container runtime not ready&quot; runtimeReady=&quot;RuntimeReady=false reason:DockerDaemonNotReady message:docker: failed to get docker version: operation timeout: context deadline exceeded&quot;</span><br><span class="line">Nov 25 04:49:01 k8s-work2 kubelet[17604]: E1125 04:49:01.878007   17604 kubelet.go:2010] &quot;Skipping pod synchronization&quot; err=&quot;[container runtime is down, container runtime not ready: RuntimeReady=false reason:DockerDaemonNotReady message:docker: failed to get docker version: operation timeout: context deadline exceeded]&quot;</span><br><span class="line">Nov 25 04:49:03 k8s-work2 kubelet[17604]: E1125 04:49:03.329558   17604 remote_runtime.go:536] &quot;ListContainers with filter from runtime service failed&quot; err=&quot;rpc error: code = Unknown desc = operation timeout: context deadline exceeded&quot; filter=&quot;&amp;ContainerFilter&#123;Id:,State:nil,PodSandboxId:,LabelSelector:map[string]string&#123;&#125;,&#125;&quot;</span><br><span class="line">Nov 25 04:49:03 k8s-work2 kubelet[17604]: E1125 04:49:03.329585   17604 container_log_manager.go:183] &quot;Failed to rotate container logs&quot; err=&quot;failed to list containers: rpc error: code = Unknown desc = operation timeout: context deadline exceeded&quot;</span><br><span class="line"></span><br><span class="line">Nov 25 04:49:09 k8s-work2 kubelet[17604]: E1125 04:49:09.485356   17604 remote_runtime.go:168] &quot;Version from runtime service failed&quot; err=&quot;rpc error: code = Unknown desc = failed to get docker version: operation timeout: context deadline exceeded&quot;</span><br><span class="line">Nov 25 04:49:09 k8s-work2 kubelet[17604]: I1125 04:49:09.485486   17604 setters.go:532] &quot;Node became not ready&quot; node=&quot;k8s-work2&quot; condition=&#123;Type:Ready Status:False LastHeartbeatTime:2022-11-25 04:49:09.485445614 +0800 CST m=+227600.229789769 LastTransitionTime:2022-11-25 04:49:09.485445614 +0800 CST m=+227600.229789769 Reason:KubeletNotReady Message:[container runtime is down, container runtime not ready: RuntimeReady=false reason:DockerDaemonNotReady message:docker: failed to get docker version: operation timeout: context deadline exceeded]&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p> 从以上日志中，可以看到关键的日志信息：</p>
<p> <code>&quot;Skipping pod synchronization&quot; err=&quot;container runtime is down&quot;</code></p>
<p> <code>setters.go:532] &quot;Node became not ready&quot;</code>，    <code>Reason:KubeletNotReady Message:[container runtime is down, container runtime not ready: RuntimeReady=false reason:DockerDaemonNotReady message:docker: failed to get docker version: operation timeout: context deadline exceeded]&#125;</code></p>
<p> 从以上日志信息可以看出，节点状态变为了 <code>not ready</code>，原因为 <code>container runtime is down, container runtime not ready</code>，本示例中 <code>container runtime</code> 为 <code>docker</code></p>
</li>
<li><p>检查 docker 服务日志</p>
<p> 根据上面的日志时间，检查 docker 服务的日志</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">journalctl -u docker --since &quot;2022-11-25 04:0&quot; | more</span><br><span class="line">Nov 25 04:49:06 k8s-work2 dockerd[15611]: http: superfluous response.WriteHeader call from github.com/docker/docker/api/server/httputils.WriteJSON (httputils_write_json.go:11)</span><br><span class="line">Nov 25 04:49:06 k8s-work2 dockerd[15611]: time=&quot;2022-11-25T04:49:06.410127201+08:00&quot; level=error msg=&quot;Handler for GET /v1.40/containers/5cd867ce2a52311e79a20a113c7cedd2a233b3a52b556065b479f2dd11a14eac/json returned error: write unix /var/run/docker.sock-&gt;@: write: broken pipe&quot;</span><br><span class="line">Nov 25 04:49:06 k8s-work2 dockerd[15611]: time=&quot;2022-11-25T04:49:06.410342223+08:00&quot; level=error msg=&quot;Handler for GET /v1.40/containers/41e0dfe97b87c2b8ae941653fa8adbf93bf9358d91e967646e4549ab71b2f004/json returned error: write unix /var/run/docker.sock-&gt;@: write: broken pipe&quot;</span><br><span class="line">Nov 25 04:49:06 k8s-work2 dockerd[15611]: http: superfluous response.WriteHeader call from github.com/docker/docker/api/server/httputils.WriteJSON (httputils_write_json.go:11)</span><br><span class="line">Nov 25 04:49:06 k8s-work2 dockerd[15611]: time=&quot;2022-11-25T04:49:06.414773158+08:00&quot; level=error msg=&quot;Handler for GET /v1.40/containers/json returned error: write unix /var/run/docker.sock-&gt;@: write: broken pipe&quot;</span><br><span class="line">Nov 25 04:49:06 k8s-work2 dockerd[15611]: http: superfluous response.WriteHeader call from github.com/docker/docker/api/server/httputils.WriteJSON (httputils_write_json.go:11)</span><br><span class="line">Nov 25 04:49:06 k8s-work2 dockerd[15611]: time=&quot;2022-11-25T04:49:06.416474238+08:00&quot; level=error msg=&quot;Handler for GET /v1.40/containers/json returned error: write unix /var/run/docker.sock-&gt;@: write: broken pipe&quot;</span><br><span class="line">Nov 25 04:49:06 k8s-work2 dockerd[15611]: http: superfluous response.WriteHeader call from github.com/docker/docker/api/server/httputils.WriteJSON (httputils_write_json.go:11)</span><br><span class="line">Nov 25 04:49:06 k8s-work2 dockerd[15611]: time=&quot;2022-11-25T04:49:06.422844592+08:00&quot; level=error msg=&quot;Handler for GET /v1.40/containers/json returned error: write unix /var/run/docker.sock-&gt;@: write: broken pipe&quot;</span><br></pre></td></tr></table></figure>
<p>根据日志可以看到关键日志 <code>write unix /var/run/docker.sock-&gt;@: write: broken pipe</code></p>
</li>
<li><p>检查 messages 日志</p>
<p> 查看对应时间段的系统日志</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Nov 25 04:49:00 k8s-work2 kubelet: E1125 04:49:00.153089   17604 remote_runtime.go:356] &quot;ListPodSandbox with filter from runtime service failed&quot; err=&quot;rpc error: code = Unknown desc = operation timeout: context deadline exceeded&quot; filter=&quot;nil&quot;</span><br><span class="line">Nov 25 04:49:00 k8s-work2 kubelet: E1125 04:49:00.375603   17604 kubelet.go:2166] &quot;Housekeeping took longer than 15s&quot; err=&quot;housekeeping took too long&quot; seconds=119.005290203</span><br><span class="line">Nov 25 04:49:00 k8s-work2 kubelet: E1125 04:49:00.375614   17604 kubelet.go:2010] &quot;Skipping pod synchronization&quot; err=&quot;container runtime is down&quot;</span><br><span class="line">Nov 25 04:49:01 k8s-work2 kubelet: E1125 04:49:01.178942   17604 kubelet.go:2359] &quot;Container runtime not ready&quot; runtimeReady=&quot;RuntimeReady=false reason:DockerDaemonNotReady message:docker: failed to get docker version: operation timeout: context deadline exceeded&quot;</span><br><span class="line">Nov 25 04:49:01 k8s-work2 kubelet: E1125 04:49:01.878007   17604 kubelet.go:2010] &quot;Skipping pod synchronization&quot; err=&quot;[container runtime is down, container runtime not ready: RuntimeReady=false reason:DockerDaemonNotReady message:docker: failed to get docker version: operation timeout: context deadline exceeded]&quot;</span><br><span class="line">Nov 25 04:49:06 k8s-work2 dockerd: time=&quot;2022-11-25T04:49:06.410127201+08:00&quot; level=error msg=&quot;Handler for GET /v1.40/containers/5cd867ce2a52311e79a20a113c7cedd2a233b3a52b556065b479f2dd11a14eac/json returned error: write unix /var/run/docker.sock-&gt;@: write: broken pipe&quot;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>根据 <code>kubelet</code> 服务日志，节点 <code>Not Ready</code> 的原因为 <code>docker down</code>，根据 docker 服务日志，docker 存在异常，但是此时执行 <code>docker</code> 相关命令，未发现异常。此问题多次出现，<code>docker engine</code> 版本为 <code>19.03.15-3</code>，之后尝试将 <code>docker engine</code> 版本升级为最新版本 <code>20.10.9</code>，问题未在出现。<a href="https://csms.tech/202208041317/#docker-ce-19-03-15-升级到-docker-ce-20-10-9"><code>docker engine</code> 升级参考</a> </p>
<h2 id="api-server-启动失败"><a href="#api-server-启动失败" class="headerlink" title="api-server 启动失败"></a>api-server 启动失败</h2><h3 id="错误场景"><a href="#错误场景" class="headerlink" title="错误场景"></a>错误场景</h3><p>api server 启动失败，执行 <code>kubectl</code> 命令输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get nodes</span></span><br><span class="line">The connection to the server kube-apiserver.uat.148962587001:6443 was refused - did you specify the right host or port?</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>检查 Api Server 监听的端口 6443 ，显示端口未启动。</p>
<p>检查 Api Server 对应的容器状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker ps -a | grep api</span></span><br><span class="line">81688b9cbe45  1f38c0b6a9d1   &quot;kube-apiserver --ad…&quot;   14 seconds ago      Exited (1) 13 seconds ago                       k8s_kube-apiserver_kube-apiserver-k8s-uat-master1.148962587001_kube-system_c8a87f4921623c7bff57f5662ea486cc_25</span><br></pre></td></tr></table></figure>

<p>容器状态为 <code>Exited</code>，检查容器日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker logs 81688b9cbe45</span></span><br><span class="line">I1116 07:43:53.775588       1 server.go:558] external host was not specified, using 172.31.30.123</span><br><span class="line">I1116 07:43:53.776035       1 server.go:158] Version: v1.24.7</span><br><span class="line">I1116 07:43:53.776057       1 server.go:160] &quot;Golang settings&quot; GOGC=&quot;&quot; GOMAXPROCS=&quot;&quot; GOTRACEBACK=&quot;&quot;</span><br><span class="line">E1116 07:43:53.776298       1 run.go:74] &quot;command failed&quot; err=&quot;open /etc/kubernetes/pki/apiserver.crt: no such file or directory&quot;</span><br></pre></td></tr></table></figure>
<p>日志显示 <code>err=&quot;open /etc/kubernetes/pki/apiserver.crt: no such file or directory&quot;</code>，检查文件 <code>/etc/kubernetes/pki/apiserver.crt</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> /etc/kubernetes/pki/apiserver.crt</span></span><br><span class="line">ls: cannot access /etc/kubernetes/pki/apiserver.crt: No such file or directory</span><br></pre></td></tr></table></figure>

<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ul>
<li>发现此文件确实不存在。若有备份，从备份中恢复此文件。如果没有备份，<a href="https://cloud.tencent.com/developer/article/1801882">参考文档</a> 恢复证书<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /k8s/backup/pki/apiserver.key /etc/kubernetes/pki/</span><br><span class="line">cp /k8s/backup/pki/apiserver.crt /etc/kubernetes/pki/</span><br></pre></td></tr></table></figure>
重启 <code>kubelet</code> 后检查 Api Server，发现服务正常启动<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart kubelet</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>如果只是缺少了 <code>apiserver.key</code>，<code>apiserver.crt</code> 证书文件，可通过以下命令重新生成证书文件，<a href="https://csms.tech/202209121102/#集群之外的服务器使用-kubectl-报错">生成原理参考</a><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubeadm init phase certs apiserver \</span></span><br><span class="line"><span class="language-bash">     --apiserver-advertise-address  10.150.0.21 \</span></span><br><span class="line"><span class="language-bash">     --apiserver-cert-extra-sans  10.96.0.1 \</span></span><br><span class="line"><span class="language-bash">     --apiserver-cert-extra-sans 34.150.1.1</span></span><br><span class="line"> </span><br><span class="line">[certs] Generating &quot;apiserver&quot; certificate and key</span><br><span class="line">[certs] apiserver serving cert is signed for DNS names [k8s-master kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.96.0.1 10.150.0.21 34.150.1.1]</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="Ingress-接入异常"><a href="#Ingress-接入异常" class="headerlink" title="Ingress 接入异常"></a>Ingress 接入异常</h1><h2 id="503-Service-Temporarily-Unavailable"><a href="#503-Service-Temporarily-Unavailable" class="headerlink" title="503 Service Temporarily Unavailable"></a>503 Service Temporarily Unavailable</h2><p><code>Deployment</code>，<code>Service</code>，<code>Ingress</code> 部署后，通过 <code>Ingress</code> 配置的域名访问，显示 <code>503 Service Temporarily Unavailable</code><br><img src="https://i.csms.tech/img_110.png"></p>
<p><strong>排查步骤</strong></p>
<p>检查 <code>Ingress-Nginx</code> Pod 的日志，检索对应域名日志，显示返回码为 503</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">52.77.198.154 - - [15/Dec/2022:02:10:59 +0000] &quot;GET /graph HTTP/1.1&quot; 503 592 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36&quot; 507 0.000 [prometheus-prometheus-service-8080] [] - - - - 00b07fe234401054153fdbd0ffafb158</span><br></pre></td></tr></table></figure>

<p>查看 Ingress 对应的 <code>Service</code>，从以下输出中可以看到对应的 <code>Service</code> 为 <code>prometheus-service</code>，端口为 8080</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get ingress -n prometheus -o wide</span></span><br><span class="line">NAME            CLASS   HOSTS                     ADDRESS                      PORTS   AGE</span><br><span class="line">prometheus-ui   nginx   prometheus.example.com    172.31.23.72,172.31.27.193   80      19h</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl describe ingress prometheus-ui -n prometheus</span> </span><br><span class="line">Name:             prometheus-ui</span><br><span class="line">Labels:           &lt;none&gt;</span><br><span class="line">Namespace:        prometheus</span><br><span class="line">Address:          172.31.23.72,172.31.27.193</span><br><span class="line">Ingress Class:    nginx</span><br><span class="line">Default backend:  &lt;default&gt;</span><br><span class="line">Rules:</span><br><span class="line">  Host                     Path  Backends</span><br><span class="line">  ----                     ----  --------</span><br><span class="line">  prometheus.example.com  </span><br><span class="line">                           /   prometheus-service:8080 ()</span><br><span class="line">Annotations:               field.cattle.io/publicEndpoints:</span><br><span class="line">                             [&#123;&quot;addresses&quot;:[&quot;172.31.23.72&quot;,&quot;172.31.27.193&quot;],&quot;port&quot;:80,&quot;protocol&quot;:&quot;HTTP&quot;,&quot;serviceName&quot;:&quot;prometheus:prometheus-service&quot;,&quot;ingressName&quot;:&quot;pr...</span><br><span class="line">Events:                    &lt;none&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看 <code>Service</code> 信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get services -n prometheus -o wide</span></span><br><span class="line">NAME                 TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)    AGE   SELECTOR</span><br><span class="line">prometheus-service   ClusterIP   10.99.75.232   &lt;none&gt;        8090/TCP   19h   app=prometheus-server</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl describe service -n prometheus prometheus-service</span></span><br><span class="line">Name:              prometheus-service</span><br><span class="line">Namespace:         prometheus</span><br><span class="line">Labels:            &lt;none&gt;</span><br><span class="line">Annotations:       &lt;none&gt;</span><br><span class="line">Selector:          app=prometheus-server</span><br><span class="line">Type:              ClusterIP</span><br><span class="line">IP Family Policy:  SingleStack</span><br><span class="line">IP Families:       IPv4</span><br><span class="line">IP:                10.99.75.232</span><br><span class="line">IPs:               10.99.75.232</span><br><span class="line">Port:              prometheus-port  8090/TCP</span><br><span class="line">TargetPort:        9090/TCP</span><br><span class="line">Endpoints:         10.244.3.95:9090</span><br><span class="line">Session Affinity:  None</span><br><span class="line">Events:            &lt;none&gt;</span><br></pre></td></tr></table></figure>
<p>从以上信息可以看到，**服务的端口为 <code>Port:              prometheus-port  8090/TCP</code>，而 Ingress 中配置的服务端口为 <code>8080</code>**，修改 Ingress 配置，将服务端口修改正确。修改后访问正常。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://cloud.tencent.com/developer/article/1456389">相关参考</a></p>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://cloud.tencent.com/developer/article/1931089">Back-off restarting failed container 怎么办</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://tonybai.com/2017/10/16/out-of-node-resource-handling-in-kubernetes-cluster/">ephemeral-storage 问题</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes 配置文件说明</title>
    <url>/202211291130/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos7 5.4.212-1</li>
<li>Docker 20.10.18</li>
<li>containerd.io-1.6.8</li>
<li>kubectl-1.25.0</li>
<li>kubeadm-1.25.0</li>
<li>kubelet-1.25.0</li>
<li>kube-flannel</li>
</ul>
<h1 id="常见配置文件说明"><a href="#常见配置文件说明" class="headerlink" title="常见配置文件说明"></a>常见配置文件说明</h1><table>
<thead>
<tr>
<th>文件&#x2F;目录</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>/etc/kubernetes/&#123;admin.conf, controller-manager.conf, kubelet.conf, scheduler.conf &#125;</code></td>
<td>master 管理节点上的管理节点（<code>admin</code>，<code>controller-manager</code>，<code>kubelet</code>，<code>scheduler</code>）配置文件 <br/><code>admin</code> 配置文件具有全局管理员权限，可以跳过 RBAC 权限控制系统，应该禁止其共享。</td>
<td></td>
</tr>
<tr>
<td><code>/etc/kubernetes/kubelet.conf</code></td>
<td>worker 节点上，<code>kubelet</code> 配置文件</td>
<td></td>
</tr>
<tr>
<td><code>/etc/kubernetes/manifests/</code></td>
<td>管理节点上，管理节点的启动参数配置文件，主要包括 <code>etcd.yaml</code>，  <code>kube-apiserver.yaml</code>，  <code>kube-controller-manager.yaml</code>，  <code>kube-scheduler.yaml</code>。是静态 Pod 的主要配置路径</td>
<td></td>
</tr>
<tr>
<td><code>/etc/kubernetes/pki/</code></td>
<td>- 管理节点上，存放所有节点之间的通信证书文件， <br/>- worker 节点上，存放集群 CA 证书文件。  只有 <code>ca.crt</code></td>
<td></td>
</tr>
<tr>
<td><code>/etc/cni/net.d/10-flannel.conflist</code></td>
<td>管理节点上，<code>flannel</code> 配置文件</td>
<td></td>
</tr>
</tbody></table>
<span id="more"></span>]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes ConfigMap 使用说明</title>
    <url>/202212071353/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Kubernetes 1.24</li>
</ul>
<p><code>ConfigMap</code> 是 Kubernetes 用来向应用 Pod 中注入配置数据的方法。<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[配置 Pod 使用 ConfigMap](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-pod-configmap/)">[1]</span></a></sup></p>
<h1 id="使用-ConfigMap-数据定义容器环境变量"><a href="#使用-ConfigMap-数据定义容器环境变量" class="headerlink" title="使用 ConfigMap 数据定义容器环境变量"></a>使用 ConfigMap 数据定义容器环境变量</h1><h2 id="使用单个-ConfigMap-中的数据定义容器环境变量"><a href="#使用单个-ConfigMap-中的数据定义容器环境变量" class="headerlink" title="使用单个 ConfigMap 中的数据定义容器环境变量"></a>使用单个 ConfigMap 中的数据定义容器环境变量</h2><ol>
<li>在 <code>ConfigMap</code> 中将环境变量定义为键值对: <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create configmap special-config --from-literal=special.how=very</span><br></pre></td></tr></table></figure></li>
<li>将 ConfigMap 中定义的 special.how 赋值给 Pod 规约中的 SPECIAL_LEVEL_KEY 环境变量。 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">   </span><br><span class="line">kind: Pod</span><br><span class="line">   </span><br><span class="line">metadata:</span><br><span class="line">   </span><br><span class="line">  name: dapi-test-pod</span><br><span class="line">   </span><br><span class="line">spec:</span><br><span class="line">   </span><br><span class="line">  containers:</span><br><span class="line">   </span><br><span class="line">    - name: test-container</span><br><span class="line">   </span><br><span class="line">      image: registry.k8s.io/busybox</span><br><span class="line">   </span><br><span class="line">      command: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;env&quot; ]</span><br><span class="line">   </span><br><span class="line">      env:</span><br><span class="line">   </span><br><span class="line">        # 定义环境变量</span><br><span class="line">   </span><br><span class="line">        - name: SPECIAL_LEVEL_KEY</span><br><span class="line">   </span><br><span class="line">          valueFrom:</span><br><span class="line">   </span><br><span class="line">            configMapKeyRef:</span><br><span class="line">   </span><br><span class="line">              # ConfigMap 包含你要赋给 SPECIAL_LEVEL_KEY 的值</span><br><span class="line">   </span><br><span class="line">              name: special-config</span><br><span class="line">   </span><br><span class="line">              # 指定与取值相关的键名</span><br><span class="line">   </span><br><span class="line">              key: special.how</span><br><span class="line">   </span><br><span class="line">  restartPolicy: Never</span><br></pre></td></tr></table></figure>
 现在，Pod 的输出包含环境变量 <code>SPECIAL_LEVEL_KEY=very</code>。</li>
</ol>
<span id="more"></span>

<h2 id="使用来自多个-ConfigMap-的数据定义容器环境变量"><a href="#使用来自多个-ConfigMap-的数据定义容器环境变量" class="headerlink" title="使用来自多个 ConfigMap 的数据定义容器环境变量"></a>使用来自多个 ConfigMap 的数据定义容器环境变量</h2><p>创建 <code>ConfigMap</code> <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[使用来自多个 ConfigMap 的数据定义容器环境变量](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-pod-configmap/#define-container-environment-variables-with-data-from-multiple-configmaps)">[2]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">  </span><br><span class="line">kind: ConfigMap</span><br><span class="line">  </span><br><span class="line">metadata:</span><br><span class="line">  </span><br><span class="line">  name: special-config</span><br><span class="line">  </span><br><span class="line">  namespace: default</span><br><span class="line">  </span><br><span class="line">data:</span><br><span class="line">  </span><br><span class="line">  special.how: very</span><br><span class="line">  </span><br><span class="line">---</span><br><span class="line">  </span><br><span class="line">apiVersion: v1</span><br><span class="line">  </span><br><span class="line">kind: ConfigMap</span><br><span class="line">  </span><br><span class="line">metadata:</span><br><span class="line">  </span><br><span class="line">  name: env-config</span><br><span class="line">  </span><br><span class="line">  namespace: default</span><br><span class="line">  </span><br><span class="line">data:</span><br><span class="line">  </span><br><span class="line">  log_level: INFO</span><br></pre></td></tr></table></figure>
<p>在 Pod 规约中定义环境变量。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">  </span><br><span class="line">kind: Pod</span><br><span class="line">  </span><br><span class="line">metadata:</span><br><span class="line">  </span><br><span class="line">  name: dapi-test-pod</span><br><span class="line">  </span><br><span class="line">spec:</span><br><span class="line">  </span><br><span class="line">  containers:</span><br><span class="line">  </span><br><span class="line">    - name: test-container</span><br><span class="line">  </span><br><span class="line">      image: registry.k8s.io/busybox</span><br><span class="line">  </span><br><span class="line">      command: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;env&quot; ]</span><br><span class="line">  </span><br><span class="line">      env:</span><br><span class="line">  </span><br><span class="line">        - name: SPECIAL_LEVEL_KEY</span><br><span class="line">  </span><br><span class="line">          valueFrom:</span><br><span class="line">  </span><br><span class="line">            configMapKeyRef:</span><br><span class="line">  </span><br><span class="line">              name: special-config</span><br><span class="line">  </span><br><span class="line">              key: special.how</span><br><span class="line">  </span><br><span class="line">        - name: LOG_LEVEL</span><br><span class="line">  </span><br><span class="line">          valueFrom:</span><br><span class="line">  </span><br><span class="line">            configMapKeyRef:</span><br><span class="line">  </span><br><span class="line">              name: env-config</span><br><span class="line">  </span><br><span class="line">              key: log_level</span><br><span class="line">  </span><br><span class="line">  restartPolicy: Never</span><br></pre></td></tr></table></figure>
<h2 id="将-ConfigMap-中的所有键值对配置为容器环境变量"><a href="#将-ConfigMap-中的所有键值对配置为容器环境变量" class="headerlink" title="将 ConfigMap 中的所有键值对配置为容器环境变量"></a>将 ConfigMap 中的所有键值对配置为容器环境变量</h2><p>创建一个包含多个键值对的 ConfigMap。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">  </span><br><span class="line">kind: ConfigMap</span><br><span class="line">  </span><br><span class="line">metadata:</span><br><span class="line">  </span><br><span class="line">  name: special-config</span><br><span class="line">  </span><br><span class="line">  namespace: default</span><br><span class="line">  </span><br><span class="line">data:</span><br><span class="line">  </span><br><span class="line">  SPECIAL_LEVEL: very</span><br><span class="line">  </span><br><span class="line">  SPECIAL_TYPE: charm</span><br></pre></td></tr></table></figure>
<p>使用 <code>envFrom</code> 将所有 <code>ConfigMap</code> 的数据定义为容器环境变量，<code>ConfigMap</code> 中的键成为 Pod 中的环境变量名称。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">  </span><br><span class="line">kind: Pod</span><br><span class="line">  </span><br><span class="line">metadata:</span><br><span class="line">  </span><br><span class="line">  name: dapi-test-pod</span><br><span class="line">  </span><br><span class="line">spec:</span><br><span class="line">  </span><br><span class="line">  containers:</span><br><span class="line">  </span><br><span class="line">    - name: test-container</span><br><span class="line">  </span><br><span class="line">      image: registry.k8s.io/busybox</span><br><span class="line">  </span><br><span class="line">      command: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;env&quot; ]</span><br><span class="line">  </span><br><span class="line">      envFrom:</span><br><span class="line">  </span><br><span class="line">      - configMapRef:</span><br><span class="line">  </span><br><span class="line">          name: special-config</span><br><span class="line">  </span><br><span class="line">  restartPolicy: Never</span><br></pre></td></tr></table></figure>

<h2 id="将-ConfigMap-内容挂载到容器中的文件"><a href="#将-ConfigMap-内容挂载到容器中的文件" class="headerlink" title="将 ConfigMap 内容挂载到容器中的文件"></a>将 ConfigMap 内容挂载到容器中的文件</h2><h3 id="创建-ConfigMap"><a href="#创建-ConfigMap" class="headerlink" title="创建 ConfigMap"></a>创建 ConfigMap</h3><h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-pod-configmap/">配置 Pod 使用 ConfigMap</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-pod-configmap/#define-container-environment-variables-with-data-from-multiple-configmaps">使用来自多个 ConfigMap 的数据定义容器环境变量</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>ingress-nginx 安装配置</title>
    <url>/202209301604/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h2><ul>
<li>Centos7 5.4.212-1</li>
<li>Docker 20.10.18</li>
<li>containerd.io-1.6.8</li>
<li>kubectl-1.25.0</li>
<li>kubeadm-1.25.0</li>
<li>kubelet-1.25.0</li>
</ul>
<h2 id="安装-ingress-nginx-controller"><a href="#安装-ingress-nginx-controller" class="headerlink" title="安装 ingress-nginx controller"></a>安装 ingress-nginx controller</h2><p>此文档中的配置主要针对基于部署在裸机（安装通用 Linux 发行版的物理机或者云主机系统）上的 Kebernetes 集群</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.3.1/deploy/static/provider/cloud/deploy.yaml</span><br><span class="line">mv deploy.yaml ingress-nginx-controller-v1.3.1.yaml</span><br></pre></td></tr></table></figure>

<h3 id="基于-hostNetwork-的-ingress-nginx-controller"><a href="#基于-hostNetwork-的-ingress-nginx-controller" class="headerlink" title="基于 hostNetwork 的 ingress-nginx controller"></a>基于 hostNetwork 的 ingress-nginx controller</h3><p>编辑 <code>ingress-nginx-controller</code> 的 <code>Deployment</code> 配置文件，在 <code>Deployment</code> 中的 <code>.spec.template.spec</code> 下添加字段 <code>hostNetwork: true</code>，以使 <code>ingress-nginx-controller</code> 可以使用节点的主机网络提供对外访问<br><img src="https://i.csms.tech/img_61.png"></p>
<span id="more"></span>

<p>默认情况下，使用了 <code>hostNetwork: true</code> 配置的 <code>Pod</code>，无法使用集群内部的 DNS （如 <code>CoreDNS</code>）进行域名解析，除非 <code>dnsPolicy</code> 字段配置值为 <code>ClusterFirstWithHostNet</code>。</p>
<p>如果 <code>ingress-nginx-controller</code> 需要解析集群内部的域名，需要在 <code>Deployment</code> 中的 <code>.spec.template.spec</code> 修改以下配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dnsPolicy: ClusterFirstWithHostNet</span><br></pre></td></tr></table></figure>


<p>此种模式之下，<code>ingress-nginx-controller</code> 的 <code>Pod</code> 会绑定主机端口的 80 和 443 端口。此方式不需要创建暴露 <code>ingress-nginx-controller</code> 的 <code>Service</code>，如果有，建议删除<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Via the host network](https://kubernetes.github.io/ingress-nginx/deploy/baremetal/#via-the-host-network)">[1]</span></a></sup> </p>
<figure class="highlight shell"><figcaption><span>ingress-nginx-controller-v1.3.1.yaml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">---</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">apiVersion: v1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">kind: Service</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">metadata:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> labels:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   app.kubernetes.io/component: controller</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   app.kubernetes.io/instance: ingress-nginx</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   app.kubernetes.io/name: ingress-nginx</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   app.kubernetes.io/part-of: ingress-nginx</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   app.kubernetes.io/version: 1.3.1</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> name: ingress-nginx-controller</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> namespace: ingress-nginx</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">spec:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> externalTrafficPolicy: Local</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> ipFamilies:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> - IPv4</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> ipFamilyPolicy: SingleStack</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> ports:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> - appProtocol: http</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   name: http</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   port: 80</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   protocol: TCP</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   targetPort: http</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> - appProtocol: https</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   name: https</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   port: 443</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   protocol: TCP</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   targetPort: https</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> selector:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   app.kubernetes.io/component: controller</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   app.kubernetes.io/instance: ingress-nginx</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   app.kubernetes.io/name: ingress-nginx</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> <span class="built_in">type</span>: LoadBalancer</span></span><br></pre></td></tr></table></figure>

<p>在没有 <code>Service</code> 暴露 <code>ingress-nginx-controller</code> 的 <code>Pod</code> 情况下，容器启动参数中的 <code>--publish-service</code> 将会为空（未使用），需要注释或删除此启动参数。部署之后 <code>Ingress</code> 对象中的 <code>ADDRESS</code> 将为空</p>
<figure class="highlight shell"><figcaption><span>Deployment.spec.template.spec.containers[*].args</span></figcaption><table><tr><td class="code"><pre><span class="line">spec:</span><br><span class="line">  hostNetwork: true</span><br><span class="line">  containers:</span><br><span class="line">  - args:</span><br><span class="line">    - /nginx-ingress-controller</span><br><span class="line">    #- --publish-service=$(POD_NAMESPACE)/ingress-nginx-controller</span><br><span class="line">    - --election-id=ingress-controller-leader</span><br><span class="line">    - --controller-class=k8s.io/ingress-nginx</span><br><span class="line">    - --ingress-class=nginx</span><br><span class="line">    - --configmap=$(POD_NAMESPACE)/ingress-nginx-controller</span><br><span class="line">    - --validating-webhook=:8443</span><br><span class="line">    - --validating-webhook-certificate=/usr/local/certificates/cert</span><br><span class="line">    - --validating-webhook-key=/usr/local/certificates/key</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>部署成功后，查看 <code>Service</code> 对象，结果中不包含 <code>service/ingress-nginx-controller</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get services -n ingress-nginx</span></span><br><span class="line">NAME                                 TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">ingress-nginx-controller-admission   ClusterIP   10.103.195.162   &lt;none&gt;        443/TCP   39s</span><br></pre></td></tr></table></figure>
<p>查看 <code>Ingress</code> 对象，<code>ADDRESS</code> 为空</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get ingress -A</span></span><br><span class="line">NAMESPACE   NAME              CLASS   HOSTS          ADDRESS   PORTS   AGE</span><br><span class="line">default     example-ingress   nginx   cs1.k8s.info             80      26h</span><br></pre></td></tr></table></figure>
<p>如果希望显示节点 IP 地址，可以为容器添加启动参数 <code>- --report-node-internal-ip-address</code></p>
<figure class="highlight shell"><figcaption><span>Deployment.spec.template.spec.containers[*].args</span></figcaption><table><tr><td class="code"><pre><span class="line">spec:</span><br><span class="line">  hostNetwork: true</span><br><span class="line">  containers:</span><br><span class="line">  - args:</span><br><span class="line">    - /nginx-ingress-controller</span><br><span class="line">    #- --publish-service=$(POD_NAMESPACE)/ingress-nginx-controller</span><br><span class="line">    - --election-id=ingress-controller-leader</span><br><span class="line">    - --controller-class=k8s.io/ingress-nginx</span><br><span class="line">    - --ingress-class=nginx</span><br><span class="line">    - --configmap=$(POD_NAMESPACE)/ingress-nginx-controller</span><br><span class="line">    - --validating-webhook=:8443</span><br><span class="line">    - --validating-webhook-certificate=/usr/local/certificates/cert</span><br><span class="line">    - --validating-webhook-key=/usr/local/certificates/key</span><br><span class="line">    - --report-node-internal-ip-address</span><br></pre></td></tr></table></figure>
<p>成功部署后，再次查看 <code>Ingress</code> 资源，<code>ADDRESS</code> 会上报节点的 IP</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get ingress -o wide</span></span><br><span class="line">NAME              CLASS   HOSTS          ADDRESS        PORTS   AGE</span><br><span class="line">example-ingress   nginx   cs1.k8s.info   172.31.0.230   80      27h</span><br></pre></td></tr></table></figure>

<p>此种模式下，集群中的每个节点上，只能有一个 <code>ingress-nginx-controller</code> 的 <code>Pod</code> 存在，因为不可能让同一个端口绑定多次。为了确保每个节点上只能调度一个 <code>ingress-nginx-controller</code> ，可以使用 <code>DaemonSet</code> 代替 <code>Deployment</code> 的方式来部署 <code>ingress-nginx-controller</code></p>
<p>默认情况下，<code>ingress-nginx-controller</code> 日志输出到 <code>stdout</code>，可以添加启动参数 <code>--log_dir=/var/log/nginx/</code> 指定日志输出目录</p>
<figure class="highlight shell"><figcaption><span>Deployment.spec.template.spec.containers[*].args</span></figcaption><table><tr><td class="code"><pre><span class="line">spec:</span><br><span class="line">  hostNetwork: true</span><br><span class="line">  containers:</span><br><span class="line">  - args:</span><br><span class="line">    - /nginx-ingress-controller</span><br><span class="line">    #- --publish-service=$(POD_NAMESPACE)/ingress-nginx-controller</span><br><span class="line">    - --election-id=ingress-controller-leader</span><br><span class="line">    - --controller-class=k8s.io/ingress-nginx</span><br><span class="line">    - --ingress-class=nginx</span><br><span class="line">    - --configmap=$(POD_NAMESPACE)/ingress-nginx-controller</span><br><span class="line">    - --validating-webhook=:8443</span><br><span class="line">    - --validating-webhook-certificate=/usr/local/certificates/cert</span><br><span class="line">    - --validating-webhook-key=/usr/local/certificates/key</span><br><span class="line">    - --report-node-internal-ip-address</span><br><span class="line">    </span><br><span class="line">    # controller 日志选项</span><br><span class="line">    - --log_dir=/var/log/nginx/</span><br><span class="line">    - --logtostderr=false</span><br></pre></td></tr></table></figure>
<p>修改配置后，使用以下命令使配置生效：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl apply -f ingress-nginx-controller-v1.3.1.yaml</span><br></pre></td></tr></table></figure>
<p>使用以下命令删除此配置部署得相关资源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl delete -f ingress-nginx-controller-v1.3.1.yaml</span><br></pre></td></tr></table></figure>

<h2 id="ingress-nginx-相关配置"><a href="#ingress-nginx-相关配置" class="headerlink" title="ingress-nginx 相关配置"></a>ingress-nginx 相关配置</h2><p>自定义 nginx 配置，可以使用以下 3 种方式</p>
<ul>
<li><code>ConfigMap</code> - 使用 <code>Configmap</code> 配置部署 nginx 全局配置</li>
<li><code>Annotations</code> - 使用 <code>Annotations</code> 为特定的 <code>Ingress rule</code> 部署个性化的配置</li>
<li><code>Custom template</code> -</li>
</ul>
<h3 id="Annotations-配置说明"><a href="#Annotations-配置说明" class="headerlink" title="Annotations 配置说明"></a>Annotations 配置说明</h3><p><strong><code>Annotation</code> 配置中，<code>key</code> 和 <code>value</code> 只能是字符串类型的值</strong>。 </p>
<h4 id="rewrite-target"><a href="#rewrite-target" class="headerlink" title="rewrite-target"></a>rewrite-target</h4><p><code>rewrite-target</code> 示例 <sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Rewrite Target](https://kubernetes.github.io/ingress-nginx/examples/rewrite/#examples)">[3]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    nginx.ingress.kubernetes.io/rewrite-target: /$2</span><br><span class="line">  name: rewrite</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  ingressClassName: nginx</span><br><span class="line">  rules:</span><br><span class="line">  - host: rewrite.bar.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path: /something(/|$)(.*)</span><br><span class="line">        pathType: Prefix</span><br><span class="line">        backend:</span><br><span class="line">          service:</span><br><span class="line">            name: http-svc</span><br><span class="line">            port: </span><br><span class="line">              number: 80</span><br></pre></td></tr></table></figure>
<p><code>path</code> 中捕获到的匹配组会被分别放置在 <code>$1</code>,<code>$2</code>,’$3’…<code>$n</code>，可在 <code>rewrite-target</code> 中使用</p>
<p>本示例中，会产生如下效果：</p>
<ul>
<li><code>rewrite.bar.com/something</code> rewrites to <code>rewrite.bar.com/</code></li>
<li><code>rewrite.bar.com/something/</code> rewrites to <code>rewrite.bar.com/</code></li>
<li><code>rewrite.bar.com/something/new</code> rewrites to <code>rewrite.bar.com/new</code></li>
</ul>
<h4 id="app-root"><a href="#app-root" class="headerlink" title="app-root"></a>app-root</h4><p>将 <code>path</code> 中的 <code>/</code> 重写为 <code>nginx.ingress.kubernetes.io/app-root</code> 定义的内容 <sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[App Root](https://kubernetes.github.io/ingress-nginx/examples/rewrite/#app-root)">[4]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    nginx.ingress.kubernetes.io/app-root: /app1</span><br><span class="line">  name: approot</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  ingressClassName: nginx</span><br><span class="line">  rules:</span><br><span class="line">  - host: approot.bar.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path: /</span><br><span class="line">        pathType: Prefix</span><br><span class="line">        backend:</span><br><span class="line">          service:</span><br><span class="line">            name: http-svc</span><br><span class="line">            port: </span><br><span class="line">              number: 80</span><br></pre></td></tr></table></figure>
<p>验证结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -I -k http://approot.bar.com/</span></span><br><span class="line">HTTP/1.1 302 Moved Temporarily</span><br><span class="line">Server: nginx/1.11.10</span><br><span class="line">Date: Mon, 13 Mar 2017 14:57:15 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 162</span><br><span class="line">Location: http://approot.bar.com/app1</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>

<h4 id="ssl-redirect"><a href="#ssl-redirect" class="headerlink" title="ssl-redirect"></a>ssl-redirect</h4><p>默认情况下，如果 <code>Ingress</code> 中配置了 tls ，HTTP 请求会被重定向到 HTTPS （308），要更改此行为，可以配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx.ingress.kubernetes.io/ssl-redirect: &quot;false&quot;</span><br></pre></td></tr></table></figure>

<h4 id="Redirect-from-x2F-to-www"><a href="#Redirect-from-x2F-to-www" class="headerlink" title="Redirect from&#x2F;to www"></a>Redirect from&#x2F;to www</h4><p>将 <code>www.domain.com</code> 重定向到 <code>domain.com</code>，或者将 <code>domain.com</code> 重定向到 <code>www.domain.com</code> <sup id="fnref:7"><a href="#fn:7" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Redirect from/to www](https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#redirect-fromto-www)">[7]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx.ingress.kubernetes.io/from-to-www-redirect: &quot;true&quot;</span><br></pre></td></tr></table></figure>

<h4 id="Session-Affinity"><a href="#Session-Affinity" class="headerlink" title="Session Affinity"></a>Session Affinity</h4><ul>
<li><code>nginx.ingress.kubernetes.io/affinity: cookie</code><br>会话亲和性，会话保持。<code>ingress-nginx</code> 支持的值唯有 <code>cookie</code> <sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Session Affinity](https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#session-affinity)">[5]</span></a></sup></li>
<li><code>nginx.ingress.kubernetes.io/affinity-mode</code><br>定义会话保持的黏合程度。可取以下值：<ul>
<li><code>balanced</code> - <code>Pod</code> 扩容或缩减后重新分配 sessions</li>
<li><code>persistent</code> - <code>Pod</code> 扩容或缩减后依旧保持会话，不重新分配 sessions</li>
</ul>
</li>
</ul>
<h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><p>跨域相关配置 <sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Enable CORS](https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#enable-cors)">[6]</span></a></sup></p>
<table>
<thead>
<tr>
<th>key</th>
<th>value</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>cors-allow-methods</code></td>
<td>默认值 <code>GET, PUT, POST, DELETE, PATCH, OPTIONS</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>cors-allow-headers</code></td>
<td>Default: <code>DNT,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>cors-allow-origin</code></td>
<td>Default: <code>*</code></td>
<td></td>
<td><code>nginx.ingress.kubernetes.io/cors-allow-origin: &quot;https://origin-site.com:4443, http://origin-site.com, https://example.org:1199&quot;</code></td>
</tr>
</tbody></table>
<h4 id="Server-snippet"><a href="#Server-snippet" class="headerlink" title="Server snippet"></a>Server snippet</h4><p>通过此配置，可以添加自定义配置到 nginx 的 <code>server</code> 配置中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    nginx.ingress.kubernetes.io/server-snippet: |</span><br><span class="line">        set $agentflag 0;</span><br><span class="line"></span><br><span class="line">        if ($http_user_agent ~* &quot;(Mobile)&quot; )&#123;</span><br><span class="line">          set $agentflag 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if ( $agentflag = 1 ) &#123;</span><br><span class="line">          return 301 https://m.example.com;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>


<h4 id="Client-Body-Buffer-Size"><a href="#Client-Body-Buffer-Size" class="headerlink" title="Client Body Buffer Size"></a>Client Body Buffer Size</h4><figure class="highlight shell"><figcaption><span>Example</span></figcaption><table><tr><td class="code"><pre><span class="line">nginx.ingress.kubernetes.io/client-body-buffer-size: &quot;1000&quot; # 1000 bytes</span><br><span class="line">nginx.ingress.kubernetes.io/client-body-buffer-size: 1k # 1 kilobyte</span><br><span class="line">nginx.ingress.kubernetes.io/client-body-buffer-size: 1K # 1 kilobyte</span><br><span class="line">nginx.ingress.kubernetes.io/client-body-buffer-size: 1m # 1 megabyte</span><br><span class="line">nginx.ingress.kubernetes.io/client-body-buffer-size: 1M # 1 megabyte</span><br></pre></td></tr></table></figure>
<h4 id="Permanent-Redirect"><a href="#Permanent-Redirect" class="headerlink" title="Permanent Redirect"></a>Permanent Redirect</h4><p>返回永久重定向 （301）</p>
<figure class="highlight shell"><figcaption><span>Example</span></figcaption><table><tr><td class="code"><pre><span class="line">nginx.ingress.kubernetes.io/permanent-redirect: &#x27;https://www.google.com&#x27;</span><br></pre></td></tr></table></figure>


<h4 id="Temporal-Redirect"><a href="#Temporal-Redirect" class="headerlink" title="Temporal Redirect"></a>Temporal Redirect</h4><p>临时重定向 （302）</p>
<figure class="highlight shell"><figcaption><span>Example</span></figcaption><table><tr><td class="code"><pre><span class="line">nginx.ingress.kubernetes.io/temporal-redirect: &#x27;https://www.google.com&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="Whitelist-source-range"><a href="#Whitelist-source-range" class="headerlink" title="Whitelist source range"></a>Whitelist source range</h4><p>白名单 <sup id="fnref:8"><a href="#fn:8" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Whitelist source range](https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#whitelist-source-range)">[8]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx.ingress.kubernetes.io/whitelist-source-range: &#x27;10.0.0.0/24,172.10.0.1&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="Custom-timeouts"><a href="#Custom-timeouts" class="headerlink" title="Custom timeouts"></a>Custom timeouts</h4><p>自定义超时时间，所有的超时时间单位为秒 <sup id="fnref:9"><a href="#fn:9" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Custom timeouts](https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#custom-timeouts)">[9]</span></a></sup></p>
<ul>
<li><code>nginx.ingress.kubernetes.io/proxy-connect-timeout</code></li>
<li><code>nginx.ingress.kubernetes.io/proxy-send-timeout</code></li>
<li><code>nginx.ingress.kubernetes.io/proxy-read-timeout</code></li>
<li><code>nginx.ingress.kubernetes.io/proxy-next-upstream</code></li>
<li><code>nginx.ingress.kubernetes.io/proxy-next-upstream-timeout</code></li>
<li><code>nginx.ingress.kubernetes.io/proxy-next-upstream-tries</code></li>
<li><code>nginx.ingress.kubernetes.io/proxy-request-buffering</code></li>
</ul>
<h4 id="Custom-max-body-size"><a href="#Custom-max-body-size" class="headerlink" title="Custom max body size"></a>Custom max body size</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx.ingress.kubernetes.io/proxy-body-size: 8m</span><br></pre></td></tr></table></figure>
<h3 id="ConfigMaps-配置说明"><a href="#ConfigMaps-配置说明" class="headerlink" title="ConfigMaps 配置说明"></a>ConfigMaps 配置说明</h3><p>使用 <code>ConfigMaps</code> 方式配置 nginx 参数 <sup id="fnref:10"><a href="#fn:10" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Configuration options](https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/#configuration-options)">[10]</span></a></sup></p>
<blockquote>
<p>The key and values in a ConfigMap can only be strings. This means that we want a value with boolean values we need to quote the values, like “true” or “false”. Same for numbers, like “100”.</p>
</blockquote>
<h4 id="Log-format"><a href="#Log-format" class="headerlink" title="Log format"></a>Log format</h4><p>默认情况下，Access 日至输出到 <code>/var/log/nginx/access.log</code>，软链接到了 <code>/dev/stdout</code> <sup id="fnref:11"><a href="#fn:11" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[access-log-path](https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/#access-log-path)">[11]</span></a></sup></p>
<p><a href="https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/log-format/">默认日志格式及可用变量</a></p>
<p>要更改默认的日志格式，编辑 <code>ingress-nginx-controller</code> 的部署配置文件，部署 <code>ConfigMap</code> </p>
<figure class="highlight shell"><figcaption><span>ingress-nginx-controller-v1.3.1.yaml</span></figcaption><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app.kubernetes.io/component: controller</span><br><span class="line">    app.kubernetes.io/instance: ingress-nginx</span><br><span class="line">    app.kubernetes.io/name: ingress-nginx</span><br><span class="line">    app.kubernetes.io/part-of: ingress-nginx</span><br><span class="line">    app.kubernetes.io/version: 1.3.1</span><br><span class="line">  name: ingress-nginx-controller</span><br><span class="line">  namespace: ingress-nginx</span><br><span class="line">data:</span><br><span class="line">  allow-snippet-annotations: &quot;true&quot;</span><br><span class="line"></span><br><span class="line">  log-format-upstream: &quot;&#123; time: $time_iso8601|http_host:$http_host|cdn_ip:$remote_addr|request:$request|request_method:$request_method|http_user_agent:$http_user_agent|size:$body_bytes_sent|responsetime:$request_time|upstreamtime:$upstream_response_time|upstreamhost:$upstream_addr|upstreamstatus:$upstream_status|url:$http_host$uri|http_x_forwarded_for:$http_x_forwarded_for|referer:$http_referer|server_protocol:$server_protocol|status:$status&#125;&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>部署 <code>ingress-nginx-controller</code> 后，检查 nginx 配置中的 <code>log-format</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl <span class="built_in">cp</span> -n ingress-nginx ingress-nginx-controller-nxkwq:/etc/nginx/nginx.conf temp.nginx.conf</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> temp.nginx.conf</span></span><br><span class="line">...</span><br><span class="line">log_format upstreaminfo &#x27;&#123; time: $time_iso8601|http_host:$http_host|cdn_ip:$remote_addr|request:$request|reque</span><br><span class="line">st_method:$request_method|http_user_agent:$http_user_agent|size:$body_bytes_sent|responsetime:$request_time|upstreamti</span><br><span class="line">me:$upstream_response_time|upstreamhost:$upstream_addr|upstreamstatus:$upstream_status|url:$http_host$uri|http_x_forwa</span><br><span class="line">rded_for:$http_x_forwarded_for|referer:$http_referer|server_protocol:$server_protocol|status:$status&#125;&#x27;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在 <code>Ingress</code> 资源中使用此 <code>log_format</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kind: Ingress</span><br><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">metadata:</span><br><span class="line">  name: example-ingress</span><br><span class="line">  namespace: default</span><br><span class="line"></span><br><span class="line">  annotations:</span><br><span class="line">    nginx.ingress.kubernetes.io/configuration-snippet: |</span><br><span class="line">      access_log /var/log/nginx/example-ingress.access.log upstreaminfo;</span><br><span class="line">      error_log /var/log/nginx/example-ingress.err.log;</span><br></pre></td></tr></table></figure>
<p>部署成功后，查看 nginx 配置中关于域名的配置，在此 <code>Ingress</code> 资源中配置的每个域名的 <code>server</code> 配置段中会包含此日志配置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl <span class="built_in">cp</span> -n ingress-nginx ingress-nginx-controller-nxkwq:/etc/nginx/nginx.conf temp.nginx.conf</span></span><br><span class="line">cat temp.nginx.conf</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">access_log /var/log/nginx/example-ingress.access.log upstreaminfo if=$loggable;</span><br><span class="line">error_log /var/log/nginx/example-ingress.err.log;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><h3 id="证书部署后未生效"><a href="#证书部署后未生效" class="headerlink" title="证书部署后未生效"></a>证书部署后未生效</h3><p>证书部署后，通过域名访问，浏览器提示域名不安全，未使用证书。检查 <code>ingress-nginx-controller</code> 日志，报错 <code>Error getting SSL certificate &quot;default/cs.k8s.info&quot;: local SSL certificate default/cs.k8s.info was not found. Using default certificate</code></p>
<p>将 nginx 配置文件拷贝出来查看，发现配置中未配置相关域名的证书</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl cp -n ingress-nginx ingress-nginx-controller-cjxt5:/etc/nginx/nginx.conf temp.nginx.conf</span><br></pre></td></tr></table></figure>



<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://kubernetes.github.io/ingress-nginx/deploy/baremetal/">裸机注意事项</a></p>
<h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.github.io/ingress-nginx/deploy/baremetal/#via-the-host-network">Via the host network</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/">Ingress NGINX Configuration</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.github.io/ingress-nginx/examples/rewrite/#examples">Rewrite Target</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.github.io/ingress-nginx/examples/rewrite/#app-root">App Root</a><a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#session-affinity">Session Affinity</a><a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#enable-cors">Enable CORS</a><a href="#fnref:6" rev="footnote"> ↩</a></span></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#redirect-fromto-www">Redirect from/to www</a><a href="#fnref:7" rev="footnote"> ↩</a></span></li><li id="fn:8"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">8.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#whitelist-source-range">Whitelist source range</a><a href="#fnref:8" rev="footnote"> ↩</a></span></li><li id="fn:9"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">9.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#custom-timeouts">Custom timeouts</a><a href="#fnref:9" rev="footnote"> ↩</a></span></li><li id="fn:10"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">10.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/#configuration-options">Configuration options</a><a href="#fnref:10" rev="footnote"> ↩</a></span></li><li id="fn:11"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">11.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/#access-log-path">access-log-path</a><a href="#fnref:11" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>k8s</tag>
        <tag>ingress-nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes 网络数据包抓包分析</title>
    <url>/202210250956/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos7</li>
<li>Kubernetes 1.21</li>
<li>flannel 0.20</li>
</ul>
<p>为观察 Kubernetes 集群中跨主机 POD 之间的网络通信数据流，本文通过 tcpdump 抓包，对数据流向进行记录观察。</p>
<p>本示例中的 Kubernetes 集群由以下节点组成：</p>
<table>
<thead>
<tr>
<th>节点主机名</th>
<th>节点角色</th>
<th>节点 IP</th>
<th>节点上测试 POD IP</th>
</tr>
</thead>
<tbody><tr>
<td>master</td>
<td>master</td>
<td>eth0： 10.150.0.21</td>
<td>10.244.0.2</td>
</tr>
<tr>
<td>worker1</td>
<td>worker</td>
<td>eth0： 10.150.0.19</td>
<td>10.244.1.38</td>
</tr>
<tr>
<td>worker2</td>
<td>worker</td>
<td>eth0： 10.150.0.20</td>
<td>10.244.2.27</td>
</tr>
</tbody></table>
<h1 id="Flannel-简介"><a href="#Flannel-简介" class="headerlink" title="Flannel 简介"></a>Flannel 简介</h1><p>Kubernetes 系统上 POD 网络的实现依赖于第三方插件，Kubernetes 只负责提供了 CNI（容器网络接口），只要符合 CNI 规则的第三方插件都可以用于为 POD 提供网络实现。而 Flannel 是由 CoreOS 主推的目前比较主流的容器网络解决方案。</p>
<p>Flannel 支持三种不同后端实现，分别是：</p>
<ul>
<li>UDP</li>
<li>VXLAN</li>
<li>host-gw</li>
</ul>
<p>UDP 是 Flannel 项目最早支持的一种方式，是性能最差的方式，目前已被废弃。</p>
<p>用的最多的是 VXLAN 和 host-gw 模式的部署。</p>
<span id="more"></span>

<h2 id="VXLAN"><a href="#VXLAN" class="headerlink" title="VXLAN"></a>VXLAN</h2><p>Flannel 默认使用 VXLAN 模式。flannel 运行后，在各个宿主机配置了一个网络接口 <code>flannel.1</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ifconfig flannel.1</span></span><br><span class="line">flannel.1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1410</span><br><span class="line">        inet 10.244.0.0  netmask 255.255.255.255  broadcast 0.0.0.0</span><br><span class="line">        inet6 fe80::7c63:25ff:fea9:a780  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 7e:63:25:a9:a7:80  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 2857781  bytes 1505969406 (1.4 GiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 1946111  bytes 1603736503 (1.4 GiB)</span><br><span class="line">        TX errors 0  dropped 8 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>默认分配给集群 POD 的网段为 <code>10.244.0.0/16</code></p>
<p>flannel 给 master 节点配置的 Pod 网络为 <code>10.244.0.0/24</code> 段，给 <code>worker1</code> 节点配置的 Pod 网络为 <code>10.244.1.0/24</code> 段，如果有更多的节点，以此类推。</p>
<p>当有容器运行之后，flannel 会在节点上配置虚拟接口 <code>cni0</code>，比如在节点 <code>worker1</code>，IP 地址默认为 <code>10.244.1.1</code>，在 master 节点上 IP 为 <code>10.244.0.1</code>。</p>
<p>此 <code>cni0</code> 接口是一个网桥设备，会作为此节点上的 POD 的默认网关</p>
<p>在 POD 启动时，flannel 会创建一对 veth 虚拟设备，一端连接到容器，一端连接到 <code>cni0</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ifconfig cni0</span></span><br><span class="line">cni0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1410</span><br><span class="line">        inet 10.244.0.1  netmask 255.255.255.0  broadcast 10.244.0.255</span><br><span class="line">        inet6 fe80::f054:6bff:fe0e:f9ef  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether f2:54:6b:0e:f9:ef  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 3795780  bytes 469016599 (447.2 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 3832558  bytes 408850763 (389.9 MiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一旦节点启动并加入集群后，其他节点上的 flanneld 会添加路由规则，将到其他节点上的 POD 网段的流量路由到本节点的 flannel.1 接口，即进入二层隧道，然后封装 VXLAN 包，到达目标节点后(pod 网段和节点 ip 的映射关系，flannel 保存在 etcd 或者 k8s 中)，由目标节点上的 flannel.1 解封装，这就是 flannel 默认的 VXLAN 模式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip route show</span></span><br><span class="line">default via 10.150.0.1 dev eth0 </span><br><span class="line">10.150.0.1 dev eth0 scope link </span><br><span class="line">10.244.0.0/24 dev cni0 proto kernel scope link src 10.244.0.1 </span><br><span class="line">10.244.1.0/24 via 10.244.1.0 dev flannel.1 onlink </span><br><span class="line">10.244.2.0/24 via 10.244.2.0 dev flannel.1 onlink </span><br><span class="line">169.254.0.0/16 dev eth0 scope link metric 1002 </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于 VXLAN 额外的封包解包，导致其性能较差，所以 Flannel 就有了 <code>host-gw</code> 模式，即把宿主机当作网关，除了本地路由之外没有额外开销，性能和 calico 差不多，由于没有叠加来实现报文转发，这样会导致路由表庞大。因为一个节点对应一个网络，也就对应一条路由条目。</p>
<p><code>host-gw</code> 虽然比 VXLAN 网络性能要强很多，但是种方式有个缺陷：<strong>要求各物理节点必须在同一个二层网络中</strong>。物理节点必须在同一网段中。这样会使得一个网段中的主机量会非常多，万一发一个广播报文就会产生干扰。在私有云场景下，宿主机不在同一网段是很常见的状态，所以就不能使用 <code>host-gw</code> 了。</p>
<p>VXLAN 还有另外一种功能，VXLAN 也支持类似 host-gw 的方案，如果两个节点在同一网段时使用 host-gw 通信，如果不在同一网段中，即当前 pod 所在节点与目标 pod 所在节点中间有路由器，就使用 VXLAN 这种方式，使用叠加网络。</p>
<p>结合了 Host-gw 和 VXLAN，这就是 VXLAN 的 <code>Directrouting</code> 模式</p>
<p>因此 Flannel 的 VXLAN 模式有两种：</p>
<ul>
<li>VXLAN： 原生的 VXLAN，即扩展的虚拟 LAN</li>
<li>Directrouting：直接路由型</li>
</ul>
<p>配置 Directrouting 模式</p>
<p>修改 <code>kube-flannel.yml</code>，修改以下内容：</p>
<figure class="highlight shell"><figcaption><span>kube-flannel.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">net-conf.json: |</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;Network&quot;: &quot;10.244.0.0/16&quot;,</span><br><span class="line">    &quot;Backend&quot;: &#123;</span><br><span class="line">      &quot;Type&quot;: &quot;vxlan&quot;,</span><br><span class="line">      &quot;Directrouting&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="抓包示例"><a href="#抓包示例" class="headerlink" title="抓包示例"></a>抓包示例</h1><p>在 Flannel 的 VXLAN 模式下，overlay 流量需要通过节点的 <code>8472/udp</code> 端口（隧道）进行跨节点通信，如果跨节点 POD 网络通信存在异常，可以在两个节点上对 <code>8472/udp</code> 抓包观察流量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth0 -nnn &#x27;udp port 8472 and host 10.150.0.19&#x27;</span><br></pre></td></tr></table></figure>


<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://juejin.cn/post/6963106745468059684">详解Kubernetes网络原理</a></p>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>tcpdump</tag>
        <tag>Flannel</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes 网络说明</title>
    <url>/202212020941/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Kubernetes 对任何网络实现都规定了以下要求： <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[万字长文，带你搞懂 Kubernetes 网络模型](https://www.51cto.com/article/714336.html)">[1]</span></a></sup></p>
<ul>
<li><strong>所有 Pod 都可以在不使用网络地址转换 (NAT) 的情况下与所有其他 Pod 通信。</strong></li>
<li><strong>所有节点都可以在没有 NAT 的情况下与所有 Pod 通信。</strong></li>
<li><strong>Pod 认为自己的 IP 与其他人认为的 IP 相同。</strong></li>
</ul>
<h1 id="Linux-系统-Network-Namespace-说明"><a href="#Linux-系统-Network-Namespace-说明" class="headerlink" title="Linux 系统 Network Namespace 说明"></a>Linux 系统 Network Namespace 说明</h1><p>通常，我们将虚拟机中的网络通信视为直接与以太网设备交互，如下图<br><img src="https://i.csms.tech/img_97.png"><br>在 Linux 中，每个正在运行的进程都在一个网络命名空间内进行通信，该命名空间为逻辑网络堆栈提供了自己的路由、防火墙规则和网络设备。本质上，网络命名空间为命名空间内的所有进程提供了一个全新的网络堆栈。</p>
<p>默认情况下，Linux 将<strong>每个进程分配给根网络命名空间</strong>以提供对外部世界的访问<br><img src="https://i.csms.tech/img_98.png"></p>
<p>就 Docker 结构而言，Pod 被建模为一组共享网络命名空间的 Docker 容器。<strong>Pod 中的容器都具有相同的 IP 地址和端口空间</strong>，这些 IP 地址和端口空间是<strong>通过分配给 Pod 的网络命名空间分配</strong>的，并且可以通过 <code>localhost</code> 找到彼此，因为它们位于同一个命名空间中。我们可以为虚拟机上的每个 Pod 创建一个网络命名空间。这是使用 Docker 作为“Pod 容器”实现的，它保持网络命名空间打开，而“应用容器”（用户指定的东西）通过 Docker 的 <code>--net=container:</code> 函数加入该命名空间。下图显示了每个 Pod 如何由共享命名空间内的多个 Docker 容器 (ctr*) 组成。<br><img src="https://i.csms.tech/img_99.png"></p>
<p>在 Kubernetes 中，用户创建 Pod 后，系统会首先创建一个 <code>pause</code> 容器，此容器的逻辑非常简单，它一启动就会把自己永远阻塞在那里，目的是为了能<strong>占用着一个namespace</strong>，Pod 内的其他容器启动后无需初始化网络协议栈，只需要加入 <code>pause</code> 容器初始化好的 Network Namespace。</p>
<span id="more"></span>

<h1 id="Pod-和-Pod-之间网络通信"><a href="#Pod-和-Pod-之间网络通信" class="headerlink" title="Pod 和 Pod 之间网络通信"></a>Pod 和 Pod 之间网络通信</h1><p>在 Kubernetes 中，每个 Pod 都有一个真实的 IP 地址，并且每个 Pod 都使用该 IP 地址与其他 Pod 通信。</p>
<h2 id="同一节点上的-Pod-之间的通信"><a href="#同一节点上的-Pod-之间的通信" class="headerlink" title="同一节点上的 Pod 之间的通信"></a>同一节点上的 Pod 之间的通信</h2><p>从 Pod 的角度来看，它存在于自己的以太网命名空间中，需要与同一节点上的其他网络命名空间进行通信。值得庆幸的是，可以使用 <strong>Linux 虚拟以太网设备</strong>或由两个虚拟接口组成的 <strong><code>veth pair</code></strong> 连接命名空间，这些虚拟接口可以分布在多个命名空间上。要连接 Pod 命名空间，我们可以将 <code>veth pair</code> 的一侧分配给**根网络命名空间(Root Network Namespace)**，将另一侧分配给 <strong>Pod 的网络命名空间</strong>。每对 <code>veth pair</code> 的工作方式就像一根跳线，连接两侧并允许流量在它们之间流动。这个设置可以复制到机器上的尽可能多的 Pod。下图显示了将 VM 上的每个 Pod 连接到根命名空间的 <code>veth pair</code>。 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[万字长文，带你搞懂 Kubernetes 网络模型](https://www.51cto.com/article/714336.html)">[1]</span></a></sup></p>
<p><img src="https://i.csms.tech/img_100.png"></p>
<p>此时，每个 Pod 都有了自己的网络命名空间，拥有自己的以太网设备和 IP 地址，并且它们<strong>连接到了节点的根命名空间</strong>。现在，我们希望 Pod 通过根命名空间相互通信，为此我们使用网桥。</p>
<p>Linux 以太网网桥是一个虚拟的第 2 层网络设备，网桥检查通过它的数据包的目的 IP，决定是否将数据包转发到网桥的其他网段。</p>
<p>网桥实现 ARP 协议以发现与给定 IP 地址关联的链路层 MAC 地址，当网桥接收到数据帧时，网桥将广播 <strong>ARP 数据包</strong>到所有连接的设备（原始发送者除外），响应该 ARP 数据包的设备存储在 ARP 表。具有相同 IP 地址的未来流量使用 ARP 表 来将数据包转发到的正确 MAC 地址。</p>
<p><img src="https://i.csms.tech/img_101.png"></p>
<h2 id="跨节点-Pod-通信"><a href="#跨节点-Pod-通信" class="headerlink" title="跨节点 Pod 通信"></a>跨节点 Pod 通信</h2><p><a href="https://www.51cto.com/article/714336.html">描述参考</a></p>
<h3 id="Flannel-host-gw-方式说明"><a href="#Flannel-host-gw-方式说明" class="headerlink" title="Flannel host-gw 方式说明"></a>Flannel host-gw 方式说明</h3><p>这个方案采用的是每个 Node 独占网段，每个 Subnet 会绑定在一个 Node 上，网关也设置在本地，或者说直接设在 cni0 这个网桥的内部端口上。该方案的好处是管理简单，坏处就是无法跨 Node 迁移 Pod。就是说这个 IP、网段已经是属于这个 Node 之后就无法迁移到别的 Node 上。<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Kubernetes 网络模型进阶](https://www.infoq.cn/article/qduqfhrisblob7textxe)">[2]</span></a></sup><br><img src="https://i.csms.tech/img_107.png"><br>这个方案的精髓在于 route 表的设置，如上图所示。<a href="https://www.infoq.cn/article/qduqfhrisblob7textxe">包流经路径及限制参考</a></p>
<h1 id="Pod-和-Internet-的通信"><a href="#Pod-和-Internet-的通信" class="headerlink" title="Pod 和 Internet 的通信"></a>Pod 和 Internet 的通信</h1><p>在下图中，数据包源自 Pod1 的命名空间 (1)，并经过连接到根命名空间 (2) 的 <code>veth pair</code>。一旦进入根命名空间，数据包就会从网桥移动到默认设备，因为数据包上的 IP 与连接到网桥的任何网段都不匹配。在到达根命名空间的以太网设备 (3) 之前，iptables 会破坏数据包 (3)。在这种情况下，数据包的源 IP 地址是 Pod，如果我们将源保留为 Pod，Internet 网关将拒绝它，因为网关 NAT 只了解连接到 VM 的 IP 地址。解决方案是让 iptables 执行源 NAT——更改数据包源——使数据包看起来来自 VM 而不是 Pod。有了正确的源 IP，数据包现在可以离开 VM (4) 并到达 Internet 网关 (5)。Internet 网关将执行另一个 NAT，将源 IP 从 VM 内部 IP 重写为外部 IP。最后，数据包将到达公共 Internet (6)。在返回的路上，数据包遵循相同的路径，并且任何源 IP 修改都被撤消，以便系统的每一层都接收到它理解的 IP 地址：节点或 VM 级别的 VM 内部，以及 Pod 内的 Pod IP命名空间。<br><img src="https://i.csms.tech/f2894f848d4111f47856631aaca6d83471debf.gif"></p>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.51cto.com/article/714336.html">万字长文，带你搞懂 Kubernetes 网络模型</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.infoq.cn/article/qduqfhrisblob7textxe">Kubernetes 网络模型进阶</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes PV 使用方法</title>
    <url>/202211291450/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><code>PersistentVolume (PV)</code>（持久化卷），是对底层的共享存储的一种抽象，PV 由管理员进行创建和配置，它和具体的底层的共享存储技术的实现方式有关，比如 <code>Ceph</code>、<code>GlusterFS</code>、<code>NFS</code> 等，都是通过插件机制完成与共享存储的对接。<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[使用 PersistentVolume 作为存储](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-persistent-volume-storage/)">[1]</span></a></sup></p>
<p><code>PersistentVolumeClaim（PVC）</code>是由用户发起的对存储的请求。 它类似于 Pod。 Pod 消耗节点资源，PVC 消耗 PV 资源。Pod 可以请求特定级别的资源（CPU和内存）。PVC 可以请求特定的存储大小和访问模式（例如，可以一次读&#x2F;写或多次只读）匹配的 PV。</p>
<p><code>PVC</code> 和 <code>PV</code> 中的 <code>spec</code> 关键字段要匹配，比如存储（storage）大小、读写模式，才能申请到对应的 PV 中的资源。PV 和 PVC 处于一一对应的关系。 <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[k8s存储持久化（nfs用例）](https://blog.51cto.com/u_15064627/4251683)">[2]</span></a></sup></p>
<p><code>PV</code> 可以设置三种回收策略：</p>
<ul>
<li>保留（Retain） - 保留产生的数据，PV 不进行处理</li>
<li>回收（Recycle） - 将执行清除操作，之后可以被新的pvc使用，需要插件支持。NFS 支持全部 3 种。</li>
<li>删除（Delete） - 删除pv和外部关联的存储资源，需要插件支持。</li>
</ul>
<p>PV卷阶段状态</p>
<ul>
<li><code>Available</code> – 资源尚未被 claim 使用</li>
<li><code>Bound</code> – 卷已经被绑定到 claim 了</li>
<li><code>Released</code> – claim 被删除，卷处于释放状态，但未被集群回收。</li>
<li><code>Failed</code> – 卷自动回收失败</li>
</ul>
<span id="more"></span>

<h1 id="NFS-作为-PV"><a href="#NFS-作为-PV" class="headerlink" title="NFS 作为 PV"></a>NFS 作为 PV</h1><a href="/202210251713/" title="NFS 服务部署参考">NFS 服务部署参考</a>

<h2 id="创建-PV"><a href="#创建-PV" class="headerlink" title="创建 PV"></a>创建 PV</h2><p><code>PV</code> 属于集群级别的资源。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  name: nfs-pv-1</span><br><span class="line"></span><br><span class="line">spec:</span><br><span class="line">  accessModes:</span><br><span class="line">  - ReadWriteMany</span><br><span class="line">  - ReadOnlyMany</span><br><span class="line">  capacity:</span><br><span class="line">    storage: 100Gi</span><br><span class="line">  nfs:</span><br><span class="line">    path: /data/NFSDataHome</span><br><span class="line">    server: 34.230.1.1</span><br><span class="line">  persistentVolumeReclaimPolicy: Retain</span><br><span class="line">  volumeMode: Filesystem</span><br><span class="line">  </span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  name: nfs-pv-2</span><br><span class="line">  labels:</span><br><span class="line">    name: nfs-pv-2</span><br><span class="line">spec:</span><br><span class="line">  nfs:</span><br><span class="line">    path: /k8s_volumes/v2</span><br><span class="line">    server: 192.168.0.3</span><br><span class="line">  accessModes: [&quot;ReadWriteOnce&quot;]</span><br><span class="line">  persistentVolumeReclaimPolicy: Retain</span><br><span class="line">  capacity:</span><br><span class="line">    storage: 5Gi</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以上配置分别创建了 PV</p>
<ul>
<li><code>nfs-pv-1</code> - <code>accessModes</code> 为 <code>[&quot;ReadWriteMany&quot;, &quot;ReadOnlyMany&quot;]</code>，大小为 <code>100Gi</code></li>
<li><code>nfs-pv-2</code> - <code>accessModes</code> 为 <code>[&quot;ReadWriteOnce&quot;]</code>，大小为 <code>5Gi</code></li>
</ul>
<p>查看 PV</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pv</span></span><br><span class="line">NAME      CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS   REASON   AGE</span><br><span class="line">uat-nfs   100Gi      RWX            Retain           Available                                   100s</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="创建对应的-PVC-申请-PV-存储资源"><a href="#创建对应的-PVC-申请-PV-存储资源" class="headerlink" title="创建对应的 PVC 申请 PV 存储资源"></a>创建对应的 PVC 申请 PV 存储资源</h2><p><code>PVC</code> 属于 <code>Namespace</code> 基本的资源，需要在相应的 <code>Namespace</code> 中使用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">metadata:</span><br><span class="line">  name: mypvc</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  accessModes: [&quot;ReadWriteMany&quot;]</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 100Gi</span><br></pre></td></tr></table></figure>
<p>以上 PVC 会匹配到持久卷 <code>nfs-pv-1</code></p>
<p>查看 PVC</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get pvc -A</span><br></pre></td></tr></table></figure>

<h2 id="使用-PVC"><a href="#使用-PVC" class="headerlink" title="使用 PVC"></a>使用 PVC</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: vol-pvc</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  volumes:</span><br><span class="line">  - name: html</span><br><span class="line">    persistentVolumeClaim:</span><br><span class="line">      claimName: mypvc</span><br><span class="line">  containers:</span><br><span class="line">  - name: myapp</span><br><span class="line">    image: nginx</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: html</span><br><span class="line">      mountPath: /usr/share/nginx/html/</span><br><span class="line">      # subPath: logs/admin</span><br></pre></td></tr></table></figure>
<p><strong>k8s 该 Pod 所在 NODE 节点服务器需要安装 <code>nfs-utils</code>，否则挂载会报错，POD 无法运行。建议每台节点都安装</strong></p>
<p>Pod 成功运行后，进入对应容器，会看到容器中通过 NFS 方式挂载了 NFS 共享存储。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl <span class="built_in">exec</span> -it vol-pvc -- <span class="built_in">df</span> -h</span></span><br><span class="line">Filesystem                   Size  Used Avail Use% Mounted on</span><br><span class="line">overlay                       36G  3.4G   32G  10% /</span><br><span class="line">tmpfs                         64M     0   64M   0% /dev</span><br><span class="line">tmpfs                        2.0G     0  2.0G   0% /sys/fs/cgroup</span><br><span class="line">/dev/mapper/centos-root       36G  3.4G   32G  10% /etc/hosts</span><br><span class="line">shm                           64M     0   64M   0% /dev/shm</span><br><span class="line">192.168.0.3:/k8s_volumes/v4  3.6T  1.9T  1.6T  55% /usr/share/nginx/html</span><br><span class="line">tmpfs                        2.0G   12K  2.0G   1% /run/secrets/kubernetes.io/serviceaccount</span><br><span class="line">tmpfs                        2.0G     0  2.0G   0% /proc/acpi</span><br><span class="line">tmpfs                        2.0G     0  2.0G   0% /proc/scsi</span><br><span class="line">tmpfs                        2.0G     0  2.0G   0% /sys/firmware</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>以上方法创建的 PV 为静态 PV，此种情况下，PV 和 PVC 具有一对一的绑定关系</strong>，即一个 PV 只能绑定到一个 PVC，如果要在另一个 Namespace 中使用同一个的 PV，是不被允许的，此时 PVC 会绑定失败： <code>no persistent volumes available for this claim and no storage class is set</code></p>
<h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><h3 id="PV-处于-Released-状态，新建-PVC-处于-Pending-状态"><a href="#PV-处于-Released-状态，新建-PVC-处于-Pending-状态" class="headerlink" title="PV 处于 Released 状态，新建 PVC 处于 Pending 状态"></a>PV 处于 Released 状态，新建 PVC 处于 Pending 状态</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pv</span></span><br><span class="line">NAME      CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                   STORAGECLASS   REASON   AGE</span><br><span class="line">uat-nfs   100Gi      ROX,RWX        Retain           Bound    default/pvc-admin                               62m</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pvc -A</span></span><br><span class="line">NAMESPACE   NAME             STATUS   VOLUME    CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><br><span class="line">default     pvc-admin        Bound    uat-nfs   100Gi      ROX,RWX                       29s</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如上所示，创建 PVC 后，PV 处于 <code>Bound</code> 状态，此时创建其他内容一样，只是 <code>matadata.name</code> 不同的 PVC ，PVC 无法成功创建，状态为 <code>Pending</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pvc -A</span></span><br><span class="line">NAMESPACE   NAME        STATUS    VOLUME    CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><br><span class="line">default     pvc-api     Pending                                                      2m30s</span><br><span class="line">default     pvc-admin   Bound     uat-nfs   100Gi      ROX,RWX                       71m</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看新建的 PVC <code>pvc-api</code> 的描述信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl describe pvc pvc-api -n default</span></span><br><span class="line">Name:          pvc-api</span><br><span class="line">Namespace:     default</span><br><span class="line">StorageClass:  </span><br><span class="line">Status:        Pending</span><br><span class="line">...</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason         Age                   From                         Message</span><br><span class="line">  ----    ------         ----                  ----                         -------</span><br><span class="line">  Normal  FailedBinding  14s (x12 over 2m48s)  persistentvolume-controller  no persistent volumes available for this claim and no storage class is set</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果显示 <code>no persistent volumes available for this claim and no storage class is set</code>，这是因为 PV 已经分配到了 PVC，无法再进行分配。</p>
<p>此时查看 PV 状态，处于 <code>Bound</code> 状态，<code>CLAIM</code> 为第一次创建 PVC</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pv</span></span><br><span class="line">NAME      CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                   STORAGECLASS   REASON   AGE</span><br><span class="line">uat-nfs   100Gi      ROX,RWX        Retain           Bound    default/pvc-admin                               135m</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此种情况下，执行以下命令手动删除已分配的 PVC</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl delete pvc -n default      pvc-admin</span><br></pre></td></tr></table></figure>
<p>再次查看 PVC</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pvc -A</span></span><br><span class="line">NAMESPACE   NAME       STATUS    VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><br><span class="line">default     pvc-api   Pending</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pv</span></span><br><span class="line">NAME      CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS     CLAIM                   STORAGECLASS   REASON   AGE</span><br><span class="line">uat-nfs   100Gi      ROX,RWX        Retain           Released   default/pvc-admin                               140m</span><br></pre></td></tr></table></figure>
<p>发现 PVC 依然处于 <code>Pending</code> 状态，而 PV 状态变为了 <code>Released</code>，无法再分配给其他 PVC。</p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ul>
<li>删除 PV<br>  手动删除 PV，因为之前创建的 PV，其回收策略为 <code>Retain</code>，PV 删除后，数据依然存在。如果需要此存储作为 PV，创建新的 PV 即可，然后针对不同的 Namespace 创建对应的 PVC</li>
<li>修改 PV 的回收策略<br>  执行以下命令，修改 PV 的回收策略 <sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[What to do with Released persistent volume](https://stackoverflow.com/questions/50667437/what-to-do-with-released-persistent-volume)">[3]</span></a></sup>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl patch pv PV_NAME -p &#x27;&#123;&quot;spec&quot;:&#123;&quot;claimRef&quot;: null&#125;&#125;&#x27;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-persistent-volume-storage/">使用 PersistentVolume 作为存储</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://blog.51cto.com/u_15064627/4251683">k8s存储持久化（nfs用例）</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://stackoverflow.com/questions/50667437/what-to-do-with-released-persistent-volume">What to do with Released persistent volume</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes 对象的 yaml 描述语法说明</title>
    <url>/202209241108/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h2><ul>
<li>Centos7 5.4.212-1</li>
<li>Docker 20.10.18</li>
<li>containerd.io-1.6.8</li>
<li>kubectl-1.25.0</li>
<li>kubeadm-1.25.0</li>
<li>kubelet-1.25.0</li>
</ul>
<h2 id="常用字段说明"><a href="#常用字段说明" class="headerlink" title="常用字段说明"></a>常用字段说明</h2><h3 id="必需字段"><a href="#必需字段" class="headerlink" title="必需字段"></a>必需字段</h3><p>在想要创建的 Kubernetes 对象所对应的 <code>.yaml</code> 文件中，必须配置的字段如下：<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[必需字段](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/kubernetes-objects/#required-fields)">[1]</span></a></sup></p>
<ul>
<li><code>apiVersion</code> - 创建该对象所使用的 Kubernetes API 的版本</li>
<li><code>kind</code> - 想要创建的对象的类别</li>
<li><code>metadata</code> - 帮助唯一标识对象的一些数据，包括一个 <code>name</code> 字符串、<code>UID</code> 和可选的 <code>namespace</code></li>
<li><code>spec</code> - 你所期望的该对象的状态</li>
</ul>
<h3 id="metadata"><a href="#metadata" class="headerlink" title="metadata"></a>metadata</h3><p>帮助唯一标识对象的一些数据，包括一个 <code>name</code> 字符串、<code>UID</code> 和可选的 <code>namespace</code> </p>
<p>集群中的每一个对象都有一个 <strong>名称</strong>（<code>name</code>）来标识在同类资源中的唯一性。<code>name</code> 也用来作为 url 中的资源名称 <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[对象名称和 IDs](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names/)">[2]</span></a></sup></p>
<p>每个 Kubernetes 对象也有一个 <strong>UID</strong>（<code>uid</code>）来标识在整个集群中的唯一性。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-deployment</span><br><span class="line">  labels: </span><br><span class="line">    app: nginx-deployment</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  replicas: 2 </span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:1.14.2</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h3 id="标签-Labels-和选择算符-selector"><a href="#标签-Labels-和选择算符-selector" class="headerlink" title="标签 (Labels) 和选择算符 (selector)"></a>标签 (Labels) 和选择算符 (selector)</h3><p><strong>标签（labels）</strong> 是附加到 Kubernetes 对象（比如 Pod）上的键值对。 标签旨在用于指定对用户有意义且相关的对象的标识属性，但不直接对核心系统有语义含义。 标签可以用于组织和选择对象的子集。标签可以在创建时附加到对象，随后可以随时添加和修改。 每个对象都可以定义一组键&#x2F;值标签。每个键对于给定对象必须是唯一的。<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[标签和选择算符](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/)">[3]</span></a></sup></p>
<p>通过 <strong>标签选择算符</strong>，客户端&#x2F;用户可以识别一组对象。<strong>标签选择算符</strong> 是 Kubernetes 中的核心分组原语。</p>
<blockquote>
<p>对于某些 API 类别（例如 <code>ReplicaSet</code>）而言，两个实例的标签选择算符不得在命名空间内重叠， 否则它们的控制器将互相冲突，无法确定应该存在的副本个数。</p>
</blockquote>
<p>比较新的资源，例如 <code>Job</code>、 <code>Deployment</code>、 <code>ReplicaSet</code> 和 <code>DaemonSet</code>， 也支持基于集合的需求。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">selector:</span><br><span class="line">  matchLabels:</span><br><span class="line">    component: redis</span><br><span class="line">  matchExpressions:</span><br><span class="line">    - &#123;key: tier, operator: In, values: [cache]&#125;</span><br><span class="line">    - &#123;key: environment, operator: NotIn, values: [dev]&#125;</span><br></pre></td></tr></table></figure>
<p><code>matchLabels</code> 是由 {key,value} 对组成的映射。 <code>matchLabels</code> 映射中的单个 {key,value} 等同于 <code>matchExpressions</code> 的元素， 其 key 字段为 “key”，operator 为 <code>In</code>，而 values 数组仅包含 “value”。 <code>matchExpressions</code> 是 Pod 选择算符需求的列表。 有效的运算符包括 <code>In</code>、<code>NotIn</code>、<code>Exists</code> 和 <code>DoesNotExist</code>。 在 <code>In</code> 和 <code>NotIn</code> 的情况下，设置的值必须是非空的。 来自 <code>matchLabels</code> 和 <code>matchExpressions</code> 的所有要求都按 <strong>逻辑与</strong> 的关系组合到一起 – <strong>它们必须都满足才能匹配</strong>。</p>
<h4 id="字段选择器"><a href="#字段选择器" class="headerlink" title="字段选择器"></a>字段选择器</h4><p><strong>字段选择器（Field selectors）</strong> 允许你根据一个或多个资源字段的值 <strong>筛选 Kubernetes 资源</strong></p>
<p>下面是一些使用字段选择器查询的例子：</p>
<ul>
<li><code>metadata.name=my-service</code></li>
<li><code>metadata.namespace!=default</code></li>
<li><code>status.phase=Pending</code></li>
</ul>
<p>下面这个 <code>kubectl</code> 命令将筛选出 <code>status.phase</code> 字段值为 <code>Running</code> 的所有 Pod：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get pods --field-selector status.phase=Running</span><br></pre></td></tr></table></figure>

<p>不同的 Kubernetes 资源类型支持不同的字段选择器。 所有资源类型都支持 <code>metadata.name</code> 和 <code>metadata.namespace</code> 字段。 使用不被支持的字段选择器会产生错误</p>
<p>你可在字段选择器中使用 <code>=</code>、<code>==</code> 和 <code>!=</code> （<code>=</code> 和 <code>==</code> 的意义是相同的）操作符。 例如，下面这个 <code>kubectl</code> 命令将筛选所有不属于 <code>default</code> 命名空间的 Kubernetes 服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get services  --all-namespaces --field-selector metadata.namespace!=default</span><br></pre></td></tr></table></figure>

<p>同标签和其他选择器一样， 字段选择器可以通过使用逗号分隔的列表组成一个选择链。 下面这个 <code>kubectl</code> 命令将筛选 <code>status.phase</code> 字段不等于 <code>Running</code> 同时 <code>spec.restartPolicy</code> 字段等于 <code>Always</code> 的所有 Pod：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get pods --field-selector=status.phase!=Running,spec.restartPolicy=Always</span><br></pre></td></tr></table></figure>
<p>你能够跨多种资源类型来使用字段选择器。 下面这个 <code>kubectl</code> 命令将筛选出所有不在 <code>default</code> 命名空间中的 <code>StatefulSet</code> 和 <code>Service</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get statefulsets,services --all-namespaces --field-selector metadata.namespace!=default</span><br></pre></td></tr></table></figure>

<h3 id="metadata-ownerReferences"><a href="#metadata-ownerReferences" class="headerlink" title="metadata.ownerReferences"></a>metadata.ownerReferences</h3><p>在 Kubernetes 中，一些对象是其他对象的 <strong>属主（Owner）</strong>。 例如，<code>ReplicaSet</code> 是一组 <code>Pod</code> 的属主。 具有属主的对象是属主的 <strong>附属（Dependent）</strong>。<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[属主与附属](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/owners-dependents/)">[4]</span></a></sup></p>
<p>附属对象有一个 <code>metadata.ownerReferences</code> 字段，用于引用其属主对象。 一个有效的属主引用，包含与附属对象同在一个命名空间下的对象名称和一个 UID。 Kubernetes 自动为一些对象的附属资源设置属主引用的值， 这些对象包含 <code>ReplicaSet</code>、<code>DaemonSet</code>、<code>Deployment</code>、<code>Job</code>、<code>CronJob</code>、<code>ReplicationController</code> 等。</p>
<p>附属对象还有一个 <code>ownerReferences.blockOwnerDeletion</code> 字段，该字段使用布尔值， 用于控制特定的附属对象是否可以阻止垃圾收集删除其属主对象。 如果控制器（例如 Deployment 控制器） 设置了 <code>metadata.ownerReferences</code> 字段的值，Kubernetes 会自动设置 <code>blockOwnerDeletion</code> 的值为 <code>true</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ownerReferences:</span><br><span class="line">    - apiVersion: apps/v1</span><br><span class="line">      kind: ReplicaSet</span><br><span class="line">      name: test-nginx-deployment-54cb7448dc</span><br><span class="line">      uid: 34b3353a-bd05-4ac3-959f-d6fbc85a2d2e</span><br><span class="line">      controller: true</span><br><span class="line">      blockOwnerDeletion: true</span><br></pre></td></tr></table></figure>

<h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><p><a href="https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/workload-resources/pod-v1/">Pod 资源定义官网 API 说明</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: $&#123;NAME&#125;</span><br><span class="line">  namespace: $&#123;NAMESPACE&#125;</span><br><span class="line">spec:</span><br><span class="line">  restartPolicy: Always</span><br><span class="line">  containers:</span><br><span class="line">  - name: $&#123;NAME&#125;</span><br><span class="line">    image: nginx:1.14.2</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 80</span><br><span class="line">      name: http-web</span><br><span class="line">      </span><br><span class="line">    args:</span><br><span class="line">    - sh</span><br><span class="line">    - -c</span><br><span class="line">    - ping 127.0.0.1</span><br><span class="line">    </span><br><span class="line">    env:</span><br><span class="line">    - name: DEMO_GREETING</span><br><span class="line">      value: &quot;Hello from the environment&quot;</span><br><span class="line">    - name: DEMO_FAREWELL</span><br><span class="line">      value: &quot;Such a sweet sorrow&quot;</span><br><span class="line">    </span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: html</span><br><span class="line">      mountPath: /usr/share/nginx/html/</span><br><span class="line">      # subPath: logs/admin</span><br><span class="line">    </span><br><span class="line">  nodeSelector:</span><br><span class="line">      disktype: ssd</span><br><span class="line">      </span><br><span class="line">  nodeName: foo-node</span><br><span class="line">  </span><br><span class="line">  imagePullSecrets:</span><br><span class="line">  - name: $&#123;secret_name&#125;</span><br><span class="line">  </span><br><span class="line">  hostAliases:</span><br><span class="line">  - ip: &quot;50.18.1.1&quot;</span><br><span class="line">    hostnames:</span><br><span class="line">    - &quot;mysql.master&quot;</span><br><span class="line">    - &quot;mysql.slave&quot;</span><br><span class="line">    - &quot;mongo.com&quot;</span><br><span class="line">  - ip: &quot;50.18.1.2&quot;</span><br><span class="line">    hostnames:</span><br><span class="line">    - &quot;meta-service.apollo.com&quot;</span><br><span class="line">  - ip: &quot;172.31.88.78&quot;</span><br><span class="line">    hostnames:</span><br><span class="line">    - &quot;redis.com&quot;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>.spec.containers[*].ports[*].containerPort</code> - <code>Pod</code> 暴露的端口</p>
</li>
<li><p><code>.spec.containers[*].ports[*].name</code> - <code>Pod</code> 暴露的端口的自定义名称，可在 <a href="#Service"><code>Service</code></a> 的 <code>targetPort</code> 属性中，Probe 等功能中引用这些名称</p>
</li>
<li><p><code>.spec.restartPolicy</code> -  重启策略，适用于 <code>Pod</code> 中的所有容器，可取值如下</p>
<ul>
<li><code>Always</code> - 默认值</li>
<li><code>OnFailure</code></li>
<li><code>Never</code></li>
</ul>
</li>
<li><p><code>.spec.containers[*].args</code> - 定义容器启动后执行的命令，会替换镜像中定义的默认执行程序</p>
</li>
<li><p><code>.spec.nodeSelector</code>  - 根据节点标签将 <code>Pod</code> 调度到指定节点 <sup id="fnref:13"><a href="#fn:13" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[将 Pod 指派给节点](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/assign-pod-node/#nodename)">[13]</span></a></sup></p>
</li>
<li><p><code>.spec.nodeName: foo-node</code> - 将 <code>Pod</code> 调度到指定节点。 使用 <code>nodeName</code> 规则的优先级会高于使用 <code>nodeSelector</code> 或亲和性与非亲和性的规则，如果所指代的节点不存在，则 Pod 无法运行，而且在某些情况下可能会被自动删除。如果所指代的节点无法提供用来运行 Pod 所需的资源，Pod 会失败， 而其失败原因中会给出是否因为内存或 CPU 不足而造成无法运行。<sup id="fnref:12"><a href="#fn:12" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[nodeName ](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/assign-pod-node/#nodename)">[12]</span></a></sup></p>
</li>
<li><p><code>.spec.containers[*].env</code> - 创建 Pod 时，可以为其下的容器设置环境变量。通过配置文件的 <code>env</code> 或者 <code>envFrom</code> 字段来设置环境变量。 <sup id="fnref:15"><a href="#fn:15" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[为容器设置环境变量](https://kubernetes.io/zh-cn/docs/tasks/inject-data-application/define-environment-variable-container/)">[15]</span></a></sup></p>
</li>
<li><p><code>.spec.containers[*].volumeMounts</code> - 挂载卷，<code>subPath</code> 可用于指定挂载卷（<code>name: html</code>）的子目录到容器路径（<code>mountPath</code>），而不是直接挂载卷目录。</p>
</li>
</ul>
<h4 id="容器探针"><a href="#容器探针" class="headerlink" title="容器探针"></a>容器探针</h4><p><strong>探针（Probe）</strong> 主要用来检测 <code>Pod</code> 的状态，主要有 <strong>活跃（Liveness）</strong>、<strong>就绪（Readiness）</strong> 和 <strong>启动（Startup）</strong> 探针 <sup id="fnref:10"><a href="#fn:10" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[配置存活、就绪和启动探针](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/)">[10]</span></a></sup></p>
<ul>
<li><code>livenessProbe</code> - <code>kubelet</code> 使用 <strong>存活探针</strong> 来确定什么时候要重启容器，例如，存活探针可以探测到应用死锁（应用程序在运行，但是无法继续执行后面的步骤）情况。 重启这种状态下的容器有助于提高应用的可用性，即使其中存在缺陷。</li>
<li><code>readinessProbe</code> - <code>kubelet</code> 使用 <strong>就绪探针</strong> 可以知道容器何时准备好接受请求流量，当一个 <code>Pod</code> 内的所有容器都就绪时，才能认为该 <code>Pod</code> 就绪。 这种信号的一个用途就是控制哪个 <code>Pod</code> 作为 <code>Service</code> 的后端。 若 <code>Pod</code> 尚未就绪，会被从 <code>Service</code> 的负载均衡器中剔除。</li>
<li><code>startupProbe</code> - <code>kubelet</code> 使用 <strong>启动探针</strong> 来了解应用容器何时启动。 如果配置了这类探针，你就可以控制容器在启动成功后再进行存活性和就绪态检查， 确保这些存活、就绪探针不会影响应用的启动。 启动探针可以用于对慢启动容器进行存活性检测，避免它们在启动运行之前就被杀掉。</li>
</ul>
<p><code>Probe</code> 是由 <code>kubelet</code> 对容器执行的定期诊断。 要执行诊断，<code>kubelet</code> 既可以在容器内执行代码，也可以发出一个网络请求。<sup id="fnref:11"><a href="#fn:11" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[容器探针](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#container-probes)">[11]</span></a></sup></p>
<p>使用探针来检查容器有四种不同的方法。 每个探针都必须准确定义为这四种机制中的一种：</p>
<ul>
<li><code>exec</code> - 在容器内执行指定命令。如果命令退出时返回码为 0 则认为诊断成功。</li>
<li><code>grpc</code> - 使用 gRPC 执行一个远程过程调用。 目标应该实现 gRPC健康检查。 如果响应的状态是 “SERVING”，则认为诊断成功。 gRPC 探针是一个 alpha 特性，只有在你启用了 “GRPCContainerProbe” 特性门控时才能使用。</li>
<li><code>httpGet</code> - 对容器的 IP 地址上指定端口和路径执行 HTTP GET 请求。如果响应的状态码大于等于 200 且小于 400，则诊断被认为是成功的。</li>
<li><code>tcpSocket</code> - 对容器的 IP 地址上的指定端口执行 TCP 检查。如果端口打开，则诊断被认为是成功的。 如果远程系统（容器）在打开连接后立即将其关闭，这算作是健康的</li>
</ul>
<p>每次探测都将获得以下三种结果之一：</p>
<ul>
<li><code>Success</code>（成功） - 容器通过了诊断。</li>
<li><code>Failure</code>（失败） - 容器未通过诊断。</li>
<li><code>Unknown</code>（未知） - 诊断失败，因此不会采取任何行动。</li>
</ul>
<h5 id="livenessProbe"><a href="#livenessProbe" class="headerlink" title="livenessProbe"></a>livenessProbe</h5><h6 id="exec-方式的-livenessProbe"><a href="#exec-方式的-livenessProbe" class="headerlink" title="exec 方式的 livenessProbe"></a>exec 方式的 livenessProbe</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    test: liveness</span><br><span class="line">  name: liveness-exec</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: liveness</span><br><span class="line">    image: registry.k8s.io/busybox</span><br><span class="line">    args:</span><br><span class="line">    - /bin/sh</span><br><span class="line">    - -c</span><br><span class="line">    - touch /tmp/healthy; sleep 30; rm -f /tmp/healthy; sleep 600</span><br><span class="line">    livenessProbe:</span><br><span class="line">      exec:</span><br><span class="line">        command:</span><br><span class="line">        - cat</span><br><span class="line">        - /tmp/healthy</span><br><span class="line">      initialDelaySeconds: 5</span><br><span class="line">      periodSeconds: 5</span><br><span class="line">      timeoutSeconds: 10</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>.spec.containers[*].args</code> - 容器启动后执行的命令，取代镜像中默认的命令</p>
</li>
<li><p><code>.spec.containers[*].livenessProbe</code> - 配置存活探针</p>
<ul>
<li><code>exec.command</code> - 配置探测方式为 <code>exec</code> 以及在容器内执行的命令，如果命令执行成功并且返回值为 0，<code>kubelet</code> 就会认为这个容器是健康存活的。 如果这个命令返回非 0 值，<code>kubelet</code> 会杀死这个容器并 <strong>重新启动</strong> 它。</li>
<li><code>periodSeconds</code> - 指定 <code>kubelet</code> 应该每 5 秒执行一次存活探测，默认是 10 秒。最小值是 1</li>
<li><code>initialDelaySeconds</code> - <code>kubelet</code> 在执行第一次探测前等待 5 秒， 默认是 0 秒</li>
<li><code>timeoutSeconds</code> - 探测的超时后等待多少秒。默认值是 1 秒。最小值是 1。</li>
<li><code>successThreshold</code> - 探针在失败后，被视为成功的最小连续成功数。默认值是 1。 存活和启动探测的这个值必须是 1。最小值是 1。</li>
<li><code>failureThreshold</code> - 当探测失败时，Kubernetes 的重试次数。默认值是 3。最小值是 1</li>
</ul>
</li>
</ul>
<h6 id="httpGet-方式的-livenessProbe"><a href="#httpGet-方式的-livenessProbe" class="headerlink" title="httpGet 方式的 livenessProbe"></a>httpGet 方式的 livenessProbe</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    test: liveness</span><br><span class="line">  name: liveness-http</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: liveness</span><br><span class="line">    image: registry.k8s.io/liveness</span><br><span class="line">    args:</span><br><span class="line">    - /server</span><br><span class="line">    livenessProbe:</span><br><span class="line">      httpGet:</span><br><span class="line">        path: /healthz</span><br><span class="line">        port: 8080</span><br><span class="line">        </span><br><span class="line">        # 非常用字段</span><br><span class="line">        host: test.domain</span><br><span class="line">        scheme: http </span><br><span class="line">        </span><br><span class="line">        httpHeaders:</span><br><span class="line">        - name: Custom-Header</span><br><span class="line">          value: Awesome</span><br><span class="line">        - name: Accept</span><br><span class="line">          value: application/json</span><br><span class="line">        - name: Host</span><br><span class="line">          value: test.domain</span><br><span class="line">        </span><br><span class="line">      initialDelaySeconds: 3</span><br><span class="line">      periodSeconds: 3</span><br></pre></td></tr></table></figure>

<ul>
<li><code>.spec.containers[*].livenessProbe</code> - 配置存活探针<ul>
<li><code>httpGet.path</code> - 配置存活探针的探测方式为 <code>httpGet</code> ，并指定 HTTP GET 请求的路径（默认为 <code>/</code>）。返回大于或等于 200 并且小于 400 的任何代码都标示成功。其它返回代码都标示失败，失败时 <code>kubelet</code> 会杀死这个容器并将其重启</li>
<li><code>httpGet.port</code> - 指定 HTTP GET 请求的端口</li>
<li><code>httpGet.httpHeaders</code> - 请求中自定义的 HTTP 头。HTTP 头字段允许重复。</li>
<li><code>host</code> - 连接使用的主机名，默认是 <code>Pod</code> 的 IP。也可以在 HTTP 头中设置 <code>Host</code> 来代替</li>
<li><code>scheme</code> - 用于设置连接主机的方式（HTTP 还是 HTTPS）。默认是 “HTTP”</li>
</ul>
</li>
</ul>
<h6 id="tcpSocket-方式的-livenessProbe"><a href="#tcpSocket-方式的-livenessProbe" class="headerlink" title="tcpSocket 方式的 livenessProbe"></a>tcpSocket 方式的 livenessProbe</h6><p><code>kubelet</code> 会尝试在指定端口和容器建立套接字链接。 如果能建立连接，这个容器就被看作是健康的，如果不能则这个容器就被看作是有问题的。</p>
<p>对于 TCP 探测而言，kubelet 在节点上（不是在 <code>Pod</code> 里面）发起探测连接， 这意味着你不能在 <code>host</code> 参数上配置服务名称，因为 <code>kubelet</code> 不能解析服务名称。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: goproxy</span><br><span class="line">  labels:</span><br><span class="line">    app: goproxy</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: goproxy</span><br><span class="line">    image: registry.k8s.io/goproxy:0.1</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 8080</span><br><span class="line">      name: goproxy-port</span><br><span class="line">    readinessProbe:</span><br><span class="line">      tcpSocket:</span><br><span class="line">        port: goproxy-port</span><br><span class="line">      initialDelaySeconds: 5</span><br><span class="line">      periodSeconds: 10</span><br><span class="line">    livenessProbe:</span><br><span class="line">      tcpSocket:</span><br><span class="line">        port: 8080</span><br><span class="line">      initialDelaySeconds: 15</span><br><span class="line">      periodSeconds: 20</span><br></pre></td></tr></table></figure>
<ul>
<li><code>.spec.containers[*].livenessProbe</code> - 配置存活探针<ul>
<li><code>tcpSocket.port</code> - 配置存活探针的探测方式为 <code>tcpSocket</code>，并指定 TCP 探测连接的端口，可以使用命名的端口</li>
</ul>
</li>
</ul>
<h4 id="Pod-拓扑分布约束"><a href="#Pod-拓扑分布约束" class="headerlink" title="Pod 拓扑分布约束"></a>Pod 拓扑分布约束</h4><p>你可以使用 <strong>拓扑分布约束（Topology Spread Constraints）</strong> 来控制 Pod 在集群内故障域之间的分布， 例如区域（Region）、可用区（Zone）、节点和其他用户自定义拓扑域。 这样做有助于实现高可用并提升资源利用率。<sup id="fnref:16"><a href="#fn:16" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Pod 拓扑分布约束](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/topology-spread-constraints/)">[16]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: example-pod</span><br><span class="line">spec:</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">配置一个拓扑分布约束</span></span><br><span class="line">  topologySpreadConstraints:</span><br><span class="line">    - maxSkew: &lt;integer&gt;</span><br><span class="line">      minDomains: &lt;integer&gt; # 可选；自从 v1.25 开始成为 Beta</span><br><span class="line">      topologyKey: &lt;string&gt;</span><br><span class="line">      whenUnsatisfiable: &lt;string&gt;</span><br><span class="line">      labelSelector: &lt;object&gt;</span><br><span class="line">      matchLabelKeys: &lt;list&gt; # 可选；自从 v1.25 开始成为 Alpha</span><br><span class="line">      nodeAffinityPolicy: [Honor|Ignore] # 可选；自从 v1.25 开始成为 Alpha</span><br><span class="line">      nodeTaintsPolicy: [Honor|Ignore] # 可选；自从 v1.25 开始成为 Alpha</span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash"><span class="comment">## 其他 Pod 字段置于此处</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>maxSkew</code> - 描述 Pod 被（由 <code>topologyKey</code> 选中的节点组成的同一区域）均匀分布的程度</li>
<li><code>topologyKey</code> - 节点标签的 <strong>键</strong>，如果节点使用此 <strong>键</strong> 标记并且具有相同的 <strong>标签值</strong>， 则将这些节点视为处于同一拓扑域中</li>
<li><code>whenUnsatisfiable</code> - 指示如果 Pod 不满足分布约束时如何处理：<ul>
<li><code>DoNotSchedule</code> -（默认）告诉调度器不要调度。</li>
<li><code>ScheduleAnyway</code> - 告诉调度器仍然继续调度，只是根据如何能将偏差最小化来对节点进行排序。</li>
</ul>
</li>
</ul>
<h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><p><a href="https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/workload-resources/deployment-v1/">Deployment 资源定义官网 API 说明</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-deployment</span><br><span class="line">  labels:</span><br><span class="line">    app: nginx</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:1.14.2</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line">        </span><br><span class="line">  strategy:</span><br><span class="line">    rollingUpdate:</span><br><span class="line">      maxSurge: 25%</span><br><span class="line">      maxUnavailable: 25%</span><br><span class="line">    type: RollingUpdate</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>.spec.replicas</code> - Pod 副本的数量，会根据配置产生 <strong><a href="#metadata.ownerReferences">附属对象</a> ReplicaSet</strong></p>
</li>
<li><p><code>.spec.selector</code> - 字段定义了 <code>Deployment</code> 如何查找要管理的 <code>Pod</code></p>
</li>
<li><p><code>.spec.template</code> - 定义了 <code>Pod</code> 相关的必要信息，本质上是定义一个 <a href="#Pod"><code>Pod</code> 对象</a></p>
<ul>
<li><code>.metadata.labels</code> - 为容器添加的标签，<code>slector</code> 可以使用此标签查找要管理的 <code>Pod</code> </li>
<li><code>.spec.containers</code> - 容器相关定义，包含启动的容器名称，使用的镜像，容器暴露的端口等</li>
</ul>
</li>
<li><p><code>.spec.strategy</code> - 指定用于用新 Pod 替换旧 Pod 的策略。<code>.spec.strategy.type</code> 可以是 <code>Recreate</code> 或 <code>RollingUpdate</code>。<code>RollingUpdate</code> 是默认值。<sup id="fnref:17"><a href="#fn:17" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[策略](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#strategy)">[17]</span></a></sup></p>
<ul>
<li><code>.spec.strategy.type==Recreate</code> - 如果值为 <code>Recreate</code>，在创建新 Pod 之前，所有现有的 Pod 会被杀死</li>
<li><code>.spec.strategy.type==RollingUpdate</code> - Deployment 会在 <code>.spec.strategy.type==RollingUpdate</code> 时，采取 滚动更新的方式更新 Pod。你可以指定 <code>maxUnavailable</code> 和 <code>maxSurge</code> 来控制滚动更新 过程。</li>
<li><code>.spec.strategy.rollingUpdate.maxUnavailable</code> -  是一个可选字段，用来指定 更新过程中不可用的 Pod 的个数上限，默认值为 25%。如果 <code>.spec.strategy.rollingUpdate.maxSurge</code> 为 0，则此值不能为 0</li>
<li><code>.spec.strategy.rollingUpdate.maxSurge</code> - 是一个可选字段，用来指定可以创建的超出期望 Pod 个数的 Pod 数量， 如果 <code>MaxUnavailable</code> 为 0，则此值不能为 0，此字段的默认值为 25%</li>
</ul>
</li>
</ul>
<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p><a href="https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/service-resources/service-v1/">Service 资源定义官网 API 说明</a></p>
<p>将运行在一组 Pods 上的应用程序公开为网络服务的抽象方法。主要为后端的一组 POD （通过选择算符选定）提供 <code>Cluster-IP</code> 和负载均衡（默认轮询）及高可用（只有就绪的 POD 才会被对外公布，未就绪的 POD 不会对外发布）。 <sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[服务（Service）](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/)">[5]</span></a></sup></p>
<h4 id="有选择算符的-Service"><a href="#有选择算符的-Service" class="headerlink" title="有选择算符的 Service"></a>有选择算符的 Service</h4><p><code>Service</code> 所针对的 <code>Pod</code> 集合通常是通过 <strong><a href="#%E6%A0%87%E7%AD%BE-Labels-%E5%92%8C%E9%80%89%E6%8B%A9%E7%AE%97%E7%AC%A6-selector">选择算符</a></strong> 来确定的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: my-service</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app.kubernetes.io/name: MyApp</span><br><span class="line">  ports:</span><br><span class="line">    # 多端口 Service 时，必须提供所有的端口名称，以使端口无歧义</span><br><span class="line">    - name: http</span><br><span class="line">      protocol: TCP</span><br><span class="line">      port: 80</span><br><span class="line">      targetPort: 9376</span><br><span class="line">    - name: https</span><br><span class="line">      protocol: TCP</span><br><span class="line">      port: 443</span><br><span class="line">      targetPort: 9378</span><br><span class="line">      </span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">非常用字段</span></span><br><span class="line">  sessionAffinity: None</span><br><span class="line">  ipFamilies:</span><br><span class="line">    - IPv4</span><br><span class="line">  ipFamilyPolicy: SingleStack</span><br><span class="line">  internalTrafficPolicy: Cluster</span><br><span class="line">  </span><br><span class="line">  type: ClusterIP</span><br><span class="line">  clusterIPs:</span><br><span class="line">    - 10.107.120.122</span><br><span class="line">  clusterIP: 10.107.120.122</span><br><span class="line">  </span><br><span class="line">  externalTrafficPolicy: Cluster</span><br><span class="line">  internalTrafficPolicy: Cluster</span><br><span class="line">  </span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="built_in">type</span> 为 NodePort 时</span></span><br><span class="line">  type: NodePort</span><br><span class="line">  ports:</span><br><span class="line">    - nodePort: 30443</span><br><span class="line">      port: 443</span><br><span class="line">      targetPort: 8443</span><br><span class="line">      </span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>.spec.selector</code> - 根据 <strong><a href="##%E6%A0%87%E7%AD%BE-Labels-%E5%92%8C%E9%80%89%E6%8B%A9%E7%AE%97%E7%AC%A6-selector">选择算符</a></strong> 选择后端的 <code>POD</code></p>
</li>
<li><p><code>.spec.ports[*].name</code> - 对于某些服务，可能需要公开多个端口。 Kubernetes 允许在 <code>Service</code> 对象上配置多个端口定义。 <strong>为服务使用多个端口时，必须提供所有端口名称，以使它们无歧义</strong>。</p>
</li>
<li><p><code>.spec.ports[*].protocol</code> - <code>Service</code> 监听的端口协议，默认为 TCP</p>
</li>
<li><p><code>.spec.ports[*].port</code> - <code>Service</code> 监听的端口</p>
</li>
<li><p><code>.spec.ports[*].targetPort</code> - 后端 <code>POD</code> 监听的端口，不指定的情况（默认）下，<code>targetPort</code> 将被设置为与 <code>port</code> 字段相同的值。</p>
</li>
<li><p><code>.spec.sessionAffinity</code> -  要确保每次都将来自特定客户端的连接传递到同一 <code>Pod</code>，可以设置为 <code>ClientIP</code> (默认为 <code>None</code>) 来基于客户端的 IP 地址选择会话亲和性。还可以通过适当设置 <code>.spec.sessionAffinityConfig.clientIP.timeoutSeconds</code> 来设置最大会话停留时间。（默认值为 10800 秒，即 3 小时）</p>
</li>
<li><p><code>.spec.ipFamilies</code> - 定义分配 ip 版本(IPv4,IPv6)的顺序，此字段是不可变的，因为系统无法为已经存在的服务重新分配 <code>.spec.ClusterIP</code>。如果你想改变 <code>.spec.ipFamilies</code>，则需要删除并重新创建服务。可以配置为以下值：</p>
<ul>
<li><code>IPv4</code></li>
<li><code>IPv6</code></li>
<li><code>&quot;IPv4&quot;,&quot;IPv6&quot;</code></li>
<li><code>&quot;IPv6&quot;,&quot;IPv4&quot;</code></li>
</ul>
</li>
<li><p><code>.spec.ipFamilyPolicy</code> - IP 地址族策略。<sup id="fnref:7"><a href="#fn:7" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[配置 IPv4/IPv6 双协议栈](https://kubernetes.io/zh-cn/docs/concepts/services-networking/dual-stack/#%E9%85%8D%E7%BD%AE-ipv4-ipv6-%E5%8F%8C%E5%8D%8F%E8%AE%AE%E6%A0%88)">[7]</span></a></sup></p>
<ul>
<li><code>SingleStack</code> - 默认值。单栈服务。控制面使用第一个配置的服务集群 IP 范围为服务分配集群 IP</li>
<li><code>PreferDualStack</code> - 为服务分配 IPv4 和 IPv6 集群 IP 地址</li>
<li><code>RequireDualStack</code> - 从基于在 <code>.spec.ipFamilies</code> 数组中第一个元素的地址族的 <code>.spec.ClusterIPs</code> 列表中选择 <code>.spec.ClusterIP</code></li>
</ul>
</li>
<li><p><code>.spec.clusterIPs</code> - IP 的主要字段，值根据 <code>ipFamilies</code>, <code>ipFamilyPolicy</code> 的配置计算而出，<a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/dual-stack/#dual-stack-options-on-new-services">规则参考</a></p>
</li>
<li><p><code>.spec.clusterIP</code> - IP 的次要字段，其取值从 <code>.spec.ClusterIPs</code> 计算而来。也可以通过此字段配置自定义的 IP 地址 <sup id="fnref:9"><a href="#fn:9" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[选择自己的 IP 地址](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#%E9%80%89%E6%8B%A9%E8%87%AA%E5%B7%B1%E7%9A%84-ip-%E5%9C%B0%E5%9D%80)">[9]</span></a></sup> </p>
</li>
<li><p><code>.spec.type</code> - 指定 <code>Service</code> 的类型，默认为 <code>ClusterIP</code>，可选值如下<sup id="fnref:8"><a href="#fn:8" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[NodePort 类型](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#type-nodeport)">[8]</span></a></sup>：</p>
<ul>
<li><code>ClusterIP</code> - 通过集群的内部 IP 暴露服务，选择该值时服务只能够在集群内部访问。 这也是默认值。</li>
<li><code>NodePort</code> - 通过每个节点上的 IP 和静态端口（<code>NodePort</code>，默认范围 <code>30000-32767</code>）暴露服务。<code>NodePort</code> 服务会路由到自动创建的 <code>ClusterIP</code> 服务，此种类型，服务可通过节点 ip 和 <code>NodePort</code> (<code>nodeIP:.spec.ports[*].nodePort</code>)对外访问，也可以通过 <code>.spec.clusterIP:.spec.ports[*].port</code> 对外可见。</li>
<li><code>LoadBalancer</code> - 使用云提供商的负载均衡器向外部暴露服务。 外部负载均衡器可以将流量路由到自动创建的 <code>NodePort</code> 服务和 <code>ClusterIP</code> 服务上。</li>
<li><code>ExternalName</code> - 通过返回 <code>CNAME</code> 和对应值，可以将服务映射到 <code>externalName</code> 字段的内容（例如，<code>foo.bar.example.com</code>）。 无需创建任何类型代理。</li>
</ul>
</li>
<li><p><code>.spec.externalTrafficPolicy</code> - 控制来自于外部的流量是如何路由的, 可选值有 <code>Cluster</code> 和 <code>Local</code></p>
<ul>
<li><code>Cluster</code> - 将外部流量路由到所有就绪的端点</li>
<li><code>Local</code> - 只路由到当前节点上就绪的端点，如果当前节点上没有就绪的端点，<code>kube-proxy</code> 不会转发请求相关服务的任何流量</li>
</ul>
</li>
<li><p><code>.spec.internalTrafficPolicy</code> - 控制内部来源的流量是如何转发的，可选值有 <code>Cluster</code> 和 <code>Local</code></p>
</li>
</ul>
<p>Kubernetes 为该服务分配一个 IP 地址（有时称为 “集群 IP”），该 IP 地址由服务代理使用。</p>
<p><code>Pod</code> 中的端口定义是有名字的，你可以在 <code>Service</code> 的 <code>targetPort</code> 属性中引用这些名称。 例如，我们可以通过以下方式将 <code>Service</code> 的 <code>targetPort</code> 绑定到 <code>Pod</code> 端口：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">  labels:</span><br><span class="line">    app.kubernetes.io/name: proxy</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx:stable</span><br><span class="line">    ports:</span><br><span class="line">      - containerPort: 80</span><br><span class="line">        name: http-web-svc</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-service</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app.kubernetes.io/name: proxy</span><br><span class="line">  ports:</span><br><span class="line">  - name: name-of-service-port</span><br><span class="line">    protocol: TCP</span><br><span class="line">    port: 80</span><br><span class="line">    targetPort: http-web-svc</span><br></pre></td></tr></table></figure>

<h4 id="没有选择算符的-Service"><a href="#没有选择算符的-Service" class="headerlink" title="没有选择算符的 Service"></a>没有选择算符的 Service</h4><p>由于选择算符的存在，服务最常见的用法是为 Kubernetes Pod 的访问提供抽象， 但是当与相应的 <code>Endpoints</code> 对象一起使用且没有选择算符时， 服务也可以为其他类型的后端提供抽象，包括在集群外运行的后端 <sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[没有选择算符的 Service](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#services-without-selectors)">[6]</span></a></sup></p>
<p>定义没有选择算符的 <code>Service</code> 实例:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: my-service</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">    - protocol: TCP</span><br><span class="line">      port: 80</span><br><span class="line">      targetPort: 9376</span><br></pre></td></tr></table></figure>
<p>由于此服务没有选择算符，因此不会自动创建相应的 <code>Endpoints</code> 对象。 你可以通过手动添加 <code>Endpoints</code> 对象，将服务手动映射到运行该服务的网络地址和端口：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Endpoints</span><br><span class="line">metadata:</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">这里的 name 要与 Service 的名字相同</span></span><br><span class="line">  name: my-service</span><br><span class="line">subsets:</span><br><span class="line">  - addresses:</span><br><span class="line">      - ip: 192.0.2.42</span><br><span class="line">    ports:</span><br><span class="line">      - port: 9376</span><br></pre></td></tr></table></figure>
<p><strong>当你为某个 <code>Service</code> 创建一个 <code>Endpoints</code> 对象时，你要将新对象的名称设置为与 <code>Service</code> 的名称相同。</strong></p>
<blockquote>
<p><strong>说明</strong>：<br>端点 IPs 必须不可以 是：本地回路（IPv4 的 127.0.0.0&#x2F;8, IPv6 的 ::1&#x2F;128） 或本地链接（IPv4 的 169.254.0.0&#x2F;16 和 224.0.0.0&#x2F;24，IPv6 的 fe80::&#x2F;64)。</p>
<p>端点 IP 地址不能是其他 Kubernetes 服务的集群 IP，因为 kube-proxy 不支持将虚拟 IP 作为目标。</p>
</blockquote>
<h4 id="无头服务（Headless-Services）"><a href="#无头服务（Headless-Services）" class="headerlink" title="无头服务（Headless Services）"></a>无头服务（Headless Services）</h4><p>有时不需要或不想要负载均衡，以及单独的 Service IP。 遇到这种情况，可以通过指定 Cluster IP（<code>spec.clusterIP</code>）的值为 <code>None</code> 来创建 <code>Headless Service</code>。<sup id="fnref:14"><a href="#fn:14" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[无头服务（Headless Services）](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#headless-services)">[14]</span></a></sup></p>
<p>创建 <code>Headless Services</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia-headless</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  clusterIP: None              #这使得服务成为 headless service</span><br><span class="line">  ports:</span><br><span class="line">  - port: 80</span><br><span class="line">    targetPort: 8080</span><br><span class="line">  selector:</span><br><span class="line">    app: kubia</span><br></pre></td></tr></table></figure>

<p>使用此配置创建的 <code>Headless Services</code>，系统不会为其分配 <code>CLUSTER-IP</code>。</p>
<p>当通过此服务的 FQDN <code>kubia-headless.default.svc.cluster.local</code> 解析时，系统会返回此服务 <strong>选择算符 <code>.spec.selector</code></strong> 选择的 <strong>就绪</strong> 的后端 POD 的 IP。</p>
<p>如果配置的是 **<a href="#%E6%B2%A1%E6%9C%89%E9%80%89%E6%8B%A9%E7%AE%97%E7%AC%A6%E7%9A%84-Service">不带选择算符的服务</a>**，<a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#without-selectors">解析规则如是</a>，如果查找到了和 Service 的 <code>name</code> 一样的 <code>endpoint</code>，则解析到此 <code>endpoint</code>。</p>
<h3 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h3><p><code>Ingress</code> 可为 <code>Service</code> 提供外部可访问的 URL、负载均衡流量、终止 SSL&#x2F;TLS，以及基于名称的虚拟托管。</p>
<p><strong><code>Ingress</code> 不会公开任意端口或协议</strong>。 将 HTTP 和 HTTPS 以外的服务公开到 Internet 时，通常使用 <code>Service.Type=NodePort</code> 或 <code>Service.Type=LoadBalancer</code> 类型的 <code>Service</code>。</p>
<p>你必须拥有一个 <code>Ingress 控制器</code> 才能满足 <code>Ingress</code> 的要求。 仅创建 <code>Ingress</code> 资源本身没有任何效果。</p>
<h4 id="安装-ingress-nginx-controller"><a href="#安装-ingress-nginx-controller" class="headerlink" title="安装 ingress-nginx controller"></a>安装 ingress-nginx controller</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.3.1/deploy/static/provider/cloud/deploy.yaml</span><br></pre></td></tr></table></figure>
<p>编辑 <code>ingress-nginx</code> 的 <code>Deployment</code> 配置文件，在 <code>Deployment</code> 中的 <code>.spec.template.spec</code> 下添加字段 <code>hostNetwork: true</code>，以使 <code>ingress-nginx-controller</code> 可以使用节点的主机网络提供对外访问<br><img src="https://i.csms.tech/img_61.png"></p>
<p>创建 <code>Ingress</code> 对象</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: example-ingress</span><br><span class="line">  annotations:</span><br><span class="line">    nginx.ingress.kubernetes.io/rewrite-target: /$1</span><br><span class="line">spec:</span><br><span class="line">  ingressClassName: nginx</span><br><span class="line">  rules:</span><br><span class="line">    - host: hello-world.info</span><br><span class="line">      http:</span><br><span class="line">        paths:</span><br><span class="line">          - path: /</span><br><span class="line">            pathType: Prefix</span><br><span class="line">            backend:</span><br><span class="line">              service:</span><br><span class="line">                name: web</span><br><span class="line">                port:</span><br><span class="line">                  number: 8080</span><br></pre></td></tr></table></figure>
<p>配置完成后，查看 <code>Ingress</code> 资源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get ingress -o wide</span></span><br><span class="line">NAME              CLASS   HOSTS              ADDRESS   PORTS   AGE</span><br><span class="line">example-ingress   nginx   hello-world.info             80      131m</span><br></pre></td></tr></table></figure>
<p>将域名解析到 <code>ingress-nginx-controller</code> 所在节点的 IP，即可在外部访问服务。</p>
<p>为了将 <code>ingress-nginx-controller</code> 固定启动在边缘节点，可以使用 <code>DaemonSet</code> 替代 <code>Deployment</code>。</p>
<h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/kubernetes-objects/#required-fields">必需字段</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names/">对象名称和 IDs</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/">标签和选择算符</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/owners-dependents/">属主与附属</a><a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/">服务（Service）</a><a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#services-without-selectors">没有选择算符的 Service</a><a href="#fnref:6" rev="footnote"> ↩</a></span></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/dual-stack/#%E9%85%8D%E7%BD%AE-ipv4-ipv6-%E5%8F%8C%E5%8D%8F%E8%AE%AE%E6%A0%88">配置 IPv4/IPv6 双协议栈</a><a href="#fnref:7" rev="footnote"> ↩</a></span></li><li id="fn:8"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">8.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#type-nodeport">NodePort 类型</a><a href="#fnref:8" rev="footnote"> ↩</a></span></li><li id="fn:9"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">9.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#%E9%80%89%E6%8B%A9%E8%87%AA%E5%B7%B1%E7%9A%84-ip-%E5%9C%B0%E5%9D%80">选择自己的 IP 地址</a><a href="#fnref:9" rev="footnote"> ↩</a></span></li><li id="fn:10"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">10.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/">配置存活、就绪和启动探针</a><a href="#fnref:10" rev="footnote"> ↩</a></span></li><li id="fn:11"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">11.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#container-probes">容器探针</a><a href="#fnref:11" rev="footnote"> ↩</a></span></li><li id="fn:12"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">12.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/assign-pod-node/#nodename">nodeName </a><a href="#fnref:12" rev="footnote"> ↩</a></span></li><li id="fn:13"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">13.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/assign-pod-node/#nodename">将 Pod 指派给节点</a><a href="#fnref:13" rev="footnote"> ↩</a></span></li><li id="fn:14"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">14.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#headless-services">无头服务（Headless Services）</a><a href="#fnref:14" rev="footnote"> ↩</a></span></li><li id="fn:15"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">15.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/tasks/inject-data-application/define-environment-variable-container/">为容器设置环境变量</a><a href="#fnref:15" rev="footnote"> ↩</a></span></li><li id="fn:16"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">16.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/topology-spread-constraints/">Pod 拓扑分布约束</a><a href="#fnref:16" rev="footnote"> ↩</a></span></li><li id="fn:17"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">17.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#strategy">策略</a><a href="#fnref:17" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S 上安装 Prometheus 并监控 K8S 集群</title>
    <url>/202212141608/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="版本信息"><a href="#版本信息" class="headerlink" title="版本信息"></a>版本信息</h1><ul>
<li>Kubernetes 1.24</li>
</ul>
<h1 id="Prometheus-部署步骤"><a href="#Prometheus-部署步骤" class="headerlink" title="Prometheus 部署步骤"></a>Prometheus 部署步骤</h1><h2 id="为-Prometheus-创建专用的-Namespace，此处创建-prometheus"><a href="#为-Prometheus-创建专用的-Namespace，此处创建-prometheus" class="headerlink" title="为 Prometheus 创建专用的 Namespace，此处创建 prometheus"></a>为 Prometheus 创建专用的 Namespace，此处创建 <code>prometheus</code></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create namespace prometheus</span><br></pre></td></tr></table></figure>

<h2 id="创建集群角色"><a href="#创建集群角色" class="headerlink" title="创建集群角色"></a>创建集群角色</h2><p>Prometheus 使用 Kubernetes API 从 Nodes、Pods、Deployments 等等中读取所有可用的指标。因此，我们需要创建一个包含 read access 所需 API 组的 RBAC 策略，并将该策略绑定到新建的 <code>prometheus</code> 命名空间。<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[如何部署 Prometheus 监控K8S](https://zhuanlan.zhihu.com/p/456205833)">[1]</span></a></sup></p>
<ol>
<li>创建一个名为 <code>prometheusClusterRole.yaml</code>的文件，并复制以下 RBAC 角色。<blockquote>
<p>在下面给出的角色中，可以看到，我们已经往 <code>nodes</code>, <code>services endpoints</code>, <code>pods</code> 和 <code>ingresses</code> 中添加了 <code>get</code>，<code>list</code> 以及 <code>watch</code> 权限。角色绑定被绑定到监控命名空间。如果有任何要从其他对象中检索指标的用例，则需要将其添加到此集群角色中。</p>
</blockquote>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRole</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus</span><br><span class="line">rules:</span><br><span class="line">- apiGroups: [&quot;&quot;]</span><br><span class="line">  resources:</span><br><span class="line">  - nodes</span><br><span class="line">  - nodes/proxy</span><br><span class="line">  - services</span><br><span class="line">  - endpoints</span><br><span class="line">  - pods</span><br><span class="line">  verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;]</span><br><span class="line">- apiGroups:</span><br><span class="line">  - extensions</span><br><span class="line">  resources:</span><br><span class="line">  - ingresses</span><br><span class="line">  verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;]</span><br><span class="line">- nonResourceURLs: [&quot;/metrics&quot;]</span><br><span class="line">  verbs: [&quot;get&quot;]</span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: prometheus</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: default</span><br><span class="line">  namespace: prometheus</span><br></pre></td></tr></table></figure></li>
<li>使用下面的命令创建角色<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl apply -f prometheusClusterRole.yaml</span><br></pre></td></tr></table></figure></li>
</ol>
<span id="more"></span>
<h2 id="创建-ConfigMap-以外部化-Prometheus-配置"><a href="#创建-ConfigMap-以外部化-Prometheus-配置" class="headerlink" title="创建 ConfigMap 以外部化 Prometheus 配置"></a>创建 ConfigMap 以外部化 Prometheus 配置</h2><p>Prometheus 的所有配置都是 <code>prometheus.yaml</code> 文件的一部分，而 <code>Alertmanager</code> 的所有警报规则都配置在 <code>prometheus.rules</code></p>
<ul>
<li><code>prometheus.yaml</code> - 这是主要的 Prometheus 配置，包含所有抓取配置、服务发现详细信息、存储位置、数据保留配置等</li>
<li><code>prometheus.rules</code> - 此文件包含所有 Prometheus 警报规则</li>
</ul>
<p>通过将 Prometheus 配置外部化到 Kubernetes 的 <code>ConfigMap</code>，那么就无需当需要添加或删除配置时，再来构建 Prometheus 镜像。这里需要更新配置映射并重新启动 Prometheus pod 以应用新配置。</p>
<p>使用以下内容创建 <code>ConfigMap</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus-server-conf</span><br><span class="line">  labels:</span><br><span class="line">    name: prometheus-server-conf</span><br><span class="line">  namespace: prometheus</span><br><span class="line">data:</span><br><span class="line">  prometheus.rules: |-</span><br><span class="line">    groups:</span><br><span class="line">    - name: devopscube demo alert</span><br><span class="line">      rules:</span><br><span class="line">      - alert: High Pod Memory</span><br><span class="line">        expr: sum(container_memory_usage_bytes) &gt; 1</span><br><span class="line">        for: 1m</span><br><span class="line">        labels:</span><br><span class="line">          severity: slack</span><br><span class="line">        annotations:</span><br><span class="line">          summary: High Memory Usage</span><br><span class="line">  prometheus.yml: |-</span><br><span class="line">    global:</span><br><span class="line">      scrape_interval: 5s</span><br><span class="line">      evaluation_interval: 5s</span><br><span class="line">    rule_files:</span><br><span class="line">      - /etc/prometheus/prometheus.rules</span><br><span class="line">    alerting:</span><br><span class="line">      alertmanagers:</span><br><span class="line">      - scheme: http</span><br><span class="line">        static_configs:</span><br><span class="line">        - targets:</span><br><span class="line">          - &quot;alertmanager.monitoring.svc:9093&quot;</span><br><span class="line"></span><br><span class="line">    scrape_configs:</span><br><span class="line">      - job_name: &#x27;node-exporter&#x27;</span><br><span class="line">        kubernetes_sd_configs:</span><br><span class="line">          - role: endpoints</span><br><span class="line">        relabel_configs:</span><br><span class="line">        - source_labels: [__meta_kubernetes_endpoints_name]</span><br><span class="line">          regex: &#x27;node-exporter&#x27;</span><br><span class="line">          action: keep</span><br><span class="line">      </span><br><span class="line">      - job_name: &#x27;kubernetes-apiservers&#x27;</span><br><span class="line"></span><br><span class="line">        kubernetes_sd_configs:</span><br><span class="line">        - role: endpoints</span><br><span class="line">        scheme: https</span><br><span class="line"></span><br><span class="line">        tls_config:</span><br><span class="line">          ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt</span><br><span class="line">        bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token</span><br><span class="line"></span><br><span class="line">        relabel_configs:</span><br><span class="line">        - source_labels: [__meta_kubernetes_namespace, __meta_kubernetes_service_name, __meta_kubernetes_endpoint_port_name]</span><br><span class="line">          action: keep</span><br><span class="line">          regex: default;kubernetes;https</span><br><span class="line"></span><br><span class="line">      - job_name: &#x27;kubernetes-nodes&#x27;</span><br><span class="line"></span><br><span class="line">        scheme: https</span><br><span class="line"></span><br><span class="line">        tls_config:</span><br><span class="line">          ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt</span><br><span class="line">        bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token</span><br><span class="line"></span><br><span class="line">        kubernetes_sd_configs:</span><br><span class="line">        - role: node</span><br><span class="line"></span><br><span class="line">        relabel_configs:</span><br><span class="line">        - action: labelmap</span><br><span class="line">          regex: __meta_kubernetes_node_label_(.+)</span><br><span class="line">        - target_label: __address__</span><br><span class="line">          replacement: kubernetes.default.svc:443</span><br><span class="line">        - source_labels: [__meta_kubernetes_node_name]</span><br><span class="line">          regex: (.+)</span><br><span class="line">          target_label: __metrics_path__</span><br><span class="line">          replacement: /api/v1/nodes/$&#123;1&#125;/proxy/metrics     </span><br><span class="line">      </span><br><span class="line">      - job_name: &#x27;kubernetes-pods&#x27;</span><br><span class="line"></span><br><span class="line">        kubernetes_sd_configs:</span><br><span class="line">        - role: pod</span><br><span class="line"></span><br><span class="line">        relabel_configs:</span><br><span class="line">        - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]</span><br><span class="line">          action: keep</span><br><span class="line">          regex: true</span><br><span class="line">        - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path]</span><br><span class="line">          action: replace</span><br><span class="line">          target_label: __metrics_path__</span><br><span class="line">          regex: (.+)</span><br><span class="line">        - source_labels: [__address__, __meta_kubernetes_pod_annotation_prometheus_io_port]</span><br><span class="line">          action: replace</span><br><span class="line">          regex: ([^:]+)(?::\d+)?;(\d+)</span><br><span class="line">          replacement: $1:$2</span><br><span class="line">          target_label: __address__</span><br><span class="line">        - action: labelmap</span><br><span class="line">          regex: __meta_kubernetes_pod_label_(.+)</span><br><span class="line">        - source_labels: [__meta_kubernetes_namespace]</span><br><span class="line">          action: replace</span><br><span class="line">          target_label: kubernetes_namespace</span><br><span class="line">        - source_labels: [__meta_kubernetes_pod_name]</span><br><span class="line">          action: replace</span><br><span class="line">          target_label: kubernetes_pod_name</span><br><span class="line">      </span><br><span class="line">      - job_name: &#x27;kube-state-metrics&#x27;</span><br><span class="line">        static_configs:</span><br><span class="line">          - targets: [&#x27;kube-state-metrics.kube-system.svc.cluster.local:8080&#x27;]</span><br><span class="line"></span><br><span class="line">      - job_name: &#x27;kubernetes-cadvisor&#x27;</span><br><span class="line"></span><br><span class="line">        scheme: https</span><br><span class="line"></span><br><span class="line">        tls_config:</span><br><span class="line">          ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt</span><br><span class="line">        bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token</span><br><span class="line"></span><br><span class="line">        kubernetes_sd_configs:</span><br><span class="line">        - role: node</span><br><span class="line"></span><br><span class="line">        relabel_configs:</span><br><span class="line">        - action: labelmap</span><br><span class="line">          regex: __meta_kubernetes_node_label_(.+)</span><br><span class="line">        - target_label: __address__</span><br><span class="line">          replacement: kubernetes.default.svc:443</span><br><span class="line">        - source_labels: [__meta_kubernetes_node_name]</span><br><span class="line">          regex: (.+)</span><br><span class="line">          target_label: __metrics_path__</span><br><span class="line">          replacement: /api/v1/nodes/$&#123;1&#125;/proxy/metrics/cadvisor</span><br><span class="line">      </span><br><span class="line">      - job_name: &#x27;kubernetes-service-endpoints&#x27;</span><br><span class="line"></span><br><span class="line">        kubernetes_sd_configs:</span><br><span class="line">        - role: endpoints</span><br><span class="line"></span><br><span class="line">        relabel_configs:</span><br><span class="line">        - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_scrape]</span><br><span class="line">          action: keep</span><br><span class="line">          regex: true</span><br><span class="line">        - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_scheme]</span><br><span class="line">          action: replace</span><br><span class="line">          target_label: __scheme__</span><br><span class="line">          regex: (https?)</span><br><span class="line">        - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_path]</span><br><span class="line">          action: replace</span><br><span class="line">          target_label: __metrics_path__</span><br><span class="line">          regex: (.+)</span><br><span class="line">        - source_labels: [__address__, __meta_kubernetes_service_annotation_prometheus_io_port]</span><br><span class="line">          action: replace</span><br><span class="line">          target_label: __address__</span><br><span class="line">          regex: ([^:]+)(?::\d+)?;(\d+)</span><br><span class="line">          replacement: $1:$2</span><br><span class="line">        - action: labelmap</span><br><span class="line">          regex: __meta_kubernetes_service_label_(.+)</span><br><span class="line">        - source_labels: [__meta_kubernetes_namespace]</span><br><span class="line">          action: replace</span><br><span class="line">          target_label: kubernetes_namespace</span><br><span class="line">        - source_labels: [__meta_kubernetes_service_name]</span><br><span class="line">          action: replace</span><br><span class="line">          target_label: kubernetes_name</span><br></pre></td></tr></table></figure>

<p><code>prometheus.yaml</code> 包含了用以发现动态运行在 Kubernetes 集群的 <code>pods</code> 和 <code>services</code> 的所有配置。</p>
<p>Prometheus 抓取配置中有以下 <code>scrape jobs</code>：</p>
<ul>
<li><code>kubernetes-apiservers</code> - 它从 API 服务器获取所有指标。</li>
<li><code>kubernetes-nodes</code> - 它收集所有 Kubernetes 节点指标。</li>
<li><code>kubernetes-pods</code> - 如果 pod 元数据用 <code>prometheus.io/scrape</code> 和 <code>prometheus.io/port</code> 来注释，那么所有的 pod 都得以发现。</li>
<li><code>kubernetes-cadvisor</code> - 收集所有 cAdvisor 指标。</li>
<li><code>kubernetes-service-endpoints</code> - 如果服务元数据使用 <code>prometheus.io/scrape</code> 和 <code>prometheus.io/port</code> 注释来进行注释，那么所有服务端点都将被报废。它可以用于黑盒监控。</li>
</ul>
<h2 id="部署-Prometheus-Server"><a href="#部署-Prometheus-Server" class="headerlink" title="部署 Prometheus Server"></a>部署 Prometheus Server</h2><p>使用以下内容创建 Deployment，在此配置中，我们将 Prometheus 的 <code>ConfigMap</code> 作为文件安装在 <code>/etc/prometheus</code> 中，持久化存储使用 PV。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus-deployment</span><br><span class="line">  namespace: prometheus</span><br><span class="line">  labels:</span><br><span class="line">    app: prometheus-server</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: prometheus-server</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: prometheus-server</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">        - name: prometheus</span><br><span class="line">          image: prom/prometheus</span><br><span class="line">          args:</span><br><span class="line">            - &quot;--storage.tsdb.retention.time=12h&quot;</span><br><span class="line">            - &quot;--config.file=/etc/prometheus/prometheus.yml&quot;</span><br><span class="line">            - &quot;--storage.tsdb.path=/prometheus/&quot;</span><br><span class="line">          ports:</span><br><span class="line">            - containerPort: 9090</span><br><span class="line">          resources:</span><br><span class="line">            requests:</span><br><span class="line">              cpu: 500m</span><br><span class="line">              memory: 500M</span><br><span class="line">            limits:</span><br><span class="line">              cpu: 1</span><br><span class="line">              memory: 1Gi</span><br><span class="line">          volumeMounts:</span><br><span class="line">            - name: prometheus-config-volume</span><br><span class="line">              mountPath: /etc/prometheus/</span><br><span class="line">            - name: prometheus-storage-volume</span><br><span class="line">              mountPath: /prometheus/</span><br><span class="line">      volumes:</span><br><span class="line">        - name: prometheus-config-volume</span><br><span class="line">          configMap:</span><br><span class="line">            defaultMode: 420</span><br><span class="line">            name: prometheus-server-conf</span><br><span class="line">  </span><br><span class="line">        - name: prometheus-storage-volume</span><br><span class="line">          persistentVolumeClaim:</span><br><span class="line">            claimName: prometheus-pvc</span><br></pre></td></tr></table></figure>

<p>使用以下内容为 Prometheus Server 创建 Ingress</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus-service</span><br><span class="line">  namespace: prometheus</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">    - name: prometheus-port</span><br><span class="line">      port: 8090</span><br><span class="line">      protocol: TCP</span><br><span class="line">      targetPort: 9090</span><br><span class="line">  selector:</span><br><span class="line">    app: prometheus-server</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus-ui</span><br><span class="line">  namespace: prometheus</span><br><span class="line"></span><br><span class="line">spec:</span><br><span class="line">  ingressClassName: nginx</span><br><span class="line">  rules:</span><br><span class="line">  - host: prometheus.example.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - backend:</span><br><span class="line">          service:</span><br><span class="line">            name: prometheus-service</span><br><span class="line">            port: </span><br><span class="line">              number: 8090</span><br><span class="line">        path: /</span><br><span class="line">        pathType: Prefix</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>部署完成后，使用 <code>prometheus.example.com</code> 访问<br><img src="https://i.csms.tech/img_109.png"></p>
<h2 id="部署-Grafana"><a href="#部署-Grafana" class="headerlink" title="部署 Grafana"></a>部署 Grafana</h2><p>如需部署 Grafana，可以使用以下配置，需要持久化数据目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus-deployment</span><br><span class="line">  namespace: prometheus</span><br><span class="line">  labels:</span><br><span class="line">    app: prometheus-server</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: prometheus-server</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: prometheus-server</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">        - name: prometheus</span><br><span class="line">          image: prom/prometheus</span><br><span class="line">          args:</span><br><span class="line">            - &quot;--storage.tsdb.retention.time=12h&quot;</span><br><span class="line">            - &quot;--config.file=/etc/prometheus/prometheus.yml&quot;</span><br><span class="line">            - &quot;--storage.tsdb.path=/prometheus/&quot;</span><br><span class="line">          ports:</span><br><span class="line">            - containerPort: 9090</span><br><span class="line">          resources:</span><br><span class="line">            requests:</span><br><span class="line">              cpu: 500m</span><br><span class="line">              memory: 500M</span><br><span class="line">            limits:</span><br><span class="line">              cpu: 1</span><br><span class="line">              memory: 1Gi</span><br><span class="line">          volumeMounts:</span><br><span class="line">            - name: prometheus-config-volume</span><br><span class="line">              mountPath: /etc/prometheus/</span><br><span class="line">            - name: prometheus-storage-volume</span><br><span class="line">              mountPath: /prometheus/</span><br><span class="line">              subPath: prometheus</span><br><span class="line">        - name: grafana</span><br><span class="line">          image: grafana/grafana</span><br><span class="line">          ports:</span><br><span class="line">            - containerPort: 3000</span><br><span class="line">          volumeMounts:</span><br><span class="line">            - name: prometheus-storage-volume</span><br><span class="line">              mountPath: /var/lib/grafana</span><br><span class="line">              subPath: grafana</span><br><span class="line">      volumes:</span><br><span class="line">        - name: prometheus-config-volume</span><br><span class="line">          configMap:</span><br><span class="line">            defaultMode: 420</span><br><span class="line">            name: prometheus-server-conf</span><br><span class="line">  </span><br><span class="line">        - name: prometheus-storage-volume</span><br><span class="line">          persistentVolumeClaim:</span><br><span class="line">            claimName: prometheus-pvc</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus-service</span><br><span class="line">  namespace: prometheus</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">    - name: prometheus-port</span><br><span class="line">      port: 8090</span><br><span class="line">      protocol: TCP</span><br><span class="line">      targetPort: 9090</span><br><span class="line">    - name: grafana-port</span><br><span class="line">      port: 3000</span><br><span class="line">      targetPort: 3000</span><br><span class="line">  selector:</span><br><span class="line">    app: prometheus-server</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus-ui</span><br><span class="line">  namespace: prometheus</span><br><span class="line"></span><br><span class="line">spec:</span><br><span class="line">  ingressClassName: nginx</span><br><span class="line">  rules:</span><br><span class="line">  - host: prometheus.example.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - backend:</span><br><span class="line">          service:</span><br><span class="line">            name: prometheus-service</span><br><span class="line">            port: </span><br><span class="line">              number: 8090</span><br><span class="line">        path: /</span><br><span class="line">        pathType: Prefix</span><br><span class="line">  - host: grafana.example.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - backend:</span><br><span class="line">          service:</span><br><span class="line">            name: prometheus-service</span><br><span class="line">            port:</span><br><span class="line">              number: 3000</span><br><span class="line">        path: /</span><br><span class="line">        pathType: Prefix</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="集群节点上部署-node-exporter-对集群进行监控"><a href="#集群节点上部署-node-exporter-对集群进行监控" class="headerlink" title="集群节点上部署 node-exporter 对集群进行监控"></a>集群节点上部署 node-exporter 对集群进行监控</h2><p>使用 <code>DaemonSet</code> 方式在每个 Node 上部署 <code>node-exporter</code>，本示例运行在 <code>prometheus</code> 的 Namespace 中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: DaemonSet</span><br><span class="line">metadata:</span><br><span class="line">  name: node-exporter</span><br><span class="line">  namespace: prometheus</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: node-exporter</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      name: node-exporter</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        name: node-exporter</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: node-exporter</span><br><span class="line">        image: prom/node-exporter</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 9100</span><br><span class="line">          protocol: TCP</span><br><span class="line">          name: http</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: node-exporter</span><br><span class="line">  name: node-exporter</span><br><span class="line">  namespace: prometheus</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - name: http</span><br><span class="line">    port: 9100</span><br><span class="line">    </span><br><span class="line">    protocol: TCP</span><br><span class="line">  </span><br><span class="line">  selector:</span><br><span class="line">    name: node-exporter</span><br></pre></td></tr></table></figure>
<p>部署之后通过 Grafana 导入 <a href="https://grafana.com/grafana/dashboards/8919">8919 Dashboard</a>，可以通过 <code>node exporter</code> 实现采集 node 节点上的监控数据。</p>
<p>如果部署之后，Dashboard 显示无数据，需要排查 <code>node-exporter</code> 相关的 <code>Service</code>，<code>EndPoint</code> 是否正常。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get services -n prometheus</span></span><br><span class="line">NAME                 TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)             AGE</span><br><span class="line">node-exporter        ClusterIP   10.102.48.208   &lt;none&gt;        9100/TCP            44m</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get endpoints -n prometheus</span></span><br><span class="line">NAME                 ENDPOINTS                             AGE</span><br><span class="line">node-exporter        10.244.3.107:9100,10.244.4.64:9100    49m</span><br></pre></td></tr></table></figure>

<h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><h2 id="failed-to-list-v1-Pod-pods-is-forbidden-User-quot-system-serviceaccount-prometheus-default-quot-cannot-list-resource-quot-pods-quot-in-API-group-quot-quot-at-the-cluster-scope”"><a href="#failed-to-list-v1-Pod-pods-is-forbidden-User-quot-system-serviceaccount-prometheus-default-quot-cannot-list-resource-quot-pods-quot-in-API-group-quot-quot-at-the-cluster-scope”" class="headerlink" title="failed to list *v1.Pod: pods is forbidden: User &quot;system:serviceaccount:prometheus:default&quot; cannot list resource &quot;pods&quot; in API group &quot;&quot; at the cluster scope”"></a>failed to list *v1.Pod: pods is forbidden: User &quot;system:serviceaccount:prometheus:default&quot; cannot list resource &quot;pods&quot; in API group &quot;&quot; at the cluster scope”</h2><p>部署 Prometheus 后，无法访问，检查 Pod 日志，显示错误： <code>failed to list *v1.Pod: pods is forbidden: User \&quot;system:serviceaccount:prometheus:default\&quot; cannot list resource \&quot;pods\&quot; in API group \&quot;\&quot; at the cluster scope&quot;</code> <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Configure Prometheus for service discovery](https://uzimihsr.github.io/post/2022-11-28-kubernetes-prometheus-kube-state-metrics-cadvisor/)">[2]</span></a></sup></p>
<p>根据输出，应该是因为 Namespace <code>prometheus</code>  中的 <code>ServiceAccount</code> 账号 <code>default</code> 无相关权限导致，此权限是于 <a href="#%E5%88%9B%E5%BB%BA%E9%9B%86%E7%BE%A4%E8%A7%92%E8%89%B2">此处配置</a>，检查相关账号权限。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl describe clusterrole prometheus</span></span><br><span class="line">Name:         prometheus</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">PolicyRule:</span><br><span class="line">  Resources             Non-Resource URLs  Resource Names  Verbs</span><br><span class="line">  ---------             -----------------  --------------  -----</span><br><span class="line">  endpoints             []                 []              [get list watch]</span><br><span class="line">  nodes/proxy           []                 []              [get list watch]</span><br><span class="line">  nodes                 []                 []              [get list watch]</span><br><span class="line">  pods                  []                 []              [get list watch]</span><br><span class="line">  services              []                 []              [get list watch]</span><br><span class="line">  ingresses.extensions  []                 []              [get list watch]</span><br><span class="line">                        [/metrics]         []              [get]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl describe clusterrolebinding prometheus</span></span><br><span class="line">Name:         prometheus</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">Role:</span><br><span class="line">  Kind:  ClusterRole</span><br><span class="line">  Name:  prometheus</span><br><span class="line">Subjects:</span><br><span class="line">  Kind            Name     Namespace</span><br><span class="line">  ----            ----     ---------</span><br><span class="line">  ServiceAccount  default  prometheus</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>正常配置的 RBAC 账号输出如上，如果权限显示异常，需要重新检查 <a href="#%E5%88%9B%E5%BB%BA%E9%9B%86%E7%BE%A4%E8%A7%92%E8%89%B2">此处配置</a> 是否正常，如文件格式是否正确。本示例中是因为 yaml 文件格式导致 <code>clusterrolebinding</code> 绑定异常，输出结果如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl describe clusterrolebinding prometheus</span></span><br><span class="line">Name:         prometheus</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">Role:</span><br><span class="line">  Kind:  ClusterRole</span><br><span class="line">  Name:  prometheus</span><br><span class="line">Subjects:</span><br><span class="line">  Kind            Name     Namespace</span><br><span class="line">  ----            ----     ---------</span><br></pre></td></tr></table></figure>
<p>更正文件格式后，重新 <code>kubectl apply</code> ，Prometheus Server 部署正常。</p>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://zhuanlan.zhihu.com/p/456205833">如何部署 Prometheus 监控K8S</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://uzimihsr.github.io/post/2022-11-28-kubernetes-prometheus-kube-state-metrics-cadvisor/">Configure Prometheus for service discovery</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes 安装配置</title>
    <url>/202209121102/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="https://kubernetes.io/zh-cn/docs/setup/production-environment/">Kubernetes 官网文档</a></p>
<h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Centos 7 5.4.212-1</li>
<li>Docker 20.10.18</li>
<li>containerd.io-1.6.8</li>
<li>kubectl-1.24.7</li>
<li>kubeadm-1.24.7</li>
<li>kubelet-1.24.7</li>
</ul>
<h3 id="kubernetes-环境安装前配置"><a href="#kubernetes-环境安装前配置" class="headerlink" title="kubernetes 环境安装前配置"></a>kubernetes 环境安装前配置</h3><h4 id="升级内核版本"><a href="#升级内核版本" class="headerlink" title="升级内核版本"></a>升级内核版本</h4><p>Centos 7 默认的内核版本 3.10 在运行 kubernetes 时存在不稳定性，建议升级内核版本到新版本</p>
<a href="/202209140931/" title="Centos 7 升级内核">Centos 7 升级内核</a>

<h4 id="关闭-SELinux"><a href="#关闭-SELinux" class="headerlink" title="关闭 SELinux"></a>关闭 SELinux</h4><p>kubernetes 目前未实现对 SELinux 的支持，因此必须要关闭 SELinux</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo setenforce 0</span><br><span class="line">sudo sed -i &#x27;s/^SELINUX=enforcing$/SELINUX=disabled/&#x27; /etc/selinux/config</span><br></pre></td></tr></table></figure>

<h4 id="集群中所有计算机之间具有完全的网络连接"><a href="#集群中所有计算机之间具有完全的网络连接" class="headerlink" title="集群中所有计算机之间具有完全的网络连接"></a>集群中所有计算机之间具有完全的网络连接</h4><p>配置集群所有节点的防火墙，确保所有集群节点之间具有完全的网络连接。</p>
<ul>
<li>放通节点之间的通信</li>
<li>确保防火墙允许 <code>FORWARD</code> 链的流量<figure class="highlight shell"><figcaption><span>/etc/sysconfig/iptables</span></figcaption><table><tr><td class="code"><pre><span class="line">*filter</span><br><span class="line">:INPUT DROP [0:0]</span><br><span class="line">:FORWARD ACCEPT [0:0]</span><br><span class="line">:OUTPUT ACCEPT [4:368]</span><br><span class="line"></span><br><span class="line">-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">-A INPUT -i lo -j ACCEPT</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kubernetes nodes</span></span><br><span class="line">-A INPUT -m comment --comment &quot;kubernetes nodes&quot; -s 172.31.5.58 -j ACCEPT</span><br><span class="line">-A INPUT -m comment --comment &quot;kubernetes nodes&quot; -s 172.31.5.68 -j ACCEPT</span><br><span class="line">-A INPUT -m comment --comment &quot;kubernetes nodes&quot; -s 172.31.0.230 -j ACCEPT</span><br><span class="line"></span><br><span class="line">-A INPUT -p tcp -m multiport --dports 80,443 -j ACCEPT -m comment --comment &quot;k8s ingress http,https&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">-A INPUT -p icmp -m icmp --icmp-type 8 -j ACCEPT</span><br><span class="line">-A INPUT -p icmp -m icmp --icmp-type 0 -j ACCEPT</span><br><span class="line">-A INPUT -j REJECT --reject-with icmp-host-prohibited</span><br><span class="line">COMMIT</span><br></pre></td></tr></table></figure></li>
</ul>
<span id="more"></span>

<p>集群通信 ( iptables ) 矩阵说明：</p>
<table>
<thead>
<tr>
<th>Protocol</th>
<th>iptables table</th>
<th>ipables chain</th>
<th>Port Range</th>
<th>Purpose</th>
<th>Used by</th>
</tr>
</thead>
<tbody><tr>
<td>UDP</td>
<td>filter</td>
<td>INPUT</td>
<td>8472</td>
<td>flannel</td>
<td>network</td>
</tr>
<tr>
<td>TCP</td>
<td>filter</td>
<td>INPUT</td>
<td>6443</td>
<td>Kubernetes API server</td>
<td>ALL node</td>
</tr>
<tr>
<td>TCP</td>
<td>filter</td>
<td>INPUT</td>
<td>2379-2380</td>
<td>etcd server client API</td>
<td>kube-apiserver,etcd</td>
</tr>
<tr>
<td>TCP</td>
<td>filter</td>
<td>INPUT</td>
<td>10250</td>
<td>kubelet API</td>
<td>Control plane, Self ,kubectl exec</td>
</tr>
<tr>
<td>TCP</td>
<td>filter</td>
<td>INPUT</td>
<td>10251</td>
<td>kube-scheduler</td>
<td>self</td>
</tr>
<tr>
<td>TCP</td>
<td>filter</td>
<td>INPUT</td>
<td>10252</td>
<td>kube-controller-manager</td>
<td>self</td>
</tr>
<tr>
<td>TCP</td>
<td>filter</td>
<td>INPUT</td>
<td>30000-32767</td>
<td>NodePortService</td>
<td>All</td>
</tr>
</tbody></table>
<ul>
<li>不同节点之间的 <code>Pod</code> 通信需要经过 <code>flannel</code> 的 <code>8472/udp</code> </li>
<li><code>nodePort</code> 类型的 <code>service</code> ，默认可用的 <code>nodePort</code> 端口范围为 <code>30000-32767</code>，根据实际情况配置</li>
</ul>
<h4 id="禁止swap分区"><a href="#禁止swap分区" class="headerlink" title="禁止swap分区"></a>禁止swap分区</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">swapoff -a</span><br></pre></td></tr></table></figure>

<h4 id="配置主机名"><a href="#配置主机名" class="headerlink" title="配置主机名"></a>配置主机名</h4><p>节点之中不可以有重复的主机名、MAC 地址或 product_uuid</p>
<p>配置集群中的 3 台主机名分别为 <code>kubernetes1</code>，<code>kubernetes2</code>，<code>kubernetes3</code>，本示例中 <code>kubernetes1</code> 作为 master </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hostnamectl set-hostname kubernetes1</span><br></pre></td></tr></table></figure>

<p>添加主机名和 ip 解析到 <code>/etc/hosts</code> 文件</p>
<figure class="highlight shell"><figcaption><span>/etc/hosts</span></figcaption><table><tr><td class="code"><pre><span class="line">172.31.10.19 kubernetes1</span><br><span class="line">172.31.9.241 kubernetes2</span><br><span class="line">172.31.14.115 kubernetes3</span><br></pre></td></tr></table></figure>

<h4 id="为-kube-proxy-开启-ipvs"><a href="#为-kube-proxy-开启-ipvs" class="headerlink" title="为 kube-proxy 开启 ipvs"></a>为 kube-proxy 开启 ipvs</h4><p><a href="https://blog.fleeto.us/post/iptables-or-ipvs/">kube-proxy 模式对比：iptables 还是 IPVS</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1890887">kube-proxy中使用ipvs与iptables的比较</a></p>
<p>此配置为<strong>可选操作</strong>，在不启用 ipvs 模式的情况下，kube-proxy 会使用 iptables 模式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &gt; /etc/sysconfig/modules/ipvs.modules &lt;&lt;EOF</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">modprobe -- ip_vs</span><br><span class="line">modprobe -- ip_vs_rr</span><br><span class="line">modprobe -- ip_vs_wrr</span><br><span class="line">modprobe -- ip_vs_sh</span><br><span class="line">modprobe -- nf_conntrack_ipv4</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">chmod 755 /etc/sysconfig/modules/ipvs.modules &amp;&amp; bash /etc/sysconfig/modules/ipvs.modules </span><br></pre></td></tr></table></figure>

<h4 id="转发-IPv4-并让-iptables-看到桥接流量"><a href="#转发-IPv4-并让-iptables-看到桥接流量" class="headerlink" title="转发 IPv4 并让 iptables 看到桥接流量"></a>转发 IPv4 并让 iptables 看到桥接流量</h4><p>以下操作需要在 kubernetes 集群中的所有节点操作<br>通过运行 <code>lsmod | grep br_netfilter</code> 来验证 <code>br_netfilter</code> 模块是否已加载。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">lsmod | grep br_netfilter</span></span><br><span class="line">br_netfilter           22256  0 </span><br><span class="line">bridge                151336  1 br_netfilter</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>若要显式加载此模块，请运行以下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo modprobe overlay</span><br><span class="line">sudo modprobe br_netfilter</span><br></pre></td></tr></table></figure>


<p>为了让 Linux 节点的 iptables 能够正确查看桥接流量，请确认 <code>sysctl</code> 配置中的 <code>net.bridge.bridge-nf-call-iptables</code> 设置为 1</p>
<p>为配置永久生效，可以添加以下配置，<code>/etc/modules-load.d/k8s.conf</code> 中追加要加载的模块</p>
<figure class="highlight shell"><figcaption><span>/etc/modules-load.d/k8s.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">overlay</span><br><span class="line">br_netfilter</span><br></pre></td></tr></table></figure>

<p><code>/etc/sysctl.d/k8s.conf</code> 中追加内核参数</p>
<figure class="highlight shell"><figcaption><span>/etc/sysctl.d/k8s.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">net.bridge.bridge-nf-call-iptables  = 1</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.ipv4.ip_forward                 = 1</span><br></pre></td></tr></table></figure>

<p>执行以下命令重新载入 sysctl 参数而无需重启系统</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo sysctl --system</span><br></pre></td></tr></table></figure>

<!-- more -->

<h4 id="安装-Docker-Engine"><a href="#安装-Docker-Engine" class="headerlink" title="安装 Docker Engine"></a>安装 Docker Engine</h4><p>以下操作需要在 kubernetes 集群中的所有节点操作<br>参考以下链接，在每个节点上安装 Docker Engine<br><a href="https://docs.docker.com/engine/install/centos/">Centos 安装 Docker Engine 官网参考文档</a></p>
<a href="/202208041317/" title="docker 安装及常用命令介绍">docker 安装及常用命令介绍</a>

<h4 id="安装-cri-dockerd"><a href="#安装-cri-dockerd" class="headerlink" title="安装 cri-dockerd"></a>安装 cri-dockerd</h4><p>Docker Engine 没有实现 CRI，因此 Kubernetes 无法直接使用 Docker Engine，需要先安装 cri-dockerd，以让 Kubernetes 可以通过 Kubernetes 的 CRI 操作 Docker。</p>
<p>以下操作需要在 kubernetes 集群中的所有节点操作 </p>
<p>按照源代码仓库中的说明安装 <a href="https://github.com/Mirantis/cri-dockerd">cri-dockerd</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/Mirantis/cri-dockerd.git</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Run these commands as root</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##Install GO###</span></span></span><br><span class="line">wget https://storage.googleapis.com/golang/getgo/installer_linux</span><br><span class="line">chmod +x ./installer_linux</span><br><span class="line">./installer_linux</span><br><span class="line">source ~/.bash_profile</span><br><span class="line"></span><br><span class="line">cd cri-dockerd</span><br><span class="line">mkdir bin</span><br><span class="line">go build -o bin/cri-dockerd</span><br><span class="line">mkdir -p /usr/local/bin</span><br><span class="line">install -o root -g root -m 0755 bin/cri-dockerd /usr/local/bin/cri-dockerd</span><br><span class="line">cp -a packaging/systemd/* /etc/systemd/system</span><br><span class="line">sed -i -e &#x27;s,/usr/bin/cri-dockerd,/usr/local/bin/cri-dockerd,&#x27; /etc/systemd/system/cri-docker.service</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 使用 iptables 替换 firewalld</span></span></span><br><span class="line">sed -i -e &#x27;s,firewalld.service,iptables.service,&#x27; /etc/systemd/system/cri-docker.service</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable --now cri-docker.service</span><br><span class="line">systemctl enable --now cri-docker.socket</span><br></pre></td></tr></table></figure>

<p>对于 <code>cri-dockerd</code>，默认情况下，CRI 套接字是 <code>/run/cri-dockerd.sock</code></p>
<h3 id="Kubernetes-安装配置"><a href="#Kubernetes-安装配置" class="headerlink" title="Kubernetes 安装配置"></a>Kubernetes 安装配置</h3><h4 id="安装-kubeadm、kubelet-和-kubectl"><a href="#安装-kubeadm、kubelet-和-kubectl" class="headerlink" title="安装 kubeadm、kubelet 和 kubectl"></a>安装 kubeadm、kubelet 和 kubectl</h4><p>需要在每台机器上安装以下的软件包：</p>
<ul>
<li><p><code>kubeadm</code> ： 用来初始化集群的指令。</p>
</li>
<li><p><code>kubelet</code> ： 在集群中的每个节点上用来启动 Pod 和容器等。</p>
</li>
<li><p><code>kubectl</code> ： 用来与集群通信的命令行工具。</p>
</li>
</ul>
<p>添加 <code>yum</code> 源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF | sudo tee /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-\$basearch</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg</span><br><span class="line">exclude=kubelet kubeadm kubectl</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<p>安装软件包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install -y kubelet-1.24.7 kubeadm-1.24.7 kubectl-1.24.7 --disableexcludes=kubernetes</span><br></pre></td></tr></table></figure>
<p>启动服务并配置开机启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable --now kubelet</span><br></pre></td></tr></table></figure>
<p>kubelet 现在每隔几秒就会重启，因为它陷入了一个等待 <code>kubeadm</code> 指令的死循环。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl status kubelet</span></span><br><span class="line">● kubelet.service - kubelet: The Kubernetes Node Agent</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/kubelet.service; enabled; vendor preset: disabled)</span><br><span class="line">  Drop-In: /usr/lib/systemd/system/kubelet.service.d</span><br><span class="line">           └─10-kubeadm.conf</span><br><span class="line">   Active: activating (auto-restart) (Result: exit-code) since Mon 2022-09-12 14:35:58 CST; 7s ago</span><br><span class="line">     Docs: https://kubernetes.io/docs/</span><br><span class="line">  Process: 2056 ExecStart=/usr/bin/kubelet $KUBELET_KUBECONFIG_ARGS $KUBELET_CONFIG_ARGS $KUBELET_KUBEADM_ARGS $KUBELET_EXTRA_ARGS (code=exited, status=1/FAILURE)</span><br><span class="line"> Main PID: 2056 (code=exited, status=1/FAILURE)</span><br><span class="line"></span><br><span class="line">Sep 12 14:35:58 ip-172-31-14-115.us-west-1.compute.internal systemd[1]: Unit kubelet.service entered failed state.</span><br><span class="line">Sep 12 14:35:58 ip-172-31-14-115.us-west-1.compute.internal systemd[1]: kubelet.service failed.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="初始化控制平面节点"><a href="#初始化控制平面节点" class="headerlink" title="初始化控制平面节点"></a>初始化控制平面节点</h4><h5 id="创建单控制平面集群"><a href="#创建单控制平面集群" class="headerlink" title="创建单控制平面集群"></a>创建单控制平面集群</h5><p>控制平面节点是运行控制平面组件的机器， 包括 etcd （集群数据库） 和 API Server （命令行工具 kubectl 与之通信）。</p>
<ol>
<li><p>初始化控制平面节点</p>
<p> 要初始化控制平面节点，请在 master 节点上（<code>kubernetes1</code>）运行以下命令，<a href="(https://csms.tech%3C!--swig%EF%BF%BC82--%3E#%E5%88%9B%E5%BB%BA%E9%9B%86%E7%BE%A4)">命令参数说明</a>：</p>
 <figure class="highlight shell"><figcaption><span>kubernetes1</span></figcaption><table><tr><td class="code"><pre><span class="line">kubeadm init --pod-network-cidr=10.244.0.0/16 --cri-socket=unix:///var/run/cri-dockerd.sock</span><br></pre></td></tr></table></figure>
<ul>
<li><code>--pod-network-cidr=10.244.0.0/16</code> 指定 pod 使用的网络段，后面配置网络（CNI）时配置的网段要和此处一致</li>
<li><code>--cri-socket=unix:///var/run/cri-dockerd.sock</code> 指定使用的 CRI 为 Docker</li>
</ul>
<p> 输出结果如下：<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[init] Using Kubernetes version: v1.25.0</span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">[preflight] Pulling images required for setting up a Kubernetes cluster</span><br><span class="line">[preflight] This might take a minute or two, depending on the speed of your internet connection</span><br><span class="line">[preflight] You can also perform this action in beforehand using &#x27;kubeadm config images pull&#x27;</span><br><span class="line">[certs] Using certificateDir folder &quot;/etc/kubernetes/pki&quot;</span><br><span class="line">[certs] Generating &quot;ca&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;apiserver&quot; certificate and key</span><br><span class="line">[certs] apiserver serving cert is signed for DNS names [kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local kubernetes1] and IPs [10.96.0.1 172.31.10.19]</span><br><span class="line">[certs] Generating &quot;apiserver-kubelet-client&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;front-proxy-ca&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;front-proxy-client&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;etcd/ca&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;etcd/server&quot; certificate and key</span><br><span class="line">[certs] etcd/server serving cert is signed for DNS names [localhost kubernetes1] and IPs [172.31.10.19 127.0.0.1 ::1]</span><br><span class="line">[certs] Generating &quot;etcd/peer&quot; certificate and key</span><br><span class="line">[certs] etcd/peer serving cert is signed for DNS names [localhost kubernetes1] and IPs [172.31.10.19 127.0.0.1 ::1]</span><br><span class="line">[certs] Generating &quot;etcd/healthcheck-client&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;apiserver-etcd-client&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;sa&quot; key and public key</span><br><span class="line">[kubeconfig] Using kubeconfig folder &quot;/etc/kubernetes&quot;</span><br><span class="line">[kubeconfig] Writing &quot;admin.conf&quot; kubeconfig file</span><br><span class="line">[kubeconfig] Writing &quot;kubelet.conf&quot; kubeconfig file</span><br><span class="line">[kubeconfig] Writing &quot;controller-manager.conf&quot; kubeconfig file</span><br><span class="line">[kubeconfig] Writing &quot;scheduler.conf&quot; kubeconfig file</span><br><span class="line">[kubelet-start] Writing kubelet environment file with flags to file &quot;/var/lib/kubelet/kubeadm-flags.env&quot;</span><br><span class="line">[kubelet-start] Writing kubelet configuration to file &quot;/var/lib/kubelet/config.yaml&quot;</span><br><span class="line">[kubelet-start] Starting the kubelet</span><br><span class="line">[control-plane] Using manifest folder &quot;/etc/kubernetes/manifests&quot;</span><br><span class="line">[control-plane] Creating static Pod manifest for &quot;kube-apiserver&quot;</span><br><span class="line">[control-plane] Creating static Pod manifest for &quot;kube-controller-manager&quot;</span><br><span class="line">[control-plane] Creating static Pod manifest for &quot;kube-scheduler&quot;</span><br><span class="line">[etcd] Creating static Pod manifest for local etcd in &quot;/etc/kubernetes/manifests&quot;</span><br><span class="line">[wait-control-plane] Waiting for the kubelet to boot up the control plane as static Pods from directory &quot;/etc/kubernetes/manifests&quot;. This can take up to 4m0s</span><br><span class="line">[apiclient] All control plane components are healthy after 17.003297 seconds</span><br><span class="line">[upload-config] Storing the configuration used in ConfigMap &quot;kubeadm-config&quot; in the &quot;kube-system&quot; Namespace</span><br><span class="line">[kubelet] Creating a ConfigMap &quot;kubelet-config&quot; in namespace kube-system with the configuration for the kubelets in the cluster</span><br><span class="line">[upload-certs] Skipping phase. Please see --upload-certs</span><br><span class="line">[mark-control-plane] Marking the node kubernetes1 as control-plane by adding the labels: [node-role.kubernetes.io/control-plane node.kubernetes.io/exclude-from-external-load-balancers]</span><br><span class="line">[mark-control-plane] Marking the node kubernetes1 as control-plane by adding the taints [node-role.kubernetes.io/control-plane:NoSchedule]</span><br><span class="line">[bootstrap-token] Using token: 8ca35s.butdpihinkdczvqb</span><br><span class="line">[bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles</span><br><span class="line">[bootstrap-token] Configured RBAC rules to allow Node Bootstrap tokens to get nodes</span><br><span class="line">[bootstrap-token] Configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials</span><br><span class="line">[bootstrap-token] Configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token</span><br><span class="line">[bootstrap-token] Configured RBAC rules to allow certificate rotation for all node client certificates in the cluster</span><br><span class="line">[bootstrap-token] Creating the &quot;cluster-info&quot; ConfigMap in the &quot;kube-public&quot; namespace</span><br><span class="line">[kubelet-finalize] Updating &quot;/etc/kubernetes/kubelet.conf&quot; to point to a rotatable kubelet client certificate and key</span><br><span class="line">[addons] Applied essential addon: CoreDNS</span><br><span class="line">[addons] Applied essential addon: kube-proxy</span><br><span class="line"></span><br><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p $HOME/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line">Alternatively, if you are the root user, you can run:</span><br><span class="line"></span><br><span class="line">  export KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">  beadm join 172.31.10.19:6443 --token 8ca35s.butdpihinkdczvqb \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:b2793f9a6bea44a64640f99042f11c4ff6e4fef99fa2407241e1a0e8ea652149 </span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p> 根据 <code>kubeadm init</code> 输出提示，配置 <code>kubectl</code> 需要的环境变量，root 用户执行以下命令<br> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export KUBECONFIG=/etc/kubernetes/admin.conf</span><br></pre></td></tr></table></figure><br> 为永久生效，可将其添加到 <code>~/.bash_profile</code></p>
<p> 此时，执行以下命令查看集群节点信息<br> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods -A</span></span><br><span class="line">NAMESPACE     NAME                                      READY   STATUS    RESTARTS   AGE</span><br><span class="line">kube-system   coredns-565d847f94-dc8tl                  0/1     Pending   0          5m42s</span><br><span class="line">kube-system   coredns-565d847f94-zqctg                  0/1     Pending   0          5m42s</span><br><span class="line">kube-system   etcd-kubernetes1                      1/1     Running   0          5m54s</span><br><span class="line">kube-system   kube-apiserver-kubernetes1            1/1     Running   0          5m53s</span><br><span class="line">kube-system   kube-controller-manager-kubernetes1   1/1     Running   0          5m54s</span><br><span class="line">kube-system   kube-proxy-6kwdx                          1/1     Running   0          5m43s</span><br><span class="line">kube-system   kube-scheduler-kubernetes1            1/1     Running   0          5m54s</span><br><span class="line"></span><br></pre></td></tr></table></figure><br> 其中，<code>coredns</code> 的 pod 处于 <code>Pending</code> 状态，是因为网络还没配置。</p>
<p> 因为 CRI 使用 docker，此时使用以下命令，可以查看到启动的所有容器<br> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker ps -a</span></span><br><span class="line">CONTAINER ID   IMAGE                  COMMAND                  CREATED         STATUS         PORTS     NAMES</span><br><span class="line">741a6d32b2cd   58a9a0c6d96f           &quot;/usr/local/bin/kube…&quot;   5 minutes ago   Up 5 minutes             k8s_kube-proxy_kube-proxy-6kwdx_kube-system_93101b10-7ee5-437c-a234-3e31edc7cfa9_0</span><br><span class="line">31509b3f06cc   k8s.gcr.io/pause:3.6   &quot;/pause&quot;                 5 minutes ago   Up 5 minutes             k8s_POD_kube-proxy-6kwdx_kube-system_93101b10-7ee5-437c-a234-3e31edc7cfa9_0</span><br><span class="line">fb3ec15950b6   bef2cf311509           &quot;kube-scheduler --au…&quot;   6 minutes ago   Up 6 minutes             k8s_kube-scheduler_kube-scheduler-kubernetes1_kube-system_c455960b65afeadd009ff9ba9e7ab7b0_0</span><br><span class="line">333188677c01   4d2edfd10d3e           &quot;kube-apiserver --ad…&quot;   6 minutes ago   Up 6 minutes             k8s_kube-apiserver_kube-apiserver-kubernetes1_kube-system_11596873d958a699a1b923df2333eaad_0</span><br><span class="line">4bdbf8689bbb   1a54c86c03a6           &quot;kube-controller-man…&quot;   6 minutes ago   Up 6 minutes             k8s_kube-controller-manager_kube-controller-manager-kubernetes1_kube-system_23ce2f60ac97b06bde25c1662e88e409_0</span><br><span class="line">a399d3484c17   a8a176a5d5d6           &quot;etcd --advertise-cl…&quot;   6 minutes ago   Up 6 minutes             k8s_etcd_etcd-kubernetes1_kube-system_84da44e552601c02573afe1dc1e3b0a2_0</span><br><span class="line">28aae0e41a7d   k8s.gcr.io/pause:3.6   &quot;/pause&quot;                 6 minutes ago   Up 6 minutes             k8s_POD_kube-apiserver-kubernetes1_kube-system_11596873d958a699a1b923df2333eaad_0</span><br><span class="line">3f4f378ed731   k8s.gcr.io/pause:3.6   &quot;/pause&quot;                 6 minutes ago   Up 6 minutes             k8s_POD_kube-scheduler-kubernetes1_kube-system_c455960b65afeadd009ff9ba9e7ab7b0_0</span><br><span class="line">eaa6d312a174   k8s.gcr.io/pause:3.6   &quot;/pause&quot;                 6 minutes ago   Up 6 minutes             k8s_POD_etcd-kubernetes1_kube-system_84da44e552601c02573afe1dc1e3b0a2_0</span><br><span class="line">707e84291ac2   k8s.gcr.io/pause:3.6   &quot;/pause&quot;                 6 minutes ago   Up 6 minutes             k8s_POD_kube-controller-manager-kubernetes1_kube-system_23ce2f60ac97b06bde25c1662e88e409_0</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
</li>
<li><p><a href="#%E5%AE%89%E8%A3%85-kube-flannel">安装 kube-flannel</a></p>
<p> 在进行下一步之前，必须选择并部署合适的网络插件。 否则集群不会正常运行。</p>
</li>
<li><p>将节点加入集群</p>
<p> 在 work 节点上执行以下命令加入集群</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm join 172.31.10.19:6443 --token 8ca35s.butdpihinkdczvqb --discovery-token-ca-cert-hash sha256:b2793f9a6bea44a64640f99042f11c4ff6 \ </span><br><span class="line">        --cri-socket=unix:///var/run/cri-dockerd.sock</span><br></pre></td></tr></table></figure>
<p> 加入集群成功后，在 master 上查看所有节点</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get nodes</span></span><br><span class="line">NAME              STATUS     ROLES           AGE   VERSION</span><br><span class="line">kubernetes1   Ready      control-plane   36m   v1.25.0</span><br><span class="line">kubernetes2   NotReady   &lt;none&gt;          21s   v1.25.0</span><br><span class="line">kubernetes3   NotReady   &lt;none&gt;          18s   v1.25.0</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="创建高可用控制平面的集群"><a href="#创建高可用控制平面的集群" class="headerlink" title="创建高可用控制平面的集群"></a>创建高可用控制平面的集群</h5><p>创建 <a href="https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/ha-topology/#stacked-etcd-topology"><code>堆叠（Stacked）etcd 拓扑</code></a> 的高可用控制平面集群</p>
<p><code>堆叠（Stacked）etcd 拓扑</code> 主要有以下特点：</p>
<ul>
<li><code>etcd</code> 分布式数据存储集群堆叠在 <code>kubeadm</code> 管理的控制平面节点上，作为控制平面的一个组件运行。</li>
<li>每个控制平面节点运行 <code>etcd</code>、 <code>kube-apiserver</code>、<code>kube-scheduler</code> 和 <code>kube-controller-manager</code> 实例。 <code>kube-apiserver</code> 使用负载均衡器暴露给工作节点。</li>
<li>每个控制平面节点创建一个本地 <code>etcd</code> 成员（member），这个 <code>etcd</code> 成员只与该节点的 <code>kube-apiserver</code> 通信。 这同样适用于本地 <code>kube-controller-manager</code> 和 <code>kube-scheduler</code> 实例。</li>
<li>堆叠集群存在耦合失败的风险。如果一个节点发生故障，则 <code>etcd</code> 成员和控制平面实例都将丢失， 并且冗余会受到影响。你可以通过添加更多控制平面节点来降低此风险。</li>
</ul>
<p><code>堆叠（Stacked）etcd 拓扑</code><br><img src="https://i.csms.tech/img_77.png"></p>
<p>为 kube-apiserver 创建负载均衡器，该负载均衡器将流量分配给目标列表中所有运行状况良好的控制平面节点。 API 服务器的健康检查是在 kube-apiserver 的监听端口（默认值 :6443） 上进行的一个 TCP 检查。 <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[为 kube-apiserver 创建负载均衡器](https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/high-availability/#%E4%B8%BA-kube-apiserver-%E5%88%9B%E5%BB%BA%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8)">[2]</span></a></sup></p>
<p>此处假设 kube-apiserver 的负载均衡地址为 <code>kube-apiserver.my.com:6443</code>。</p>
<ol>
<li><p>初始化控制平面：</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm init --pod-network-cidr=10.244.0.0/16 --cri-socket=unix:///var/run/cri-dockerd.sock \</span><br><span class="line">             --control-plane-endpoint &quot;kube-apiserver.my.com:6443&quot; \</span><br><span class="line">             --upload-certs</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>--upload-certs</code> 标志用来将在所有控制平面实例之间的共享证书上传到集群。</p>
<p> 根据 <code>kubeadm init</code> 输出提示，配置 <code>kubectl</code> 需要的环境变量，root 用户执行以下命令</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export KUBECONFIG=/etc/kubernetes/admin.conf</span><br></pre></td></tr></table></figure>
<p> 为永久生效，可将其添加到 <code>~/.bash_profile</code></p>
</li>
<li><p><a href="#%E5%AE%89%E8%A3%85-kube-flannel">安装 kube-flannel</a></p>
<p> 在进行下一步之前，必须选择并部署合适的网络插件。 否则集群不会正常运行。</p>
<p> 输入以下内容，并查看控制平面组件的 Pod 启动：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl get pod -n kube-system -w</span><br></pre></td></tr></table></figure></li>
<li><p>其余控制平面节点上的操作</p>
<p> 执行先前由第一个节点上的 <code>kubeadm init</code> 输出提供给你的 <code>join</code> 命令。 在 CRI 是 <code>cri-dockerd</code> 的场景下，要添加 <code>--cri-socket=unix:///var/run/cri-dockerd.sock</code>。它看起来应该像这样：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubeadm join 192.168.0.200:6443 --token 9vr73a.a8uxyaju799qwdjv \</span><br><span class="line">             --discovery-token-ca-cert-hash sha256:7c2e69131a36ae2a042a339b33381c6d0d43887e2de83720eff5359e26aec866 \</span><br><span class="line">             --control-plane \</span><br><span class="line">             --certificate-key f8902e114ef118304e561c3ecd4d0b543adc226b7a07f675f56564185ffe0c07 \</span><br><span class="line">             --cri-socket=unix:///var/run/cri-dockerd.sock</span><br></pre></td></tr></table></figure>
</li>
<li><p>工作节点上的操作</p>
<p> 在工作节点上执行以下命令，添加工作节点到集群中。在 CRI 是 <code>cri-dockerd</code> 的场景下，要添加 <code>--cri-socket=unix:///var/run/cri-dockerd.sock</code>。它看起来应该像这样：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubeadm join kube-apiserver.uat.148962587001:6443 \</span><br><span class="line">        --token 0nf24o.fb98ll5qkhpcxd70 \</span><br><span class="line">        --discovery-token-ca-cert-hash sha256:a5d589a3476777df757e38334b035a93811d94e75131e3d9cc1d7efad22fc793 \</span><br><span class="line">        --cri-socket=unix:///var/run/cri-dockerd.sock</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="安装-kube-flannel"><a href="#安装-kube-flannel" class="headerlink" title="安装 kube-flannel"></a>安装 kube-flannel</h4><p>Kubernetes 安装时已经安装了网络相关驱动，位于 <code>/opt/cni/bin/flannel</code>，此时只需要根据相关配置文件生成 <code>kube-flannel</code> 的 pod 即可</p>
<p>请在 master 节点上（<code>kubernetes1</code>）运行以下命令创建 <code>kube-flannel</code> 相关 POD</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl apply -f https://raw.githubusercontent.com/flannel-io/flannel/master/Documentation/kube-flannel.yml</span></span><br><span class="line"></span><br><span class="line">namespace/kube-flannel created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/flannel created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/flannel created</span><br><span class="line">serviceaccount/flannel created</span><br><span class="line">configmap/kube-flannel-cfg created</span><br><span class="line">daemonset.apps/kube-flannel-ds created</span><br></pre></td></tr></table></figure>
<p>使用默认的 <code>kube-flannel.yml</code>，默认的 Network 为 <code>10.244.0.0/16</code>，要变更默认网段，更改 <code>kube-flannel.yml</code> 中的以下内容即可：</p>
<figure class="highlight shell"><figcaption><span>kube-flannel.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">net-conf.json: |</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;Network&quot;: &quot;10.244.0.0/16&quot;,</span><br><span class="line">    &quot;Backend&quot;: &#123;</span><br><span class="line">      &quot;Type&quot;: &quot;vxlan&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>此处的网段配置需要和 <a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2%E8%8A%82%E7%82%B9">初始化集群时定义的 pod 网段</a> 保持一致</p>
<p>创建完成 <code>kube-flannel</code> 后，再次查看集群中的 pod 信息，可以看到 <code>coredns</code> 已经处于运行状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods -A</span></span><br><span class="line">NAMESPACE      NAME                                      READY   STATUS    RESTARTS   AGE</span><br><span class="line">kube-flannel   kube-flannel-ds-rg969                     1/1     Running   0          20s</span><br><span class="line">kube-system    coredns-565d847f94-dc8tl                  0/1     Running   0          22m</span><br><span class="line">kube-system    coredns-565d847f94-zqctg                  0/1     Running   0          22m</span><br><span class="line">kube-system    etcd-kubernetes1                      1/1     Running   0          22m</span><br><span class="line">kube-system    kube-apiserver-kubernetes1            1/1     Running   0          22m</span><br><span class="line">kube-system    kube-controller-manager-kubernetes1   1/1     Running   0          22m</span><br><span class="line">kube-system    kube-proxy-6kwdx                          1/1     Running   0          22m</span><br><span class="line">kube-system    kube-scheduler-kubernetes1            1/1     Running   0          22m</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="安装-dashboard"><a href="#安装-dashboard" class="headerlink" title="安装 dashboard"></a>安装 dashboard</h4><p><a href="https://github.com/kubernetes/dashboard">kubernetes-dashboard 项目地址</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/kubernetes/dashboard/v2.6.1/aio/deploy/recommended.yaml</span><br></pre></td></tr></table></figure>

<p>修改 <code>recommended.yaml</code> 以下内容</p>
<figure class="highlight shell"><figcaption><span>recommended.yaml</span></figcaption><table><tr><td class="code"><pre><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line">  name: kubernetes-dashboard</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line">spec:</span><br><span class="line">  type: NodePort     </span><br><span class="line">  ports:</span><br><span class="line">    - port: 443</span><br><span class="line">      targetPort: 8443</span><br><span class="line">      nodePort: 30443</span><br><span class="line">  selector:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以上修改主要是新加以下 2 行，配置对外的端口，可用范围为 30000-32767：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">type: NodePort </span><br><span class="line">    nodePort: 30443</span><br></pre></td></tr></table></figure>
<p>以下 2 处新增配置 <code>nodeName: kubernetes1</code>，其中 <code>kubernetes1</code> 为 master 节点名称，可以通过 <code>kubectl get nodes</code> 查看</p>
<figure class="highlight shell"><figcaption><span>recommended.yaml</span></figcaption><table><tr><td class="code"><pre><span class="line">spec:</span><br><span class="line">  securityContext:</span><br><span class="line">    seccompProfile:</span><br><span class="line">      type: RuntimeDefault</span><br><span class="line">  nodeName: kubernetes1</span><br><span class="line">  containers:</span><br><span class="line">    - name: kubernetes-dashboard</span><br><span class="line">      image: kubernetesui/dashboard:v2.6.1</span><br><span class="line">      imagePullPolicy: Always</span><br><span class="line">      ports:</span><br><span class="line">        - containerPort: 8443</span><br><span class="line">          protocol: TCP</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上 2 处修改主要是配置 <code>kubernetes-dashboard</code> 运行在 master 节点上，否则可能运行在其他节点上，会因为网络问题导致 <code>kubernetes-dashboard</code> 无法正常启动，查看日志会报以下错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl logs -n kubernetes-dashboard kubernetes-dashboard-66c887f759-5rbbb</span></span><br><span class="line">2022/09/14 06:59:17 Starting overwatch</span><br><span class="line">2022/09/14 06:59:17 Using namespace: kubernetes-dashboard</span><br><span class="line">2022/09/14 06:59:17 Using in-cluster config to connect to apiserver</span><br><span class="line">2022/09/14 06:59:17 Using secret token for csrf signing</span><br><span class="line">2022/09/14 06:59:17 Initializing csrf token from kubernetes-dashboard-csrf secret</span><br><span class="line">panic: Get &quot;https://10.96.0.1:443/api/v1/namespaces/kubernetes-dashboard/secrets/kubernetes-dashboard-csrf&quot;: dial tcp 10.96.0.1:443: connect: no route to host</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>关键日志 ： <code>panic: Get &quot;https://10.96.0.1:443/api/v1/namespaces/kubernetes-dashboard/secrets/kubernetes-dashboard-csrf&quot;: dial tcp 10.96.0.1:443: connect: no route to host </code></p>
<p>以上报错也有可能是因为防火墙未放通各个 <code>service</code> 的 <code>CLUSTER-IP</code> 网段导致，可以在防火墙中放通相应网段</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get services -A</span></span><br><span class="line">NAMESPACE              NAME                        TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)                  AGE</span><br><span class="line">default                kubernetes                  ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP                  3h9m</span><br><span class="line">kube-system            kube-dns                    ClusterIP   10.96.0.10      &lt;none&gt;        53/UDP,53/TCP,9153/TCP   3h9m</span><br><span class="line">kubernetes-dashboard   dashboard-metrics-scraper   ClusterIP   10.107.39.231   &lt;none&gt;        8000/TCP                 88m</span><br><span class="line">kubernetes-dashboard   kubernetes-dashboard        NodePort    10.101.165.61   &lt;none&gt;        443:30443/TCP            88m</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>iptables</code> 中放通对应网段</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -I INPUT 6 -s 10.0.0.0/8 -j ACCEPT</span><br></pre></td></tr></table></figure>

<p>使用修改后的配置文件 <code>recommended.yaml</code> 启动 <code>kubernetes-dashboard</code> pod</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl apply -f recommended.yaml</span></span><br><span class="line"></span><br><span class="line">namespace/kubernetes-dashboard created</span><br><span class="line">serviceaccount/kubernetes-dashboard created</span><br><span class="line">service/kubernetes-dashboard created</span><br><span class="line">secret/kubernetes-dashboard-certs created</span><br><span class="line">secret/kubernetes-dashboard-csrf created</span><br><span class="line">secret/kubernetes-dashboard-key-holder created</span><br><span class="line">configmap/kubernetes-dashboard-settings created</span><br><span class="line">role.rbac.authorization.k8s.io/kubernetes-dashboard created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/kubernetes-dashboard created</span><br><span class="line">rolebinding.rbac.authorization.k8s.io/kubernetes-dashboard created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/kubernetes-dashboard created</span><br><span class="line">deployment.apps/kubernetes-dashboard created</span><br><span class="line">service/dashboard-metrics-scraper created</span><br><span class="line">deployment.apps/dashboard-metrics-scraper created</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看 pod</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods -A</span></span><br><span class="line">NAMESPACE              NAME                                         READY   STATUS    RESTARTS      AGE</span><br><span class="line">kube-flannel           kube-flannel-ds-bdms5                        1/1     Running   1 (17h ago)   19h</span><br><span class="line">kube-flannel           kube-flannel-ds-kq7gz                        1/1     Running   1             19h</span><br><span class="line">kube-flannel           kube-flannel-ds-rg969                        1/1     Running   2 (17h ago)   19h</span><br><span class="line">kube-system            coredns-565d847f94-dc8tl                     1/1     Running   2 (17h ago)   20h</span><br><span class="line">kube-system            coredns-565d847f94-zqctg                     1/1     Running   2 (17h ago)   20h</span><br><span class="line">kube-system            etcd-kubernetes1                         1/1     Running   2 (17h ago)   20h</span><br><span class="line">kube-system            kube-apiserver-kubernetes1               1/1     Running   2 (17h ago)   20h</span><br><span class="line">kube-system            kube-controller-manager-kubernetes1      1/1     Running   2 (17h ago)   20h</span><br><span class="line">kube-system            kube-proxy-6kwdx                             1/1     Running   2 (17h ago)   20h</span><br><span class="line">kube-system            kube-proxy-7lk7c                             1/1     Running   1 (17h ago)   19h</span><br><span class="line">kube-system            kube-proxy-rjr76                             1/1     Running   1 (17h ago)   19h</span><br><span class="line">kube-system            kube-scheduler-kubernetes1               1/1     Running   3 (17h ago)   20h</span><br><span class="line">kubernetes-dashboard   dashboard-metrics-scraper-746f6b45bf-ndvbr   1/1     Running   0             40s</span><br><span class="line">kubernetes-dashboard   kubernetes-dashboard-64f444d4f9-2mjdb        1/1     Running   0             40s</span><br></pre></td></tr></table></figure>

<p><code>kubernetes-dashboard</code> 运行正常后，在防火墙放通 <code>kubernetes-dashboard</code> 对外的端口（30443）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -I INPUT 6 -p tcp --dport 30443  -j ACCEPT</span><br></pre></td></tr></table></figure>

<p>浏览器通过访问 master 节点的公网 ip 地址和端口（<a href="https://ip:30443）">https://ip:30443）</a> ，可以打开 <code>kubernetes-dashboard</code> web 界面<br><img src="https://i.csms.tech/img_56.png"></p>
<p>此时要验证 Token。需要首先创建管理员用户，创建以下配置文件，文件命名为 <code>kubernetes-dashboard-adminuser.yaml</code>，<a href="https://github.com/kubernetes/dashboard/blob/master/docs/user/access-control/creating-sample-user.md">参考文档</a></p>
<figure class="highlight shell"><figcaption><span>kubernetes-dashboard-adminuser.yaml</span></figcaption><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: admin</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: admin</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: cluster-admin</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: admin</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上配置创建了一个 <code>admin</code> 用户（用户名字随便起），赋予 <code>ClusterRoleBinding</code> 角色权限，关联到 <code>clusert-admin</code>（名称是固定的不能修改）。</p>
<p>根据此配置创建账号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl apply -f kubernetes-dashboard-adminuser.yaml</span></span><br><span class="line">serviceaccount/admin created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/admin created</span><br></pre></td></tr></table></figure>

<p>获取 <code>Bearer Token</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl -n kubernetes-dashboard create token admin</span></span><br><span class="line">eyJhbGciOiJSUzI1NiIsImtpZCI6InUxMDNNUmZmU3BFenZYTEZjNjk2LUR0S1Q..</span><br></pre></td></tr></table></figure>
<p>将生成的 <code>Token</code> 输入浏览器进行验证，验证成功后可以登入 Dashboard<br><img src="https://i.csms.tech/img_57.png"></p>
<p>默认的 token 有效期很短，要修改 token 的有限时间，可以在登陆 Dashboard 后，编辑 <code>kubernetes-dashboard</code> 的 <code>Deployment</code><br><img src="https://i.csms.tech/img_58.png"></p>
<p>在 <code>spec:template:spec:containers:args</code> 下新增 <code>- &#39;--token-ttl=2592000&#39;</code><br><img src="https://i.csms.tech/img_59.png"></p>
<h4 id="安装-Kubernetes-Metrics-Server"><a href="#安装-Kubernetes-Metrics-Server" class="headerlink" title="安装 Kubernetes Metrics Server"></a>安装 Kubernetes Metrics Server</h4><p>安装 <code>Kubernetes Metrics Server</code> 可以支持使用 <code>kubectl top</code> 命令来查看集群使用的资源情况。 <sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Kubernetes Metrics Server](https://github.com/kubernetes-sigs/metrics-server)">[5]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml</span><br><span class="line">mv components.yaml kubernetes-mitrics-server.yaml</span><br><span class="line">kubectl apply -f kubernetes-mitrics-server.yaml</span><br></pre></td></tr></table></figure>
<p>部署后为了解决证书问题，可以临时配置不使用安全证书进行通信，修改 <code>metrics-server</code> 的 <code>Deployment</code>，在 <code>metrics-server</code> 启动时添加参数 <code>--kubelet-insecure-tls</code></p>
<figure class="highlight shell"><figcaption><span>kubernetes-mitrics-server.yaml</span></figcaption><table><tr><td class="code"><pre><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - args:</span><br><span class="line">    - --cert-dir=/tmp</span><br><span class="line">    - --secure-port=4443</span><br><span class="line">    - --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname</span><br><span class="line">    - --kubelet-use-node-status-port</span><br><span class="line">    - --metric-resolution=15s</span><br><span class="line">    - --kubelet-insecure-tls</span><br></pre></td></tr></table></figure>

<h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><h4 id="Found-multiple-CRI-endpoints-on-the-host"><a href="#Found-multiple-CRI-endpoints-on-the-host" class="headerlink" title="Found multiple CRI endpoints on the host"></a>Found multiple CRI endpoints on the host</h4><p><strong>错误场景</strong> ： 执行以下命令将节点加入集群时报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubeadm <span class="built_in">join</span> 172.31.10.19:6443 --token 8ca35s.butdpihinkdczvqb --discovery-token-ca-cert-hash sha256:b2793f9a6bea44a64640f99042</span></span><br><span class="line"></span><br><span class="line">Found multiple CRI endpoints on the host. Please define which one do you wish to use by setting the &#x27;criSocket&#x27; field in the kubeadm configuration file: unix:///var/run/containerd/containerd.sock, unix:///var/run/cri-dockerd.sock</span><br><span class="line">To see the stack trace of this error execute with --v=5 or higher</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>报错原因</strong> ： 在没有明确指定 Kubernetes 要使用的 CRI 情况下，会自动扫描主机上面安装的 CRI，如果出现多个可用的 CRI，会报错并提示确定使用哪个 CRI。</p>
<p><strong>解决方法</strong> ： 使用如下命令，指定要使用的 CRI</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm join 172.31.10.19:6443 --token 8ca35s.butdpihinkdczvqb --discovery-token-ca-cert-hash sha256:b2793f9a6bea44a64640f99042f11c4ff6 \ </span><br><span class="line">        --cri-socket=unix:///var/run/cri-dockerd.sock</span><br></pre></td></tr></table></figure>

<h4 id="kube-flannel-状态为-CrashLoopBackOff"><a href="#kube-flannel-状态为-CrashLoopBackOff" class="headerlink" title="kube-flannel 状态为 CrashLoopBackOff"></a>kube-flannel 状态为 CrashLoopBackOff</h4><p><strong>错误场景</strong> ：<br><code>kube-flannel</code> 一直重启，状态为 <code>CrashLoopBackOff</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods --all-namespaces</span></span><br><span class="line">NAMESPACE      NAME                                      READY   STATUS              RESTARTS         AGE</span><br><span class="line">kube-flannel   kube-flannel-ds-7q2hp                     0/1     CrashLoopBackOff    40 (3m39s ago)   3h4m</span><br><span class="line">kube-flannel   kube-flannel-ds-k8wd6                     0/1     CrashLoopBackOff    35 (53s ago)     76m</span><br><span class="line">kube-flannel   kube-flannel-ds-x6ck2                     0/1     CrashLoopBackOff    18 (106s ago)    69m</span><br><span class="line">kube-system    coredns-565d847f94-b4sgn                  0/1     ContainerCreating   0                3h40m</span><br><span class="line">kube-system    coredns-565d847f94-ml6k5                  0/1     ContainerCreating   0                3h40m</span><br><span class="line">kube-system    etcd-kubernetes1                      1/1     Running             0                3h40m</span><br><span class="line">kube-system    kube-apiserver-kubernetes1            1/1     Running             0                3h40m</span><br><span class="line">kube-system    kube-controller-manager-kubernetes1   1/1     Running             0                3h40m</span><br><span class="line">kube-system    kube-proxy-9vwxl                          1/1     Running             0                76m</span><br><span class="line">kube-system    kube-proxy-qxsc7                          1/1     Running             0                69m</span><br><span class="line">kube-system    kube-proxy-v5msf                          1/1     Running             0                3h40m</span><br><span class="line">kube-system    kube-scheduler-kubernetes1            1/1     Running             0                3h40m</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>排查步骤</strong> ：<br>查看日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl logs kube-flannel-ds-7q2hp -n kube-flannel</span></span><br><span class="line">Defaulted container &quot;kube-flannel&quot; out of: kube-flannel, install-cni-plugin (init), install-cni (init)</span><br><span class="line">I0913 06:42:19.799473       1 main.go:207] CLI flags config: &#123;etcdEndpoints:http://127.0.0.1:4001,http://127.0.0.1:2379 etcdPrefix:/coreos.com/network etcdKeyfile: etcdCertfile: etcdCAFile: etcdUsername: etcdPassword: version:false kubeSubnetMgr:true kubeApiUrl: kubeAnnotationPrefix:flannel.alpha.coreos.com kubeConfigFile: iface:[] ifaceRegex:[] ipMasq:true ifaceCanReach: subnetFile:/run/flannel/subnet.env publicIP: publicIPv6: subnetLeaseRenewMargin:60 healthzIP:0.0.0.0 healthzPort:0 iptablesResyncSeconds:5 iptablesForwardRules:true netConfPath:/etc/kube-flannel/net-conf.json setNodeNetworkUnavailable:true&#125;</span><br><span class="line">W0913 06:42:19.799563       1 client_config.go:614] Neither --kubeconfig nor --master was specified.  Using the inClusterConfig.  This might not work.</span><br><span class="line">I0913 06:42:19.903750       1 kube.go:120] Waiting 10m0s for node controller to sync</span><br><span class="line">I0913 06:42:19.903882       1 kube.go:401] Starting kube subnet manager</span><br><span class="line">I0913 06:42:20.903967       1 kube.go:127] Node controller sync successful</span><br><span class="line">I0913 06:42:20.903995       1 main.go:227] Created subnet manager: Kubernetes Subnet Manager - kubernetes1</span><br><span class="line">I0913 06:42:20.904004       1 main.go:230] Installing signal handlers</span><br><span class="line">I0913 06:42:20.904152       1 main.go:467] Found network config - Backend type: vxlan</span><br><span class="line">I0913 06:42:20.904195       1 match.go:206] Determining IP address of default interface</span><br><span class="line">I0913 06:42:20.904542       1 match.go:259] Using interface with name eth0 and address 172.31.10.19</span><br><span class="line">I0913 06:42:20.904570       1 match.go:281] Defaulting external address to interface address (172.31.10.19)</span><br><span class="line">I0913 06:42:20.904651       1 vxlan.go:138] VXLAN config: VNI=1 Port=0 GBP=false Learning=false DirectRouting=false</span><br><span class="line">E0913 06:42:20.904962       1 main.go:330] Error registering network: failed to acquire lease: node &quot;kubernetes1&quot; pod cidr not assigned</span><br><span class="line">I0913 06:42:20.905100       1 main.go:447] Stopping shutdownHandler...</span><br><span class="line">W0913 06:42:20.905251       1 reflector.go:436] github.com/flannel-io/flannel/subnet/kube/kube.go:402: watch of *v1.Node ended with: an error on the server (&quot;unable to decode an event from the watch stream: context canceled&quot;) has prevented the request from succeeding</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>关键日志： <code>Error registering network: failed to acquire lease: node &quot;kubernetes1&quot; pod cidr not assigned</code></p>
<p><strong>问题原因</strong> ： worker 节点的 flannel 组件无法正常获取 podCIDR 的定义</p>
<p><strong>解决方法</strong> ： 编辑控制节点上的配置文件 <code>/etc/kubernetes/manifests/kube-controller-manager.yaml</code>，在 <code>- command</code> 下添加以下内容：</p>
<figure class="highlight shell"><figcaption><span>/etc/kubernetes/manifests/kube-controller-manager.yaml</span></figcaption><table><tr><td class="code"><pre><span class="line">- --allocate-node-cidrs=true</span><br><span class="line">- --cluster-cidr=10.244.0.0/16</span><br></pre></td></tr></table></figure>
<p>如果内容已存在的话，更改 cidr 的网段和 <a href="#%E5%AE%89%E8%A3%85-kube-flannel"><code>kube-flannel.yml</code> 中的 cidr</a> 一致</p>
<p>更改配置后，重启所有节点的 <code>kubelet</code> 服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart kubelet</span><br></pre></td></tr></table></figure>
<p>重新查看所有 pod 状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods -A</span></span><br><span class="line">NAMESPACE      NAME                                      READY   STATUS    RESTARTS         AGE</span><br><span class="line">kube-flannel   kube-flannel-ds-7q2hp                     1/1     Running   62 (2m20s ago)   4h43m</span><br><span class="line">kube-flannel   kube-flannel-ds-k8wd6                     1/1     Running   55 (4m33s ago)   175m</span><br><span class="line">kube-flannel   kube-flannel-ds-x6ck2                     1/1     Running   38 (2m43s ago)   168m</span><br><span class="line">kube-system    coredns-565d847f94-b4sgn                  0/1     Running   0                5h19m</span><br><span class="line">kube-system    coredns-565d847f94-ml6k5                  0/1     Running   0                5h19m</span><br><span class="line">kube-system    etcd-kubernetes1                      1/1     Running   0                5h19m</span><br><span class="line">kube-system    kube-apiserver-kubernetes1            1/1     Running   0                5h19m</span><br><span class="line">kube-system    kube-controller-manager-kubernetes1   1/1     Running   0                2m39s</span><br><span class="line">kube-system    kube-proxy-9vwxl                          1/1     Running   0                175m</span><br><span class="line">kube-system    kube-proxy-qxsc7                          1/1     Running   0                168m</span><br><span class="line">kube-system    kube-proxy-v5msf                          1/1     Running   0                5h19m</span><br><span class="line">kube-system    kube-scheduler-kubernetes1            1/1     Running   0                5h19m</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="master-节点状态为-NotReady"><a href="#master-节点状态为-NotReady" class="headerlink" title="master 节点状态为 NotReady"></a>master 节点状态为 NotReady</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get nodes</span></span><br><span class="line">NAME              STATUS     ROLES                  AGE    VERSION</span><br><span class="line">k8s-work1         Ready      &lt;none&gt;                 99m    v1.21.2</span><br><span class="line">k8s-master        NotReady   control-plane,master   102m   v1.21.2</span><br><span class="line">k8s-work2         Ready      &lt;none&gt;                 99m    v1.21.2</span><br></pre></td></tr></table></figure>

<p>查看节点详细信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl describe node k8s-master</span></span><br><span class="line"></span><br><span class="line">Conditions:</span><br><span class="line">  Type             Status    LastHeartbeatTime                 LastTransitionTime                Reason              Message</span><br><span class="line">  ----             ------    -----------------                 ------------------                ------              -------</span><br><span class="line">  MemoryPressure   Unknown   Tue, 11 Oct 2022 14:54:19 +0800   Tue, 11 Oct 2022 14:57:46 +0800   NodeStatusUnknown   Kubelet stopped posting node status.</span><br><span class="line">  DiskPressure     Unknown   Tue, 11 Oct 2022 14:54:19 +0800   Tue, 11 Oct 2022 14:57:46 +0800   NodeStatusUnknown   Kubelet stopped posting node status.</span><br><span class="line">  PIDPressure      Unknown   Tue, 11 Oct 2022 14:54:19 +0800   Tue, 11 Oct 2022 14:57:46 +0800   NodeStatusUnknown   Kubelet stopped posting node status.</span><br><span class="line">  Ready            Unknown   Tue, 11 Oct 2022 14:54:19 +0800   Tue, 11 Oct 2022 14:57:46 +0800   NodeStatusUnknown   Kubelet stopped posting node status.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看 <code>Pod</code> 状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods -A</span></span><br><span class="line">NAMESPACE      NAME                                 READY   STATUS    RESTARTS   AGE</span><br><span class="line">kube-flannel   kube-flannel-ds-84s24                0/1     Pending   0          22m</span><br><span class="line">kube-flannel   kube-flannel-ds-qzd9g                1/1     Running   1          22m</span><br><span class="line">kube-flannel   kube-flannel-ds-sbtrr                1/1     Running   1          22m</span><br><span class="line">kube-system    coredns-558bd4d5db-8mbl5             1/1     Running   1          105m</span><br><span class="line">kube-system    coredns-558bd4d5db-gzrrx             1/1     Running   1          105m</span><br><span class="line">kube-system    etcd-k8s-master             1/1     Running   0          105m</span><br><span class="line">kube-system    kube-apiserver-k8s-master            1/1     Running   0          105m</span><br><span class="line">kube-system    kube-proxy-747cx                     1/1     Running   1          103m</span><br><span class="line">kube-system    kube-proxy-8bs8l                     1/1     Running   1          103m</span><br><span class="line">kube-system    kube-proxy-mvqjq                     1/1     Running   0          105m</span><br><span class="line">kube-system    kube-scheduler-k8s-master            1/1     Running   0          105m</span><br></pre></td></tr></table></figure>
<p>结果显示 <code>kube-flannel</code> 位于 master 上的 <code>Pod</code> 状态异常。</p>
<p>查看 <code>kubelet</code> 日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">journalctl -f -u kubelet</span></span><br><span class="line"> E1011 16:28:53.898132     796 kubelet_node_status.go:93] &quot;Unable to register node with API server&quot; err=&quot;nodes \&quot;k8s-admin\&quot; is forbidden: node \&quot;k8s-master\&quot; is not allowed to modify node \&quot;k8s-admin\&quot;&quot; node=&quot;k8s-admin&quot;</span><br><span class="line"> E1011 16:28:53.900459     796 kubelet.go:2291] &quot;Error getting node&quot; err=&quot;node \&quot;k8s-admin\&quot; not found&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看主机名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hostname status</span></span><br><span class="line"></span><br><span class="line">   Static hostname: k8s-master</span><br><span class="line">Transient hostname: k8s-admin</span><br><span class="line">         Icon name: computer-vm</span><br><span class="line">           Chassis: vm</span><br><span class="line">        Machine ID: b1527a5456aab241a74a8a3dc31395c0</span><br><span class="line">           Boot ID: f8428003692349298cf2bb9efae8a664</span><br><span class="line">    Virtualization: kvm</span><br><span class="line">  Operating System: CentOS Linux 7 (Core)</span><br><span class="line">       CPE OS Name: cpe:/o:centos:centos:7</span><br><span class="line">            Kernel: Linux 3.10.0-1160.76.1.el7.x86_64</span><br><span class="line">      Architecture: x86-64</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>根据 <code>kubelet</code> 日志，Kubenetes 节点名称和主机名不一致。修改节点主机名。</p>
<h4 id="集群之外的服务器使用-kubectl-报错"><a href="#集群之外的服务器使用-kubectl-报错" class="headerlink" title="集群之外的服务器使用 kubectl 报错"></a>集群之外的服务器使用 kubectl 报错</h4><p><strong>问题场景</strong>：</p>
<p>将集群的管理配置文件 (<code>/etc/kubernetes/admin.conf</code>) 拷贝到集群之外的服务器，并命名为指定文件 <code>~/.kube/config</code>，修改 <code>~/.kube/config</code> 中 <code>server</code> 的 IP 为 Kubernetes API Server 的实际 IP，使用 <code>kubectl</code> 命令时，报错 <code>Unable to connect to the server: x509: certificate is valid for 10.96.0.1, 10.150.0.21, not </code>。</p>
<p><strong>问题原因</strong>：</p>
<p>报错表示，当使用安全端口 6443 访问 Kubernetes API Server 时，默认证书中的 DNS 包含了 API Server 服务的 CLUSTER-IP 和 服务器的 IP ，如果是云主机，则为云服务器的私有 IP，不包含其公网 IP，如果使用公网 IP 访问 6443 端口，会报此错误</p>
<p>通过以下命令，可以看到默认的 API Server 的 HTTPS 证书中包含的 DNS</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /etc/kubernetes/pki</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">openssl x509 -noout -text -<span class="keyword">in</span> apiserver.crt</span></span><br><span class="line">...</span><br><span class="line">    DNS:k8s-master, DNS:kubernetes, DNS:kubernetes.default, DNS:kubernetes.default.svc, DNS:kubernetes.default.svc.cluster.local, IP Address:10.96.0.1, IP Address:10.150.0.21</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>解决方法</strong>：</p>
<ul>
<li><p>使用 <code>kubectl</code> 的命令行选项 <code>--insecure-skip-tls-verify</code> 可跳过证书验证。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get nodes</span></span><br><span class="line">Unable to connect to the server: x509: certificate is valid for 10.96.0.1, 10.150.0.21, not 34.150.1.1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get nodes --insecure-skip-tls-verify</span></span><br><span class="line"></span><br><span class="line">NAME         STATUS   ROLES                  AGE    VERSION</span><br><span class="line">k8s-master   Ready    control-plane,master   6d5h   v1.21.2</span><br><span class="line">k8s-work1    Ready    &lt;none&gt;                 6d5h   v1.21.2</span><br><span class="line">k8s-work2    Ready    &lt;none&gt;                 6d5h   v1.21.2</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>修改 <code>~/.kube/config</code> 中 <code>server</code> 地址为证书中包含的 DNS 名称，如 <code>k8s-master</code>，并确保域名本地可解析</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep server .kube/config</span></span><br><span class="line">  server: https://k8s-master:6443</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get nodes</span></span><br><span class="line">  NAME         STATUS   ROLES                  AGE    VERSION</span><br><span class="line">  k8s-master   Ready    control-plane,master   6d6h   v1.21.2</span><br><span class="line">  k8s-work1    Ready    &lt;none&gt;                 6d6h   v1.21.2</span><br><span class="line">  k8s-work2    Ready    &lt;none&gt;                 6d6h   v1.21.2</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新生成 API Server 证书</p>
<ol>
<li><p>备份当前证书</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /etc/kubernetes/pki</span><br><span class="line">mkdir /data/k8s/backup/pki</span><br><span class="line">mv apiserver.* /data/k8s/backup/pki/</span><br></pre></td></tr></table></figure></li>
<li><p>生成新的 API Server 证书</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"> $ </span><span class="language-bash">kubeadm init phase certs apiserver \</span></span><br><span class="line"><span class="language-bash">         --apiserver-advertise-address  10.150.0.21 \</span></span><br><span class="line"><span class="language-bash">         --apiserver-cert-extra-sans  10.96.0.1 \</span></span><br><span class="line"><span class="language-bash">         --apiserver-cert-extra-sans 34.150.1.1</span></span><br><span class="line">     </span><br><span class="line">[certs] Generating &quot;apiserver&quot; certificate and key</span><br><span class="line">[certs] apiserver serving cert is signed for DNS names [k8s-master kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.96.0.1 10.150.0.21 34.150.1.1]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>10.150.0.21</code> - 为云主机的私有（内网） IP 地址，同时也是 <code>--apiserver-advertise-address</code>，必须要有</li>
<li><code>10.96.0.1</code> - 为 Kubernetes 集群中 API Server 对应的 Service 的 ClusterIP，必须要有</li>
<li><code>34.150.1.1</code> - 为云主机的公网（弹性） IP，是本次要添加的 IP</li>
</ul>
<p>如果还有其他 IP，可以参照格式 <code>--apiserver-cert-extra-sans 34.150.1.1</code> 添加。</p>
<p> 命令执行成功后，会生成新的证书。<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ls apiserver*</span><br><span class="line">   apiserver.crt              apiserver-etcd-client.key  apiserver-kubelet-client.crt</span><br><span class="line">   apiserver-etcd-client.crt  apiserver.key              apiserver-kubelet-client.key</span><br></pre></td></tr></table></figure></p>
</li>
<li><p>重启 kubelet 服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart kubelet</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证</p>
<p> 在远端服务器执行以下命令验证效果 </p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ rm -rf .kube/cache/</span><br><span class="line">     </span><br><span class="line">$ grep server .kube/config </span><br><span class="line">  server: https://34.150.1.1:6443</span><br><span class="line">     </span><br><span class="line">$ kubectl get nodes</span><br><span class="line">   NAME                  STATUS   ROLES                  AGE    VERSION</span><br><span class="line">   k8s-master   Ready    control-plane,master   6d6h   v1.21.2</span><br><span class="line">   k8s-work1    Ready    &lt;none&gt;                 6d6h   v1.21.2</span><br><span class="line">   k8s-work2    Ready    &lt;none&gt;                 6d6h   v1.21.2</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h3 id="其他常用配置"><a href="#其他常用配置" class="headerlink" title="其他常用配置"></a>其他常用配置</h3><h4 id="将-CRI-由-containerd-变更为-Docker"><a href="#将-CRI-由-containerd-变更为-Docker" class="headerlink" title="将 CRI 由 containerd 变更为 Docker"></a>将 CRI 由 <code>containerd</code> 变更为 <code>Docker</code></h4><p>编辑 <code>/var/lib/kubelet/kubeadm-flags.env</code> 文件，在该文件中可以添加 <code>kubelet</code> 启动参数，将 <code>--container-runtime-endpoint</code> 标志，设置为 <code>unix:///var/run/cri-dockerd.sock</code> <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[配置 kubelet 使用 cri-dockerd](https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/migrating-from-dockershim/migrate-dockershim-dockerd/#configure-the-kubelet-to-use-cri-dockerd)">[1]</span></a></sup></p>
<figure class="highlight shell"><figcaption><span>/var/lib/kubelet/kubeadm-flags.env</span></figcaption><table><tr><td class="code"><pre><span class="line">KUBELET_KUBEADM_ARGS=&quot;--container-runtime=remote --container-runtime-endpoint=unix:///var/run/cri-dockerd.sock --pod-infra-container-image=registry.k8s.io/pause:3.8&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>kubeadm</code> 工具将节点上的套接字存储为控制面上 <code>Node</code> 对象的注解。 要为每个被影响的节点更改此套接字：</p>
<ol>
<li>编辑 Node 对象的 YAML 表示：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">KUBECONFIG=/path/to/admin.conf kubectl edit no &lt;NODE_NAME&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><code>/path/to/admin.conf</code> ：指向 <code>kubectl</code> 配置文件 <code>admin.conf</code> 的路径；</li>
<li><code>&lt;NODE_NAME&gt;</code> ：你要修改的节点的名称。</li>
</ul>
<ol start="2">
<li>将 <code>kubeadm.alpha.kubernetes.io/cri-socket</code> 标志更改为 <code>unix:///var/run/cri-dockerd.sock</code>；</li>
</ol>
<p>配置完成后，重启 kubelet</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart kubelet </span><br></pre></td></tr></table></figure>

<p>查看 node 使用的 CRI</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get nodes -o wide</span></span><br><span class="line">NAME              STATUS   ROLES           AGE    VERSION   INTERNAL-IP    EXTERNAL-IP   OS-IMAGE                KERNEL-VERSION                CONTAINER-RUNTIME</span><br><span class="line">kubernetes1   Ready    control-plane   7d2h   v1.25.0   172.31.5.58    &lt;none&gt;        CentOS Linux 7 (Core)   5.4.212-1.el7.elrepo.x86_64   docker://20.10.18</span><br><span class="line">kubernetes2   Ready    &lt;none&gt;          7d1h   v1.25.0   172.31.5.68    &lt;none&gt;        CentOS Linux 7 (Core)   5.4.212-1.el7.elrepo.x86_64   docker://20.10.18</span><br><span class="line">kubernetes3   Ready    &lt;none&gt;          7d1h   v1.25.0   172.31.0.230   &lt;none&gt;        CentOS Linux 7 (Core)   5.4.212-1.el7.elrepo.x86_64   docker://20.10.18</span><br></pre></td></tr></table></figure>

<h4 id="修改-Service-可使用的-nodePort-端口范围"><a href="#修改-Service-可使用的-nodePort-端口范围" class="headerlink" title="修改 Service 可使用的 nodePort 端口范围"></a>修改 Service 可使用的 nodePort 端口范围</h4><p>默认情况下，<code>Service</code> 中可使用的 <code>nodePort</code> 端口的默认范围为 <code>30000-32767</code>，要修改此配置，参考以下步骤。</p>
<p>Master 节点上编辑 kube-apiserver 的 <code>Pod</code> 配置文件 <code>/etc/kubernetes/manifests/kube-apiserver.yaml</code>，在 <code>.spec.containers.command</code> 下添加以下内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">- --service-node-port-range=1-65535</span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_60.png"></p>
<p><code>apiserver</code> 是以静态 <code>Pod</code> 的形式运行，<code>/etc/kubernetes/manifests</code> 目录下是所有静态 <code>Pod</code> 文件的定义，<code>kubelet</code> 会监控该目录下文件的变动，只要发生变化，<code>Pod</code> 就会重建，响应相应的改动。所以我们修改 <code>/etc/kubernetes/manifests/kube-apiserver.yaml</code> 文件，添加 <code>nodePort</code> 范围参数后会自动生效，无需进行其他操作</p>
<h4 id="开启-corndns-日志记录"><a href="#开启-corndns-日志记录" class="headerlink" title="开启 corndns 日志记录"></a>开启 corndns 日志记录</h4><p>默认的coredns配置没有开启日志插件，这导致kubernetes集群中一些dns解析超时问题难以定位。要打开 coredns 的日志功能，可以通过以下命令开启日志功能</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl edit configmap -n kube-system  coredns</span><br></pre></td></tr></table></figure>
<p>添加以下配置：<br><img src="https://i.csms.tech/img_66.png"></p>
<p>接下来我们再使用命令查看日志，就可以看到 dns 解析的记录，无需重启 coredns</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl logs -f -n kube-system coredns-558bd4d5db-z6mst</span></span><br><span class="line">...</span><br><span class="line">[INFO] 10.244.2.23:39830 - 37988 &quot;A IN raw.githubusercontent.com.google.internal. udp 59 false 512&quot; NXDOMAIN qr,aa,rd,ra 164 0.000065843s</span><br><span class="line">[INFO] 10.244.2.23:56581 - 52144 &quot;A IN raw.githubusercontent.com. udp 43 false 512&quot; NOERROR qr,aa,rd,ra 207 0.000133489s</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="添加-Harbor-私有镜像仓库的认证信息"><a href="#添加-Harbor-私有镜像仓库的认证信息" class="headerlink" title="添加 Harbor 私有镜像仓库的认证信息"></a>添加 Harbor 私有镜像仓库的认证信息</h4><p>在命令行上提供凭证来创建 Secret <sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[在命令行上提供凭证来创建 Secret](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/pull-image-private-registry/#create-a-secret-by-providing-credentials-on-the-command-line)">[3]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create secret docker-registry $&#123;secretname&#125; \</span><br><span class="line">  --namespace default</span><br><span class="line">  --docker-server=https://index.docker.io/v1/ \</span><br><span class="line">  --docker-username=&lt;你的用户名&gt; \</span><br><span class="line">  --docker-password=&lt;你的密码&gt; \</span><br><span class="line">  --docker-email=&lt;你的邮箱地址&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>&lt;your-registry-server&gt;</code> 是你的私有 Docker 仓库全限定域名（FQDN）。 DockerHub 使用 <code>https://index.docker.io/v1/</code>。</li>
<li><code>&lt;your-name&gt;</code> 是你的 Docker 用户名。</li>
<li><code>&lt;your-pword&gt;</code> 是你的 Docker 密码。</li>
<li><code>&lt;your-email&gt;</code> 是你的 Docker 邮箱。</li>
</ul>
<p>这样你就成功地将集群中的 Docker 凭证设置为名为 <code>$&#123;secretname&#125;</code> 的 Secret。</p>
<p>Secret 属于 namespace 级别的资源，不能跨 namespace 使用。</p>
<p>检查创建的 Secret</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get secret <span class="variable">$&#123;secretname&#125;</span> --output=yaml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">data:</span><br><span class="line">  .dockerconfigjson: eyJhdXRocfX19</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: &quot;2022-11-04T08:55:51Z&quot;</span><br><span class="line">  name: $&#123;secretname&#125;</span><br><span class="line">  namespace: default</span><br><span class="line">  resourceVersion: &quot;1679647&quot;</span><br><span class="line">  uid: a780ac6d-9525-4620-a171-b818021cc6ca</span><br><span class="line">type: kubernetes.io/dockerconfigjson</span><br></pre></td></tr></table></figure>

<p><code>.dockerconfigjson</code> 字段的值是 Docker 凭证的 base64 表示。要了解 <code>dockerconfigjson</code> 字段中的内容，请将 Secret 数据转换为可读格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get secret <span class="variable">$&#123;secretname&#125;</span> --output=<span class="string">&quot;jsonpath=&#123;.data.\.dockerconfigjson&#125;&quot;</span> | <span class="built_in">base64</span> --decode</span></span><br><span class="line">&#123;&quot;auths&quot;:&#123;&quot;https://harbor1.my.com&quot;:&#123;&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;password&quot;,&quot;email&quot;:&quot;docker@q.com&quot;,&quot;auth&quot;:&quot;YWRdsUQ==&quot;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Pod-添加-hosts"><a href="#Pod-添加-hosts" class="headerlink" title="Pod 添加 hosts"></a>Pod 添加 hosts</h4><p>有时需要在启动 Pod 时为其 <code>/etc/hosts</code> 中添加解析，以覆盖对主机名的解析，此时可以通过 <code>PodSpec</code> 的 <code>HostAliases</code> 字段来 <strong>添加这些自定义条目</strong> <sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[使用 HostAliases 向 Pod /etc/hosts 文件添加条目](https://kubernetes.io/zh-cn/docs/tasks/network/customize-hosts-file-for-pods/)">[4]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: hostaliases-pod</span><br><span class="line">spec:</span><br><span class="line">  restartPolicy: Never</span><br><span class="line">  hostAliases:</span><br><span class="line">  - ip: &quot;127.0.0.1&quot;</span><br><span class="line">    hostnames:</span><br><span class="line">    - &quot;foo.local&quot;</span><br><span class="line">    - &quot;bar.local&quot;</span><br><span class="line">  - ip: &quot;10.1.2.3&quot;</span><br><span class="line">    hostnames:</span><br><span class="line">    - &quot;foo.remote&quot;</span><br><span class="line">    - &quot;bar.remote&quot;</span><br><span class="line">  containers:</span><br><span class="line">  - name: cat-hosts</span><br><span class="line">    image: busybox:1.28</span><br><span class="line">    command:</span><br><span class="line">    - cat</span><br><span class="line">    args:</span><br><span class="line">    - &quot;/etc/hosts&quot;</span><br></pre></td></tr></table></figure>

<h4 id="配置-Pod-中的时区和时间"><a href="#配置-Pod-中的时区和时间" class="headerlink" title="配置 Pod 中的时区和时间"></a>配置 Pod 中的时区和时间</h4><p><a href="https://www.cnblogs.com/ssgeek/p/15192028.html">关于 OS 中的时间及时区的说明</a></p>
<p>通常情况下，我们的环境中，宿主机都是配置为 CST 时间（东八区），而使用的基础镜像中的默认时间都是 UTC 时间，而不是本地时间，通常需要确保系统中所有的时间格式一致，需将容器中的时间也修改为 CST 时间。</p>
<p>为此可使用以下方法中的一种来实现</p>
<ul>
<li><p>在 Dockerfile 中添加时区</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Set timezone</span><br><span class="line">RUN ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \</span><br><span class="line">           &amp;&amp; echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone</span><br></pre></td></tr></table></figure></li>
<li><p>将时区文件挂载到 Pod 中</p>
<p>  在定义 Pod 上层控制器的时候，添加一个用于挂载时区的卷，挂载宿主机的时区文件</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  ...</span><br><span class="line">containers:</span><br><span class="line">- name: xxx</span><br><span class="line">  ...</span><br><span class="line">  volumeMounts:</span><br><span class="line">    - name: timezone</span><br><span class="line">      mountPath: /etc/localtime</span><br><span class="line">volumes:</span><br><span class="line">  - name: timezone</span><br><span class="line">    hostPath:</span><br><span class="line">      path: /usr/share/zoneinfo/Asia/Shanghai</span><br></pre></td></tr></table></figure></li>
<li><p>通过环境变量定义时区</p>
<p>  在定义pod上层控制器的时候，添加一个用于指定时区的环境变量</p>
<p>  <code>TZ</code> 环境变量用于设置时区。它由各种时间函数用于计算相对于全球标准时间 UTC（以前称为格林威治标准时间 GMT）的时间。格式由操作系统指定</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  ...</span><br><span class="line">containers:</span><br><span class="line">- name: xxx</span><br><span class="line">  ...</span><br><span class="line">  env:</span><br><span class="line">  - name: TZ</span><br><span class="line">    value: Asia/Shanghai</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://kubernetes.io/zh-cn/docs/setup/production-environment/">Kubernetes 官网文档</a><br><a href="https://github.com/Mirantis/cri-dockerd">cri-dockerd 安装链接</a><br><a href="https://juejin.cn/post/6844904148001882120">Centos7 集群部署k8s 版本v1.17.4及Dashboard </a><br><a href="https://github.com/kubernetes/dashboard/tree/master/docs">kubernetes-dashboard 配置官网说明</a><br><a href="https://kubernetes.io/zh-cn/docs/tasks/access-application-cluster/web-ui-dashboard/">部署和访问 Kubernetes 仪表板（Dashboard）</a></p>
<h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/migrating-from-dockershim/migrate-dockershim-dockerd/#configure-the-kubelet-to-use-cri-dockerd">配置 kubelet 使用 cri-dockerd</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/high-availability/#%E4%B8%BA-kube-apiserver-%E5%88%9B%E5%BB%BA%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8">为 kube-apiserver 创建负载均衡器</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/pull-image-private-registry/#create-a-secret-by-providing-credentials-on-the-command-line">在命令行上提供凭证来创建 Secret</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/tasks/network/customize-hosts-file-for-pods/">使用 HostAliases 向 Pod /etc/hosts 文件添加条目</a><a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://github.com/kubernetes-sigs/metrics-server">Kubernetes Metrics Server</a><a href="#fnref:5" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 常用文件说明</title>
    <url>/202208180923/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Centos 7</li>
</ul>
<span id="more"></span>

<h3 id="常用文件说明"><a href="#常用文件说明" class="headerlink" title="常用文件说明"></a>常用文件说明</h3><table>
<thead>
<tr>
<th>文件路径</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;etc&#x2F;motd</td>
<td>登录成功后的欢迎信息，ssh 登录和 console 登录成功后都会显示</td>
<td></td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;issue</td>
<td>在登录系统输入用户名之前显示的信息，远程 ssh 连接的时候并不会显示此信息</td>
<td><a href="#x2F-etc-x2F-issue">说明示例</a></td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;services</td>
<td>记录网络服务名和它们对应使用的端口号及协议</td>
<td></td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;protocols</td>
<td>该文件是网络协议定义文件，里面记录了 <code>TCP/IP</code> 协议族的所有协议类型。文件中的每一行对应一个协议类型，它有3个字段，分别表示 <code>协议名称</code>、<code>协议号</code> 和 <code>协议别名</code></td>
<td></td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;vimrc<br/>~&#x2F;.vimrc</td>
<td><code>vim</code> 启动时会读取 <code>/etc/vimrc</code>（全局配置） 和 <code>~/.vimrc</code> （用户配置）</td>
<td><a href="/202208181117/" title="vim">vim</a></td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;passwd<br/>&#x2F;etc&#x2F;shadow<br/>&#x2F;etc&#x2F;group</td>
<td>用户数据库，其中记录了 <code>用户名</code>，<code>id</code>，<code>用户家目录</code>，<code>shell</code> 等<br/>用户密码文件<br/>组信息</td>
<td></td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;fstab</td>
<td>系统启动时需要自动挂载的文件系统列表</td>
<td></td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;mtab</td>
<td>当前系统已挂载的文件系统，并由 <code>mount</code> 命令自动更新。当需要当前挂载的文件系统的列表时使用(例如df命令)</td>
<td></td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;shells</td>
<td>系统可使用的 <code>shell</code></td>
<td></td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;filesystems</td>
<td>系统可使用的 <code>文件系统</code></td>
<td></td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;hostname</td>
<td>存放这主机名</td>
<td></td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;hosts</td>
<td>主机名查询静态表，域名和 ip 本地静态表</td>
<td></td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;nsswitch.conf</td>
<td>它规定通过哪些途径以及按照什么顺序以及通过这些途径来查找特定类型的信息，还可以指定某个方法奏效或失效时系统将采取什么动作</td>
<td><code>hosts:      files dns myhostname</code><br/>此配置设定：在查找域名解析的时候，先查找本地 <code>/etc/hosts</code>，再发送给 DNS 服务器查询</td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;rsyslog.conf</td>
<td><code>rsyslog</code> 服务的配置文件，用来托管其他服务的日志</td>
<td><a href="/202208191014/" title="linux rsyslog 服务">linux rsyslog 服务</a></td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;logrotate.conf</td>
<td>linux 日志切割工具</td>
<td><a href="/202208191317/" title="linux logrotate 服务">linux logrotate 服务</a></td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;rsyncd.conf</td>
<td><code>rsync</code> 服务的配置文件</td>
<td><a href="/36f703dc/" title="rsyncd 服务">rsyncd 服务</a></td>
</tr>
</tbody></table>
<h3 id="说明示例"><a href="#说明示例" class="headerlink" title="说明示例"></a>说明示例</h3><h4 id="x2F-etc-x2F-issue"><a href="#x2F-etc-x2F-issue" class="headerlink" title="&#x2F;etc&#x2F;issue"></a>&#x2F;etc&#x2F;issue</h4><p><img src="https://i.csms.tech/img_40.png"></p>
<p>文件内容可使用的各个变量说明如下</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>\d</td>
<td>显示当前日期</td>
</tr>
<tr>
<td>\l</td>
<td>显示虚拟控制台号</td>
</tr>
<tr>
<td>\m</td>
<td>显示机器类型，即 CPU 架构，如 i386 或 x86_64 等（相当于 uname -m）</td>
</tr>
<tr>
<td>\n</td>
<td>显示主机的网络名（相当于 uname -n）</td>
</tr>
<tr>
<td>\o</td>
<td>显示域名</td>
</tr>
<tr>
<td>\r</td>
<td>显示 Kernel 内核版本号（相当于 uname -r）</td>
</tr>
<tr>
<td>\t</td>
<td>显示当前时间</td>
</tr>
<tr>
<td>\s</td>
<td>显示当前操作系统名称</td>
</tr>
<tr>
<td>\u</td>
<td>显示当前登录用户的编号</td>
</tr>
<tr>
<td>\U</td>
<td>显示当前登录用户的编号和用户</td>
</tr>
<tr>
<td>\v</td>
<td>显示当前操作系统的版本日期</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 压缩解压缩</title>
    <url>/202209301257/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h2><h3 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">file test.gz</span> </span><br><span class="line">test.gz: gzip compressed data, from FAT filesystem (MS-DOS, OS/2, NT)</span><br><span class="line"></span><br><span class="line">gzip -d test.gz </span><br></pre></td></tr></table></figure>

<h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gzip test.txt</span><br></pre></td></tr></table></figure>

<p>压缩后默认生成压缩文件 <code>test.txt.gz</code></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>cp 命令用法</title>
    <url>/202210281406/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>常用选项</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>-R, -r, --recursive</code></td>
<td>递归拷贝</td>
<td></td>
</tr>
<tr>
<td><code>-p, --preserve</code></td>
<td>拷贝时保留文件信息（default: mode,ownership,timestamps）</td>
<td></td>
</tr>
</tbody></table>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="拷贝时包含隐藏文件一起"><a href="#拷贝时包含隐藏文件一起" class="headerlink" title="拷贝时包含隐藏文件一起"></a>拷贝时包含隐藏文件一起</h3><p><code>cp -rf dir1/* dir2/</code> </p>
<p>使用此格式拷贝时，假如 <code>dir1</code> 下面包含隐藏文件，拷贝时隐藏文件不会被拷贝过去</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree -a</span></span><br><span class="line">.</span><br><span class="line">├── dir1</span><br><span class="line">│    ├── test1</span><br><span class="line">│    └── .test2</span><br><span class="line">└── dir2</span><br><span class="line"></span><br><span class="line">2 directories, 2 files</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如上所示的目录结构，执行命令 <code>cp -rf dir1/* dir2/</code>，观察目录结构:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree -a</span></span><br><span class="line">.</span><br><span class="line">├── dir1</span><br><span class="line">│    ├── test1</span><br><span class="line">│    └── .test2</span><br><span class="line">└── dir2</span><br><span class="line">    └── test1</span><br><span class="line"></span><br><span class="line">2 directories, 3 files</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>看见，<code>dir/.test</code> 未被拷贝，如果拷贝时希望同时保护隐藏文件，可以使用 <code>.</code> 代替 <code>*</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree -a</span></span><br><span class="line">.</span><br><span class="line">├── dir1</span><br><span class="line">│    ├── test1</span><br><span class="line">│    └── .test2</span><br><span class="line">└── dir2</span><br><span class="line"></span><br><span class="line">2 directories, 2 files</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> -rf dir1/. dir2/</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree -a</span></span><br><span class="line">.</span><br><span class="line">├── dir1</span><br><span class="line">│    ├── test1</span><br><span class="line">│    └── .test2</span><br><span class="line">└── dir2</span><br><span class="line">    ├── test1</span><br><span class="line">    └── .test2</span><br><span class="line"></span><br><span class="line">2 directories, 4 files</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux find 命令</title>
    <url>/202208180949/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Centos 7</li>
</ul>
<h3 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h3><p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find   path   -option   [ -print ]   [ -exec   -ok   command ]   &#123;&#125; \;</span><br></pre></td></tr></table></figure>
<p>常用查找选项（<code>-option</code>）：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>-amin n<br/>-amin +n<br/>-amin -n</td>
<td>在过去 n 分钟内被读取过<br/>更改时间超过 n<br/>更改时间在 n 以内</td>
<td></td>
</tr>
<tr>
<td>-anewer file</td>
<td>比文件 file 更晚被读取过的文件</td>
<td></td>
</tr>
<tr>
<td>-atime n</td>
<td>在过去 n 天内被读取过的文件</td>
<td></td>
</tr>
<tr>
<td>-cmin n</td>
<td>在过去 n 分钟内被修改过</td>
<td></td>
</tr>
<tr>
<td>-cnewer file</td>
<td>比文件 file 更新的文件</td>
<td></td>
</tr>
<tr>
<td>-ctime n</td>
<td>在过去 n 天内创建的文件</td>
<td></td>
</tr>
<tr>
<td>-mtime n</td>
<td>在过去 n 天内修改过的文件</td>
<td></td>
</tr>
<tr>
<td>-empty</td>
<td>空的文件</td>
<td></td>
</tr>
<tr>
<td>-gid n<br/>-group name</td>
<td>gid 是 n<br/>group 名称是 name</td>
<td></td>
</tr>
<tr>
<td>-user u</td>
<td>根据用户名查找</td>
<td></td>
</tr>
<tr>
<td>-nouser</td>
<td>属主不存在</td>
<td></td>
</tr>
<tr>
<td>-ipath p<br/>-path p</td>
<td>路径名称符合 p 的文件，ipath 会忽略大小写</td>
<td></td>
</tr>
<tr>
<td>-name name<br/> -iname name</td>
<td>文件名称符合 name 的文件。iname 会忽略大小写</td>
<td></td>
</tr>
<tr>
<td>-size n <br/>-size +n<br/>-size -n</td>
<td>文件大小 是 n 单位，b 代表 512 位元组的区块，c 表示字元数，k 表示 kilo bytes，w 是二个位元组。<br/>文件大小大于 n<br/>文件大小小于 n</td>
<td></td>
</tr>
<tr>
<td>-type c</td>
<td>文件类型是 c 的文件，c 包括：<br/>d : 目录<br/>c : 字符设备<br/>b : 块设备<br/> p : 通道设备<br/>f : 文件<br/>l : 链接文件<br/>s : socker</td>
<td></td>
</tr>
<tr>
<td>-pid n</td>
<td>process id 是 n 的文件</td>
<td></td>
</tr>
<tr>
<td>-perm 0644</td>
<td>权限</td>
<td></td>
</tr>
<tr>
<td>-maxdepth<br/>-mindepth</td>
<td>查找深度</td>
<td></td>
</tr>
</tbody></table>
<span id="more"></span>

<p>常用运算符：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>()</code></td>
<td>将运算表达式组合起来</td>
<td></td>
</tr>
<tr>
<td><code>-and</code></td>
<td>与</td>
<td></td>
</tr>
<tr>
<td><code>-or</code></td>
<td>或</td>
<td></td>
</tr>
<tr>
<td><code>-not</code></td>
<td>取反</td>
<td></td>
</tr>
<tr>
<td><code>!</code></td>
<td>非</td>
<td><code>find . ! -type f -print</code><br/><code>find . -anewer FILE1 ! -anewer FILE2</code></td>
</tr>
</tbody></table>
<p>常用子命令：</p>
<table>
<thead>
<tr>
<th>子命令</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>-print &#123;&#125; \;</code></td>
<td>默认命令，输出查找到的目标到标准输出</td>
<td></td>
</tr>
<tr>
<td><code>-exec command &#123;&#125; \;</code></td>
<td>对查找到的目标执行命令</td>
<td></td>
</tr>
<tr>
<td><code>-ok   command &#123;&#125; \;</code></td>
<td>和 <code>-exec</code> 一样，不过执行前先询问是否执行</td>
<td></td>
</tr>
</tbody></table>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>查找读取时间比文件 <code>FILE1</code> 晚，但又比文件 <code>FILE2</code> 早的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">`find . -anewer FILE1 ! -anewer FILE2`</span><br></pre></td></tr></table></figure>

<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3>]]></content>
      <categories>
        <category>Linux</category>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>iptables 服务使用说明</title>
    <url>/202210241051/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="iptables-命令"><a href="#iptables-命令" class="headerlink" title="iptables 命令"></a>iptables 命令</h1><p>常用选项说明</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>--line-numbers</code></td>
<td>显示规则行号</td>
<td></td>
</tr>
<tr>
<td><code>-F</code></td>
<td>清除所有规则</td>
<td></td>
</tr>
</tbody></table>
<h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><h2 id="删除指定规则"><a href="#删除指定规则" class="headerlink" title="删除指定规则"></a>删除指定规则</h2><p>查看规则及行号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iptables -L -v -n --line-number</span></span><br><span class="line">Chain INPUT (policy DROP 0 packets, 0 bytes)</span><br><span class="line">num   pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line">1       90  6516 ACCEPT     all  --  *      *       0.0.0.0/0            0.0.0.0/0            state RELATED,ESTABLISHED</span><br><span class="line">2        0     0 ACCEPT     all  --  lo     *       0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">3        0     0 ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            state NEW tcp multiport dports 10050,10051</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>删除指定行号的规则</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -D INPUT 7</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title>linux logrotate 服务</title>
    <url>/202208191317/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Centos 7</li>
</ul>
<p><code>logrotate</code> 程序是一个日志文件管理工具。用于分割日志文件，压缩转存、删除旧的日志文件，并创建新的日志文件  </p>
<p><code>logrotate</code> 是基于 <code>crond</code> 来运行的，其脚本是 <code>/etc/cron.daily/logrotate</code>，日志轮转是系统自动完成的。<br>实际运行时，<code>logrotate</code> 会调用配置文件 <code>/etc/logrotate.conf</code>。<br><code>/etc/cron.daily/logrotate</code> 文件内容如下：</p>
<figure class="highlight shell"><figcaption><span>/etc/cron.daily/logrotate</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">/usr/sbin/logrotate -s /var/lib/logrotate/logrotate.status /etc/logrotate.conf</span><br><span class="line">EXITVALUE=$?</span><br><span class="line">if [ $EXITVALUE != 0 ]; then</span><br><span class="line">    /usr/bin/logger -t logrotate &quot;ALERT exited abnormally with [$EXITVALUE]&quot;</span><br><span class="line">fi</span><br><span class="line">exit 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以执行以下命令手动执行日志切割：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">logrotate -f /etc/logrotate.conf</span><br></pre></td></tr></table></figure>
<p>以下命令可以检测配置文件是否正确：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">logrotate -d /etc/logrotate.conf</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h3><p><code>logrotate</code> 的主配置文件默认为 <code>/etc/logrotate.conf</code>，默认配置如下：</p>
<figure class="highlight shell"><figcaption><span>/etc/logrotate.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认每一周执行一次 rotate 轮转工作</span></span><br><span class="line">weekly</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">保留多少个日志文件(轮转几次).默认保留四个.0 指没有备份</span></span><br><span class="line">rotate 4</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">自动创建新的日志文件，新的日志文件具有和原来的文件相同的权限；</span></span><br><span class="line">create</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这个参数很重要！就是切割后的日志文件以当前日期为格式结尾，如xxx.log-20131216这样,</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果注释掉,切割出来是按数字递增,即 xxx.log-1这种格式</span></span><br><span class="line">dateext</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">包含 /etc/logrotate.d 下的其他配置文件 ，用于隔离出各个服务的配置</span></span><br><span class="line">include /etc/logrotate.d</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">是否通过gzip压缩转储以后的日志文件，如xxx.log-20131216.gz ；如果不需要压缩，注释掉就行</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">compress</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">nocompress</span> </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">针对指定的文件做轮转切割</span></span><br><span class="line">/var/log/wtmp &#123;</span><br><span class="line">    # 每月轮转一次，取代全局默认值</span><br><span class="line">    monthly</span><br><span class="line">    </span><br><span class="line">    # 创建新文件，并指定权限，用户和组</span><br><span class="line">    create 0664 root utmp</span><br><span class="line">    </span><br><span class="line">    # 文件大小超过 1m 后才进行切割，到了 1 个月，文件大小小于 1m，不会进行切割</span><br><span class="line">	minsize 1M</span><br><span class="line">	</span><br><span class="line">    rotate 1</span><br><span class="line">&#125;</span><br><span class="line">/var/log/btmp &#123;</span><br><span class="line">    # 如果日志丢失，不报错继续滚动下一个日志</span><br><span class="line">    missingok</span><br><span class="line">    </span><br><span class="line">    monthly</span><br><span class="line">    create 0600 root utmp</span><br><span class="line">    rotate 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他常用选项说明如下：</p>
<figure class="highlight shell"><figcaption><span>/etc/logrotate.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定转储周期为每天</span></span><br><span class="line">daily </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">即使日志文件为空文件也做轮转，这个是 logrotate 的缺省选项。</span></span><br><span class="line">ifempty </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当日志文件为空时，不进行轮转</span></span><br><span class="line">notifempty </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当日志文件大于指定大小后就轮转，支持的单位： k，K，m，M</span></span><br><span class="line">size 5M</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用于还在打开中的日志文件，把当前日志备份并截断；</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">是先拷贝再清空的方式，拷贝和清空之间有一个时间差，可能会丢失部分日志数据。</span></span><br><span class="line">copytruncate</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行 postrotate 脚本，作用是在所有日志都轮转后统一执行一次脚本。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果没有配置这个，那么每个日志轮转后都会执行一次脚本</span></span><br><span class="line">sharedscripts                      </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 logrotate 转储之后需要执行的指令，例如重新启动 (<span class="built_in">kill</span> -HUP) 某个服务！必须独立成行</span></span><br><span class="line">postrotate                         </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 logrotate 转储之前需要执行的指令，例如修改文件的属性等动作；必须独立成行</span></span><br><span class="line">prerotate      </span><br><span class="line">                    </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将轮转的日志保存到指定路径下，默认保存在日志文件同一目录下</span></span><br><span class="line">olddir /data/logs/</span><br></pre></td></tr></table></figure>

<h3 id="配置示例"><a href="#配置示例" class="headerlink" title="配置示例"></a>配置示例</h3><p><code>nginx</code> 日志切割配置文件示例，创建 <code>/etc/logrotate.d/nginx</code>:</p>
<figure class="highlight shell"><figcaption><span>/etc/logrotate.d/nginx</span></figcaption><table><tr><td class="code"><pre><span class="line">/logs/nginx/access/*.log</span><br><span class="line">/logs/bginx/error/*.log &#123;</span><br><span class="line">    daily</span><br><span class="line">    compress</span><br><span class="line">    rotate 7</span><br><span class="line">    missingok</span><br><span class="line">    notifempty</span><br><span class="line">    dateext</span><br><span class="line">    sharedscripts</span><br><span class="line">    postrotate</span><br><span class="line">        if [ -f /run/nginx.pid ]; then</span><br><span class="line">                    kill -USR1 `cat /run/nginx.pid`</span><br><span class="line">        fi</span><br><span class="line">    endscript</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用 <code>copytruncate</code> 方式切割 <code>nginx</code> 日志，此种方式不需要重启 <code>nginx</code> 服务<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[logrotate 原理介绍和配置详解](https://wsgzao.github.io/post/logrotate/)
">[1]</span></a></sup></p>
<figure class="highlight shell"><figcaption><span>/etc/logrotate.d/nginx</span></figcaption><table><tr><td class="code"><pre><span class="line">/logs/nginx/access/*.log</span><br><span class="line">/logs/bginx/error/*.log &#123;</span><br><span class="line">    copytruncate</span><br><span class="line">    daily</span><br><span class="line">    compress</span><br><span class="line">    rotate 7</span><br><span class="line">    missingok</span><br><span class="line">    notifempty</span><br><span class="line">    dateext</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://wsgzao.github.io/post/logrotate/">logrotate 原理介绍和配置详解</a></p>
<h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://wsgzao.github.io/post/logrotate/">logrotate 原理介绍和配置详解</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>logrotate</tag>
      </tags>
  </entry>
  <entry>
    <title>linux rsyslog 服务</title>
    <url>/202208191014/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Centos 7</li>
</ul>
<p>系统默认的日志托管服务，部分系统服务（如 <code>crond</code>, 邮件系统，安全审计等）会将日志发送给 <code>rsyslog</code> 服务来进行日志管理。</p>
<p><code>rsyslog</code> 服务是依赖其配置文件 <code>/etc/rsyslog.conf</code> 来确定哪个服务的什么等级的日志信息会被记录在哪个位置的。也就是说，日志服务的配置文件中主要定义了服务的名称、日志等级和日志记录位置。</p>
<span id="more"></span>

<h3 id="配置文件说明"><a href="#配置文件说明" class="headerlink" title="配置文件说明"></a>配置文件说明</h3><p>默认配置文件(<code>/etc/rsyslog.conf</code>)内容如下</p>
<figure class="highlight shell"><figcaption><span>/etc/rsyslog.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载指定模块</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">ModLoad imuxsock <span class="comment"># provides support for local system logging (e.g. via logger command)</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">ModLoad imjournal <span class="comment"># provides access to the systemd journal</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">放置 rsyslog 辅助文件的路径</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">WorkDirectory /var/lib/rsyslog</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">时间格式</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">ActionFileDefaultTemplate RSYSLOG_TraditionalFileFormat</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">包含其他配置</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">IncludeConfig /etc/rsyslog.d/*.conf</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">OmitLocalLogging on</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">IMJournalStateFile imjournal.state</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">日志记录规则</span></span><br><span class="line">*.info;mail.none;authpriv.none;cron.none                /var/log/messages</span><br><span class="line">authpriv.*                                              /var/log/secure</span><br><span class="line">mail.*                                                  -/var/log/maillog</span><br><span class="line">cron.*                                                  /var/log/cron</span><br><span class="line">*.emerg                                                 :omusrmsg:*</span><br><span class="line">uucp,news.crit                                          /var/log/spooler</span><br><span class="line">local7.*                                                /var/log/boot.log</span><br></pre></td></tr></table></figure>

<p>其中最为关键的部分是日志记录规则，其配置格式如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务名称 连接符号 日志等级               日志记录位置</span></span><br><span class="line">authpriv.*                                              /var/log/secure</span><br></pre></td></tr></table></figure>
<p>以上配置，指定认证相关服务 (<code>authpriv</code>) 的所有等级的日志，记录在 <code>/var/log/secure</code> 日志中</p>
<p>多个服务可以指定同一个<code>日志记录位置</code>，多个 <code>服务名称 连接符号 日志等级</code> 中间使用 <code>;</code> 分割  </p>
<figure class="highlight shell"><figcaption><span>/etc/rsyslog.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">*.info;mail.none;authpriv.none;cron.none                /var/log/messages</span><br></pre></td></tr></table></figure>
<p>多个服务也可以共用同一个 <code>日志等级</code>，格式如下，多个 <code>服务名称</code> 使用 <code>,</code> 分割</p>
<figure class="highlight shell"><figcaption><span>/etc/rsyslog.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">uucp,news.crit                                          /var/log/spooler</span><br></pre></td></tr></table></figure>

<p><code>rsyslog</code> 服务可识别的服务如下</p>
<table>
<thead>
<tr>
<th>服务</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>auth</td>
<td>安全和认证相关消息 (不推荐使用 <code>authpriv</code> 替代）</td>
</tr>
<tr>
<td>authpirv</td>
<td>安全和认证相关信息（私有的）</td>
</tr>
<tr>
<td>cron</td>
<td>系统定时任务 <code>cront</code> 和 <code>at</code> 产生的日志</td>
</tr>
<tr>
<td>daemon</td>
<td>和各个守护进程相关的日志</td>
</tr>
<tr>
<td>ftp</td>
<td>ftp守护进程产生的日志</td>
</tr>
<tr>
<td>kern</td>
<td>内核产生的日志（不是用户进程产生的）</td>
</tr>
<tr>
<td>local0-local7</td>
<td>为本地使用预留的服务</td>
</tr>
<tr>
<td>lpr</td>
<td>打印机产生的日志</td>
</tr>
<tr>
<td>mail</td>
<td>邮件收发信息</td>
</tr>
<tr>
<td>news</td>
<td>与新闻服务器相关的日志</td>
</tr>
<tr>
<td>syslog</td>
<td>有 <code>rsyslog</code> 服务产生的日志信息（虽然服务名称已经改为 <code>rsyslog</code> 服务，但是很多配置都还是沿用了 <code>syslogd</code> 的，这里并没有修改服务名）</td>
</tr>
<tr>
<td>user</td>
<td>用户等级类别的日志信息</td>
</tr>
<tr>
<td>uucp</td>
<td><code>uucp</code> 子系统的日志信息，<code>uucp</code> 是早期 Linux 系统进行数据传递的协议，后来也经常用在新闻组服务中。</td>
</tr>
</tbody></table>
<p><code>rsyslog</code> 服务配置中可使用的连接符号如下</p>
<table>
<thead>
<tr>
<th>连接符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>.</code></td>
<td>代表只要比后面的等级高的（包含该等级）日志都记录下来。比如： <code>cron.info</code> 代表 <code>crond</code> 服务产生的日志，只要日志等级大于等于 <code>info</code> 级别，就记录。</td>
</tr>
<tr>
<td><code>.=</code></td>
<td>代表只记录所需等级的日志，其他等级的都不记录。比如： <code>*.=emerg</code> 代表任何日志服务产生的日志，只要等级是 <code>emerg</code> 等级就记录。</td>
</tr>
<tr>
<td><code>.!</code></td>
<td>代表不等于，也就是除了该等级的日志外，其他等级的日志都记录。</td>
</tr>
</tbody></table>
<p><code>rsyslog</code> 服务配置中可使用的日志等级如下</p>
<table>
<thead>
<tr>
<th>日志等级</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>debug</td>
<td>一般的调试信息说明</td>
</tr>
<tr>
<td>info</td>
<td>基本的通知信息</td>
</tr>
<tr>
<td>notice</td>
<td>普通信息，但是有一定的重要性</td>
</tr>
<tr>
<td>warning</td>
<td>警告信息，但是还不会影响到服务或系统的运行</td>
</tr>
<tr>
<td>err</td>
<td>错误信息，一般达到 <code>err</code> 等级的信息以及可以影响到服务或系统的运行了</td>
</tr>
<tr>
<td>crit</td>
<td>临界状况信息，比 <code>err</code> 等级还要严重</td>
</tr>
<tr>
<td>alert</td>
<td>警告状态信息，比 <code>crit</code> 还要严重。必须立即采取行动</td>
</tr>
<tr>
<td>emerg</td>
<td>致命（毁灭）等级信息，系统已经无法使用了</td>
</tr>
<tr>
<td>*</td>
<td>代表所有等级的日志</td>
</tr>
<tr>
<td>none</td>
<td>忽略这个日志服务，该服务的所有日志都不再记录</td>
</tr>
</tbody></table>
<p>可用的 <code>日志记录位置</code> 如下</p>
<table>
<thead>
<tr>
<th>日志记录位置</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>/var/log/secure</code></td>
<td>日志文件的绝对路径</td>
<td><code>/var/log/secure</code></td>
</tr>
<tr>
<td><code>/dev/lp0</code></td>
<td>系统设备文件</td>
<td>如 <code>/dev/lp0</code> 代表第一台打印机，如果日志保存位置是打印机设备，当有日志时就会在打印机上打印。</td>
</tr>
<tr>
<td>远程主机</td>
<td>可以选择使用 <code>TCP</code> (<code>@@192.168.0.210：514</code>) 和 <code>UDP</code> (<code>@192.168.0.210：514</code>) 协议传输日志信息</td>
<td></td>
</tr>
</tbody></table>
<p><code>日志记录位置</code> 之前可以加以下符号：</p>
<ul>
<li><code>-</code>  ： 表示延迟写入</li>
</ul>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3>]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>rsyslog</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 系统状态查看</title>
    <url>/202301171137/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos 7 kernel 5.4.221</li>
</ul>
<h1 id="查看内存信息"><a href="#查看内存信息" class="headerlink" title="查看内存信息"></a>查看内存信息</h1><p>内存相关概念说明：</p>
<ul>
<li>VSS ,Virtual Set Size , VERT - 虚拟耗用内存（包含共享库占用的内存）</li>
<li>RSS , Resident Set Size , RES- 实际使用物理内存（包含共享库占用的内存）</li>
<li>PSS , Proportional Set Size - 实际使用的物理内存（比例分配共享库占用的内存）</li>
<li>USS , Unique Set Size - 进程独自占用的物理内存（不包含共享库占用的内存）</li>
</ul>
<h2 id="查看某个进程使用的内存量"><a href="#查看某个进程使用的内存量" class="headerlink" title="查看某个进程使用的内存量"></a>查看某个进程使用的内存量</h2><p>比如检查 docker 使用的内存量，首先通过 <code>ps</code> 命令查询到 <code>docker</code> 的 pid 信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps -elf | grep docker</span></span><br><span class="line">4 S root      1243     1  4  80   0 - 1067527 futex_ Jan03 ?      15:14:45 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock</span><br></pre></td></tr></table></figure>
<p>例如此处的 <code>docker</code> 进程的 pid 为 1243</p>
<ul>
<li><p>使用 <code>top</code> 命令动态查看 <code>docker</code> 使用的内存信息</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">top -p 1243</span></span><br><span class="line">top - 11:47:40 up 14 days,  2:09,  3 users,  load average: 0.65, 1.42, 1.70</span><br><span class="line">Tasks:   1 total,   0 running,   1 sleeping,   0 stopped,   0 zombie</span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">Cpu(s):  1.0 us,  0.6 sy,  0.0 ni, 98.3 <span class="built_in">id</span>,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span></span><br><span class="line">KiB Mem : 32068748 total,  2494500 free, 18536188 used, 11038060 buff/cache</span><br><span class="line">KiB Swap:        0 total,        0 free,        0 used.  9586340 avail Mem </span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                           </span><br><span class="line"> 1243 root      20   0 4270108   1.4g  53956 S   1.0  4.6 914:55.80 dockerd</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>ps aux</code> 命令查看内存使用量</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps aux | grep 1243</span></span><br><span class="line">root      1243  4.5  4.6 4270108 1486460 ?     Ssl  Jan03 914:57 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock</span><br></pre></td></tr></table></figure>

<p>  输出结果中</p>
<ul>
<li>第 3、4 列 (<code>4.5  4.6</code>) 分别表示 <code>cpu 使用率</code>、<code>内存使用率</code>。</li>
<li>第 5、6 列 (<code>4270108 1486460</code>) 分别表示 <code>虚拟内存使用量</code>、<code>物理内存使用量</code>，单位为 <code>k</code>。</li>
</ul>
</li>
<li><p>通过进程的 <code>status</code> 文件查看内存使用</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /proc/1243/status</span></span><br><span class="line">Name:	dockerd</span><br><span class="line">Umask:	0022</span><br><span class="line">State:	S (sleeping)</span><br><span class="line">Pid:	1243</span><br><span class="line">PPid:	1</span><br><span class="line">VmPeak:	 4270364 kB</span><br><span class="line">VmSize:	 4270108 kB</span><br><span class="line">VmLck:	       0 kB</span><br><span class="line">VmPin:	       0 kB</span><br><span class="line">VmHWM:	 1562204 kB</span><br><span class="line">VmRSS:	 1492340 kB</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>其中，<code>VmRSS</code> 为进程使用的物理内存</p>
</li>
<li><p>使用 <code>pmap</code> 命令查看进程使用的内存信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pmap -x 1243</span><br><span class="line">pmap -p 1243</span><br></pre></td></tr></table></figure>
<span id="more"></span></li>
</ul>
<h2 id="内存使用量统计"><a href="#内存使用量统计" class="headerlink" title="内存使用量统计"></a>内存使用量统计</h2><p>查看使用内存排名前十的进程：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps aux | sort -k4,4nr | head -n 10</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux systemd-journald 服务说明</title>
    <url>/202211211437/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="systemd-journald-服务简介"><a href="#systemd-journald-服务简介" class="headerlink" title="systemd-journald 服务简介"></a>systemd-journald 服务简介</h1><p><code>systemd-journald</code> 服务是 <code>systemd init</code> 系统提供的收集系统日志的服务。它会根据从内核、用户进程、标准输入和系统服务错误收到的日志记录信息，维护结构化的索引日记，并以此方式来收集和储存日志记录数据。<code>systemd-journald</code> 服务默认处于启用状态。</p>
<p>默认情况下，日记在 <code>/run/log/journal/</code> 中储存日志数据。由于 <code>/run/</code> 目录具有易失本性，因此，在重引导时会丢失日志数据。要永久保存日志数据，<code>/var/log/journal/</code> 目录必须存在且具有正确的所有权和权限，如此，<code>systemd-journald</code> 服务便可在其中储存其数据。</p>
<p>要在终端中查看日志信息，可以使用命令 <code>journalctl</code></p>
<h1 id="systemd-journald-服务常用配置"><a href="#systemd-journald-服务常用配置" class="headerlink" title="systemd-journald 服务常用配置"></a>systemd-journald 服务常用配置</h1><h2 id="持久化日志存储"><a href="#持久化日志存储" class="headerlink" title="持久化日志存储"></a>持久化日志存储</h2><p>默认情况下，日志位于 <code>/run/log/journal/</code>，重启后日志会丢失，为了持久化日志，可按照以下 2 种方法之一配置</p>
<ul>
<li><p>方法 1</p>
<ol>
<li>以 <code>root</code> 身份打开 <code>/etc/systemd/journald.conf</code> 进行编辑 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/systemd/journald.conf</span><br></pre></td></tr></table></figure></li>
<li>将包含 <code>Storage=</code> 的行取消注释，并将它更改为 <code>Storage=persistent</code><figure class="highlight shell"><figcaption><span>/etc/systemd/journald.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">[Journal]</span><br><span class="line">Storage=persistent</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Compress=<span class="built_in">yes</span></span></span><br><span class="line">SystemMaxUse=50M</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure></li>
<li>重启动 <code>systemd-journald</code> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart systemd-journald</span><br></pre></td></tr></table></figure>
之后日志会持久化存储于 <code>/var/log/journal</code>。这些数据最多会占用 <code>/var/log/journal</code> 所在文件系统空间的 10%，要更改此限制，可以修改选项 <code>SystemMaxUse=50M</code></li>
</ol>
</li>
</ul>
<span id="more"></span>

<ul>
<li>方法 2<ol>
<li>创建目录 <code>/var/log/journal</code></li>
<li>重启日志服务 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemd-journald.service</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h1 id="journalctl-命令查看日志"><a href="#journalctl-命令查看日志" class="headerlink" title="journalctl 命令查看日志"></a>journalctl 命令查看日志</h1><p>不带任何选项时，<code>journalctl</code> 输出所有的日志。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">journalctl</span> </span><br><span class="line">-- Logs begin at Thu 2022-11-17 12:09:10 CST, end at Mon 2022-11-21 14:53:36 CST. --</span><br><span class="line">Nov 17 12:09:10 localhost systemd-journal[156]: Runtime journal is using 8.0M (max allowed 380.5M, trying to leave 570</span><br><span class="line">Nov 17 12:09:10 localhost kernel: Linux version 5.4.217-1.el7.elrepo.x86_64 (mockbuild@Build64R7) (gcc version 9.3.1 2</span><br><span class="line">Nov 17 12:09:10 localhost kernel: Command line: BOOT_IMAGE=/boot/vmlinuz-5.4.217-1.el7.elrepo.x86_64 root=UUID=44a6a61</span><br><span class="line">Nov 17 12:09:10 localhost kernel: x86/fpu: Supporting XSAVE feature 0x001: &#x27;x87 floating point registers&#x27;</span><br><span class="line">Nov 17 12:09:10 localhost kernel: x86/fpu: Supporting XSAVE feature 0x002: &#x27;SSE registers&#x27;</span><br><span class="line">Nov 17 12:09:10 localhost kernel: x86/fpu: Supporting XSAVE feature 0x004: &#x27;AVX registers&#x27;</span><br><span class="line">Nov 17 12:09:10 localhost kernel: x86/fpu: Supporting XSAVE feature 0x008: &#x27;MPX bounds registers&#x27;</span><br><span class="line">Nov 17 12:09:10 localhost kernel: x86/fpu: Supporting XSAVE feature 0x010: &#x27;MPX CSR&#x27;</span><br><span class="line">Nov 17 12:09:10 localhost kernel: x86/fpu: Supporting XSAVE feature 0x020: &#x27;AVX-512 opmask&#x27;</span><br><span class="line">Nov 17 12:09:10 localhost kernel: x86/fpu: Supporting XSAVE feature 0x040: &#x27;AVX-512 Hi256&#x27;</span><br><span class="line">Nov 17 12:09:10 localhost kernel: x86/fpu: Supporting XSAVE feature 0x080: &#x27;AVX-512 ZMM_Hi256&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>日常使用中，需要配合各种匹配策略类匹配具体的日志。我们可以通过 <code>FIELD=VALUE</code> 的格式来匹配具体的日志记录，通过 <code>man 7 systemd.journal-fields</code> 可以查看所有可用的 <code>match</code> 字段</p>
<h2 id="日志匹配"><a href="#日志匹配" class="headerlink" title="日志匹配"></a>日志匹配</h2><p>通过字段 <code>_SYSTEMD_UNIT=cron.service</code> 可以查看服务 <code>cron.service</code> 的日志，等同于选项 <code>-u cron.service</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">journalctl -u crond</span><br><span class="line">journalctl _SYSTEMD_UNIT=crond.service</span><br></pre></td></tr></table></figure>

<p>可以同时添加多个字段进行匹配，它们之间是与的关系，就是同时符合多个条件的记录才会被匹配，比如添加 <code>PRIORITY</code> 字段的匹配条件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">journalctl _SYSTEMD_UNIT=crond.service PRIORITY=6</span><br></pre></td></tr></table></figure>
<p>注意各个字段的取值，比如为 <code>PRIORITY</code> 设置 <code>debug</code>、<code>info</code> 是不工作的，必须设置为对应的数字。可以通过 <code>-F</code> 选项来查看某个字段的可选值：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">journalctl -F PRIORITY</span></span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对同一个字段使用多个字段匹配时，相当于 <strong>或</strong> 的关系，匹配的字段都会输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">journalctl _SYSTEMD_UNIT=cron.service _SYSTEMD_UNIT=prometheus.service</span><br></pre></td></tr></table></figure>
<p>此时 <code>cron.service</code> 和 <code>prometheus.service</code> 的日志都会输出。</p>
<p>使用 <code>+</code> 号可以对多个匹配字段执行 <strong>或</strong> 操作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">journalctl _SYSTEMD_UNIT=cron.service + _PID=28097</span><br></pre></td></tr></table></figure>
<p>上面的命令会输出 cron.service 的日志和进程 28097 的日志。</p>
<p>下面是一个更复杂的例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">journalctl _SYSTEMD_UNIT=avahi-daemon.service _PID=28097 + _SYSTEMD_UNIT=dbus.service</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>前面的两个条件是 <strong>与</strong> 的关系，最后一个条件与前面的两个条件是 <strong>或</strong> 的关系，也就是相当于用小括号把前面的两个条件括起来。</p>
<h2 id="查看指定时间段的日志"><a href="#查看指定时间段的日志" class="headerlink" title="查看指定时间段的日志"></a>查看指定时间段的日志</h2><p>利用 <code>--since</code> 与 <code>--until</code> 选项设定时间段，二者分别负责指定给定时间之后与之前的日志记录，时间格式可以使用多种，如：<code>YYYY-MM-DD HH:MM:SS</code>，格式中的某些组成部分未进行填写，系统会直接进行默认填充。例如，如果日期部分未填写，则会直接显示当前日期。如果时间部分未填写，则缺省使用 <code>00:00:00</code>(午夜)。秒字段亦可留空，默认值为 “00”</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">journalctl _SYSTEMD_UNIT=cron.service --since &quot;2018-03-27&quot; --until &quot;2018-03-27 01:00&quot;</span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.cnblogs.com/sparkdev/p/8795141.html">linux journalctl 命令 </a></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux tcp_wrappers 详解</title>
    <url>/202208171106/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Centos 7</li>
</ul>
<p><code>TCP_wrappers</code> 主要是工作在应用层的一个安全工具，使用访问控制列表（<code>ACL</code>）来防止主机名和主机地址的欺骗，用于过滤对 <code>类 Unix</code> 系统的网络访问。  </p>
<p>在一个安全的系统中，<code>Linux</code> 自身具有两层安全的防火墙。第一层是通过 IP&#x2F;Port 过滤机制的 <code>iptables</code> 来实现，第二层，也就是 <code>TCP_wrappers</code> 了，它主要是通过对系统中的某些服务进行开放与关闭，允许和禁止来有效保证系统安全运行。<br>可以简单理解为 <code>Linux</code> 系统访问控制的流程：  </p>
<blockquote>
<p>Client -&gt; iptables -&gt; TCP_wrappers -&gt; Server 的访问控制</p>
</blockquote>
<ul>
<li>iptables ：基于源 IP&#x2F;端口、目的 IP&#x2F;端口进行访问控制</li>
<li>TCP_wrappers：基于服务自身运行情况进行访问控制</li>
<li>Server：基于服务器本身行为包括文件、目录等权限进行访问控制</li>
</ul>
<span id="more"></span>

<h3 id="TCP-wrappers-的工作原理"><a href="#TCP-wrappers-的工作原理" class="headerlink" title="TCP_wrappers 的工作原理"></a>TCP_wrappers 的工作原理</h3><p><code>TCP_wrappers</code> 通过访问控制列表来提供保护机制，同时依赖 <code>/etc/hosts.allow</code> 和 <code>/etc/hosts.deny</code> 配置文件所设定的规则转交给相应的守护进程进行处理，同时记录请求过程。</p>
<p><code>TCP_wrappers</code> 在对报文做过滤操作的过程中，会链接到 <code>TCP_wrappers</code> 的函数库， <code>TCP_wrappers</code> 的主要功能是来自于 <code>libwrap.a</code> 这个静态库。</p>
<p>服务是否可以使用 <code>TCP_wrappers</code> 进行安全防护，取决于服务程序在编译时是否针对 <code>libwrap</code> 进行编译，如果库文件中有 <code>libwrap.so</code> 文件，就可以实现访问控制</p>
<p>可以通过下面的命令来确定要过滤的服务是否已经链接到了 <code>libwrap</code> 这个函数库中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ldd /usr/sbin/sshd | grep libwrap</span></span><br><span class="line">	libwrap.so.0 =&gt; /lib64/libwrap.so.0 (0x00007f283cdf1000)</span><br></pre></td></tr></table></figure>

<p>当客户端的 IP 通过了安全系统中第一层（iptables 防火墙），想要进一步访问服务器资源时，系统就会由 <code>TCP_wrappers</code> 来对请求进行分析处理，根据服务设定的规则来查看这个请求是否存在于 <code>/etc/hosts.allow</code> 列表中，如果存在就接受；如果不存在就继续对比 <code>/etc/hosts/deny</code> 列表，如果存在于 <code>hosts.deny</code> 中就拒绝 IP 请求，反之则接受请求。  </p>
<p><strong>判断规则的文件顺序必须严格按照先 <code>hosts.allow</code> 再 <code>hosts.deny</code> 的顺序进行判断。同时，<code>TCP_wrappers</code> 不会缓存 <code>hosts.allow</code> 和 <code>hosts.deny</code> 中的规则，所以针对 <code>hosts.allow</code> 和 <code>hosts.deny</code> 中规则的更改是立即生效的。</strong></p>
<h3 id="TCP-wrappers-的配置"><a href="#TCP-wrappers-的配置" class="headerlink" title="TCP_wrappers 的配置"></a>TCP_wrappers 的配置</h3><p><code>TCP_wrappers</code> 实现防火墙的功能主要是依靠 <code>/etc/hosts.allow</code> 和 <code>/etc/hosts.deny</code> 这两个文件的。<code>/etc/hosts.allow</code> 主要是定义允许访问，<code>/etc/hosts.deny</code> 用来定义拒绝访问。  </p>
<p>配置文件中的配置格式如下，格式说明可以参考 <code>man 5 hosts_options</code></p>
<figure class="highlight shell"><figcaption><span>/etc/hosts.allow</span></figcaption><table><tr><td class="code"><pre><span class="line">daemon_list[@host] : client_list : option : option ...</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>daemon_list</code> ： 服务名，例如：sshd、vsftpd、sendmail 等，多个服务之间使用逗号分割。</li>
<li><code>client_list</code> : IP 或 IP 段或主机名。（列表中存在多个服务或者主机的时候用 , 逗号分隔开）</li>
<li><code>option</code> : 包括对匹配规则的 <code>action</code>， 最主要的有 <code>allow</code> 或 <code>deny</code>（这个可以忽略不写）</li>
</ul>
<p>例如，配置限制 <code>192.168.0.0/16</code> 网段不能 <code>ssh</code> 到本机的 <code>sshd</code> 服务</p>
<figure class="highlight shell"><figcaption><span>/etc/hosts.deny</span></figcaption><table><tr><td class="code"><pre><span class="line">sshd:192.168.</span><br></pre></td></tr></table></figure>
<p>如上配置后，指定网段不能 <code>ssh</code> 到本机  </p>
<p>配置后有问题，可以查看日志文件 <code>/var/log/secure</code>，如配置有问题，日志中会记录相关日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /var/log/secure</span></span><br><span class="line">sshd[7699]: error: /etc/hosts.allow, line 12: bad option name: &quot;%d&quot;&quot;</span><br></pre></td></tr></table></figure>

<h4 id="配置文件中-daemon-list-常用格式"><a href="#配置文件中-daemon-list-常用格式" class="headerlink" title="配置文件中 daemon_list 常用格式"></a>配置文件中 daemon_list 常用格式</h4><table>
<thead>
<tr>
<th>格式</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>ALL</code></td>
<td>完全匹配，适配所有接受 <code>TCP_wrappers</code> 防护的服务</td>
<td></td>
</tr>
<tr>
<td><code>service1</code><br/><code>service1,service2</code><br/><code>service1@172.16.1.2</code></td>
<td>指定服务<br/>多个服务使用逗号分割<br/>针对本机的某个 ip 做限制</td>
<td><code>sshd,vsftpd:192.168.1.:allow</code></td>
</tr>
</tbody></table>
<h4 id="配置文件中-client-list-常用格式"><a href="#配置文件中-client-list-常用格式" class="headerlink" title="配置文件中 client_list 常用格式"></a>配置文件中 client_list 常用格式</h4><table>
<thead>
<tr>
<th>格式</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>ALL</code></td>
<td>完全匹配，适配所有客户端</td>
<td></td>
</tr>
<tr>
<td><code>.HOSTNAME</code></td>
<td>适配整个域</td>
<td><code>sshd:.csms.tech:allow</code>，允许 <a href="https://csms.tech/"><code>csms.tech</code></a> 内的所有主机访问</td>
</tr>
<tr>
<td><code>192.168.</code><br/><code>192.168.0.0/255.255.0.0</code><br/><code>192.168.0.0/16</code></td>
<td>适配整个网段，会匹配到 <code>192.168.0.0/16</code> 网段</td>
<td></td>
</tr>
<tr>
<td><code>172.16. EXCEPT 172.16.100.0/24</code></td>
<td>排除部分客户端</td>
<td><code>172.16. EXCEPT 172.16.100.0/24 EXCEPT 172.16.10.1</code></td>
</tr>
</tbody></table>
<h4 id="配置文件中-option-常用格式"><a href="#配置文件中-option-常用格式" class="headerlink" title="配置文件中 option 常用格式"></a>配置文件中 option 常用格式</h4><table>
<thead>
<tr>
<th>格式</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>allow</code></td>
<td>主要用在 <code>/etc/hosts.deny</code> 定义 <code>允许</code> 规则</td>
<td></td>
</tr>
<tr>
<td><code>deny</code></td>
<td>主要用在 <code>/etc/hosts.allow</code> 定义 <code>拒绝</code> 规则</td>
<td></td>
</tr>
<tr>
<td><code>spawn</code></td>
<td>启动一个外部程序(<code>shell</code>)完成指定的命令</td>
<td></td>
</tr>
<tr>
<td><code>twist</code></td>
<td>替换客户端的请求成我们指定的命令，会导致服务拒绝，即使写在 <code>/etc/hosts.allow</code></td>
<td></td>
</tr>
</tbody></table>
<h5 id="spawn-示例"><a href="#spawn-示例" class="headerlink" title="spawn 示例"></a>spawn 示例</h5><p>在 <code>/etc/hosts.allow</code> 中添加以下内容</p>
<figure class="highlight shell"><figcaption><span>/etc/hosts.allow</span></figcaption><table><tr><td class="code"><pre><span class="line">sshd: ALL :\</span><br><span class="line">         spawn echo $(date +%%F) login attempt from %c to %s,%d &gt;&gt;/var/log/sshd.log</span><br></pre></td></tr></table></figure>
<p>以上配置，会在客户端 ssh 登录时记录日志  </p>
<p>其中，可以变量包含以下</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>%a</code></td>
<td>客户端的 IP 地址</td>
</tr>
<tr>
<td><code>%A</code></td>
<td>服务端的 IP 地址</td>
</tr>
<tr>
<td><code>%d	</code></td>
<td>守护进程的名字</td>
</tr>
<tr>
<td><code>%h</code></td>
<td>客户端的主机名</td>
</tr>
<tr>
<td><code>%H</code></td>
<td>服务端的主机名</td>
</tr>
<tr>
<td><code>%p</code></td>
<td>守护进程的 pid</td>
</tr>
<tr>
<td><code>%u</code></td>
<td>客户端的用户名</td>
</tr>
</tbody></table>
<h5 id="twist-示例"><a href="#twist-示例" class="headerlink" title="twist 示例"></a>twist 示例</h5><p>在 <code>/etc/hosts.allow</code> 中添加以下内容</p>
<figure class="highlight shell"><figcaption><span>/etc/hosts.allow</span></figcaption><table><tr><td class="code"><pre><span class="line">vsftpd: 172.16.0.1 :twist /bin/echo “connection prohibited”</span><br></pre></td></tr></table></figure>

<p>以上配置会将客户端的请求替换成 <code>twist</code> 指定的命令，因此客户端无法使用指定的服务，即使配置在 <code>/etc/hosts.allow</code> 中</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://m-zhoujie2.gitbooks.io/-linux-devops-2/content/chapter3-5.html">TCP wrappers</a></p>
<p><a href="https://www.cnblogs.com/duzhaoqi/p/7607801.html">TCP_Wrappers</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>tcp_wrappers</tag>
      </tags>
  </entry>
  <entry>
    <title>tcpdump 抓包命令使用</title>
    <url>/202210241503/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="tcpdump-命令格式说明"><a href="#tcpdump-命令格式说明" class="headerlink" title="tcpdump 命令格式说明"></a>tcpdump 命令格式说明</h1><p><img src="https://i.csms.tech/img_67.png"></p>
<ul>
<li><code>option</code> - <a href="#%E5%B8%B8%E7%94%A8%E9%80%89%E9%A1%B9">可选选项（参数）</a> </li>
<li><code>proto</code> - 协议类过滤器：根据协议进行过滤，可识别的关键词有： <code>tcp</code>, <code>udp</code>, <code>icmp</code>, <code>ip</code>, <code>ip6</code>, <code>arp</code>, <code>rarp</code>,<code>ether</code>,<code>wlan</code>, <code>fddi</code>, <code>tr</code>, <code>decnet</code></li>
<li><code>direction</code> - 数据流向类过滤器：根据数据流向进行过滤，可识别的关键字有：<code>src</code>, <code>dst</code>，同时你可以使用逻辑运算符进行组合，比如 <code>src or dst</code></li>
<li><code>type</code> 类过滤器：可识别的关键词有：<code>host</code>, <code>net</code>, <code>port</code>, <code>portrange</code>，这些词后边需要再接参数。</li>
</ul>
<h2 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h2><table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>-i</code></td>
<td>目标网卡</td>
<td></td>
</tr>
<tr>
<td><code>-n</code> <br/><code>-nn</code></td>
<td>不对 IP&#x2F;DOMAIN 进行解析<br/> 不对 IP&#x2F;DOMAIN 及 PORT 进行解析</td>
<td></td>
</tr>
<tr>
<td><code>-w</code></td>
<td>将结果写入文件</td>
<td><code>tcpdump icmp -w icmp.pcap</code></td>
</tr>
</tbody></table>
<span id="more"></span>

<h1 id="tcpdump-命令输出内容说明"><a href="#tcpdump-命令输出内容说明" class="headerlink" title="tcpdump 命令输出内容说明"></a>tcpdump 命令输出内容说明</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">21:26:49.013621 IP 172.20.20.1.15605 &gt; 172.20.20.2.5920: Flags [P.], seq 49:97, ack 106048, win 4723, length 48</span><br></pre></td></tr></table></figure>
<ol>
<li>第一列：时分秒毫秒 21:26:49.013621</li>
<li>第二列：网络协议 IP</li>
<li>第三列：发送方的 ip 地址+端口号，其中 172.20.20.1 是 ip，而 15605 是端口号</li>
<li>第四列：箭头 &gt;， 表示数据流向</li>
<li>第五列：接收方的 ip 地址+端口号，其中 172.20.20.2 是 ip，而 5920 是端口号</li>
<li>第六列：冒号</li>
<li>第七列：数据包内容，包括 Flags 标识符，seq 号，ack 号，win 窗口，数据长度 length，其中 [P.] 表示 PUSH 标志位为 1，更多标识符见下面</li>
</ol>
<h2 id="Flags-标识符"><a href="#Flags-标识符" class="headerlink" title="Flags 标识符"></a>Flags 标识符</h2><p>使用 <code>tcpdump</code> 抓包后，会遇到的 TCP 报文 Flags，有以下几种：</p>
<ul>
<li>[S] : <code>SYN</code>（开始连接）</li>
<li>[P] : <code>PSH</code>（推送数据）</li>
<li>[F] : <code>FIN</code> （结束连接）</li>
<li>[R] : <code>RST</code>（重置连接）</li>
<li>[.] : 没有 Flag （意思是除上面四种类型外的其他情况，有可能是 <code>ACK</code> 也有可能是 <code>URG</code>）</li>
</ul>
<h1 id="常见用法示例"><a href="#常见用法示例" class="headerlink" title="常见用法示例"></a>常见用法示例</h1><h2 id="基于IP地址过滤：host"><a href="#基于IP地址过滤：host" class="headerlink" title="基于IP地址过滤：host"></a>基于IP地址过滤：host</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tcpdump host 192.168.10.100</span><br><span class="line"></span><br><span class="line">tcpdump -i eth0 src 192.168.10.100</span><br><span class="line"></span><br><span class="line">tcpdump -i eth0 dst 192.168.10.100</span><br></pre></td></tr></table></figure>

<h2 id="基于网段进行过滤：net"><a href="#基于网段进行过滤：net" class="headerlink" title="基于网段进行过滤：net"></a>基于网段进行过滤：net</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tcpdump net 192.168.10.0/24</span><br><span class="line"></span><br><span class="line">tcpdump src net 192.168</span><br><span class="line"></span><br><span class="line">tcpdump dst net 192.168</span><br></pre></td></tr></table></figure>

<h2 id="基于端口进行过滤：port"><a href="#基于端口进行过滤：port" class="headerlink" title="基于端口进行过滤：port"></a>基于端口进行过滤：port</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tcpdump src port 8088</span><br><span class="line"></span><br><span class="line">tcpdump dst port 8088</span><br><span class="line"></span><br><span class="line">tcpdump port 80 or port 8088</span><br><span class="line"></span><br><span class="line">tcpdump port 80 or 8088</span><br><span class="line"></span><br><span class="line">tcpdump portrange 8000-8080</span><br><span class="line"></span><br><span class="line">tcpdump src portrange 8000-8080</span><br><span class="line"></span><br><span class="line">tcpdump dst portrange 8000-8080</span><br></pre></td></tr></table></figure>

<h2 id="基于协议进行过滤：proto"><a href="#基于协议进行过滤：proto" class="headerlink" title="基于协议进行过滤：proto"></a>基于协议进行过滤：proto</h2><p>常见的网络协议有：tcp, udp, icmp, http, ip,ipv6 等</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tcpdump icmp</span><br></pre></td></tr></table></figure>
<p>protocol 可选值：ip, ip6, arp, rarp, atalk, aarp, decnet, sca, lat, mopdl, moprc, iso, stp, ipx, or netbeui</p>
<h2 id="组合过滤规则"><a href="#组合过滤规则" class="headerlink" title="组合过滤规则"></a>组合过滤规则</h2><p>支持的运算符：</p>
<ul>
<li><code>and</code> - 所有的条件都需要满足，也可以表示为 <code>&amp;&amp;</code></li>
<li><code>or</code> - 只要有一个条件满足就可以，也可以表示为 <code>||</code></li>
<li><code>not</code> - 取反，也可以使用 <code>!</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tcpdump src 10.5.2.3 and dst port 3389</span><br><span class="line"></span><br><span class="line">tcpdump &#x27;src 10.0.2.4 and (dst port 3389 or 22)&#x27;</span><br></pre></td></tr></table></figure>


<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.cnblogs.com/wongbingming/p/13212306.html">tcpdump 抓包指南</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>tcpdump</tag>
      </tags>
  </entry>
  <entry>
    <title>LVM 逻辑卷管理</title>
    <url>/202208021256/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>LVM是 Logical Volume Manager(逻辑卷管理)的简写,LVM将一个或多个硬盘或分区在逻辑上集合，相当于一个大硬盘来使用，当硬盘的空间不够使用的时候，可以继续将其它的硬盘或分区加入其中，这样可以实现磁盘空间的动态管理，相对于普通的磁盘分区有很大的灵活性。与传统的磁盘与分区相比，LVM为计算机提供了更高层次的磁盘存储。它使系统管理员可以更方便的为应用与用户分配存储空间。  </p>
<blockquote>
<p><strong><code>/boot</code> 分区不可以在逻辑卷组上,否则bootloader会无法读取.</strong></p>
</blockquote>
<span id="more"></span>

<h3 id="LVM-原理简介"><a href="#LVM-原理简介" class="headerlink" title="LVM 原理简介"></a>LVM 原理简介</h3><p>单一硬盘系统的 LVM 基本原理如下图所示<br><img src="https://i.csms.tech/img_23.png"></p>
<p>多硬盘系统的 LVM 基本原理如下图所示<br><img src="https://i.csms.tech/img_24.png"><br><img src="https://i.csms.tech/img_25.png"></p>
<h4 id="基本概念说明"><a href="#基本概念说明" class="headerlink" title="基本概念说明"></a>基本概念说明</h4><h5 id="PV（Physical-Volume）-物理卷"><a href="#PV（Physical-Volume）-物理卷" class="headerlink" title="PV（Physical Volume）- 物理卷"></a>PV（Physical Volume）- 物理卷</h5><p>物理卷在逻辑卷管理中处于最底层，它可以是实际物理硬盘上的分区，也可以是整个物理硬盘，也可以是raid设备,是LVM的基本存储逻辑块，但和基本的物理存储介质(如分区、磁盘等)比较，却包含有与LVM相关的管理参数。  </p>
<p>PE（physical extent）：每一个物理卷被划分为称为PE(Physical Extents)的基本单元，具有唯一编号的PE是可以被LVM寻址的最小单元。PE的大小是在VG过程中配置的，默认为4MB。</p>
<h5 id="VG（Volumne-Group）-卷组"><a href="#VG（Volumne-Group）-卷组" class="headerlink" title="VG（Volumne Group）- 卷组"></a>VG（Volumne Group）- 卷组</h5><p>卷组建立在物理卷之上，一个卷组中至少要包括一个物理卷，在卷组建立之后可动态添加物理卷到卷组中。一个逻辑卷管理系统工程中可以只有一个卷组，也可以拥有多个卷组。  </p>
<h5 id="LV（Logical-Volume）-逻辑卷"><a href="#LV（Logical-Volume）-逻辑卷" class="headerlink" title="LV（Logical Volume）- 逻辑卷"></a>LV（Logical Volume）- 逻辑卷</h5><p>逻辑卷建立在卷组之上，卷组中的未分配空间可以用于建立新的逻辑卷，逻辑卷建立后可以动态地扩展和缩小空间。系统中的多个逻辑卷可以属于同一个卷组，也可以属于不同的多个卷组。</p>
<h3 id="LVM-基本操作"><a href="#LVM-基本操作" class="headerlink" title="LVM 基本操作"></a>LVM 基本操作</h3><h4 id="创建-PV-常用操作命令"><a href="#创建-PV-常用操作命令" class="headerlink" title="创建 PV 常用操作命令"></a>创建 PV 常用操作命令</h4><p>将空闲分区 <code>/dev/vdb1</code> 配置为可用的 PV（Physical Volume）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pvcreate /dev/vdb1</span><br></pre></td></tr></table></figure>
<p>将空闲磁盘 <code>/dev/vdd</code> 配置为可用的 PV（Physical Volume）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pvcreate /dev/vdd </span><br></pre></td></tr></table></figure>
<p>查看 PV 的信息，常用以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pvs</span><br><span class="line">pvscan</span><br><span class="line">pvdisplay</span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_26.png"><br><img src="https://i.csms.tech/img_27.png"></p>
<h4 id="创建-VG-常用操作命令"><a href="#创建-VG-常用操作命令" class="headerlink" title="创建 VG 常用操作命令"></a>创建 VG 常用操作命令</h4><p>使用已有的PV ，创建卷组（Volumne Group）名为 <code>VG1</code> 的 VG</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vgcreate VG1 /dev/vdb1 /dev/vdd</span><br></pre></td></tr></table></figure>

<p>查看 VG 的信息，常用以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vgs</span><br><span class="line">vgscan</span><br><span class="line">vgdisplay</span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_28.png"><br><img src="https://i.csms.tech/img_29.png"></p>
<h4 id="创建-LV-常用操作命令"><a href="#创建-LV-常用操作命令" class="headerlink" title="创建 LV 常用操作命令"></a>创建 LV 常用操作命令</h4><p>使用已有的卷组 VG1 ，创建逻辑卷（Logical Volume）名为 <code>data</code> 的 LV，并配置 <code>data</code> 逻辑卷的大小为1000m</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lvcreate -L 1000M -n data VG1</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>-L|--size</code>  指定逻辑卷的大小</p>
</blockquote>
<p>查看 LV 的信息，常用以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lvs</span><br><span class="line">lvscan</span><br><span class="line">lvdisplay</span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_30.png"><br><img src="https://i.csms.tech/img_31.png"></p>
<blockquote>
<p><strong>逻辑卷无法直接使用，必须格式化挂载之后才能使用</strong><br>逻辑卷的引用需要逻辑卷的设备文件, 逻辑卷的设备文件有两种书写形式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/dev/vg_name/lv_name</span><br><span class="line">/dev/mapper/vg_name-lv_name</span><br></pre></td></tr></table></figure>
<p>格式化 LV 并挂载，正确的挂载后，可正常使用新加的磁盘空间</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkfs.xfs /dev/VG1/data</span><br><span class="line">mount /dev/VG1/data /data</span><br></pre></td></tr></table></figure>
<p>为了防止系统重启后挂载失效，需要将挂载信息写入配置文件 <code>/etc/fstab</code></p>
<figure class="highlight shell"><figcaption><span>/etc/fstab</span></figcaption><table><tr><td class="code"><pre><span class="line">/dev/VG1/data /data xfs defaults 0 0</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="LVM-扩容操作"><a href="#LVM-扩容操作" class="headerlink" title="LVM 扩容操作"></a>LVM 扩容操作</h4><h5 id="VG-扩容"><a href="#VG-扩容" class="headerlink" title="VG 扩容"></a>VG 扩容</h5><p>使用已有的 PV ，或者 <a href="#%E5%88%9B%E5%BB%BA-PV-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4">新建 PV</a> 来扩容已有的 VG, 假设用来扩容的 PV 为 <code>/dev/vde</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vgextend VG1 /dev/vde</span><br></pre></td></tr></table></figure>

<h5 id="LV-扩容"><a href="#LV-扩容" class="headerlink" title="LV 扩容"></a>LV 扩容</h5><p>使用 VG 的空闲空间扩容 LV<br>指定要扩容的大小</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lvextend -L +100m /dev/VG1/data</span><br></pre></td></tr></table></figure>
<p>或者直接通过指定 PV 扩容 LV， 整个 PV 的空间被扩容到 LV， 前提是 PV 已被扩容到了 VG</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lvextend /dev/VG1/data /dev/vde</span><br></pre></td></tr></table></figure>
<p>其他扩容方式可查看命令帮助 <code>lvextend -h</code>  </p>
<p>扩容 LV 后需要重新调整分区文件系统大小</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">resize2fs /dev/VG1/data</span><br></pre></td></tr></table></figure>
<p><code>xfs</code> 文件系统需要使用以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xfs_growfs /dev/VG1/data</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>LVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql 常见错误</title>
    <url>/22072111/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息说明"><a href="#环境信息说明" class="headerlink" title="环境信息说明"></a>环境信息说明</h3><ul>
<li>默认mysql版本5.7</li>
<li>Centos 7</li>
</ul>
<span id="more"></span>

<h3 id="错误集锦"><a href="#错误集锦" class="headerlink" title="错误集锦"></a>错误集锦</h3><h4 id="MySQL主从不同步，尝试跳过执行错误的事务"><a href="#MySQL主从不同步，尝试跳过执行错误的事务" class="headerlink" title="MySQL主从不同步，尝试跳过执行错误的事务"></a>MySQL主从不同步，尝试跳过执行错误的事务</h4><p>执行以下命令，可跳过对应的slave事务</p>
<figure class="highlight shell"><figcaption><span>slave</span></figcaption><table><tr><td class="code"><pre><span class="line">stop slave;</span><br><span class="line">SET GLOBAL SQL_SLAVE_SKIP_COUNTER = 1;</span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure>
<p>可以通过分析主库日志中的事务，来确定 <code>SQL_SLAVE_SKIP_COUNTER</code> 的合适值。<br>具体步骤如下：<br>在slave库中执行 <code>show slave status\G</code> ，确认以下两个参数:<br>    - Relay_Master_Log_File<br>    - Exec_Master_Log_Pos<br>或者以下2个参数：<br>    - Master_Log_File<br>    - Read_Master_Log_Pos<br><img src="https://i.csms.tech/img_11.png"></p>
<blockquote>
<p>通过以上2个值，可以知道当前slave执行到了master对应的哪个binlog文件(Relay_Master_Log_File)以及文件中的对应位置(Exec_Master_Log_Pos )</p>
</blockquote>
<p>根据上述两个参数的值，在master中可以查看当前阻碍从库复制的事务以及之后的事务。可以执行以下命令查看</p>
<figure class="highlight shell"><figcaption><span>master</span></figcaption><table><tr><td class="code"><pre><span class="line">SHOW BINLOG EVENTS in &#x27;mysql-bin.001015&#x27; from 366269088;</span><br></pre></td></tr></table></figure>
<p>这个可以查看到对应日志文件mysql-bin.001015中，事务ID为366269088之后的所有事务，<br>以下命令可以限制查询条数</p>
<figure class="highlight shell"><figcaption><span>master</span></figcaption><table><tr><td class="code"><pre><span class="line">SHOW BINLOG EVENTS in &#x27;mysql-bin.001015&#x27; from 366269088 limit 10;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="主从具有相同的server-uuid"><a href="#主从具有相同的server-uuid" class="headerlink" title="主从具有相同的server-uuid"></a>主从具有相同的server-uuid</h4><p><strong>报错信息</strong>：</p>
<blockquote>
<p>Fatal error: The slave I&#x2F;O thread stops because master and slave have equal MySQL server UUIDs; these UUIDs must be different for replication to work</p>
</blockquote>
<p><strong>问题原因</strong>： 主从数据目录(默认<code>/var/lib/mysql/</code>)都有一个auto.cnf文件，里面记录的server-uuid是相同的，在云主机clone的场景可能会出现此问题。</p>
<p><strong>解决方法</strong>： 修改auto.cnf文件中<code>uuid</code>的值，重启Mysql服务即可</p>
<p>查询uuid的方式，登录mysql，执行以下命令查看</p>
<figure class="highlight shell"><figcaption><span>mysql</span></figcaption><table><tr><td class="code"><pre><span class="line">select uuid();</span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_12.png"></p>
<hr>
<h4 id="主从具有相同的server-id"><a href="#主从具有相同的server-id" class="headerlink" title="主从具有相同的server-id"></a>主从具有相同的server-id</h4><p><strong>报错信息</strong>：</p>
<blockquote>
<p>Fatal error: The slave I&#x2F;O thread stops because master and slave have equal MySQL server ids; </p>
</blockquote>
<p><strong>问题原因</strong>： 主从配置文件中配置了同样的 <code>server-id</code></p>
<p><strong>解决方法</strong>： 修改<code>my.cnf</code>， 主从配置不同的<code>server-id</code></p>
<hr>
<h4 id="主从同步错误-1032"><a href="#主从同步错误-1032" class="headerlink" title="主从同步错误 1032"></a>主从同步错误 1032</h4><p><strong>报错信息</strong>：</p>
<blockquote>
<p>Could not execute Update_rows event on table ceshi.bbs_online; Can’t find record in ‘bbs_online’, Error_code: 1032; handler error HA_ERR_KEY_NOT_FOUND; the event’s master log mysql-bin.001423, end_log_pos 866646715</p>
</blockquote>
<p><strong>问题原因</strong>： 主从不同步，从数据库中记录被删除或者未同步到从库，主数据库中存在记录，主DB更新后，从无法同步</p>
<p><strong>解决方法1</strong>： 重新备份 master DB，恢复到slave，重新<a href="/94ee2c23/" title="恢复主从">恢复主从</a></p>
<p><strong>解决方法2</strong>： 找出丢失的数据在slave上插入。可以通过<a href="#MySQL%E4%B8%BB%E4%BB%8E%E4%B8%8D%E5%90%8C%E6%AD%A5%EF%BC%8C%E5%B0%9D%E8%AF%95%E8%B7%B3%E8%BF%87%E6%89%A7%E8%A1%8C%E9%94%99%E8%AF%AF%E7%9A%84%E4%BA%8B%E5%8A%A1">分析出错的binlog找出丢失的记录</a></p>
<hr>
<h4 id="主从同步错误-1396"><a href="#主从同步错误-1396" class="headerlink" title="主从同步错误 1396"></a>主从同步错误 1396</h4><p><strong>报错信息</strong>：</p>
<blockquote>
<p>ERROR 1396 (HY000): Operation CREATE USER failed for ‘XXXX‘@’XXXX’</p>
</blockquote>
<p><strong>问题原因</strong>： slave同步时，从数据库中已存在用户</p>
<p><strong>解决方法</strong>： slave上删除已存在的用户</p>
<hr>
<h4 id="主从同步错误-1062"><a href="#主从同步错误-1062" class="headerlink" title="主从同步错误 1062"></a>主从同步错误 1062</h4><p><strong>报错信息</strong>：</p>
<blockquote>
<p>Last_SQL_Error: Could not execute Write_rows event on table *;<br>    Duplicate entry ‘2’ for key ‘PRIMARY’,<br>Error_code: 1062;<br>handler error HA_ERR_FOUND_DUPP_KEY; the event’s master log mysql-bin.000006, end_log_pos 924</p>
</blockquote>
<p><strong>问题原因</strong>： slave上已有该记录，master上又插入，可能存在主从数据不一致</p>
<p><strong>解决方法</strong>： 删除slave上重复的主键记录</p>
<hr>
<h4 id="主从同步错误-1042"><a href="#主从同步错误-1042" class="headerlink" title="主从同步错误 1042"></a>主从同步错误 1042</h4><p><strong>报错信息</strong>：</p>
<blockquote>
<p>error code 1042 (ER_BAD_HOST_ERROR): Can’t get hostname for your address</p>
</blockquote>
<p><strong>问题原因</strong>： 解析主机名失败</p>
<p><strong>解决方法</strong>： mysql配置（<code>my.cnf</code>）中设置 <code>skip-name-resolve</code></p>
<p>使用以下命令解析mysql错误码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">perror 1042</span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_13.png"></p>
<hr>
<h4 id="导出导入数据错误-1290"><a href="#导出导入数据错误-1290" class="headerlink" title="导出导入数据错误 1290"></a>导出导入数据错误 1290</h4><p><strong>报错场景</strong>： 使用select&#x2F;insert 导出&#x2F;导入 时报错</p>
<p><strong>报错信息</strong>：</p>
<blockquote>
<p>ERROR 1290 (HY000): The MySQL server is running with the –secure-file-priv option so it cannot execute this statement</p>
</blockquote>
<p><strong>问题原因</strong>： secure_file_priv参数用于限制LOAD DATA, SELECT …OUTFILE, LOAD_FILE()传到哪个指定目录。  </p>
<ul>
<li>secure_file_priv 为 NULL 时，表示限制mysqld不允许导入或导出。</li>
<li>secure_file_priv 为 &#x2F;tmp 时，表示限制mysqld只能在&#x2F;tmp目录中执行导入导出，其他目录不能执行。</li>
<li>secure_file_priv 没有值时，表示不限制mysqld在任意目录的导入导出。</li>
</ul>
<p>可以通过以下命令，查看当前的配置  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> &quot;%secure_file_priv%&quot;;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.csms.tech/img_18.png"></p>
<p><strong>解决方法</strong>： 因为secure_file_priv参数是只读参数，不能使用set global命令修改。<br><img src="https://i.csms.tech/img_19.png"></p>
<p>需要修改配置文件，添加以下内容</p>
<figure class="highlight shell"><figcaption><span>my.cnf</span></figcaption><table><tr><td class="code"><pre><span class="line">secure_file_priv = &#x27;&#x27;</span><br></pre></td></tr></table></figure>

<p>修改配置后，重启mysql服务生效</p>
<h4 id="xtrbackup-备份时被阻塞，一直显示-log-scanned-up-to"><a href="#xtrbackup-备份时被阻塞，一直显示-log-scanned-up-to" class="headerlink" title="xtrbackup 备份时被阻塞，一直显示 log scanned up to"></a>xtrbackup 备份时被阻塞，一直显示 <code>log scanned up to</code></h4><p><strong>报错场景</strong>: xtrbackup 备份时间过长，一直输出 <code>log scanned up to</code><br><img src="https://i.csms.tech/img_20.png"></p>
<p><strong>可能原因</strong>： 备份在等待锁<br><img src="https://i.csms.tech/img_21.png"></p>
<p><strong>解决方法</strong>： 如果对业务无影响，可以重启mysql服务后重新备份，或者根据ID kill掉对应的线程</p>
<figure class="highlight shell"><figcaption><span>mysql</span></figcaption><table><tr><td class="code"><pre><span class="line">show processlist;</span><br><span class="line">kill ID;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql 常用sql</title>
    <url>/2207221611/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Mysql 5.7</li>
</ul>
<h3 id="常用sql"><a href="#常用sql" class="headerlink" title="常用sql"></a>常用sql</h3><h4 id="导出到文件"><a href="#导出到文件" class="headerlink" title="导出到文件"></a>导出到文件</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> [<span class="keyword">TABLE</span>] </span><br><span class="line">    <span class="keyword">INTO</span> OUTFILE <span class="string">&#x27;[FILE]&#x27;</span> </span><br><span class="line">    FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;,&#x27;</span> </span><br><span class="line">    OPTIONALLY ENCLOSED <span class="keyword">BY</span> <span class="string">&#x27;&quot;&#x27;</span> </span><br><span class="line">    LINES TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\n&#x27;</span>；</span><br></pre></td></tr></table></figure>
<blockquote>
<p>into outfile ‘导出的目录和文件名’<br>fields terminated by ‘字段间分隔符’<br>optionally enclosed by ‘字段包围符’   </p>
<blockquote>
<p>数值型字段无效  </p>
</blockquote>
<p>lines terminated by ‘行间分隔符’ </p>
</blockquote>
<p>产生报错可参考 <a href="https://csms.tech/22072111/#导出导入数据错误-1290">Mysql常见错误</a></p>
<h4 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb(c1,c2) <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<h4 id="翻页查看输出"><a href="#翻页查看输出" class="headerlink" title="翻页查看输出"></a>翻页查看输出</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">pager less <span class="operator">-</span>S</span><br></pre></td></tr></table></figure>
<blockquote>
<p>之后的输出可以使用和less命令一样的参数</p>
</blockquote>
<h4 id="mysqldump导出时排除某些表"><a href="#mysqldump导出时排除某些表" class="headerlink" title="mysqldump导出时排除某些表"></a>mysqldump导出时排除某些表</h4><blockquote>
<p><code>--ignore-table=database.table</code> 导出时排除指定的表</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p database --ignore-table=database.table1 --ignore-table=database.table2 &gt; backup.sql</span><br></pre></td></tr></table></figure>

<h4 id="mysqldump导出表结构"><a href="#mysqldump导出表结构" class="headerlink" title="mysqldump导出表结构"></a>mysqldump导出表结构</h4><blockquote>
<p><code>-d</code> 选项，只导出表结构，不导出数据</p>
</blockquote>
<p>导出整个数据库表结构（不包含数据）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p -d DB &gt; db.sql</span><br></pre></td></tr></table></figure>

<p>导出单个数据表结构（不包含数据）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p -d DB TABLE &gt; table.sql</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 常用配置说明</title>
    <url>/22721459/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>默认配置文件路径: <code>/etc/my.cnf</code></p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##############通用配置##############</span><br><span class="line">user = mysql</span><br><span class="line">port = 3306</span><br><span class="line">default_storage_engine = InnoDB</span><br><span class="line">## 只读</span><br><span class="line">read_only=1  </span><br><span class="line">             </span><br><span class="line">## 跳过域名解析参数，禁止MySQL对外部连接进行DNS解析，使用这一选项可以消除MySQL进行DNS解析的时间。</span><br><span class="line">## 但需要注意，如果开启该选项，则所有远程主机连接授权都要使用IP地址方式，否则MySQL将无法正常处理连接请求！</span><br><span class="line">skip-name-resolve  </span><br><span class="line"></span><br><span class="line">## 跳过授权，重置密码时需要</span><br><span class="line">## 重置密码：update mysql.user set authentication_string=password(&#x27;AynT7ZD5eGzk@dzO@JvjDY@Q&#x27;) where user=&#x27;root&#x27;;          </span><br><span class="line">skip-grant-tables   </span><br><span class="line">          </span><br><span class="line">datadir=/var/lib/mysql</span><br><span class="line">socket=/var/lib/mysql/mysql.sock</span><br><span class="line"></span><br><span class="line">## 解决日志中因wait-timeout的报错：</span><br><span class="line">## Aborted connection 40476 to db: &#x27;&#x27; user: &#x27;&#x27; host: &#x27;&#x27; (Got an error reading communication packets)</span><br><span class="line">log_warnings=1  </span><br><span class="line">                 </span><br><span class="line">### 连接错误超过此值，客户端无法连接，即拉黑</span><br><span class="line">max_connect_errors = 1000      </span><br><span class="line"></span><br><span class="line">###########主从配置选项###########</span><br><span class="line">server-id = 1</span><br><span class="line"># 主库要生成的二进制日志文件名称</span><br><span class="line">log-bin = mysql-bin    </span><br><span class="line">    </span><br><span class="line">## 从库中继日志名称</span><br><span class="line">relay-log = mysql-relay-bin    </span><br><span class="line"></span><br><span class="line">################</span><br><span class="line">## sync_binlog = 0    表示MySQL 不控制binlog的刷新，由文件系统自己控制它的缓存的刷新。</span><br><span class="line">## 这时候的性能是最好的，但是风险也是最大的。因为一旦系统Crash，在binlog_cache中的所有binlog信息都会被丢失。</span><br><span class="line">## sync_binlog&gt;0    表示每N个sync_binlog次事务提交，MySQL调用文件系统的刷新操作将缓存刷下去。</span><br><span class="line">## 最安全的就是sync_binlog=1了，表示每次事务提交，MySQL都会把binlog刷下去，是最安全但是性能损耗最大的设置。这样的话，在数据库所在的主机操作系统损坏或者突然掉电的情况下，系统才有可能丢失1个事务的数据。 </span><br><span class="line">## 但是binlog虽然是顺序IO，但是设置sync_binlog=1，多个事务同时提交，同样很大的影响MySQL和IO性能。</span><br><span class="line">## 对于高并发事务的系统来说，“sync_binlog”设置为0和设置为1的系统写入性能差距可能高达5倍甚至更多。</span><br><span class="line">## 只适用于主库的二进制日志，不适用中继日志</span><br><span class="line">################</span><br><span class="line">sync_binlog=0</span><br><span class="line"></span><br><span class="line">## 要同步的库.应该在从库上尽可能的使用replicate_wild_*，不建议在主库上使用</span><br><span class="line">binlog-do-db = rtzc_pnc_base       </span><br><span class="line"></span><br><span class="line"># 不同步的数据库,应该在从库上尽可能的使用replicate_wild_*</span><br><span class="line">binlog-ignore-db = mysql</span><br><span class="line"></span><br><span class="line">### 应该在从库上尽可能的使用replicate_wild_*              </span><br><span class="line">#replicate-wild-ignore-table=db.*               </span><br><span class="line">#replicate-wild-ignore-table=mysql.*</span><br><span class="line">#replicate-wild-ignore-table=information_schema.*</span><br><span class="line">#replicate-wild-ignore-table=performance_schema.*</span><br><span class="line">#replicate-wild-ignore-table=sys.*</span><br><span class="line">#replicate_wild_do_table=DB_NAME.%</span><br><span class="line">#replicate_ignore_db=test</span><br><span class="line"></span><br><span class="line">###复制实现模式/级别</span><br><span class="line">binlog_format=statement/row/mixed   </span><br><span class="line"></span><br><span class="line"># binlog日志大于此值是重新生成新的日志，默认(最大)1G，若使用大事务，日志可能会超过此值     </span><br><span class="line">max_binlog_size = 100M        </span><br><span class="line"></span><br><span class="line"># bilog日志保存天数，过期后清除</span><br><span class="line">expire_logs_days = 7   </span><br><span class="line"></span><br><span class="line"># 跳过某些同步错误号</span><br><span class="line">slave-skip-errors = 1032,1062  </span><br><span class="line"></span><br><span class="line">### 从库需要记录binlog，如级联从库场景，级联从库必须有此参数</span><br><span class="line">log-slave-updates=1          </span><br><span class="line"></span><br><span class="line"># 阻止slave自动启动复制</span><br><span class="line">skip_slave_start     </span><br><span class="line"></span><br><span class="line"># 从库发现和主库连接失败后，重连等待的时间，默认1小时       </span><br><span class="line">slave_net_timeout = 1        </span><br><span class="line"></span><br><span class="line"># 在从库上同步状态文件到磁盘，默认10000，表示在10000个事务执行完成后，将信息同步到磁盘</span><br><span class="line"># 打开后，可能会降低IO性能，设置为1最安全，但是IO性能最差；设置为0，由OS控制刷新</span><br><span class="line">sync_master_info | sync_relay_log | sync_relay_log_info  = 1      </span><br><span class="line"></span><br><span class="line"># SQL线程重放完一个中继日志后尽快将其删除</span><br><span class="line">relay_log_purge = 1         </span><br><span class="line"></span><br><span class="line"># 所有中继日志大小和的最大值。可防止主从延迟很大时，IO线程写relay log，导致磁盘空间不足。中继日志总和超过此值，IO线程会停止，等待SQL线程释放空间；</span><br><span class="line"># 风险是从库未从主库读取所有relaylog，这些日志可能在主库崩溃时丢失，磁盘空间足够的情况下，不推荐配置  </span><br><span class="line">relay_log_space_limit = 1G       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#########日志选项###########</span><br><span class="line">slow_query_log =1   </span><br><span class="line">long_query_time=2     </span><br><span class="line">slow_query_log_file=/var/lib/mysql/slow.log</span><br><span class="line"></span><br><span class="line">log-error=/var/log/mysqld.log</span><br><span class="line"></span><br><span class="line">##########编码选项######</span><br><span class="line">character-set-server = utf8</span><br><span class="line">collation-server=utf8_general_ci </span><br><span class="line"></span><br><span class="line">#############连接选项#############</span><br><span class="line"></span><br><span class="line"># 客户端的连接闲置的最大时间，默认8小时，设置非交互模式(jdbc)时的超时时间</span><br><span class="line">wait-timeout = 60      </span><br><span class="line"></span><br><span class="line"># 交互模式超时时间      </span><br><span class="line">interactive_timeout = 60    </span><br><span class="line"></span><br><span class="line"># 并发连接数,最终值由open_files_limit共同决定</span><br><span class="line">max_connections=65535    </span><br><span class="line"></span><br><span class="line"># 一个账号最大可发起多少并发连接                </span><br><span class="line">max_user_connections=65535            </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#############性能选项#############</span><br><span class="line"></span><br><span class="line"># 缓存的表个数，可以观察Opened_tables状态变量值，若很大(若经常需要创建/删除临时表，该计数器也会不停增长)，建议增加此配置值，由OS rlimit共同决定</span><br><span class="line">table_open_cache = 65535  </span><br><span class="line"></span><br><span class="line"># 缓存的线程个数，具体配置值可以观察Threads_created状态变量，如果此值较大，可加大thread_cache_size,建议此值保持足够大    </span><br><span class="line">thread_cache_size = 5000   </span><br><span class="line"></span><br><span class="line"># 查询缓存使用的内存大小，启动时，一次性分配</span><br><span class="line">query_cache_size = 1024M      </span><br><span class="line"></span><br><span class="line"># 查询需排序时分配内存，立即分配指定的全部内存，无论是否需要这么多</span><br><span class="line">sort_buffer_size = 10k            </span><br><span class="line"></span><br><span class="line"># 需要在服务启动程序(/usr/lib/systemd/system/mysqld.service)中配置：LimitNOFILE = 65535</span><br><span class="line">open_files_limit = 65535</span><br><span class="line">     </span><br><span class="line">max_allowed_packet = 200M</span><br><span class="line">innodb_open_files = 65535      </span><br><span class="line"></span><br><span class="line"># 默认值一般都太小，此值建议配置为os和其他应用消耗的内存除外的内存大小</span><br><span class="line"># 配置太大也会导致预热和关闭花费较多时间</span><br><span class="line">innodb_buffer_pool_size = 20G       </span><br><span class="line"></span><br><span class="line"># 事务日志的文件大小，太小，InnoDB必须做更多检查点，导致更多日志写，不利于IO。日志缓存满，事务提交或每秒，会刷新缓存到磁盘;</span><br><span class="line"># 可以观察show innodb status中log部分，Innodb_os_log_written查看写入了多少数据</span><br><span class="line">innodb_log_file_size = (32-128)M</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">innodb_flush_log_at_trx_commit = N</span><br><span class="line">########## innodb特有参数，事务日志用于在mysql崩溃后的恢复</span><br><span class="line"># N=0   每隔一秒，把事务日志缓存区的数据写到日志文件中，以及把日志文件的数据刷新到磁盘上；</span><br><span class="line"># 在这种情况下，MySQL性能最好，但如果 mysqld 进程崩溃，通常会导致最后 1s 的日志丢失。</span><br><span class="line"></span><br><span class="line"># N=1   每个事务提交时候，把事务日志从缓存区写到日志文件中，并且刷新日志文件的数据到磁盘上；每次事务提交时，log buffer 会被写入到日志文件并刷写到磁盘。 </span><br><span class="line"># 这也是默认值。这是最安全的配置，但由于每次事务都需要进行磁盘I/O，所以也最慢。</span><br><span class="line"></span><br><span class="line"># N=2    当取值为2 时，每次事务提交会写入日志文件，但并不会立即刷写到磁盘，日志文件会每秒刷写一次到磁盘。</span><br><span class="line"># 这时如果 mysqld 进程崩溃，由于日志已经写入到系统缓存，所以并不会丢失数据；在操作系统崩溃的情况下，通常会导致最后 1s 的日志丢失。</span><br><span class="line"># 对于一些数据一致性和完整性要求不高的应用，配置为 2 就足够了；如果为了最高性能，可以设置为 0。有些应用，如支付服务，对一致性和完整性要求很高，所以即使最慢，也最好设置为 1.</span><br><span class="line">##########</span><br><span class="line"></span><br><span class="line"># 限制一次性可以有多少线程进入内核，建议值：cpu数量* 磁盘数量* 2,进入内核的线程超过此值，新线程无法进入。</span><br><span class="line"># 为使线程高效进入内核，线程第一次休眠innodb_thread_sleep_delay(默认10000)微秒，然后重试，若依然不能进入内核，则放入一个等待线程队列，由OS内核处理。</span><br><span class="line"># 在高并发环境或大量小查询时，可减小此值。</span><br><span class="line">innodb_thread_concurrency = 64</span><br><span class="line"></span><br><span class="line"># 一旦线程进入内核，可以有指定数量的tickents，再次进入内核时，可不在做并发检查，按照查询授权，而非事务            </span><br><span class="line">innodb_concurrency_tickets = 10</span><br><span class="line"></span><br><span class="line"># 多少个线程可以在同一时间提交事务，太小会有线程冲突      </span><br><span class="line">innodb_commit_concurrency = 100   </span><br><span class="line"></span><br><span class="line"># 指定磁盘IO能力，默认为100，使用SSD或IO性能好的磁盘时，建议提高此值</span><br><span class="line">innodb_io_capacity = 1000     </span><br><span class="line"></span><br><span class="line"># 控制后台由多少线程负责IO操作，默认为4</span><br><span class="line">innodb_read_io_threads | innodb_write_io_threads = 10             </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 主从恢复</title>
    <url>/94ee2c23/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Centos 7</li>
<li>Mysql 5.7</li>
<li>Percona-XtraBackup-2.4.4</li>
</ul>
<h3 id="恢复方法1：mysqldump主库锁表备份恢复"><a href="#恢复方法1：mysqldump主库锁表备份恢复" class="headerlink" title="恢复方法1：mysqldump主库锁表备份恢复"></a>恢复方法1：mysqldump主库锁表备份恢复</h3><p><strong>前提</strong> ： 接受主库锁表操作，备份恢复过程中主库无法写入数据</p>
<h4 id="从库停止slave进程"><a href="#从库停止slave进程" class="headerlink" title="从库停止slave进程"></a>从库停止slave进程</h4><p>登录mysql从库，执行以下命令，停止slave进程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">stop slave;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h4 id="主库锁表"><a href="#主库锁表" class="headerlink" title="主库锁表"></a>主库锁表</h4><p>登录mysql主库，执行以下命令，对主库进行锁表操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FLUSH TABLES WITH READ LOCK;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行锁表操作后，不要退出mysql命令行，否则会自动解锁。</p>
</blockquote>
<p>执行以下命令，查看主库锁表后的binlog位置信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SHOW MASTER STATUS\G</span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_3.png"></p>
<h4 id="备份主库数据库数据"><a href="#备份主库数据库数据" class="headerlink" title="备份主库数据库数据"></a>备份主库数据库数据</h4><p>执行以下命令备份数据库db1</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p --master-data=2 --databases db1 &gt; db1.sql</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>--master-data=2</code>  将日志名和位置写入到备份结果并注释，可以从备份文件中搜索<code>change master to</code>  查看binlog文件名和position</p>
</blockquote>
<p>主库备份完成后，可以解锁：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure>

<h4 id="从库恢复主库的备份数据"><a href="#从库恢复主库的备份数据" class="headerlink" title="从库恢复主库的备份数据"></a>从库恢复主库的备份数据</h4><p>将主库的备份数据拷贝到从库，使用备份数据覆盖恢复从库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p db1 &lt; db1.sql</span><br></pre></td></tr></table></figure>
<p>从库恢复备份完成后，和主库建立主从连接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">change master to master_host=&#x27;1.1.1.1&#x27;,master_user=&#x27;repl&#x27;,master_password=&#x27;pswd&#x27;,master_port=3306,master_log_file=&#x27;mysql-bin.000196&#x27;,master_log_pos=1037640668;</span><br><span class="line">start slave</span><br></pre></td></tr></table></figure>
<p>配置完成后，通过以下命令，查看主从状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">show slave status\G</span><br></pre></td></tr></table></figure>
<blockquote>
<p>主要关注以下项：<br>Slave_IO_Running: Yes<br>Slave_SQL_Running: Yes<br>Seconds_Behind_Master: 0  </p>
</blockquote>
<p><img src="https://i.csms.tech/img_5.png"></p>
<h3 id="恢复方法2：mysqldump主库不锁表备份恢复"><a href="#恢复方法2：mysqldump主库不锁表备份恢复" class="headerlink" title="恢复方法2：mysqldump主库不锁表备份恢复"></a>恢复方法2：mysqldump主库不锁表备份恢复</h3><h4 id="从库停止slave进程-1"><a href="#从库停止slave进程-1" class="headerlink" title="从库停止slave进程"></a>从库停止slave进程</h4><p>登录mysql从库，执行以下命令，停止slave进程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">stop slave;</span><br></pre></td></tr></table></figure>
<h4 id="备份主库数据库数据-1"><a href="#备份主库数据库数据-1" class="headerlink" title="备份主库数据库数据"></a>备份主库数据库数据</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p --master-data=2 --single-transaction -R --databases db01 &gt; db01.sql</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>--master-data=2</code> : 实现将日志名和位置写入到备份结果并注释,db01.sql中会包含当前日志的文件名以及位置<br><code>--routines, -R</code>：导出存储过程和函数</p>
</blockquote>
<h4 id="从库导入备份"><a href="#从库导入备份" class="headerlink" title="从库导入备份"></a>从库导入备份</h4><p>将主库的备份数据拷贝到从库，并进行恢复</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p db01 &lt; db01.sql</span><br></pre></td></tr></table></figure>
<h4 id="备份文件中查看binlog日志文件名和position"><a href="#备份文件中查看binlog日志文件名和position" class="headerlink" title="备份文件中查看binlog日志文件名和position"></a>备份文件中查看binlog日志文件名和position</h4><p>在备份文件(<code>db01.sql</code>)中搜索<code>CHANGE MASTER TO </code>, 结果中可以获取到binlog日志文件名和position</p>
<h4 id="建立主从连接"><a href="#建立主从连接" class="headerlink" title="建立主从连接"></a>建立主从连接</h4><p>根据上一步获取到的binlog文件名和position信息，建立主从连接并启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">change master to master_host=&#x27;1.1.1.1&#x27;,master_user=&#x27;repl&#x27;,master_password=&#x27;pswd&#x27;,master_port=3306,master_log_file=&#x27;mysql-bin.000196&#x27;,master_log_pos=1037640668;</span><br><span class="line">start slave</span><br></pre></td></tr></table></figure>
<p>通过命令<code>show slave status\G</code> 检查主从同步状态</p>
<h3 id="恢复方法3：-xbackup整库备份恢复"><a href="#恢复方法3：-xbackup整库备份恢复" class="headerlink" title="恢复方法3： xbackup整库备份恢复"></a>恢复方法3： xbackup整库备份恢复</h3><h4 id="xbackup安装"><a href="#xbackup安装" class="headerlink" title="xbackup安装"></a>xbackup安装</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y libaio-devel.x86_64 bzip2</span><br><span class="line">wget https://www.percona.com/downloads/XtraBackup/Percona-XtraBackup-2.4.4/binary/tarball/percona-xtrabackup-2.4.4-Linux-x86_64.tar.gz</span><br><span class="line">tar -zxf percona-xtrabackup-2.4.4-Linux-x86_64.tar.gz</span><br><span class="line">cp percona-xtrabackup-2.4.4-Linux-x86_64/bin/* /usr/bin</span><br></pre></td></tr></table></figure>

<h4 id="主库整库备份"><a href="#主库整库备份" class="headerlink" title="主库整库备份"></a>主库整库备份</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">innobackupex --defaults-file=/etc/my.cnf --user=root --password=PASSWD --port=3306 --socket=/var/lib/mysql/mysql.sock  [--databases  &quot;db1 db2 &quot;] $&#123;backup_data_dir&#125;</span><br></pre></td></tr></table></figure>

<h4 id="从库整库恢复"><a href="#从库整库恢复" class="headerlink" title="从库整库恢复"></a>从库整库恢复</h4><p>拷贝主库备份数据到从库,在从库上执行以下命令恢复数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd $&#123;backup_data_dir&#125;</span><br><span class="line"></span><br><span class="line">innobackupex --defaults-file=/etc/my.cnf --apply-log --use-memory=20000M $&#123;backup_data_dir&#125;</span><br><span class="line"></span><br><span class="line">cp -r $&#123;backup_data_dir&#125;/* $&#123;mysql_base_dir&#125;/data/</span><br></pre></td></tr></table></figure>

<h4 id="建立主从连接-1"><a href="#建立主从连接-1" class="headerlink" title="建立主从连接"></a>建立主从连接</h4><p>备份数据中的<code>xtrabackup_binlog_info</code>文件包含了从库建立主从连接时需要的binlog信息，根据此文件中的信息，在从库执行命令，建立主从连接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">change master to master_host=&#x27;1.1.1.1&#x27;,master_user=&#x27;repl&#x27;,master_password=&#x27;pswd&#x27;,master_port=3306,master_log_file=&#x27;mysql-bin.000196&#x27;,master_log_pos=1037640668;</span><br><span class="line">start slave</span><br></pre></td></tr></table></figure>
<p>通过命令<code>show slave status\G</code> 检查主从同步状态</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql 多主一从即多源复制</title>
    <url>/2207210946/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Mysql 5.7 之后版本支持多主一从</li>
</ul>
<h3 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h3><h4 id="分别在Master-1和Master-2上导出需要同步的数据库"><a href="#分别在Master-1和Master-2上导出需要同步的数据库" class="headerlink" title="分别在Master_1和Master_2上导出需要同步的数据库"></a>分别在Master_1和Master_2上导出需要同步的数据库</h4><p>分别在Master_1和Master_2上执行以下命令，导出需要同步的数据库备份</p>
<figure class="highlight shell"><figcaption><span>Master_1</span></figcaption><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p123456 --master-data=2 --single-transaction --databases  --add-drop-database  db1  &gt; db1.sql</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><figcaption><span>Master_2</span></figcaption><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p123456 --master-data=2 --single-transaction --databases  --add-drop-database  db2  &gt; db2.sql</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>备份完成后，将备份数据拷贝到从库服务器上面</p>
<span id="more"></span>

<h4 id="在Master-1和Master-2上创建复制账号"><a href="#在Master-1和Master-2上创建复制账号" class="headerlink" title="在Master_1和Master_2上创建复制账号"></a>在Master_1和Master_2上创建复制账号</h4><blockquote>
<p>如果已有复制账号，跳过此步骤</p>
</blockquote>
<p>分别在Master_1和Master_2上执行以下命令，创建复制账号</p>
<figure class="highlight shell"><figcaption><span>Master_1 Master_2</span></figcaption><table><tr><td class="code"><pre><span class="line">grant replication slave on *.* to &#x27;repl&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27;;</span><br></pre></td></tr></table></figure>
<h4 id="更改slave配置以支持多主一从"><a href="#更改slave配置以支持多主一从" class="headerlink" title="更改slave配置以支持多主一从"></a>更改slave配置以支持多主一从</h4><p>mysql支持多主一从(多源复制)的关键配置。<br>要配置mysql支持多源复制，必须配置mysql存储同步信息的方式，主要有以下2种方式 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[存储同步信息的方式说明](https://dev.mysql.com/doc/refman/5.7/en/replication-multi-source-configuration.html)
">[1]</span></a></sup></p>
<ul>
<li>FILE  默认配置，此时同步信息存储在文件master.info和relay-log.info</li>
<li>TABLE  同步信息存储在mysql.slave_master_info和mysql.slave_relay_log_info</li>
</ul>
<p>更改mysql配置文件(默认&#x2F;etc&#x2F;my.cnf)，配置存储同步信息的方式</p>
<figure class="highlight shell"><figcaption><span>/etc/my.cnf</span></figcaption><table><tr><td class="code"><pre><span class="line">master_info_repository=TABLE</span><br><span class="line">relay_log_info_repository=TABLE</span><br></pre></td></tr></table></figure>
<p>更改配置后，重启mysql生效</p>
<h4 id="slave上恢复Master-1和Master-2的备份数据"><a href="#slave上恢复Master-1和Master-2的备份数据" class="headerlink" title="slave上恢复Master_1和Master_2的备份数据"></a>slave上恢复Master_1和Master_2的备份数据</h4><figure class="highlight shell"><figcaption><span>slave</span></figcaption><table><tr><td class="code"><pre><span class="line">mysql -uroot -p  &lt; db1.sql</span><br><span class="line">mysql -uroot -p  &lt; db2.sql</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为在 <code>mysqldump</code> 备份时，使用了选项 <code>--add-drop-database</code>，slave导入备份时，无需指定db</p>
</blockquote>
<h4 id="slave上配置多源复制"><a href="#slave上配置多源复制" class="headerlink" title="slave上配置多源复制"></a>slave上配置多源复制</h4><h5 id="找到配置主从需要的binlog位置和Pos位置"><a href="#找到配置主从需要的binlog位置和Pos位置" class="headerlink" title="找到配置主从需要的binlog位置和Pos位置"></a>找到配置主从需要的binlog位置和Pos位置</h5><p>分别在Master_1和Master_2的备份数据中，查找以下内容，找到需要的binlog位置和Pos位置</p>
<figure class="highlight shell"><figcaption><span>slave</span></figcaption><table><tr><td class="code"><pre><span class="line">cat db1.sql |grep &quot; CHANGE MASTER&quot;</span><br><span class="line">cat db2.sql |grep &quot; CHANGE MASTER&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这些信息是由  <code>mysqldump</code> 的选项 <code>--master-data=2</code>提供 <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[--master-data=2说明](https://dev.mysql.com/doc/mysql-replication-excerpt/5.7/en/replication-howto-mysqldump.html)">[2]</span></a></sup><br>结果中包含以下类似内容：<br>CHANGE MASTER TO MASTER_LOG_FILE&#x3D;’log-bin.000001’, MASTER_LOG_POS&#x3D;1539;</p>
</blockquote>
<h5 id="登录salve数据库配置多源复制"><a href="#登录salve数据库配置多源复制" class="headerlink" title="登录salve数据库配置多源复制"></a>登录salve数据库配置多源复制</h5><p>登录slave数据库，分别执行以下命令，创建到Master_1和Master_2的复制</p>
<figure class="highlight shell"><figcaption><span>slave</span></figcaption><table><tr><td class="code"><pre><span class="line">CHANGE MASTER TO MASTER_HOST=&#x27;Master_1&#x27;,MASTER_USER=&#x27;repl&#x27;, MASTER_PASSWORD=&#x27;123456&#x27;,MASTER_LOG_FILE=&#x27;log-bin.000001&#x27;,MASTER_LOG_POS=1539 FOR CHANNEL &#x27;Master_1&#x27;;</span><br><span class="line">CHANGE MASTER TO MASTER_HOST=&#x27;Master_2&#x27;,MASTER_USER=&#x27;repl&#x27;, MASTER_PASSWORD=&#x27;123456&#x27;,MASTER_LOG_FILE=&#x27;log-bin.000001&#x27;,MASTER_LOG_POS=1539 FOR CHANNEL &#x27;Master_2&#x27;; </span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<blockquote>
<p>不同的主从复制以最后的 <code>FOR CHANNEL</code> 来区分</p>
</blockquote>
<h5 id="启动主从复制"><a href="#启动主从复制" class="headerlink" title="启动主从复制"></a>启动主从复制</h5><p>在slave数据库中执行以下命令分别启动复制</p>
<figure class="highlight shell"><figcaption><span>slave</span></figcaption><table><tr><td class="code"><pre><span class="line">start slave for channel &quot;Master_1&quot;;</span><br><span class="line">start slave for channel &quot;Master_1&quot;;</span><br></pre></td></tr></table></figure>
<p>也可以通过 <code>start slave;</code> 启动所有的复制</p>
<p>可以通过以下命令查看启动复制后的状态</p>
<figure class="highlight shell"><figcaption><span>slave</span></figcaption><table><tr><td class="code"><pre><span class="line">SHOW SLAVE STATUS FOR CHANNEL &#x27;Master_1&#x27;\G</span><br><span class="line">SHOW SLAVE STATUS FOR CHANNEL &#x27;Master_2&#x27;\G</span><br><span class="line">SHOW SLAVE STATUS\G</span><br></pre></td></tr></table></figure>

<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://dev.mysql.com/doc/">Mysql 官网</a></p>
<h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://dev.mysql.com/doc/refman/5.7/en/replication-multi-source-configuration.html">存储同步信息的方式说明</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://dev.mysql.com/doc/mysql-replication-excerpt/5.7/en/replication-howto-mysqldump.html">--master-data=2说明</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>yum 安装 Mysql 5.7</title>
    <url>/202211021345/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos 7 kernel 5.4</li>
<li>Mysql Server 5.7</li>
</ul>
<h1 id="Mysql-Server-安装步骤"><a href="#Mysql-Server-安装步骤" class="headerlink" title="Mysql Server 安装步骤"></a>Mysql Server 安装步骤</h1><h2 id="yum-方式安装"><a href="#yum-方式安装" class="headerlink" title="yum 方式安装"></a>yum 方式安装</h2><h3 id="安装-MySQL-5-7-的-yum-源"><a href="#安装-MySQL-5-7-的-yum-源" class="headerlink" title="安装  MySQL 5.7 的 yum 源"></a>安装  MySQL 5.7 的 yum 源</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum localinstall -y http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm</span><br></pre></td></tr></table></figure>
<p>如果因为源冲突，类似如下错误</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Processing Conflict: mysql80-community-release-el7-2.noarch conflicts mysql57-community-release</span><br></pre></td></tr></table></figure>

<p>可以卸载旧的 <code>yum</code> 源安装包，重新安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rpm -qa | grep mysql</span></span><br><span class="line">mysql80-community-release-el7-2.noarch</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum remove mysql80-community-release-el7-2</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum localinstall -y http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm</span></span><br></pre></td></tr></table></figure>

<p>检查 <code>yum</code> 源中的 <code>mysql-community-server</code> 信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum info mysql-community-server</span></span><br><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * base: download.cf.centos.org</span><br><span class="line"> * elrepo: reflector.westga.edu</span><br><span class="line"> * epel: coresite.mm.fcix.net</span><br><span class="line"> * extras: download.cf.centos.org</span><br><span class="line"> * updates: download.cf.centos.org</span><br><span class="line">Available Packages</span><br><span class="line">Name        : mysql-community-server</span><br><span class="line">Arch        : x86_64</span><br><span class="line">Version     : 5.7.40</span><br><span class="line">Release     : 1.el7</span><br><span class="line">Size        : 178 M</span><br><span class="line">Repo        : mysql57-community/x86_64</span><br><span class="line">Summary     : A very fast and reliable SQL database server</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<span id="more"></span>
<h3 id="安装-mysql-community-server"><a href="#安装-mysql-community-server" class="headerlink" title="安装 mysql-community-server"></a>安装 mysql-community-server</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y mysql-community-server</span><br></pre></td></tr></table></figure>

<h3 id="启动-mysql-server"><a href="#启动-mysql-server" class="headerlink" title="启动 mysql server"></a>启动 mysql server</h3><p>配置 mysql server 开机启动，同时启动服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable mysqld --now</span><br></pre></td></tr></table></figure>

<p>MySQL5.7 会为 root 用户随机生成一个临时密码，密码记录在日志 <code>/var/log/mysqld.log </code> 中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep &#x27;temporary password&#x27; /var/log/mysqld.log </span><br><span class="line">2022-11-02T06:09:54.520945Z 1 [Note] A temporary password is generated for root@localhost: ZQc6OCFidi:g</span><br></pre></td></tr></table></figure>

<p>使用临时密码登陆，修改密码，临时密码登陆后不能做任何操作，必须先更改密码</p>
<figure class="highlight shell"><figcaption><span>mysql</span></figcaption><table><tr><td class="code"><pre><span class="line">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;WadgyWwRdgDNEb+5Pw==&#x27;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>nfs 服务部署使用</title>
    <url>/202210251713/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>NFS（Network File System 的缩写），它的主要功能是：通过网络、让不同的机器、不同的 OS 可以共享彼此的文件</p>
<p>NFS 服务器可以允许 NFS 客户端将远端 NFS 服务器的共享目录挂载到自己的系统上，当作本地磁盘一样使用</p>
<h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos 7</li>
</ul>
<h1 id="服务安装"><a href="#服务安装" class="headerlink" title="服务安装"></a>服务安装</h1><h2 id="服务端安装"><a href="#服务端安装" class="headerlink" title="服务端安装"></a>服务端安装</h2><p>安装需要的软件包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install nfs-utils rpcbind</span><br></pre></td></tr></table></figure>

<p>创建数据目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /data/NFSDataHome</span><br><span class="line">chmod 666 /data/NFSDataHome</span><br></pre></td></tr></table></figure>

<p>修改配置文件 <code>/etc/exports</code>:</p>
<figure class="highlight shell"><figcaption><span>/etc/exports</span></figcaption><table><tr><td class="code"><pre><span class="line">/data/NFSDataHome 192.168.1.0/24(rw,sync,insecure,no_subtree_check,no_root_squash) </span><br><span class="line">/data/NFSDataHome *(ro)</span><br></pre></td></tr></table></figure>

<p>相关选项说明：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ro</td>
<td>只读访问</td>
</tr>
<tr>
<td>rw</td>
<td>读写访问</td>
</tr>
<tr>
<td>sync</td>
<td>所有数据在请求时写入共享</td>
</tr>
<tr>
<td>async</td>
<td>nfs 在写入数据前可以响应请求</td>
</tr>
<tr>
<td>secure</td>
<td>nfs 通过 1024 以下的安全 TCP&#x2F;IP 端口发送</td>
</tr>
<tr>
<td>insecure</td>
<td>nfs 通过 1024 以上的端口发送</td>
</tr>
<tr>
<td>wdelay</td>
<td>如果多个用户要写入 nfs 目录，则归组写入（默认）</td>
</tr>
<tr>
<td>no_wdelay</td>
<td>如果多个用户要写入 nfs 目录，则立即写入，当使用 async 时，无需此设置</td>
</tr>
<tr>
<td>hide</td>
<td>在 nfs 共享目录中不共享其子目录</td>
</tr>
<tr>
<td>no_hide</td>
<td>共享 nfs 目录的子目录</td>
</tr>
<tr>
<td>subtree_check</td>
<td>如果共享 &#x2F;usr&#x2F;bin 之类的子目录时，强制 nfs 检查父目录的权限（默认）</td>
</tr>
<tr>
<td>no_subtree_check</td>
<td>不检查父目录权限</td>
</tr>
<tr>
<td>all_squash</td>
<td>无论 NFS 客户端以哪种用户身份访问，均映射为 NFS 服务器的 nfsnobody 用户</td>
</tr>
<tr>
<td>no_all_squash</td>
<td>保留共享文件的 UID 和 GID（默认）</td>
</tr>
<tr>
<td>root_squash</td>
<td>当 NFS 客户端以 root 用户身份访问时，映射为 NFS 服务器的 nfsnobody 用户</td>
</tr>
<tr>
<td>no_root_squash</td>
<td>当 NFS 客户端以 root 身份访问时，映射为 NFS 服务器的 root 用户，也就是要为超级用户保留权限。这个选项会留下严重的安全隐患，一般不建议采用。</td>
</tr>
<tr>
<td>anonuid&#x3D;xxx</td>
<td>指定 nfs 服务器 &#x2F;etc&#x2F;passwd 文件中匿名用户的 UID</td>
</tr>
<tr>
<td>anongid&#x3D;xxx</td>
<td>指定 nfs 服务器 &#x2F;etc&#x2F;passwd 文件中匿名用户的 GID</td>
</tr>
</tbody></table>
<span id="more"></span>

<p>启动 <code>rpcbind</code> 服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable rpcbind.service --now</span><br></pre></td></tr></table></figure>
<p>启动 <code>nfs</code> 服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable nfs.service --now</span><br></pre></td></tr></table></figure>

<p>检查 expose 的资源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">showmount -e localhost</span></span><br><span class="line">Export list for localhost:</span><br><span class="line">/data/NFSDataHome *</span><br></pre></td></tr></table></figure>

<p>默认情况下，NFS server 启动时会随机启动多个端口并向 RPC 注册，有防火墙的场景下，不利于防火墙配置确切的端口。所以建议配置 NFS 使用固定的端口，配置方式如下</p>
<ol>
<li><p>编辑配置文件 <code>/etc/sysconfig/nfs</code>，添加以下内容</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RQUOTAD_PORT=30001</span><br><span class="line"></span><br><span class="line">LOCKD_TCPPORT=30002</span><br><span class="line"></span><br><span class="line">LOCKD_UDPPORT=30002</span><br><span class="line"></span><br><span class="line">MOUNTD_PORT=30003</span><br><span class="line"></span><br><span class="line">STATD_PORT=30004</span><br></pre></td></tr></table></figure></li>
<li><p>重启服务</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart rpcbind</span><br><span class="line">systemctl restart nfs</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>查看 NFS 使用的 RPC 端口</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ rpcinfo -p</span><br><span class="line">program vers proto   port  service</span><br><span class="line"> 100000    4   tcp    111  portmapper</span><br><span class="line"> 100000    3   tcp    111  portmapper</span><br><span class="line"> 100000    2   tcp    111  portmapper</span><br><span class="line"> 100000    4   udp    111  portmapper</span><br><span class="line"> 100000    3   udp    111  portmapper</span><br><span class="line"> 100000    2   udp    111  portmapper</span><br><span class="line"> 100005    1   udp  30003  mountd</span><br><span class="line"> 100005    1   tcp  30003  mountd</span><br><span class="line"> 100005    2   udp  30003  mountd</span><br><span class="line"> 100005    2   tcp  30003  mountd</span><br><span class="line"> 100005    3   udp  30003  mountd</span><br><span class="line"> 100005    3   tcp  30003  mountd</span><br><span class="line"> 100003    3   tcp   2049  nfs</span><br><span class="line"> 100003    4   tcp   2049  nfs</span><br><span class="line"> 100227    3   tcp   2049  nfs_acl</span><br><span class="line"> 100003    3   udp   2049  nfs</span><br><span class="line"> 100003    4   udp   2049  nfs</span><br><span class="line"> 100227    3   udp   2049  nfs_acl</span><br><span class="line"> 100021    1   udp  30002  nlockmgr</span><br><span class="line"> 100021    3   udp  30002  nlockmgr</span><br><span class="line"> 100021    4   udp  30002  nlockmgr</span><br><span class="line"> 100021    1   tcp  30002  nlockmgr</span><br><span class="line"> 100021    3   tcp  30002  nlockmgr</span><br><span class="line"> 100021    4   tcp  30002  nlockmgr</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>添加防火墙规则</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iptables -I INPUT 6 -p udp -m multiport --dports 111,2049,30001:30004 -j ACCEPT -m comment --comment &quot;nfs&quot;</span><br><span class="line">iptables -I INPUT 6 -p tcp -m multiport --dports 111,2049,30001:30004 -j ACCEPT -m comment --comment &quot;nfs&quot;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="客户端安装"><a href="#客户端安装" class="headerlink" title="客户端安装"></a>客户端安装</h2><h3 id="linux-客户端安装"><a href="#linux-客户端安装" class="headerlink" title="linux 客户端安装"></a>linux 客户端安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install nfs-utils</span><br></pre></td></tr></table></figure>

<p>测试 NFS 服务端 expose 的资源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">showmount -e <span class="variable">$&#123;NFS_SERVER_IP&#125;</span></span></span><br><span class="line">Export list for $&#123;NFS_SERVER_IP&#125;:</span><br><span class="line">/data/NFSDataHome *</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>客户端挂载</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount.nfs $&#123;NFS_SERVER_IP&#125;:/data/NFSDataHome /mnt/</span><br></pre></td></tr></table></figure>

<p>配置开机自动挂载，在 <code>/etc/fstab</code> 文件中添加以下内容</p>
<figure class="highlight shell"><figcaption><span>/etc/fstab</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;NFS_SERVER_IP&#125;:/data/NFSDataHome /mnt nfs defaults        0 0</span></span><br></pre></td></tr></table></figure>

<h3 id="Windows-客户端安装"><a href="#Windows-客户端安装" class="headerlink" title="Windows 客户端安装"></a>Windows 客户端安装</h3><ul>
<li>windows os： Win 10</li>
</ul>
<p>打开控制面板 -&gt; 程序 -&gt; 打开或关闭windows功能 -&gt; NFS客户端 ，启用 NFS。</p>
<p>cmd  执行以下命令挂载：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount IP:/nfsroot X:</span><br></pre></td></tr></table></figure>
<p>其中，<code>IP</code> 为 NFS 服务器得 IP，<code>/nfsroot</code> 为你挂载得 NFS 目录路径，执行成功后 NFS 路径会被挂载到 <code>X:</code> 盘</p>
<h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><h5 id="windows-挂载-NFS-后访问速度慢"><a href="#windows-挂载-NFS-后访问速度慢" class="headerlink" title="windows 挂载 NFS 后访问速度慢"></a>windows 挂载 NFS 后访问速度慢</h5><p>在 cmd 中通过命令 <code>mount</code> 查看挂载信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mount</span></span><br><span class="line"></span><br><span class="line">Local    Remote                                 Properties</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">x:       \\nfsserver\NFSDataHome                UID=-2, GID=-2</span><br><span class="line">                                                rsize=1048576, wsize=1048576</span><br><span class="line">                                                mount=soft, timeout=0.8</span><br><span class="line">                                                retry=1, locking=yes</span><br><span class="line">                                                fileaccess=755, lang=ANSI</span><br><span class="line">                                                casesensitive=no</span><br><span class="line">                                                sec=sys</span><br></pre></td></tr></table></figure>
<p>输出中可以看到读写大小（<code>rsize=1048576, wsize=1048576</code>，1M），NFS 服务默认的读写大小在配置文件 <code>/etc/nfsmount.conf</code>，默认大小为 8k</p>
<figure class="highlight shell"><figcaption><span>/etc/nfsmount.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Maximum Read Size (<span class="keyword">in</span> Bytes)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Rsize=8k</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Maximum Write Size (in Bytes)</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Wsize=8k</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将此配置修改为和 windows nfs 客户端的读写大小一样，重启 nfs 服务，window 重新挂载。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx 服务常用配置说明</title>
    <url>/202207261420/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<h3 id="全局通用配置"><a href="#全局通用配置" class="headerlink" title="全局通用配置"></a>全局通用配置</h3></blockquote>
<figure class="highlight shell"><figcaption><span>nginx.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">user nginx nginx;    </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">建议设置为cpu核心数或者cpu核心数的2倍，进程会包含一个`master process`，多个`worker process`</span>  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">master process负责绑定端口、调度进程等，不负责业务的处理</span>  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">worker process是业务进程，负责业务的处理</span></span><br><span class="line">worker_processes auto;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一个worker进程可以打开的最大的fd个数，受Linux内核限制</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">理论值应该是系统最多打开文件数（<span class="built_in">ulimit</span> -n）与nginx进程数相除</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可通过<span class="built_in">ulimit</span>设置或修改系统文件：`/etc/securit/limits.conf`</span></span><br><span class="line">worker_rlimit_nofile 1024；</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">cpu亲和性设置</span> </span><br><span class="line">worker_cpu_affinity    0001 0010 0100 1000;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">工作进程调度优先级，-20到19之间的值，值越小越优先调用。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果系统同时运行多个任务，你可能需要提高nginx的工作进程的优先级</span> </span><br><span class="line">worker_priority 0；              </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ssl硬件加速服务器，需要硬件支持</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ssl_engine ssl_engine device;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">nginx是否以守护进程运行，是否让nignx运行于后台；调试时可为off，使得所有信息直接输出在控制台</span></span><br><span class="line">daemon      on | off;         </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">events模块中包含nginx中所有处理连接的设置。</span></span><br><span class="line">events &#123;</span><br><span class="line">    # 每个worker进程允许的最多连接数, </span><br><span class="line">    # nginx服务最大连接数：worker_processes * worker_connections (受worker_rlimit_nofile限制)</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">    use epoll;</span><br><span class="line">    </span><br><span class="line">    # 是否允许一次性地响应多个用户请求</span><br><span class="line">    multi_accept on;                    </span><br><span class="line"></span><br><span class="line">    # 是否打开nginx的accept锁；此锁能够让多个worker进行轮流地、序列化地与新的客户端建立连接；</span><br><span class="line">    # 而通常当一个worker进程的负载达到其上限的7/8，master就尽可能不将请求调度至worker.</span><br><span class="line">	accept_mutex on | off;              </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">HTTP模块控制着nginx http处理的所有核心特性</span></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    # 是否在错误页面中显示和响应头字段中发出nginx版本号。</span><br><span class="line">    # 安全考虑建议关闭</span><br><span class="line">    server_tokens on | off | string; </span><br><span class="line">    </span><br><span class="line">    # 是否启用sendfile内核复制模式功能。作为静态服务器可以提供最大的IO访问速度。</span><br><span class="line">    sendfile on | off; </span><br><span class="line">    </span><br><span class="line">    # 尽快发送数据，否则会在数据包达到一定大小后再发送数据。这样会减少网络通信次数，降低阻塞概率，但也会影响响应及时性。</span><br><span class="line">    # 比较适合于文件下载这类的大数据通信场景。</span><br><span class="line">    tcp_nodelay on|off; </span><br><span class="line">    </span><br><span class="line">    # 单位s，适当降低此值可以提高响应连接数量</span><br><span class="line">    keepalive_timeout  65; </span><br><span class="line">    </span><br><span class="line">    # 一次长连接上允许的最大请求数</span><br><span class="line">    keepalive_requests 100；       </span><br><span class="line">    </span><br><span class="line">    # 禁止指定浏览器使用keepalive</span><br><span class="line">    keepalive_disable msie6|none；    </span><br><span class="line">    </span><br><span class="line">    # 读取http请求首部的超时时长。如果客户端在此时间内未传输整个头，则会向客户端返回408（请求超时）错误</span><br><span class="line">    client_header_timeout 1;     </span><br><span class="line">    </span><br><span class="line">    # 读取http请求包体的超时时间。</span><br><span class="line">    client_body_timeout 2;</span><br><span class="line">    </span><br><span class="line">    # 发送响应的超时时长。超时后连接将关闭。</span><br><span class="line">    send_timeout 5;  </span><br><span class="line">    </span><br><span class="line">    #http请求包体的最大值，常用于限定客户端所能够请求的最大包体，根据请求首部中的Content-Length来检查，以避免无用的传输。</span><br><span class="line">    client_max_body_size 1m;</span><br><span class="line">    </span><br><span class="line">    # 限制客户端每秒传输的字节数，默认为0，表示没有限制。单位Byte/s</span><br><span class="line">    limit_rate 0;</span><br><span class="line">    </span><br><span class="line">    # nginx向客户端发送响应报文时，如果大小超过了此处指定的值，则后续的发送过程开始限速，单位Byte</span><br><span class="line">    limit_rate_after 0;</span><br><span class="line">    </span><br><span class="line">    # 是否忽略不合法的http首部，默认为on，off意味着请求首部中出现不合规的首部将拒绝响应。</span><br><span class="line">    ignore_invalid_headers on|off;</span><br><span class="line">    </span><br><span class="line">    # 用户访问的文件不存在时，是否将其记录到错误日志中。</span><br><span class="line">    log_not_found on|off;   </span><br><span class="line">    </span><br><span class="line">    # nginx使用的dns地址，及缓存解析结果的时间               </span><br><span class="line">    resolver 8.8.8.8 [valid=time] [ipv6=on|off];</span><br><span class="line">    </span><br><span class="line">    # dns解析超时时间 </span><br><span class="line">    resolver_timeout 2；     </span><br><span class="line">    </span><br><span class="line">    # 是否打开文件缓存功能，max：用于缓存条目的最大值，</span><br><span class="line">    # inactive：某缓存条目在指定时长内没有被访问过时，将自动被删除，即缓存有效期，通常默认为60s。</span><br><span class="line">    open_file_cache off;  </span><br><span class="line">    open_file_cache max=N [inactive=time];    </span><br><span class="line">    </span><br><span class="line">    # 是否缓存文件找不到或没有权限访问等相关信息。</span><br><span class="line">    open_file_cache_errors on | off; </span><br><span class="line">    </span><br><span class="line">    # 多长时间检查一次缓存中的条目是否超出非活动时长。</span><br><span class="line">    # 建议值：小于等于open_file_cache inactive</span><br><span class="line">    open_file_cache_valid 60;   </span><br><span class="line">    </span><br><span class="line">    # 在open_file_cache inactive指定的时长内被访问超过此处指定的次数时，才不会被删除（删除低命中率的缓存）。</span><br><span class="line">    open_file_cache_min_uses 2;     </span><br><span class="line">    </span><br><span class="line">    # 开启内容压缩，可以有效降低客户端的访问流量和网络带宽</span><br><span class="line">    gzip on | off;</span><br><span class="line">    </span><br><span class="line">    # 内容超过最少长度后才开启压缩，太短的内容压缩效果不佳，且会浪费系统资源。</span><br><span class="line">    # 压缩长度会作为http响应头Content-Length字段返回给客户端。 建议值：64</span><br><span class="line">    gzip_min_length length;</span><br><span class="line">    </span><br><span class="line">    # 压缩级别，默认值为1。范围为1～9级，压缩级别越高压缩率越高，但对系统性能要求越高。建议值：4</span><br><span class="line">    gzip_comp_level 1~9;</span><br><span class="line">    </span><br><span class="line">    # 压缩内容类型，默认为text/html;。只压缩html文本，一般我们都会压缩js、css、json之类的，可以把这些常见的文本数据都配上。</span><br><span class="line">    如：text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;</span><br><span class="line">    gzip_types mime-type …;     </span><br><span class="line">    </span><br><span class="line">    # 自动显示目录</span><br><span class="line">    autoindex on;</span><br><span class="line">    </span><br><span class="line">    # off ： 以人类易读的方式显示文件大小，on：以 bytes 显示文件大小</span><br><span class="line">    autoindex_exact_size off;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    # 定义日志格式</span><br><span class="line">    log_format main &#x27;&#123; time: $time_iso8601|&#x27;</span><br><span class="line">                    &#x27;http_host:$http_host|&#x27;</span><br><span class="line">                    &#x27;cdn_ip:$remote_addr|&#x27;</span><br><span class="line">                    &#x27;request:$request|&#x27;</span><br><span class="line">                    &#x27;request_method:$request_method|&#x27;</span><br><span class="line">                    &#x27;http_user_agent:$http_user_agent|&#x27;</span><br><span class="line">                    &#x27;size:$body_bytes_sent|&#x27;</span><br><span class="line">                    &#x27;responsetime:$request_time|&#x27;</span><br><span class="line">                    &#x27;upstreamtime:$upstream_response_time|&#x27;</span><br><span class="line">                    &#x27;upstreamhost:$upstream_addr|&#x27;</span><br><span class="line">                    &#x27;upstreamstatus:$upstream_status|&#x27;</span><br><span class="line">                    &#x27;url:$http_host$uri|&#x27;</span><br><span class="line">                    &#x27;http_x_forwarded_for:$clientRealIp|&#x27;</span><br><span class="line">                    &#x27;status:$status&#125;&#x27;;</span><br><span class="line">    </span><br><span class="line">    # server负责具体的http服务器实现</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80 [default_server]  [rcvbuf=SIZE]  [sndbuf=SIZE] [ssl];</span><br><span class="line">        </span><br><span class="line">        # 可使用通配符*或正则表达式(~开头)，多个域名先精确匹配，再通配，再正则,&#x27;_&#x27;表示空主机头</span><br><span class="line">        server_name  _  ;</span><br><span class="line">        </span><br><span class="line">        access_log logs/access.log main;</span><br><span class="line">        error_log logs/access.err.log;</span><br><span class="line">        </span><br><span class="line">        # 跨域配置</span><br><span class="line">        add_header Access-Control-Allow-Origin *;</span><br><span class="line">        add_header Access-Control-Allow-Headers &#x27;Origin, No-Cache, X-Requested-With, If-Modified-Since, Pragma, Last-Modified, Cache-Control, Expires, Content-Type, X-E4M-With&#x27;;</span><br><span class="line">        add_header Access-Control-Allow-Methods GET,POST,OPTIONS;</span><br><span class="line">        add_header Access-Control-Allow-Credentials: true;</span><br><span class="line">        </span><br><span class="line">        location / &#123;       </span><br><span class="line">            # web资源路径             </span><br><span class="line">            root   html;          </span><br><span class="line">            </span><br><span class="line">            # 定义默认页面，从左往右匹配           </span><br><span class="line">            index  index.html index.htm;   </span><br><span class="line">            </span><br><span class="line">            # 自左向右读取指定路径，找到即停止，如果都不存在，返回一个错误码</span><br><span class="line">            try_files $uri $uri.html $uri/index.html =404;        </span><br><span class="line">            </span><br><span class="line">            # 自左向右读取指定路径，找到即停止，如果都不存在，返回一个uri</span><br><span class="line">            try_files $uri $uri.html $uri/index.html /404.html; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        location /i/ &#123; </span><br><span class="line">            # 路径别名，只能用于location中。</span><br><span class="line">            # 访问 http://a.com/i/a.html, 资源路径为：/data/www/html/a.html</span><br><span class="line">            # 若是root指令，访问 http://a.com/i/a.html，资源路径为：/data/www/html/i/a.html</span><br><span class="line">		    alias /data/www/html/;          </span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">	    # 对于某个请求发生错误，如果匹配到错误码，重定向到新的url</span><br><span class="line">	    error_page  404              /404.html; </span><br><span class="line">	    error_page   500 502 503 504  /50x.html;</span><br><span class="line">	    </span><br><span class="line">	    # 对于某个请求发生错误，如果匹配到错误码，重定向到新的url,同时可以更改返回码</span><br><span class="line">	    error_page 404 =200 /404.html;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    # 包含其他配置文件</span><br><span class="line">    include vhosts/*.conf;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h3 id="Server-常用配置"><a href="#Server-常用配置" class="headerlink" title="Server 常用配置"></a>Server 常用配置</h3><h4 id="nginx-代理-php"><a href="#nginx-代理-php" class="headerlink" title="nginx 代理 php"></a>nginx 代理 php</h4><figure class="highlight shell"><figcaption><span>vhosts/web.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name  _  ;</span><br><span class="line">    root           html;</span><br><span class="line">    </span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        fastcgi_index  index.php;</span><br><span class="line">        fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;          ###fastcgi程序的页面文件位置，$document_root = 之前配置的root           html;</span><br><span class="line">        ##include        fastcgi_params;</span><br><span class="line">	    fastcgi_param  QUERY_STRING       $query_string;                  ###将请求中的参数透传</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="nginx-状态监控"><a href="#nginx-状态监控" class="headerlink" title="nginx 状态监控"></a>nginx 状态监控</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置访问路径，即uri</span></span><br><span class="line">location = /nginx_status&#123;  </span><br><span class="line">  </span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">开启该模块</span></span><br><span class="line">  stub_status on;    </span><br><span class="line">  </span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">关闭日志</span>  </span><br><span class="line">  access_log off;   </span><br><span class="line">        </span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">允许访问的ip，即白名单ip</span> </span><br><span class="line">  allow 101.106.102.129;        </span><br><span class="line">  allow 127.0.0.1;</span><br><span class="line">  </span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">拒绝白名单ip以外的ip访问</span></span><br><span class="line">  deny all;               </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="ssl-配置"><a href="#ssl-配置" class="headerlink" title="ssl 配置"></a>ssl 配置</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name csms.tech;</span><br><span class="line">  </span><br><span class="line">    ssl_certificate /path/to/your_certificate.pem;</span><br><span class="line">    ssl_certificate_key /path/to/your_key.key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">强制跳转https</span></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name csms.tech;</span><br><span class="line">    rewrite ^(.*)$  https://$host$1 permanent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用pem类型证书链：可将中间证书导入pem文件，再将私钥导入pem文件，ssl_certificate和ssl_certificate_key都使用pem文件，可解决以下报错：<br>SSL_CTX_use_PrivateKey_file(“pri.key”) failed  (SSL: error:0906D06C:PEM routines:PEM_read_bio:no start line:Expecting: ANY PRIVATE KEY error:140B0009:SSL routines:SSL_CTX_use_PrivateKey_file:PEM lib</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat gd_bundle-g2-g1.crt &gt;&gt; f549150b196cd59e.pem</span><br><span class="line">cat f549150b196cd59e.key &gt;&gt; f549150b196cd59e.pem</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><figcaption><span>nginx.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">ssl_certificate f549150b196cd59e.pem;</span><br><span class="line">ssl_certificate_key  f549150b196cd59e.pem;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="配置-upstream-代理"><a href="#配置-upstream-代理" class="headerlink" title="配置 upstream 代理"></a>配置 upstream 代理</h4><figure class="highlight shell"><figcaption><span>upstream.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">upstream myserver &#123;</span><br><span class="line">    # 调度策略,默认为轮询</span><br><span class="line">    ip_hash | url_hash ...</span><br><span class="line">    </span><br><span class="line">    # 后端服务器列表</span><br><span class="line">    # backup:其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。</span><br><span class="line">    # max_fails:允许请求失败的次数，默认为1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误.</span><br><span class="line">    # fail_timeout : max_fails次失败后，暂停的时间。 </span><br><span class="line">    server 10.0.0.1:8080 [weight=1] [backup] [down] [max_fails] [fail_timeout];</span><br><span class="line">    server 10.0.0.2:8080 [weight=1] [backup] [down] [max_fails] [fail_timeout];</span><br><span class="line"></span><br><span class="line">    keepalive 2000;</span><br><span class="line">    </span><br><span class="line">    # 后端健康检测，需要第三方插件ngx_http_healthcheck_module</span><br><span class="line">    # healthcheck_enabled;         </span><br><span class="line">    # healthcheck_delay 3000;</span><br><span class="line">    # healthcheck_timeout 1000;</span><br><span class="line">    # healthcheck_failcount 2;</span><br><span class="line">    # healthcheck_send &#x27;GET /healthcheck.html HTTP/1.0&#x27; &#x27;Host: local.com&#x27; &#x27;Connection: close&#x27;;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;                                                         </span><br><span class="line">    server_name  csms.tech;                                               </span><br><span class="line">    client_max_body_size 1024M;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        # 指定协议、主机名、端口</span><br><span class="line">        proxy_pass http://myserver/uri;</span><br><span class="line">                     </span><br><span class="line">        [proxy_set_header Host $host:$server_port;]</span><br><span class="line">        [proxy_redirect     off;]</span><br><span class="line">        [proxy_set_header X-Real-IP $remote_addr;]</span><br><span class="line">        [proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;]</span><br><span class="line">        [proxy_set_header X-Forwarded-Proto https;]</span><br><span class="line">        [proxy_ignore_client_abort on;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ip-限制"><a href="#ip-限制" class="headerlink" title="ip 限制"></a>ip 限制</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;                                                         </span><br><span class="line">    server_name  csms.tech;</span><br><span class="line">    </span><br><span class="line">    root html;</span><br><span class="line">    </span><br><span class="line">    if ($http_x_forwarded_for !~ (1.1.1.1|1.1.1.2)) &#123;</span><br><span class="line">        return 403;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="地区限制"><a href="#地区限制" class="headerlink" title="地区限制"></a>地区限制</h4><p>依赖nginx 的<code>http_geoip_module</code> 模块，检查<code>GeoIP</code>是否安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./sbin/nginx -V </span><br></pre></td></tr></table></figure>
<p>输出结果中如果不包含：<code>--with-http_geoip_module</code>，说明未安装，重新编译安装nginx<br>安装<code>http_geoip_module</code>模块后使用以下配置</p>
<figure class="highlight shell"><figcaption><span>nginx.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    geoip_country /usr/share/GeoIP/GeoIP.dat;</span><br><span class="line">    </span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name csms.tech;</span><br><span class="line">        </span><br><span class="line">        location / &#123;</span><br><span class="line">            if ($geoip_country_code != CN) &#123;</span><br><span class="line">                root outChina;</span><br><span class="line">            &#125;</span><br><span class="line">            root China;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="server-中location优先级"><a href="#server-中location优先级" class="headerlink" title="server 中location优先级"></a>server 中<code>location</code>优先级</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    # 精确匹配，最高优先级</span><br><span class="line">    location = /url  &#123;&#125;        </span><br><span class="line"></span><br><span class="line">    # 从前往后匹配，匹配到即停止继续匹配，不是正则匹配，第二优先级</span><br><span class="line">    location ^~ /uri  &#123;&#125;          </span><br><span class="line"></span><br><span class="line">    # 正则匹配，~ 区分大小写， ~* 不区分大小写，第三优先级</span><br><span class="line">    location ~ ^/url$ &#123;&#125;    </span><br><span class="line">    location ~* ^/url$ &#123;&#125;    </span><br><span class="line">	</span><br><span class="line">    # / 会匹配到所有未被匹配到的url</span><br><span class="line">    location /documents/ &#123;&#125; </span><br><span class="line">    location / &#123;&#125; </span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="301-跳转配置"><a href="#301-跳转配置" class="headerlink" title="301 跳转配置"></a>301 跳转配置</h4><p>如下配置，使用 <code>rewrite</code> 或 <code>return</code> 指令，所有 <a href="https://csms.tech/"><code>csms.tech</code></a> 的请求都会 <code>301</code> 重定向到 <a href="https://csms.tech/"><code>www.csms.tech</code></a>，并携带原来的 <code>uri</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name csms.tech;</span><br><span class="line">    </span><br><span class="line">    rewrite ^/(.*)$ https://www.csms.tech$1 permanent;</span><br><span class="line">    </span><br><span class="line">    # return 301 https://www.csms.tech$request_uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="stream-配置"><a href="#stream-配置" class="headerlink" title="stream 配置"></a>stream 配置</h3><p>nginx 通过 stream 模块实现了 tcp 代理功能，无需其他软件配合即可实现四层代理和七层代理，即：访问该服务器的指定端口，nginx 就可以充当端口转发的作用将流量导向另一个服务器，同时获取目标服务器的返回数据并返回给请求者。这是一个非常实用的功能。</p>
<p>yum 安装的 nginx ，使用以下命令安装 <code>stream</code> 模块 <sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Nginx Stream 配置](https://blog.junmoyu.com/posts/linux-nginx-install-stream/)">[3]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y nginx-mod-stream</span><br></pre></td></tr></table></figure>
<p><strong>请注意，stream 块和 http 块是两个不同的模块，stream 不属于 http 模块</strong>，即不能放到 &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;，stream 是通过 tcp 层转发，而不是 http 转发。</p>
<p>如配置在 http 内，启动 nginx 会报如下错误：<br><code>nginx: [emerg] &quot;server&quot; directive is not allowed here</code></p>
<p><code>stream</code> 需要配置在 <code>nginx.conf</code> 中和 <code>http</code> 命令同级的位置。</p>
<figure class="highlight shell"><figcaption><span>nginx.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">load_module /usr/lib64/nginx/modules/ngx_stream_module.so;</span><br><span class="line"></span><br><span class="line">user nginx nginx;</span><br><span class="line">worker_processes  auto;</span><br><span class="line">worker_rlimit_nofile 65535;</span><br><span class="line">pid     conf/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">        use     epoll;</span><br><span class="line">        worker_connections  309600;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">        include     mime.types;</span><br><span class="line">        default_type  application/octet-stream;</span><br><span class="line">        ...</span><br><span class="line">        include     vhosts.d/*.conf;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">stream config.</span></span><br><span class="line">stream &#123;</span><br><span class="line">    # tcp/ip proxy</span><br><span class="line">    include /etc/nginx/tcp.d/*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>安装了 <code>nginx-mod-stream</code>，nginx 启动报错：<code>unknown directive &quot;stream&quot;</code>，需要在 <code>nginx.conf</code> 中手动加载模块：<code>load_module /usr/lib64/nginx/modules/ngx_stream_module.so;</code></p>
<h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><h4 id="worker-connections-exceed-open-file-resource-limit"><a href="#worker-connections-exceed-open-file-resource-limit" class="headerlink" title="worker_connections exceed open file resource limit"></a>worker_connections exceed open file resource limit</h4><p><strong>问题原因</strong>： worker_rlimit_nofile的值小于worker_connections的值，参数说明可参考<a href="#%E5%85%A8%E5%B1%80%E9%80%9A%E7%94%A8%E9%85%8D%E7%BD%AE">全局通用配置</a>  </p>
<h4 id="Response-to-preflight-request-doesn’t-pass-access-control-check-The-value-of-the-‘Access-Control-Allow-Origin’-header-in-the-response-must-not-be-the-wildcard-‘-’"><a href="#Response-to-preflight-request-doesn’t-pass-access-control-check-The-value-of-the-‘Access-Control-Allow-Origin’-header-in-the-response-must-not-be-the-wildcard-‘-’" class="headerlink" title="Response to preflight request doesn’t pass access control check: The value of the ‘Access-Control-Allow-Origin’ header in the response must not be the wildcard ‘*’"></a>Response to preflight request doesn’t pass access control check: The value of the ‘Access-Control-Allow-Origin’ header in the response must not be the wildcard ‘*’</h4><p><strong>错误场景</strong>：</p>
<p>浏览器访问报跨域错误，nginx 已配置了 <code>add_header Access-Control-Allow-Origin *;</code>，具体报错：<code>Access to XMLHttpRequest at &#39;http://spin-gate.test.com/webhooks/preconfigured&#39; from origin &#39;http://spinnaker.test.com&#39; has been blocked by CORS policy: Response to preflight request doesn&#39;t pass access control check: The value of the &#39;Access-Control-Allow-Origin&#39; header in the response must not be the wildcard &#39;*&#39; when the request&#39;s credentials mode is &#39;include&#39;. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute.</code><br><img src="https://i.csms.tech/img_95.png"><br><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS/Errors/CORSNotSupportingCredentials">问题原因及客户端解决方法</a></p>
<p><strong>nginx 服务端解决方法</strong>：</p>
<h5 id="nginx-配置允许单个目标跨域"><a href="#nginx-配置允许单个目标跨域" class="headerlink" title="nginx 配置允许单个目标跨域"></a>nginx 配置允许单个目标跨域</h5><p>nginx 配置 <code>add_header Access-Control-Allow-Origin </code> 可以配置允许跨域，此参数只允许配置单个域名或者 <code>*</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">add_header Access-Control-Allow-Origin *;</span></span><br><span class="line">add_header Access-Control-Allow-Origin http://127.0.0.1;</span><br><span class="line">add_header Access-Control-Allow-Methods &#x27;GET, POST, OPTIONS&#x27;;</span><br><span class="line">add_header Access-Control-Allow-Headers &#x27;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization,lang,access-token&#x27;;</span><br></pre></td></tr></table></figure>

<h5 id="nginx-配置允许多个目标跨域"><a href="#nginx-配置允许多个目标跨域" class="headerlink" title="nginx 配置允许多个目标跨域"></a>nginx 配置允许多个目标跨域</h5><p>nginx 配置 <code>add_header Access-Control-Allow-Origin</code> 只能配置一个目标，不能配置多个目标，要使用此指令配置多个目标允许跨域，可参考以下方法</p>
<ul>
<li><p>通过设置变量值解决指定多个域名白名单跨域请求配置</p>
<p>  通过在 nginx 配置中设置变量，来匹配允许跨域的目标，示例代码如下 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[设置变量解决指定多个域名白名单跨域请求配置](https://www.yidude.com/nginx/100001.html)">[1]</span></a></sup></p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    set $cors_origin &quot;&quot;;</span><br><span class="line">    if ($http_origin ~* &quot;^http://127.0.0.1$&quot;) &#123;</span><br><span class="line">            set $cors_origin $http_origin;</span><br><span class="line">    &#125;</span><br><span class="line">    if ($http_origin ~* &quot;^http://localhost$&quot;) &#123;</span><br><span class="line">            set $cors_origin $http_origin;</span><br><span class="line">    &#125;</span><br><span class="line">    add_header Access-Control-Allow-Origin $cors_origin;</span><br><span class="line">    add_header Access-Control-Allow-Methods GET,POST,PUT,DELETE,OPTIONS;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<p>通过以上配置，可实现允许 <code>http://127.0.0.1</code>，<code>http://localhost</code> 跨域，如果需要允许其他目标跨域，以此添加配置即可。</p>
</li>
<li><p>使用 map 实现 Nginx 允许多个域名跨域</p>
<p>  在 Nginx 中可以使用 map 得到一个自定义变量，可以对请求中的 origin 做一个过滤处理，把符合要求的请求域名放到一个变量中，在设置 allow origin 时使用该变量就能实现一个动态的、多个的允许跨域域名，示例配置如下 <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[使用 map 实现 Nginx 允许多个域名跨域](https://priesttomb.github.io/%E6%8A%80%E6%9C%AF/2020/10/24/using-map-to-set-multiple-allow-origins-in-nginx/)">[2]</span></a></sup></p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map $http_origin $allow_origin &#123;</span><br><span class="line">    default &quot;&quot;;</span><br><span class="line">    &quot;~^(https?://localhost(:[0-9]+)?)$&quot; $1;</span><br><span class="line">    &quot;~^(https?://127.0.0.1(:[0-9]+)?)$&quot; $1;</span><br><span class="line">    &quot;~^(https?://172.10(.[\d]+)&#123;2&#125;(:[0-9]+)?)$&quot; $1;</span><br><span class="line">    &quot;~^(https?://192.168(.[\d]+)&#123;2&#125;(:[0-9]+)?)$&quot; $1;</span><br><span class="line">  </span><br><span class="line">    &quot;~http://www.123admin.com&quot; http://www.123admin.com;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       11111;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    location ~ /xxx/xx &#123;</span><br><span class="line">        if ($request_method = &#x27;OPTIONS&#x27;) &#123;</span><br><span class="line">            return 204;</span><br><span class="line">        &#125;</span><br><span class="line">        add_header Access-Control-Allow-Origin $allow_origin;</span><br><span class="line">        add_header Access-Control-Allow-Methods &#x27;GET, POST, OPTIONS&#x27;;</span><br><span class="line">        add_header Access-Control-Allow-Headers &#x27;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization&#x27;;</span><br><span class="line">        add_header Access-Control-Allow-Credentials &#x27;true&#x27;;</span><br><span class="line">        proxy_pass http://1.2.3.4:5678;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  解释说明：</p>
<ul>
<li><p><code>$http_origin</code> 是 Nginx 的内部变量，用于获取请求头中的 origin</p>
</li>
<li><p><code>$allow_origin</code> 是可以自定义的变量名，用于接收 map 返回的值</p>
</li>
<li><p><code>$1</code> 是 Nginx 对 PCRE 中关于后向引用和子组的兼容，用于获取匹配字符串的整个部分，并返回给 <code>$allow_origin</code></p>
</li>
</ul>
</li>
</ul>
<h4 id="Nginx-配置-ssl-时未指定-ssl"><a href="#Nginx-配置-ssl-时未指定-ssl" class="headerlink" title="Nginx 配置 ssl 时未指定 ssl"></a>Nginx 配置 ssl 时未指定 ssl</h4><p>nginx 如下的 server 配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 443;</span><br><span class="line">        server_name test.com;</span><br><span class="line">      </span><br><span class="line">        ssl_certificate test.com.pem;       </span><br><span class="line">        ssl_certificate_key test.com.pem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过浏览器访问 https 协议，报错： <code>This site can’t provide a secure connection</code> ，<code>ERR_SSL_PROTOCOL_ERROR</code></p>
<p>使用 <code>curl</code> 命令访问报错： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">* NSS error -12263 (SSL_ERROR_RX_RECORD_TOO_LONG)</span><br><span class="line">* SSL received a record that exceeded the maximum permissible length.</span><br><span class="line">* Closing connection 0</span><br><span class="line">curl: (35) SSL received a record that exceeded the maximum permissible length.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>修改配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 443 ssl;</span><br><span class="line">        server_name test.com;</span><br><span class="line">      </span><br><span class="line">        ssl_certificate test.com.pem;       </span><br><span class="line">        ssl_certificate_key test.com.pem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.yidude.com/nginx/100001.html">设置变量解决指定多个域名白名单跨域请求配置</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://priesttomb.github.io/%E6%8A%80%E6%9C%AF/2020/10/24/using-map-to-set-multiple-allow-origins-in-nginx/">使用 map 实现 Nginx 允许多个域名跨域</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://blog.junmoyu.com/posts/linux-nginx-install-stream/">Nginx Stream 配置</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>nodejs安装配置</title>
    <url>/647e4c1a/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://nodejs.org/dist/latest/node-v15.12.0-linux-x64.tar.gz</span><br><span class="line">tar -xf node-v15.12.0-linux-x64.tar.gz -C /usr/local</span><br><span class="line">ln -s /usr/local/node-v15.12.0-linux-x64/bin/* /bin/</span><br></pre></td></tr></table></figure>

<p>安装pm2</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install pm2 -g</span><br><span class="line">npm install -g pm2@3.5.1    # 安装指定版本</span><br><span class="line">npm install -g pm2@latest   # 安装最新版本</span><br></pre></td></tr></table></figure>

<h4 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h4><blockquote>
<p>WARN EACCES user “root” does not have permission to access the dev dir “&#x2F;root&#x2F;.node-gyp&#x2F;11.15.0”<br>ERR! stack Error: EACCES: permission denied, mkdir ‘node_modules&#x2F;sqlite3&#x2F;.node-gyp’</p>
</blockquote>
<p>[解决方法]：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --unsafe-perm</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>php 编译安装配置</title>
    <url>/202207301722/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Centos 7</li>
<li>Php 7.2</li>
</ul>
<span id="more"></span>

<h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><p>安装依赖包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y gcc libxml2-devel libjpeg-turbo-devel libpng-devel libxslt libxslt-devel libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel libxml2 libxml2-devel zlib zlib-devel curl curl-devel openssl openssl-devel  bzip2  bzip2-devel  libxslt libxslt-devel  libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel libxml2 libxml2-devel zlib zlib-devel curl curl-devel openssl openssl-devel perl perl-devel httpd-devel readline-devel autoconf</span><br></pre></td></tr></table></figure>
<p>下载安装包，编译安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://am1.php.net/distributions/php-7.2.0.tar.bz2</span><br><span class="line">tar -xf php-7.2.0.tar.bz2</span><br><span class="line">cd php-7.2.0</span><br><span class="line"></span><br><span class="line">./configure --prefix=/usr/local/php7/ \</span><br><span class="line">--with-fpm-user=nginx \</span><br><span class="line">--with-curl  --with-gd --with-gettext --with-iconv-dir --with-kerberos --with-libdir=lib64 \</span><br><span class="line">--with-libxml-dir --with-mysqli --with-openssl --with-pcre-regex --with-pdo-mysql \</span><br><span class="line">--with-pdo-sqlite --with-pear --with-png-dir --with-xmlrpc --with-xsl --with-zlib \</span><br><span class="line">--enable-fpm --enable-bcmath -enable-inline-optimization  --enable-mbregex --enable-mbstring \</span><br><span class="line">--enable-opcache --enable-pcntl --enable-shmop --enable-soap --enable-sockets --enable-sysvsem \</span><br><span class="line">--enable-xml --enable-zip --enable-pcntl --with-curl  --enable-ftp --enable-session --enable-xml \</span><br><span class="line">--with-freetype-dir --with-jpeg-dir --enable-calendar --enable-exif --with-readline --enable-sysvshm --enable-wddx</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>安装完成后，拷贝配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp php.ini-production /usr/local/php7/etc/php.ini</span><br><span class="line">cd /usr/local/php7/etc</span><br><span class="line">mv php-fpm.conf.default php-fpm.conf</span><br></pre></td></tr></table></figure>
<p>php编译好之后，提供了一个php-fpm的程序作为服务管理程序，位置在编译后的源码目录：<code>php-7.2.0/sapi/fpm/</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp php-fpm.service /usr/lib/systemd/system/</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start php-fpm</span><br></pre></td></tr></table></figure>

<h3 id="php-常用扩展安装方法"><a href="#php-常用扩展安装方法" class="headerlink" title="php 常用扩展安装方法"></a>php 常用扩展安装方法</h3><p>php 扩展优先选择使用 <code>pecl</code> 命令安装，需要特殊配置时再选择编译安装， <code>pecl</code> 安装 <code>redis</code> 扩展示例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pecl install redis</span><br></pre></td></tr></table></figure>

<h4 id="yac-扩展安装"><a href="#yac-扩展安装" class="headerlink" title="yac 扩展安装"></a>yac 扩展安装</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/laruence/yac</span><br><span class="line">cd yac</span><br><span class="line">phpize</span><br><span class="line">./configure --with-php-config=/usr/local/php7/bin/php-config</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h4 id="composer-安装"><a href="#composer-安装" class="headerlink" title="composer 安装"></a>composer 安装</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">php -r &quot;readfile(&#x27;https://getcomposer.org/installer&#x27;);&quot; | php</span><br><span class="line">mv composer.phar /usr/local/bin/composer</span><br></pre></td></tr></table></figure>

<h4 id="inotify-安装"><a href="#inotify-安装" class="headerlink" title="inotify 安装"></a>inotify 安装</h4><p>扩展<a href="http://pecl.php.net/package/inotify">下载地址</a><br>比如安装2.0.0版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://pecl.php.net/get/inotify-2.0.0.tgz</span><br><span class="line">tar -xf inotify-2.0.0.tgz</span><br><span class="line">phpize</span><br><span class="line">./configure --with-php-config=/usr/local/php7/bin/php-config --enable-inotify</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h4 id="memcache-扩展安装"><a href="#memcache-扩展安装" class="headerlink" title="memcache 扩展安装"></a>memcache 扩展安装</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install libmemcached libmemcached-devel     ##先按照依赖，否则make报错</span><br><span class="line">git clone https://github.com/php-memcached-dev/php-memcached.git php-memcache</span><br><span class="line">cd php-memcache/</span><br><span class="line">git checkout php7</span><br><span class="line">phpize</span><br><span class="line">./configure --enable-memcached --with-php-config=/usr/local/php7/bin/php-config</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p><code>php.ini</code> 中添加配置 <code>extension=memcached.so</code></p>
<h4 id="gd-扩展安装"><a href="#gd-扩展安装" class="headerlink" title="gd 扩展安装"></a>gd 扩展安装</h4><p>进入到php的源码目录下的ext&#x2F;gd目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd php-7.2.0/ext/gd</span><br><span class="line">yum -y install libjpeglibjpeg-devel libpng libpng-devel freetype freetype-devel</span><br><span class="line">make clean</span><br><span class="line">phpize</span><br><span class="line">./configure --with-png-dir --with-freetype-dir --with-jpeg-dir --with-gd --with-php-config=/usr/local/php7/bin/php-config</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p><code>php.ini</code> 中添加配置 <code>extension=gd.so</code></p>
<h4 id="mongodb-扩展安装"><a href="#mongodb-扩展安装" class="headerlink" title="mongodb 扩展安装"></a>mongodb 扩展安装</h4><p>扩展<a href="http://pecl.php.net/package/mongodb">下载地址</a>  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://pecl.php.net/get/mongodb-1.14.0.tgz</span><br><span class="line">tar -xf mongodb-1.14.0.tgz</span><br><span class="line">cd mongodb-1.14.0</span><br><span class="line">/usr/local/php7/bin/phpize</span><br><span class="line">./configure --with-php-config=/usr/local/php7/bin/php-config</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h4 id="imagick-扩展安装"><a href="#imagick-扩展安装" class="headerlink" title="imagick 扩展安装"></a>imagick 扩展安装</h4><p>首先安装ImageMagick</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://imagemagick.org/download/ImageMagick.tar.gz</span><br><span class="line">tar -xf ImageMagick.tar.gz</span><br><span class="line">cd ImageMagick</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>安装 <code>imagick</code> 扩展</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://pecl.php.net/get/imagick-3.4.4.tgz</span><br><span class="line">/usr/local/php7/bin/phpize </span><br><span class="line">./configure --with-php-config=/usr/local/php7/bin/php-config</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h4 id="trie-filter-扩展安装"><a href="#trie-filter-扩展安装" class="headerlink" title="trie_filter 扩展安装"></a>trie_filter 扩展安装</h4><p>安装依赖 <code>libdatrie</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -O ftp://linux.thai.net/pub/ThaiLinux/software/libthai/libdatrie-0.2.4.tar.gz</span><br><span class="line">tar zxvf libdatrie-0.2.4.tar.gz</span><br><span class="line">cd libdatrie-0.2.4</span><br><span class="line">make clean</span><br><span class="line">./configure --prefix=/usr/local/libdatrie</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>安装扩展 <code>trie_filter</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://github.com/jiopuud/trie_filter/archive/master.zip</span><br><span class="line">unzip master.zip</span><br><span class="line">cd trie_filter-master</span><br><span class="line">phpize</span><br><span class="line">./configure --with-php-config=/usr/local/php7/bin/php-config --with-trie_filter=/usr/local/libdatrie</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="swoole-扩展安装"><a href="#swoole-扩展安装" class="headerlink" title="swoole 扩展安装"></a>swoole 扩展安装</h4><p>安装依赖 <code>hiredis</code>（可选操作）<br><a href="https://github.com/redis/hiredis/releases">下载链接</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>安装 <code>woole</code> 扩展<br><a href="https://github.com/swoole/swoole-src/releases">下载地址</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xf swoole-src-1.9.15.tar.gz</span><br><span class="line">cd swoole-src-1.9.15</span><br><span class="line">phpize</span><br><span class="line">./configure --enable-openssl --enable-async-redis --with-php-config=/usr/local/php7/bin/php-config</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>--enable-async-redis</code> 依赖<code>hiredis</code>， 需要先安装 <code>hiredis</code><br>编译安装过程中，可能出现找不到动态链接库的问题，可将 <code>/usr/local/lib</code> 添加到共享的动态库，<br>编辑 <code>ldconfig</code> 配置文件 <code>/etc/ld.so.conf</code>，追加以下内容</p>
<figure class="highlight shell"><figcaption><span>/etc/ld.so.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">/usr/local/lib</span><br></pre></td></tr></table></figure>
<p>修改 <code>ldconfig</code> 配置后，执行以下命令使新配置生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ldconfig</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="phpredis-扩展安装"><a href="#phpredis-扩展安装" class="headerlink" title="phpredis 扩展安装"></a>phpredis 扩展安装</h4><p><a href="https://github.com/phpredis/phpredis/releases">下载地址</a>  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd phpredis/</span><br><span class="line">phpize</span><br><span class="line">./configure --with-php-config=/usr/local/php7/bin/php-config</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h3 id="php-fpm-常见配置"><a href="#php-fpm-常见配置" class="headerlink" title="php-fpm 常见配置"></a>php-fpm 常见配置</h3><h4 id="php-fpm-日志相关配置"><a href="#php-fpm-日志相关配置" class="headerlink" title="php-fpm 日志相关配置"></a>php-fpm 日志相关配置</h4><p><code>php-fpm</code> 全局错误日志配置默认位于 <code>etc/php-fpm.conf</code></p>
<figure class="highlight shell"><figcaption><span>etc/php-fpm.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">;;;;;;;;;;;;;;;;;;</span><br><span class="line">; Global Options ;</span><br><span class="line">;;;;;;;;;;;;;;;;;;</span><br><span class="line"></span><br><span class="line">[global]</span><br><span class="line">error_log = /var/log/php-fpm/error.log</span><br><span class="line"></span><br><span class="line">; Log level</span><br><span class="line">; Possible Values: alert, error, warning, notice, debug</span><br><span class="line">; Default Value: notice</span><br><span class="line">;log_level = notice</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>php-fpm</code> 默认相关 <code>pool</code> 日志配置主要位于 <code>etc/php-fpm.d/www.conf</code>。默认情况下，<code>pool</code> 中的日志（<code>stdout and stderr</code>） 会被重定向到 <code>/dev/null</code>。</p>
<p>如果需要将对应 <code>pool</code> 中的日志输出到全局错误日志配置的路径，需要配置 <code>catch_workers_output = yes</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">access.log = /var/log/php/www.access.log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">慢日志</span></span><br><span class="line">slowlog = /var/log/php/www.log.slow</span><br><span class="line">request_slowlog_timeout = 10</span><br><span class="line"></span><br><span class="line">; Redirect worker stdout and stderr into main error log. If not set, stdout and</span><br><span class="line">; stderr will be redirected to /dev/null according to FastCGI specs.</span><br><span class="line">; Note: on highloaded environement, this can cause some delay in the page</span><br><span class="line">; process time (several ms).</span><br><span class="line">; Default Value: no</span><br><span class="line">;catch_workers_output = yes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以下配置是对 php.ini 的补充，会在定义的 pool （比如 www） 中覆盖 php.ini 中的配置。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">否则为了记录日志，需要修改 php.ini 文件，增加以下配置</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># log_errors = On</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># error_log = &quot;/usr/local/php/var/log/error_log&quot;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># error_reporting=E_ALL&amp;~E_NOTICE</span></span></span><br><span class="line"></span><br><span class="line">php_flag[display_errors] = on</span><br><span class="line">php_admin_value[error_log] = /var/log/php-fpm/www-error.log</span><br><span class="line">php_admin_flag[log_errors] = on</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>predixy 安装配置</title>
    <url>/202207271506/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3></blockquote>
<ul>
<li>Centos 7</li>
<li>predixy-1.0.5</li>
</ul>
<blockquote>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3></blockquote>
<p><a href="https://github.com/joyieldInc/predixy">下载地址</a>, clone或下载最新的版本或指定版本下载后解压</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install libstdc++-static -y</span><br><span class="line">cd predixy-1.0.5</span><br><span class="line">make</span><br><span class="line">cp src/predixy /usr/local/bin/</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要依赖 <code>libstdc++-static</code>, 否则make会报错：<br>&#x2F;bin&#x2F;ld: cannot find -lstdc++<br>collect2: error: ld returned 1 exit status<br>make[1]: *** [predixy] Error 1<br>make[1]: Leaving directory &#96;&#x2F;root&#x2F;predixy-1.0.5&#x2F;src’<br>make: *** [default] Error 2</p>
</blockquote>
<blockquote>
<h3 id="配置文件说明"><a href="#配置文件说明" class="headerlink" title="配置文件说明"></a>配置文件说明</h3></blockquote>
<ul>
<li><p>predixy.conf，整体配置文件，会引用下面的配置文件</p>
</li>
<li><p>cluster.conf，用于Redis Cluster时，配置后端redis信息</p>
</li>
<li><p>sentinel.conf，用于Redis Sentinel时，配置后端redis信息</p>
</li>
<li><p>auth.conf，访问权限控制配置，可以定义多个验证密码，可每个密码指定读、写、管理权限，以及定义可访问的健空间</p>
</li>
<li><p>dc.conf，多数据中心支持，可以定义读写分离规则，读流量权重分配</p>
</li>
<li><p>latency.conf， 延迟监控规则定义，可以指定需要监控的命令以及延时时间间隔</p>
</li>
</ul>
<blockquote>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3></blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">predixy /predixy/conf/predixy.conf</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用默认的配置文件predixy.conf， predixy将监听地址0.0.0.0:7617，后端的redis是Redis Cluster 127.0.0.1:6379  </p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Predixy</tag>
      </tags>
  </entry>
  <entry>
    <title>prometheus 安装配置</title>
    <url>/202211221610/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos 7</li>
<li>Prometheus Server 2.4</li>
<li>Node Exporter v1.4.0</li>
<li>Grafana v9.2.5</li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="在-Docker-中安装-Prometheus-Server"><a href="#在-Docker-中安装-Prometheus-Server" class="headerlink" title="在 Docker 中安装 Prometheus Server"></a>在 Docker 中安装 Prometheus Server</h2><p>创建 Prometheus Server 配置文件，如 <code>/root/prometheus/prometheus.yml</code>，内容如下 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[安装Prometheus Server](https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/quickstart/prometheus-quick-start/install-prometheus-server)">[1]</span></a></sup></p>
<figure class="highlight shell"><figcaption><span>/data/prometheus/prometheus.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">my global config</span></span><br><span class="line">global:</span><br><span class="line">  scrape_interval:     15s # Set the scrape interval to every 15 seconds. Default is every 1 minute.</span><br><span class="line">  evaluation_interval: 15s # Evaluate rules every 15 seconds. The default is every 1 minute.</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">scrape_timeout is <span class="built_in">set</span> to the global default (10s).</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Alertmanager configuration</span></span><br><span class="line">alerting:</span><br><span class="line">  alertmanagers:</span><br><span class="line">  - static_configs:</span><br><span class="line">    - targets:</span><br><span class="line">      # - alertmanager:9093</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Load rules once and periodically evaluate them according to the global <span class="string">&#x27;evaluation_interval&#x27;</span>.</span></span><br><span class="line">rule_files:</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">- <span class="string">&quot;first_rules.yml&quot;</span></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">- <span class="string">&quot;second_rules.yml&quot;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">A scrape configuration containing exactly one endpoint to scrape:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Here it<span class="string">&#x27;s Prometheus itself.</span></span></span><br><span class="line">scrape_configs:</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.</span></span></span><br><span class="line">  - job_name: &#x27;prometheus&#x27;</span><br><span class="line"></span><br><span class="line">    # metrics_path defaults to &#x27;/metrics&#x27;</span><br><span class="line">    # scheme defaults to &#x27;http&#x27;.</span><br><span class="line"></span><br><span class="line">    static_configs:</span><br><span class="line">    - targets: [&#x27;localhost:9090&#x27;]</span><br></pre></td></tr></table></figure>
<p>使用 Docker 启动时挂载此文件，作为 Prometheus Server 的配置文件，之后需要修改配置，可以直接修改此文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 9090:9090 \</span><br><span class="line">           --name prometheus \</span><br><span class="line">           -v /root/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml \</span><br><span class="line">           prom/prometheus</span><br></pre></td></tr></table></figure>

<p>启动后，可以通过 <code>$Prometheus_IP:9090</code> 访问 Prometheus Server UI</p>
<span id="more"></span>
<h2 id="安装-Node-Exporter"><a href="#安装-Node-Exporter" class="headerlink" title="安装 Node Exporter"></a>安装 Node Exporter</h2><p>Node Exporter 同样采用 Golang 编写，并且不存在任何的第三方依赖，只需要下载，解压即可运行。<a href="https://prometheus.io/download/">获取最新的 node exporter 版本的二进制包</a>。<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[使用Node Exporter采集主机数据](https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/quickstart/prometheus-quick-start/use-node-exporter)">[2]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://github.com/prometheus/node_exporter/releases/download/v1.4.0/node_exporter-1.4.0.linux-amd64.tar.gz</span><br><span class="line">tar -xf node_exporter-1.4.0.linux-amd64.tar.gz</span><br><span class="line">cd node_exporter-1.4.0.linux-amd64</span><br><span class="line">cp node_exporter /usr/bin/</span><br></pre></td></tr></table></figure>
<p>运行 Node Exporter</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">node_exporter</span></span><br><span class="line">...</span><br><span class="line">ts=2022-11-22T08:29:20.717Z caller=node_exporter.go:199 level=info msg=&quot;Listening on&quot; address=:9100</span><br><span class="line">ts=2022-11-22T08:29:20.717Z caller=tls_config.go:195 level=info msg=&quot;TLS is disabled.&quot; http2=false</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>启动成功后，可以看到以下输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">INFO[0000] Listening on :9100                            source=&quot;node_exporter.go:76&quot;</span><br></pre></td></tr></table></figure>
<p>访问 <code>http://localhost:9100/metrics</code>，可以看到当前 node exporter 获取到的当前主机的所有监控数据，如下所示：<br><img src="https://i.csms.tech/img_93.png"></p>
<h2 id="配置-Prometheus-Server-从-Node-Exporter-收集数据"><a href="#配置-Prometheus-Server-从-Node-Exporter-收集数据" class="headerlink" title="配置 Prometheus Server 从 Node Exporter 收集数据"></a>配置 Prometheus Server 从 Node Exporter 收集数据</h2><p>为了能够让 Prometheus Server 能够从当前 node exporter 获取到监控数据，需要修改 Prometheus Server 配置文件。编辑 <code>prometheus.yml</code> 并在 <code>scrape_configs</code> 节点下添加以下内容 : <sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[从Node Exporter收集监控数据](https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/quickstart/prometheus-quick-start/use-node-exporter#cong-node-exporter-shou-ji-jian-kong-shu-ju)">[3]</span></a></sup></p>
<figure class="highlight shell"><figcaption><span>prometheus.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">scrape_configs:</span><br><span class="line">  - job_name: &#x27;prometheus&#x27;</span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [&#x27;localhost:9090&#x27;]</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">采集 node exporter 监控数据</span></span><br><span class="line">  - job_name: &#x27;test node&#x27;</span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [&#x27;172.17.0.3:9100&#x27;]</span><br></pre></td></tr></table></figure>
<p>重启 Prometheus Server</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker restart prometheus</span><br></pre></td></tr></table></figure>

<h2 id="配置-Grafana-可视化-Prometheus-监控数据"><a href="#配置-Grafana-可视化-Prometheus-监控数据" class="headerlink" title="配置 Grafana 可视化 Prometheus 监控数据"></a>配置 Grafana 可视化 Prometheus 监控数据</h2><p>启动 Grafana <sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[监控数据可视化](https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/quickstart/prometheus-quick-start/use-grafana-create-dashboard)">[4]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name grafana -d -p 3000:3000 grafana/grafana</span><br></pre></td></tr></table></figure>
<p>默认情况下使用账户 <code>admin/admin</code> 进行登录</p>
<h3 id="添加-DATA-SOURCES"><a href="#添加-DATA-SOURCES" class="headerlink" title="添加 DATA SOURCES"></a>添加 DATA SOURCES</h3><p>这里将添加 Prometheus 作为默认的数据源，如下图所示，指定数据源类型为 Prometheus 并且设置 Prometheus 的访问地址即可，在配置正确的情况下点击 <code>Add</code> 按钮，会提示连接成功的信息<br><img src="https://i.csms.tech/img_94.png"></p>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/quickstart/prometheus-quick-start/install-prometheus-server">安装Prometheus Server</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/quickstart/prometheus-quick-start/use-node-exporter">使用Node Exporter采集主机数据</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/quickstart/prometheus-quick-start/use-node-exporter#cong-node-exporter-shou-ji-jian-kong-shu-ju">从Node Exporter收集监控数据</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/quickstart/prometheus-quick-start/use-grafana-create-dashboard">监控数据可视化</a><a href="#fnref:4" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Tools</category>
        <category>prometheus</category>
      </categories>
      <tags>
        <tag>prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>Pycharm 常用配置</title>
    <url>/202208041319/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>PyCharm 2022.1 (Professional Edition)</li>
</ul>
<h1 id="常见配置"><a href="#常见配置" class="headerlink" title="常见配置"></a>常见配置</h1><h2 id="快速插入时间"><a href="#快速插入时间" class="headerlink" title="快速插入时间"></a>快速插入时间</h2><p>通过配置 <code>Live Template</code> 实现快速插入时间  </p>
<ol>
<li><p>打开 File &gt; Setting &gt; Editor: Live Templates</p>
</li>
<li><p>选中常用的语言，比如 <code>Python</code>，点击右上角的 <code>+</code>，添加 <code>Live Template</code><br> <code>Abbreviation</code> 输入快捷输入的名称，比如 <code>currentTime</code><br> <code>Description</code> 输入描述信息<br> <code>Template Text</code> 输入 <code>$time$</code><br> <img src="https://i.csms.tech/img_32.png"></p>
</li>
<li><p>点击 <code>Edit Variables</code> 配置命令及格式<br> <img src="https://i.csms.tech/img_33.png"></p>
</li>
<li><p><code>Define</code> 选择 <code>Everywhere</code>，<code>Apply</code>让配置生效</p>
</li>
<li><p>编辑时输入 <code>currentTime</code>,可以直接插入当前时间<br> <img src="https://i.csms.tech/img_34.png"></p>
</li>
</ol>
<h2 id="配置-git-仓库"><a href="#配置-git-仓库" class="headerlink" title="配置 git 仓库"></a>配置 git 仓库</h2><ol>
<li><p>打开 <code>File</code> -&gt; <code>Settings</code> -&gt; <code>Version Control</code> -&gt; <code>Git</code>，在 <code>Path to Git executable</code> 处选择 git 的安装位置。配置完成之后，点击<code>【Test】</code>按钮，如果成功，则会显示 Git 版本信息<br><img src="https://i.csms.tech/img_114.png"></p>
</li>
<li><p>点击 <code>VCS</code> -&gt; <code>Get from Version Control</code>，输入 Git 仓库的地址和本地目录。<br><img src="https://i.csms.tech/img_115.png"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>PyCharm</category>
      </categories>
      <tags>
        <tag>PyCharm</tag>
      </tags>
  </entry>
  <entry>
    <title>python 操作日期及时间</title>
    <url>/202301231137/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Python 3.10</li>
</ul>
<h1 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h1><h2 id="获取前一天所属月份"><a href="#获取前一天所属月份" class="headerlink" title="获取前一天所属月份"></a>获取前一天所属月份</h2><h3 id="arrow-模块获取"><a href="#arrow-模块获取" class="headerlink" title="arrow 模块获取"></a>arrow 模块获取</h3><p>以下示例使用 <code>arrow</code> 模块获取前一天所属月份 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[时间日期相关操作](https://developer.aliyun.com/article/673245)">[1]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install arrow</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; a = arrow.now() <span class="comment"># 当前本地时间</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; a.shift(months=-1).format(<span class="string">&quot;YYYYMM&quot;</span>)</span></span><br><span class="line">&#x27;202212&#x27;</span><br></pre></td></tr></table></figure>

<p>指定参数 <code>months = -1</code> 就可以计算前一个月的时间。往后一个月就是 <code>month=+1</code>，<code>format</code> 指定时间格式。</p>
<h2 id="获取前一个月的天数"><a href="#获取前一个月的天数" class="headerlink" title="获取前一个月的天数"></a>获取前一个月的天数</h2><p>通过模块 <code>calendar</code> 获取 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import calendar</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取 2022-1 月份的天数，输出 tuple ，由此月的第一天是星期几和此月的天数构成。</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; calendar.monthrange(2022,1)</span></span><br><span class="line">(5, 31)</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="时间转换为时间戳"><a href="#时间转换为时间戳" class="headerlink" title="时间转换为时间戳"></a>时间转换为时间戳</h2><h3 id="time-模块"><a href="#time-模块" class="headerlink" title="time 模块"></a>time 模块</h3><p>使用 <code>time</code> 模块将指定格式的时间，转为时间戳</p>
<figure class="highlight shell"><figcaption><span>python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import time</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; t = <span class="string">&quot;2022-12-01 00:00:00&quot;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 使用 time.strptime 将指定的时间 t 转换为时间数组</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; timeArray = time.strptime(t, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; timeArray</span></span><br><span class="line">time.struct_time(tm_year=2022, tm_mon=12, tm_mday=1, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=3, tm_yday=335, tm_isdst=-1)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; timestamp = time.mktime(timeArray)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; timestamp</span></span><br><span class="line">1669852800.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://developer.aliyun.com/article/673245">时间日期相关操作</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python dict 使用</title>
    <url>/202301101011/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Python3.10</li>
</ul>
<h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><h2 id="删除-key"><a href="#删除-key" class="headerlink" title="删除 key"></a>删除 key</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scores = &#123;&#x27;语文&#x27;: 89&#125;</span><br><span class="line">scores[&#x27;数学&#x27;] = 93</span><br><span class="line">scores[92] = 5.7</span><br><span class="line"></span><br><span class="line">del scores[&#x27;语文&#x27;]</span><br><span class="line">del scores[&#x27;数学&#x27;]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除指定的 key，并返回 key 对应的值；如果 key 不存在，返回异常：KeyError，可查看 <span class="built_in">help</span>(dict)</span></span><br><span class="line">scores.pop(92)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除最后一个 key-value，并以元组的形式返回 (key, value)</span></span><br><span class="line">scores.popitem()</span><br></pre></td></tr></table></figure>

<h2 id="清空-dict"><a href="#清空-dict" class="headerlink" title="清空 dict"></a>清空 dict</h2><p><code>clear()</code> 用于清空字典中所有的 key-value 对，对一个字典执行 clear() 方法之后，该字典就会变成一个空字典</p>
<h2 id="更新-dict"><a href="#更新-dict" class="headerlink" title="更新 dict"></a>更新 dict</h2><p><code>update()</code> 方法可使用一个字典所包含的 key-value 对来更新己有的字典。在执行 <code>update()</code> 方法时，如果被更新的字典中己包含对应的 key-value 对，那么原 value 会被覆盖；如果被更新的字典中不包含对应的 key-value 对，则该 key-value 对被添加进去；原来的 <code>dict</code> 中存在（更新中不存在）的 key-value 保持不变。</p>
<span id="more"></span>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python 中 json 格式</title>
    <url>/202301201605/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Python3.10</li>
</ul>
<p>Python 中操作 json 相关格式，主要使用模块 <code>json</code></p>
<h1 id="Python-数据类型转换为-json-格式"><a href="#Python-数据类型转换为-json-格式" class="headerlink" title="Python 数据类型转换为 json 格式"></a>Python 数据类型转换为 json 格式</h1><p>python 数据类型转换为 json ，主要使用方法 <code>dumps()</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; adict = &#123;<span class="string">&#x27;a&#x27;</span>: 1, <span class="string">&#x27;b&#x27;</span>: <span class="string">&#x27;st&#x27;</span>&#125;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; json.dumps(adict)</span></span><br><span class="line">&#x27;&#123;&quot;a&quot;: 1, &quot;b&quot;: &quot;st&quot;&#125;&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; alist = [1,2,3,4]</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; json.dumps(alist)</span></span><br><span class="line">&#x27;[1, 2, 3, 4]&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="json-格式转换为-Python-数据类型"><a href="#json-格式转换为-Python-数据类型" class="headerlink" title="json 格式转换为 Python 数据类型"></a>json 格式转换为 Python 数据类型</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; ajson = <span class="string">&#x27;[1, 2, 3, 4]&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">type</span>(ajson)</span></span><br><span class="line">&lt;class &#x27;str&#x27;&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; json.load(ajson)</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;console&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;/usr/local/lib/python3.10/json/__init__.py&quot;, line 293, in load</span><br><span class="line">    return loads(fp.read(),</span><br><span class="line">AttributeError: &#x27;str&#x27; object has no attribute &#x27;read&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; json.loads(ajson)</span></span><br><span class="line">[1, 2, 3, 4]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; bjson = <span class="string">&#x27;&#123;&quot;a&quot;: 1, &quot;b&quot;: &quot;st&quot;&#125;&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">type</span>(bjson)</span></span><br><span class="line">&lt;class &#x27;str&#x27;&gt;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; json.loads(bjson)</span></span><br><span class="line">&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: &#x27;st&#x27;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<span id="more"></span>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python 代码性能分析工具</title>
    <url>/202301261101/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>python 3.10</li>
</ul>
<h1 id="pyinstrument-使用"><a href="#pyinstrument-使用" class="headerlink" title="pyinstrument 使用"></a>pyinstrument 使用</h1><p><code>pyinstrument</code> 可以快速找到代码运行最慢的部分，帮助提高代码的性能。支持 Python 3.7+ 且能够分析异步代码，仅需一条命令即可显示具体代码的耗时 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[如何快速定位 Python 运行最慢的代码](https://jishuin.proginn.com/p/763bfbd66eae)">[1]</span></a></sup></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install pyinstrument</span><br></pre></td></tr></table></figure>

<h2 id="命令行使用"><a href="#命令行使用" class="headerlink" title="命令行使用"></a>命令行使用</h2><p>在无需更改代码的情况下，直接通过命令行使用 <code>pyinstrument</code> 分析目标代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pyinstrument main.py</span></span><br></pre></td></tr></table></figure>

<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://jishuin.proginn.com/p/763bfbd66eae">如何快速定位 Python 运行最慢的代码</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python3 requests 库使用</title>
    <url>/202302011011/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>python3.10</li>
</ul>
<h1 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h1><p>基础用法可以查看系统帮助信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">help</span>(requests)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>requests</code> 发送请求时，会自动创建 <code>requests.Request</code>，因此发送请求时如果需要发送更多数据，可以查看 <code>Request</code> 类的帮助信息，或者查看 <code>requests.models</code> 获取更多帮助信息，如 <code>headers</code>，<code>files</code> 等</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">help</span>(requests.Request)</span></span><br></pre></td></tr></table></figure>
<p>例如发送请求时需要添加头部信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; headers = &#123;<span class="string">&#x27;Authorization&#x27;</span>: token, <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Python&#x27;</span>&#125;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; r = requests.get(<span class="string">&#x27;https://api.cdn77.com/v3/cdn&#x27;</span>, headers=headers)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; r.text</span></span><br></pre></td></tr></table></figure>

<p><code>Request</code> 请求的响应是 ‘requests.models.Response’ 对象的实例。获取 <code>Response</code> 帮助，可以查看以下内容 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">help</span>(requests.models.Response)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">help</span>(requests.Response)</span></span><br></pre></td></tr></table></figure>

<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python requirements 的创建及使用</title>
    <url>/202208161710/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Python 3.10</li>
</ul>
<p><code>python</code> 项目中最好包含一个 <code>requirements.txt</code> 文件，用于记录所有依赖包及其精确的版本号。以便新环境部署。</p>
<span id="more"></span>

<h3 id="requirements-生成和使用"><a href="#requirements-生成和使用" class="headerlink" title="requirements 生成和使用"></a>requirements 生成和使用</h3><p>在项目中安装新的包之后，可以运行以下命令更新 <code>requirements</code> 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure>
<p><code>requirements.txt</code> 文件内容示例：</p>
<figure class="highlight shell"><figcaption><span>requirements.txt</span></figcaption><table><tr><td class="code"><pre><span class="line">asgiref==3.5.2</span><br><span class="line">Django==4.0</span><br><span class="line">django-mdeditor==0.1.20</span><br><span class="line">Markdown==3.3.7</span><br><span class="line">Pillow==9.2.0</span><br><span class="line">Pygments==2.12.0</span><br><span class="line">PyMySQL==1.0.2</span><br><span class="line">sqlparse==0.4.2</span><br><span class="line">uWSGI==2.0.20</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>生成的文件中会包含项目需要的所有包以及精确的版本号信息，新环境部署时，可使用以下命令安装依赖包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python 执行 shell 命令</title>
    <url>/202301201542/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Python3.10</li>
</ul>
<h1 id="Python-执行-shell-命令"><a href="#Python-执行-shell-命令" class="headerlink" title="Python 执行 shell 命令"></a>Python 执行 shell 命令</h1><h2 id="subprocess-模块"><a href="#subprocess-模块" class="headerlink" title="subprocess 模块"></a>subprocess 模块</h2><p><code>subprocess.check_output()</code> 执行一个外部命令并以Python字符串的形式获取执行结果 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[执行外部命令并获取它的输出](https://python3-cookbook-personal.readthedocs.io/zh_CN/latest/c13/p06_executing_external_command_and_get_its_output.html#id1)">[1]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">import subprocess</span><br><span class="line">out_bytes = subprocess.check_output([&#x27;netstat&#x27;,&#x27;-a&#x27;])</span><br></pre></td></tr></table></figure>
<p>如果你需要文本形式返回，加一个解码步骤即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">out_text = out_bytes.decode(&#x27;utf-8&#x27;)</span><br></pre></td></tr></table></figure>
<p>如果被执行的命令以非零码返回，就会抛出异常。 下面的例子捕获到错误并获取返回码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    out_bytes = subprocess.check_output([&#x27;cmd&#x27;,&#x27;arg1&#x27;,&#x27;arg2&#x27;])</span><br><span class="line">except subprocess.CalledProcessError as e:</span><br><span class="line">    out_bytes = e.output       # Output generated before error</span><br><span class="line">    code      = e.returncode   # Return code</span><br></pre></td></tr></table></figure>

<p>默认情况下，<code>check_output()</code> 仅仅返回输入到标准输出的值。 如果你需要同时收集标准输出和错误输出，使用 <code>stderr</code> 参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">out_bytes = subprocess.check_output([&#x27;cmd&#x27;,&#x27;arg1&#x27;,&#x27;arg2&#x27;],</span><br><span class="line">                                    stderr=subprocess.STDOUT)</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://python3-cookbook-personal.readthedocs.io/zh_CN/latest/c13/p06_executing_external_command_and_get_its_output.html#id1">执行外部命令并获取它的输出</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python 虚拟环境</title>
    <url>/202208161730/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Python 3.10</li>
</ul>
<h3 id="虚拟环境创建步骤"><a href="#虚拟环境创建步骤" class="headerlink" title="虚拟环境创建步骤"></a>虚拟环境创建步骤</h3><p>假定项目名为 <code>project01</code>, 目录名为 <code>project01</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir project01</span><br><span class="line">cd project01</span><br><span class="line">python3 -m venv .</span><br></pre></td></tr></table></figure>
<p>以上命令会在目录 <code>project01</code> 中创建虚拟环境，查看当前目录，会产生以下目录和文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">bin  include  lib  lib64  pyvenv.cfg</span><br></pre></td></tr></table></figure>
<p>观察 <code>bin</code> 目录的内容，里面有 <code>python3</code>、<code>pip3</code> 等可执行文件，实际上是链接到 <code>Python</code> 系统目录的软链接。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l bin/</span></span><br><span class="line">total 36</span><br><span class="line">-rw-r--r-- 1 root root 1991 Aug 16 17:35 activate</span><br><span class="line">-rw-r--r-- 1 root root  917 Aug 16 17:35 activate.csh</span><br><span class="line">-rw-r--r-- 1 root root 2059 Aug 16 17:35 activate.fish</span><br><span class="line">-rw-r--r-- 1 root root 9033 Aug 16 17:35 Activate.ps1</span><br><span class="line">-rwxr-xr-x 1 root root  234 Aug 16 17:35 pip</span><br><span class="line">-rwxr-xr-x 1 root root  234 Aug 16 17:35 pip3</span><br><span class="line">-rwxr-xr-x 1 root root  234 Aug 16 17:35 pip3.10</span><br><span class="line">lrwxrwxrwx 1 root root   10 Aug 16 17:35 python -&gt; python3.10</span><br><span class="line">lrwxrwxrwx 1 root root   10 Aug 16 17:35 python3 -&gt; python3.10</span><br><span class="line">lrwxrwxrwx 1 root root   25 Aug 16 17:35 python3.10 -&gt; /usr/local/bin/python3.10</span><br></pre></td></tr></table></figure>

<p><code>Linux</code> 环境使用以下命令激活虚拟环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">source</span> bin/activate</span></span><br><span class="line">(project01) [root@localhost project01]#</span><br></pre></td></tr></table></figure>
<p>命令提示符变了，有个 <code>(project01)</code> 前缀，表示当前环境是一个名为 <code>project01</code> 的 Python 环境。<br>在此虚拟环境中安装包，都会被安装到 <code>(project01)</code> 环境下，具体目录为 <code>project01/lib/python3.10/site-packages/</code>，系统 Python 环境不受任何影响，也就是说，<code>project01</code> 这个环境是专门针对 <code>project01</code> 应用（项目）创建的，和系统 python 环境或其他应用互不影响。  </p>
<p>要退出当前虚拟环境，可以执行以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure>
<p>退出虚拟环境后，再执行如 <code>pip3 install</code> 命令安装的包，会安装到系统 Python 环境。<br>完全可以针对每个应用创建独立的Python运行环境，这样就可以对每个应用的Python环境进行隔离。</p>
<p>如果不再使用某个 <code>venv</code> ，例如 <code>project01</code>，删除它也很简单。首先确认该 <code>venv</code> 没有处于 <code>激活</code> 状态，然后直接把整个目录 <code>project01</code> 删掉就行。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Rancher 安装及使用</title>
    <url>/202210071716/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h2><ul>
<li>centos7 3.10.0</li>
<li>kubernetes Server Version: v1.21.2</li>
<li>Helm 3.10.0</li>
<li>Rancher 2.6</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://docs.ranchermanager.rancher.io/zh/pages-for-subheaders/install-upgrade-on-a-kubernetes-cluster">官方安装文档</a></p>
<h3 id="安装-Helm"><a href="#安装-Helm" class="headerlink" title="安装 Helm"></a>安装 Helm</h3><p><a href="https://helm.sh/docs/intro/install/">安装文档官网参考</a></p>
<a href="/202210071543/" title="helm 安装及使用">helm 安装及使用</a>

<h3 id="安装-Ingress-nginx-controller"><a href="#安装-Ingress-nginx-controller" class="headerlink" title="安装 Ingress-nginx-controller"></a>安装 Ingress-nginx-controller</h3><p><a href="https://kubernetes.github.io/ingress-nginx/deploy/#quick-start">安装文档官网参考</a></p>
<a href="/202209301604/" title="ingress-nginx 安装配置">ingress-nginx 安装配置</a>

<span id="more"></span>

<h3 id="添加-Helm-Chart-仓库"><a href="#添加-Helm-Chart-仓库" class="headerlink" title="添加 Helm Chart 仓库"></a>添加 Helm Chart 仓库</h3><p>添加最新版本，生产环境建议使用稳定版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">helm repo add rancher-latest https://releases.rancher.com/server-charts/latest</span><br></pre></td></tr></table></figure>

<h3 id="为-Rancher-创建命名空间"><a href="#为-Rancher-创建命名空间" class="headerlink" title="为 Rancher 创建命名空间"></a>为 Rancher 创建命名空间</h3><p>你需要定义一个 Kubernetes 命名空间，用于安装由 Chart 创建的资源。这个命名空间的名称为 <code>cattle-system</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create namespace cattle-system</span><br></pre></td></tr></table></figure>

<h3 id="安装-cert-manager"><a href="#安装-cert-manager" class="headerlink" title="安装 cert-manager"></a>安装 cert-manager</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.7.1/cert-manager.crds.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加 Jetstack Helm 仓库</span></span><br><span class="line">helm repo add jetstack https://charts.jetstack.io</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新本地 Helm Chart 仓库缓存</span></span><br><span class="line">helm repo update</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 cert-manager Helm Chart</span></span><br><span class="line">helm install cert-manager jetstack/cert-manager \</span><br><span class="line">  --namespace cert-manager \</span><br><span class="line">  --create-namespace \</span><br><span class="line">  --version v1.7.1</span><br></pre></td></tr></table></figure>
<p>安装完 <code>cert-manager</code> 后，你可以通过检查 <code>cert-manager</code> 命名空间中正在运行的 <code>Pod</code> 来验证它是否已正确部署：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods -n cert-manager</span></span><br><span class="line">NAME                                      READY   STATUS    RESTARTS   AGE</span><br><span class="line">cert-manager-5b97785fbd-vvscn             1/1     Running   0          77s</span><br><span class="line">cert-manager-cainjector-c8657d84f-6b8qr   1/1     Running   0          77s</span><br><span class="line">cert-manager-webhook-8564679744-hjgkx     1/1     Running   0          77s</span><br></pre></td></tr></table></figure>
<h3 id="通过-Helm-安装-Rancher"><a href="#通过-Helm-安装-Rancher" class="headerlink" title="通过 Helm 安装 Rancher"></a>通过 Helm 安装 Rancher</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">helm install rancher rancher-stable/rancher --namespace cattle-system \</span><br><span class="line">     --set hostname=rancher.my.com --set bootstrapPassword=admin \</span><br><span class="line">     --set ingress.ingressClassName=nginx</span><br></pre></td></tr></table></figure>
<p>安装成功后，输出结果如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NAME: rancher</span><br><span class="line">LAST DEPLOYED: Wed Oct 12 10:22:25 2022</span><br><span class="line">NAMESPACE: cattle-system</span><br><span class="line">STATUS: deployed</span><br><span class="line">REVISION: 1</span><br><span class="line">TEST SUITE: None</span><br><span class="line">NOTES:</span><br><span class="line">Rancher Server has been installed.</span><br><span class="line"></span><br><span class="line">NOTE: Rancher may take several minutes to fully initialize. Please standby while Certificates are being issued, Containers are started and the Ingress rule comes up.</span><br><span class="line"></span><br><span class="line">Check out our docs at https://rancher.com/docs/</span><br><span class="line"></span><br><span class="line">If you provided your own bootstrap password during installation, browse to https://rancher.my.com to get started.</span><br><span class="line"></span><br><span class="line">If this is the first time you installed Rancher, get started by running this command and clicking the URL it generates:</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">echo https://rancher.my.com/dashboard/?setup=$(kubectl get secret --namespace cattle-system bootstrap-secret -o go-template=&#x27;&#123;&#123;.data.bootstrapPassword|base64decode&#125;&#125;&#x27;)</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">To get just the bootstrap password on its own, run:</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">kubectl get secret --namespace cattle-system bootstrap-secret -o go-template=&#x27;&#123;&#123;.data.bootstrapPassword|base64decode&#125;&#125;&#123;&#123; &quot;\n&quot; &#125;&#125;&#x27;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Happy Containering!</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>根据提示，浏览器中访问 <code>https://rancher.my.com/dashboard/?setup=admin</code>，正常情况下，显示如下页面<br><img src="https://i.csms.tech/img_62.png"></p>
<p>根据页面提示，保持密码，登陆。</p>
<h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><h3 id="helm-版本不支持最新的-kubernetes-版本"><a href="#helm-版本不支持最新的-kubernetes-版本" class="headerlink" title="helm 版本不支持最新的 kubernetes 版本"></a>helm 版本不支持最新的 kubernetes 版本</h3><p>使用 <code>helm</code> 命令报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">helm install rancher rancher-stable/rancher --namespace cattle-system --<span class="built_in">set</span> hostname=rancher.my.org --<span class="built_in">set</span> bootstrapPassword=admin</span></span><br><span class="line">Error: INSTALLATION FAILED: chart requires kubeVersion: &lt; 1.25.0-0 which is incompatible with Kubernetes v1.25.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最新版本 <code>helm</code> 不支持最新版本的 <code>Kubernetes</code>，需按照 <code>helm</code> 提示使用 <a href="https://helm.sh/zh/docs/topics/version_skew/">相应版本</a></p>
<h2 id="常见配置"><a href="#常见配置" class="headerlink" title="常见配置"></a>常见配置</h2><h3 id="权限管理配置"><a href="#权限管理配置" class="headerlink" title="权限管理配置"></a>权限管理配置</h3><h4 id="配置只读-Role"><a href="#配置只读-Role" class="headerlink" title="配置只读 Role"></a>配置只读 Role</h4><p>本示例在 Rancher 上配置有对 Pod 只读权限的 Role，确保绑定了 Role 的用户可以通过 Rancher 读取到 Pod 信息，可以 <code>exec</code> 到 Pod，查看 Pod 日志，无其他 <strong>修改</strong> 权限。</p>
<ol>
<li><p>在 Rancher 上创建具有对 Pod 只读权限的 Role，本示例中为其命名 <code>PodReadOnlyRole</code></p>
<p> 在全局面板中进入 <code>Users &amp; Authentication</code>，选择 <code>Roles</code><br> <img src="https://i.csms.tech/img_87.png"><br> 选择 <code>Project/Namespaces</code><br> <img src="https://i.csms.tech/img_88.png"><br> 点击 <code>Create Project/Namespaces Role</code>，创建 Role，按照下图，填入对应信息<br> <img src="https://i.csms.tech/img_89.png"><br> 需要添加的 <code>Resource</code> 如下：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pods </span><br><span class="line">pods/attach </span><br><span class="line">pods/exec </span><br><span class="line">pods/portforward </span><br><span class="line">pods/proxy </span><br><span class="line">pods/log </span><br><span class="line">pods/status</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>权限选择：<code>get</code>，<code>list</code>，<code>watch</code>。填写完成后点击 <code>Create</code> 创建，无误后会创建 Role : <code>PodReadOnlyRole</code></p>
</li>
<li><p>创建用户</p>
<p> 在全局面板中进入 <code>Users &amp; Authentication</code>，选择 <code>Users</code>，创建新用户。<br> <img src="https://i.csms.tech/img_90.png"><br> 在 <code>Global Permissions</code> 中，选择系统预设的 Global Role ： <code>User-Base</code>，此角色仅拥有登陆系统的权限。</p>
</li>
<li><p>绑定 User 和 Project&#x2F;Namespaces Role</p>
<p> Rancher 仅支持对 Rancher 中的 <code>Project</code> 分配 <code>Project/Namespaces Role</code>，所以为了分配权限，需要对不同的项目创建对应的 <code>Project</code>。</p>
<p> 进入对应的 Cluster，选择要分配权限的 <code>Project</code>，点击 <code>Edit Config</code><br> <img src="https://i.csms.tech/img_91.png"><br> 在 <code>Members</code> 中选择 <code>Add</code> 为 <code>Project</code> 绑定 <code>User</code> 和 <code>Project Permissions</code>，本示例中，权限选择 <code>PodReadOnlyRole</code><br> <img src="https://i.csms.tech/img_92.png"></p>
</li>
</ol>
<p>通过以上步骤创建及分配权限后，通过新创建的用户登陆 Rancher，检查新用户对 Pod 的权限。</p>
<h3 id="Rancher-新增访问域名"><a href="#Rancher-新增访问域名" class="headerlink" title="Rancher 新增访问域名"></a>Rancher 新增访问域名</h3><p>为 Rancher web UI 新增其他可访问域名，参考以下步骤</p>
<ol>
<li><p>使用 <code>cert-manager</code> 为新增域名申请证书</p>
<a href="/202301050935/" title="使用 cert-manager 申请证书的步骤">使用 cert-manager 申请证书的步骤</a></li>
<li><p>修改 Rancher 的 Ingress 配置，添加新域名及证书到 Ingress</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> spec:</span><br><span class="line">ingressClassName: nginx</span><br><span class="line">rules:</span><br><span class="line">- host: rancher.test.com</span><br><span class="line">  http:</span><br><span class="line">    paths:</span><br><span class="line">    - backend:</span><br><span class="line">        service:</span><br><span class="line">          name: rancher</span><br><span class="line">          port:</span><br><span class="line">            number: 80</span><br><span class="line">      pathType: ImplementationSpecific</span><br><span class="line">- host: rancher1.test.com</span><br><span class="line">  http:</span><br><span class="line">    paths:</span><br><span class="line">    - backend:</span><br><span class="line">        service:</span><br><span class="line">          name: rancher</span><br><span class="line">          port:</span><br><span class="line">            number: 80</span><br><span class="line">      pathType: ImplementationSpecific</span><br><span class="line">tls:</span><br><span class="line">- hosts:</span><br><span class="line">  - rancher.test.com</span><br><span class="line">  secretName: tls-rancher-ingress</span><br><span class="line">- hosts:</span><br><span class="line">  - rancher1.test.com</span><br><span class="line">  secretName: rancher1-test-com</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="nginx-反代-Rancher"><a href="#nginx-反代-Rancher" class="headerlink" title="nginx 反代 Rancher"></a>nginx 反代 Rancher</h3><p>在集群外部通过 Nginx 反代访问 Rancher，可以使用以下 Nginx 配置 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[配置 NGINX 负载均衡](https://docs.rancher.cn/docs/rancher2.5/installation/resources/k8s-tutorials/infrastructure-tutorials/nginx/_index/)">[1]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">map $http_upgrade $connection_upgrade &#123;</span><br><span class="line">        default upgrade;</span><br><span class="line">        &#x27;&#x27;      close;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用来对 用户 ip 进行映射，以便后面做访问控制</span>    </span><br><span class="line">map $http_x_forwarded_for $k8s_admin_access &#123;</span><br><span class="line">         default false;</span><br><span class="line">         include k8s_admin_access.list;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">upstream rancher &#123;</span><br><span class="line">    server 172.31.27.193:443;</span><br><span class="line">    server 172.31.23.72:443;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">	listen 443 ssl;</span><br><span class="line">	server_name rancher.test.com;</span><br><span class="line">	access_log /home/logs/nginx/access/rancher.access.log main;</span><br><span class="line">	error_log /home/logs/nginx/error/rancher.error.log;	</span><br><span class="line"></span><br><span class="line">	ssl_certificate test.com.pem;</span><br><span class="line">    ssl_certificate_key test.com.pem;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	location / &#123;</span><br><span class="line">                if ($k8s_admin_access = false) &#123;</span><br><span class="line">                    return 403;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">		proxy_pass https://rancher;      # 本示例中，rancher 使用 https 访问，必须配置为 https</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header REMOTE-HOST $remote_addr;</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">        proxy_set_header Connection $connection_upgrade;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://docs.rancher.cn/docs/rancher2.5/installation/resources/k8s-tutorials/infrastructure-tutorials/nginx/_index/">配置 NGINX 负载均衡</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>k8s</tag>
        <tag>Rancher</tag>
      </tags>
  </entry>
  <entry>
    <title>rsyncd 服务</title>
    <url>/36f703dc/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync [OPTION]... SRC DEST</span><br><span class="line">rsync [OPTION]... SRC [USER@]host:DEST</span><br><span class="line">rsync [OPTION]... [USER@]HOST:SRC DEST</span><br><span class="line">rsync [OPTION]... [USER@]HOST::SRC DEST</span><br><span class="line">rsync [OPTION]... SRC [USER@]HOST::DEST</span><br><span class="line">rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST]</span><br></pre></td></tr></table></figure>

<p><code>:</code>   ssh 方式进行备份，ssh 非默认端口使用选项 <code>-e</code> 指定端口, <code>-e &#39;ssh -p 30000&#39;</code></p>
<p><code>::</code>   socket 方式进行备份，<code>rsync</code> 以服务方式监听，<code>SRC/DEST</code> 为配置中定义的模块 <code>[]</code></p>
<blockquote>
<ul>
<li><code>rsync</code> 命令使用中，如果源参数的末尾有斜线，只会复制指定目录的内容，而不复制目录本身，没有斜线，则会复制目录本身，包括目录</li>
<li>客户端免密登录时，需要在客户端建立密码文件： <code>/etc/rsync.passwd</code>，文件中只保存密码，权限为600，用选项 <code>--password-file</code> 指明存放密码的文件位置</li>
</ul>
</blockquote>
<span id="more"></span>

<h3 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h3><table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>-v, --verbose </code></td>
<td>详细模式输出。</td>
<td></td>
</tr>
<tr>
<td><code>-q, --quiet </code></td>
<td>精简输出模式。</td>
<td></td>
</tr>
<tr>
<td><code>-c, --checksum </code></td>
<td>打开校验开关，强制对文件传输进行校验。</td>
<td></td>
</tr>
<tr>
<td><code>-a, --archive</code></td>
<td>归档模式，表示以递归方式传输文件，并保持所有文件属性，等于 <code>-rlptgoD</code>。</td>
<td></td>
</tr>
<tr>
<td><code>-r, --recursive</code></td>
<td>对子目录以递归模式处理。</td>
<td></td>
</tr>
<tr>
<td><code>-R, --relative</code></td>
<td>使用相对路径信息。</td>
<td></td>
</tr>
<tr>
<td><code>-b, --backup</code></td>
<td>创建备份，也就是对于目的已经存在有同样的文件名时，将老的文件重新命名为 <code>~filename</code> 。可以使用 <code>--suffix</code> 选项来指定不同的备份文件前缀。</td>
<td></td>
</tr>
<tr>
<td><code> --backup-dir</code></td>
<td>将备份文件(如 <code>~filename</code>)存放在在目录下。</td>
<td></td>
</tr>
<tr>
<td><code>--suffix=SUFFIX </code></td>
<td>定义备份文件前缀。</td>
<td></td>
</tr>
<tr>
<td><code>-u, --update  </code></td>
<td>仅仅进行更新，也就是跳过所有已经存在于 DST，并且文件时间晚于要备份的文件，不覆盖更新的文件。</td>
<td></td>
</tr>
<tr>
<td><code>-l, --links</code></td>
<td>保留软链结。</td>
<td></td>
</tr>
<tr>
<td><code>-L, --copy-links</code></td>
<td>想对待常规文件一样处理软链结。</td>
<td></td>
</tr>
<tr>
<td><code>--copy-unsafe-links  </code></td>
<td>仅仅拷贝指向SRC路径目录树以外的链结。</td>
<td></td>
</tr>
<tr>
<td><code>--safe-links   </code></td>
<td>忽略指向SRC路径目录树以外的链结。</td>
<td></td>
</tr>
<tr>
<td><code>-H, --hard-links</code></td>
<td>保留硬链结。</td>
<td></td>
</tr>
<tr>
<td><code>-p, --perms </code></td>
<td>保持文件权限。</td>
<td></td>
</tr>
<tr>
<td><code>-o, --owner </code></td>
<td>保持文件属主信息。</td>
<td></td>
</tr>
<tr>
<td><code>-g, --group</code></td>
<td>保持文件属组信息。</td>
<td></td>
</tr>
<tr>
<td><code>-D, --devices</code></td>
<td>保持设备文件信息。</td>
<td></td>
</tr>
<tr>
<td><code>-t, --times  </code></td>
<td>保持文件时间信息。</td>
<td></td>
</tr>
<tr>
<td><code>-S, --sparse  </code></td>
<td>对稀疏文件进行特殊处理以节省DST的空间。</td>
<td></td>
</tr>
<tr>
<td><code>-n, --dry-run </code></td>
<td>只显示哪些文件将被传输，不进行真正的传输。</td>
<td></td>
</tr>
<tr>
<td><code>-w, --whole-file </code></td>
<td>拷贝文件，不进行增量检测。</td>
<td></td>
</tr>
<tr>
<td><code>-x, --one-file-system </code></td>
<td>不要跨越文件系统边界。</td>
<td></td>
</tr>
<tr>
<td><code>-B, --block-size=SIZE</code></td>
<td>检验算法使用的块尺寸，默认是700字节。</td>
<td></td>
</tr>
<tr>
<td><code>-e, --rsh=command</code></td>
<td>指定使用rsh、ssh方式进行数据同步。</td>
<td></td>
</tr>
<tr>
<td><code>--rsync-path=PATH</code></td>
<td>指定远程服务器上的rsync命令所在路径信息。</td>
<td></td>
</tr>
<tr>
<td><code>-C, --cvs-exclude </code></td>
<td>使用和CVS一样的方法自动忽略文件，用来排除那些不希望传输的文件。</td>
<td></td>
</tr>
<tr>
<td><code>--existing </code></td>
<td>仅仅更新那些已经存在于DST的文件，而不备份那些新创建的文件。</td>
<td></td>
</tr>
<tr>
<td><code>--delete</code></td>
<td>删除那些DST中存在，而SRC没有的文件。</td>
<td></td>
</tr>
<tr>
<td><code>--delete-excluded  </code></td>
<td>同样删除接收端那些被该选项指定排除的文件。</td>
<td></td>
</tr>
<tr>
<td><code>--delete-after   </code></td>
<td>传输结束以后再删除。</td>
<td></td>
</tr>
<tr>
<td><code>--ignore-errors  </code></td>
<td>及时出现IO错误也进行删除。</td>
<td></td>
</tr>
<tr>
<td><code>--max-delete=NUM </code></td>
<td>最多删除NUM个文件。</td>
<td></td>
</tr>
<tr>
<td><code>--partial</code></td>
<td>保留那些因故没有完全传输的文件，以是加快随后的再次传输。</td>
<td></td>
</tr>
<tr>
<td><code>--force </code></td>
<td>强制删除目录，即使不为空。</td>
<td></td>
</tr>
<tr>
<td><code>--numeric-ids</code></td>
<td>不将数字的用户和组 id 匹配为用户名和组名。</td>
<td></td>
</tr>
<tr>
<td><code>--timeout=time</code></td>
<td>ip 超时时间，单位为秒。</td>
<td></td>
</tr>
<tr>
<td><code>-I, --ignore-times</code></td>
<td>不跳过那些有同样的时间和长度的文件。</td>
<td></td>
</tr>
<tr>
<td><code>--size-only</code></td>
<td>当决定是否要备份文件时，仅仅察看文件大小而不考虑文件时间。</td>
<td></td>
</tr>
<tr>
<td><code>--modify-window=NUM</code></td>
<td>决定文件是否时间相同时使用的时间戳窗口，默认为0。</td>
<td></td>
</tr>
<tr>
<td><code>-T ,--temp-dir=DIR</code></td>
<td>在DIR中创建临时文件。</td>
<td></td>
</tr>
<tr>
<td><code>--compare-dest=DIR</code></td>
<td>同样比较DIR中的文件来决定是否需要备份。</td>
<td></td>
</tr>
<tr>
<td><code>-P</code></td>
<td>等同于 <code>--partial</code>。</td>
<td></td>
</tr>
<tr>
<td><code>--progress</code></td>
<td>显示传输过程。</td>
<td></td>
</tr>
<tr>
<td><code>-z, --compress</code></td>
<td>对备份的文件在传输时进行压缩处理。</td>
<td></td>
</tr>
<tr>
<td><code>--exclude PATTERN  </code></td>
<td>指定排除不需要传输的文件模式。支持通配符</td>
<td></td>
</tr>
<tr>
<td><code>--include PATTERN</code></td>
<td>指定不排除而需要传输的文件模式。</td>
<td></td>
</tr>
<tr>
<td><code>--exclude-from=FILE</code></td>
<td>排除FILE中指定模式的文件。</td>
<td></td>
</tr>
<tr>
<td><code>--include-from=FILE</code></td>
<td>不排除FILE指定模式匹配的文件。</td>
<td></td>
</tr>
<tr>
<td><code>--version</code></td>
<td>打印版本信息。</td>
<td></td>
</tr>
<tr>
<td><code>--address</code></td>
<td>绑定到特定的地址。</td>
<td></td>
</tr>
<tr>
<td><code>--config=FILE</code></td>
<td>指定其他的配置文件，不使用默认的 <code>rsyncd.conf</code> 文件。</td>
<td></td>
</tr>
<tr>
<td><code>--port=PORT</code></td>
<td>指定其他的 rsync 服务端口。</td>
<td></td>
</tr>
<tr>
<td><code>--blocking-io</code></td>
<td>对远程shell使用阻塞IO。</td>
<td></td>
</tr>
<tr>
<td><code>--stats </code></td>
<td>给出某些文件的传输状态。</td>
<td></td>
</tr>
<tr>
<td><code>--log-format=formAT </code></td>
<td>指定日志文件格式。</td>
<td></td>
</tr>
<tr>
<td><code>--password-file=FILE </code></td>
<td>从FILE中得到密码。</td>
<td></td>
</tr>
<tr>
<td><code>--bwlimit=KBPS </code></td>
<td>限制I&#x2F;O带宽，KBytes per second。</td>
<td></td>
</tr>
<tr>
<td><code>-h, --help</code></td>
<td>显示帮助信息。</td>
<td></td>
</tr>
</tbody></table>
<h3 id="rsyncd-配置文件示例"><a href="#rsyncd-配置文件示例" class="headerlink" title="rsyncd 配置文件示例"></a>rsyncd 配置文件示例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">&lt;==该选项指定当模块传输文件时守护进程应该具有的uid、gid</span></span><br><span class="line">uid =root  </span><br><span class="line">gid = root</span><br><span class="line">port = 873</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#消息文件，客户端连接服务器的时显示给客户端</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">motd file = /etc/rsyncd.motd</span>  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">&lt;==安全相关</span></span><br><span class="line">use chroot = no  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">&lt;==设置最大连接数</span></span><br><span class="line">max connections = 200  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">&lt;==设置超时时间</span></span><br><span class="line">timeout = 300   </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">&lt;==定义进程文件</span></span><br><span class="line">pid file = /var/run/rsyncd.pid </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">&lt;==定义锁文件</span>  </span><br><span class="line">lock file = /var/run/rsync.lock </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">&lt;==定义日志文件</span> </span><br><span class="line">log file = /var/log/rsyncd.log  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#关闭解析</span></span> </span><br><span class="line">reverse lookup = no  </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">&lt;==配置一个数据存储的模块</span></span><br><span class="line">[backup]      </span><br><span class="line">    #&lt;==模块备份数据路径</span><br><span class="line">    path = /data/www/videos/  </span><br><span class="line">    ignore errors</span><br><span class="line">    read only = false</span><br><span class="line">    list = false</span><br><span class="line">    #&lt;==配置登录权限，可以多个IP网段用逗号隔开</span><br><span class="line">    #hosts allow = 172.16.1.0/24,172.25.1.0/24  </span><br><span class="line">    #hosts deny = 0.0.0.0/32</span><br><span class="line">    #&lt;==配置服务登录用户（访问服务的权限）</span><br><span class="line">    auth users = rsync        </span><br><span class="line">    #&lt;==配置用户和密码文件,权限必须600，用户名:密码格式 </span><br><span class="line">    secrets file = /etc/rsync.server.password  </span><br><span class="line">    ##是否检查secrets file的权限</span><br><span class="line">    strict modes = yes </span><br></pre></td></tr></table></figure>

<h3 id="rsync-的过滤规则说明"><a href="#rsync-的过滤规则说明" class="headerlink" title="rsync 的过滤规则说明"></a>rsync 的过滤规则说明</h3><p>rsync 过滤规则是用于定义哪些文件要传输（包含某些文件）哪些文件不要传输（排除某些文件）的一些规则。这些规则可以直接写在命令参数里，也可以写在规则文件里，然后由命令引用</p>
<p>与过滤规则有关的选项主要有：</p>
<ul>
<li><code>--include=PATTERN</code> ： 设定一条包含规则，如： <code>--include=&quot;*.php&quot;</code></li>
<li><code>--exclude=PATTERN</code> ： 设定一条排除规则，如：<code>--exclude=&quot;*&quot;</code></li>
<li><code>--include-from=FILE</code> ： 指定一个文件，文件中一行一条包含规则，以 <code>;</code> 或 <code>#</code> 开头的行为注释，空行被忽略</li>
<li><code>--exclude-from=FILE</code> ： 指定一个文件，文件中一行一条排除规则，以 <code>;</code> 或 <code>#</code> 开头的行为注释，空行被忽略</li>
<li><code>--filter=RULE, -f</code> ： 设定一条过滤规则，可能是排除或包含规则（如：<code>-f &quot;- *.php&quot;</code> ），也可能其它类型的规则（如包含一个规则文件 <code>-f &quot;. ./rsync.rules&quot;</code>）</li>
</ul>
<p>这些选项配置的规则，其本质是一样，只是描述方式有些差异。其中 <code>--filter=RULE, -f</code> 选项支持完整的规则表达语法，其它的选项都可以转化为此选项的表达。举例如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -av --include=&quot;*.php&quot; --exclude=&quot;*&quot; src_dir/ dst_dir/</span><br><span class="line">rsync -av -filter &quot;+ *.php&quot; -filter &quot;- *&quot; src_dir/ dst_dir/</span><br><span class="line">rsync -av -f &quot;+ *.php&quot; -f &quot;- *&quot; src_dir/ dst_dir/</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上的命令是完全等价的，<code>-f</code> 方式更简单<br><code>--include=&quot;xxx&quot;</code> 等价于 <code>-f &quot;+ xxx&quot;</code><br><code>--exclude=&quot;xxx&quot;</code> 等价于 <code>-f &quot;- xxx&quot;</code></p>
</blockquote>
<p>由 <code>--include-from</code> 或 <code>--exclude-from</code> 选项引入的规则文件，相当于每个规则前面自动加了 <code>+</code> 或 <code>-</code>。其规则文件内容举例如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--include-from 或 --exclude-from 引用的规则文件，开头没有 + 或 -</span></span><br><span class="line">*.php</span><br><span class="line">*</span><br></pre></td></tr></table></figure>

<h4 id="过滤规则的工作方式"><a href="#过滤规则的工作方式" class="headerlink" title="过滤规则的工作方式"></a>过滤规则的工作方式</h4><p>所有的过滤规则配置最终在 rsync 内部会形成一个有序的规则列表，在命令行中靠前选项，其规则的排序也靠前。随着要传输的（文件&#x2F;目录路径）列表的构建，针对每个路径，rsync 会依次读取有序规则列表中的规则进行检查。当第一个规则匹配成功后，立即进行操作（包含或排除），并停止后面规则的检查；若所有规则都不不匹配，此路径默认为包含。若有递归选项时（如 <code>-r -a</code>），如果子目录被规则排除，那么 rsync 不会递归检查此目录的内容了，也就是此目录下的文件和目录不会进行规则过滤也不会传输，相当于整个子目录都排除了。简单总结如下：</p>
<ol>
<li>规则有顺序，顺序同命令中参数配置顺序（从左到右）</li>
<li>扫描文件系统，读取（目录或文件的）路径后马上进行规则检查，确定包含还是排除</li>
<li>规则检查按序进行，若有命中立即包含或排除，并停止后续规则检查；若无规则命中，默认为包含</li>
<li>目录被排除时，其下所有子目录和文件都被排除</li>
</ol>
<p>此命令会同步 src_dir 目录下的所有 php 文件（<strong>不包含子目录的</strong>）<br>因为 src_dir 目录下每个文件和目录路径都会先由 <code>-f &quot;+ *.php&quot;</code> 规则检查，php 文件符合此规则就被包含了，后面的 <code>-f &quot;- *&quot;</code> 规则不会检查了<br>其余类型的文件和子目录，不符合第一个规则，继续检查第二个规则时，都被排除了<br>子目录被排除后，其中即使有 php 文件，也不会被检查，所以此命令不会同步 src_dir 目录下子目录中的 php 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -av -f &quot;+ *.php&quot; -f &quot;- *&quot; src_dir/ dst_dir/</span><br></pre></td></tr></table></figure>

<p>调换两个参数的顺序，则完全不一样了<br>此命令将不会同步任何文件和目录<br>因为第一条规则把所有文件和目录到排除了，第二条规则没有机会生效  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rsync -av -f &quot;- *&quot; -f &quot;+ *.php&quot; src_dir/ dst_dir/</span><br></pre></td></tr></table></figure>

<p>此命令会同步 src_dir 目录下的所有 php 文件（<strong>包含子目录的</strong>）<br>规则 <code>-f &quot;+ */&quot;</code> 会匹配并包含所有子目录路径，所以 rsync 会检查所有的子目录，然后其中的 php 文件被包含了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rsync -av -f &quot;+ *.php&quot; -f &quot;+ */&quot; -f &quot;- *&quot; src_dir/ dst_dir/</span><br></pre></td></tr></table></figure>
<h4 id="过滤规则的配置语法"><a href="#过滤规则的配置语法" class="headerlink" title="过滤规则的配置语法"></a>过滤规则的配置语法</h4><p>过滤规则的配置语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">操作 [匹配模式]</span><br><span class="line">操作,修饰符 [匹配模式]</span><br></pre></td></tr></table></figure>
<p>常用操作：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>+</code></td>
<td>包含</td>
<td><code>-f &quot;+ *.php&quot;</code></td>
</tr>
<tr>
<td><code>-</code></td>
<td>排除</td>
<td><code>-f &quot;- *.php&quot;</code></td>
</tr>
<tr>
<td><code>.</code></td>
<td>包含规则文件</td>
<td><code>-f &quot;. ./rsync.rules&quot;</code></td>
</tr>
</tbody></table>
<p>常用修饰符：</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>!</code></td>
<td>否定，对匹配结果进行取反，把匹配成功当做匹配失败，把匹配失败当做匹配成功</td>
<td><code>-f &quot;-! *.php&quot;</code></td>
</tr>
</tbody></table>
<p>常见匹配模式：</p>
<table>
<thead>
<tr>
<th>匹配模式</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>/*.php</code></td>
<td>模式以 <code>/</code> 开头时，表示模式必须匹配路径的开始；否则可以匹配路径中任意一层名称</td>
<td></td>
</tr>
<tr>
<td><code>config/</code></td>
<td>模式以 <code>/</code> 结尾时，表示模式只匹配目录，否则可以匹配目录或文件</td>
<td></td>
</tr>
<tr>
<td><code>subdir/view.php</code></td>
<td>模式中间的 <code>/</code> 表示路径分隔符</td>
<td></td>
</tr>
<tr>
<td><code>*</code></td>
<td>匹配任意长度的任意字符，但不匹配 <code>/</code></td>
<td></td>
</tr>
<tr>
<td><code>**</code></td>
<td>结尾时匹配任意长度的任意字符（包括 <code>/</code>）</td>
<td><code>app/**</code> 匹配路径 <code>app/xx/xx/a.txt</code></td>
</tr>
<tr>
<td><code>***</code></td>
<td>结尾时匹配任意长度的任意字符（包括 <code>/</code>），还包括目录本身。</td>
<td><code>app/***</code> 匹配路径 <code>app</code> 和 <code>xxx/app</code></td>
</tr>
<tr>
<td><code>?</code></td>
<td>匹配 <code>/</code> 以外的任意一个字符</td>
<td></td>
</tr>
<tr>
<td><code>[]</code></td>
<td>匹配一个某一类字符</td>
<td><code>[a-z]</code> 匹配一个小写字母，<code>[0-9]</code> 匹配一个数字</td>
</tr>
</tbody></table>
<blockquote>
<p>模式默认必须匹配到路径的末尾。如：<code>foo</code> 匹配 <code>foo</code> 和 <code>xx/foo</code>，但不匹配 <code>xx/foo1</code> 和 <code>foo/xx</code><br>路径被匹配的部分必须是包含完整的（目录或文件）名称，不可从名称中间切开。如：<code>foo</code> 不匹配 <code>xxx/afoo</code> ，<code>abc/foo</code> 不匹配 <code>subdir/aabc/foo</code><br>默认是包含所有文件和目录  </p>
</blockquote>
<h3 id="常用命令示例"><a href="#常用命令示例" class="headerlink" title="常用命令示例"></a>常用命令示例</h3><h4 id="测试同步结果"><a href="#测试同步结果" class="headerlink" title="测试同步结果"></a>测试同步结果</h4><p>如果不确定 <code>rsync</code> 执行的结果，可以不写目标目录，这样不会同步数据，只会输出要同步的目录和文件列表。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -a --exclude &#x27;file.txt&#x27; src_dir/</span><br></pre></td></tr></table></figure>
<p>或者使用选项 <code>--dry-run, -n</code>，模拟实际的运行效果，但不真的执行同步  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -a --dry-run --exclude &#x27;file.txt&#x27; src_dir/ dst_dir/</span><br></pre></td></tr></table></figure>

<h4 id="ssh-模式同步，默认-ssh-端口非-22-时指定-ssh-端口，使用-e-39-ssh-p-222-39-选项"><a href="#ssh-模式同步，默认-ssh-端口非-22-时指定-ssh-端口，使用-e-39-ssh-p-222-39-选项" class="headerlink" title="ssh 模式同步，默认 ssh 端口非 22 时指定 ssh 端口，使用 -e &#39;ssh -p 222&#39; 选项"></a>ssh 模式同步，默认 ssh 端口非 22 时指定 ssh 端口，使用 <code>-e &#39;ssh -p 222&#39;</code> 选项</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -e &#x27;ssh -p 222&#x27; /data/wwwroot/  rsync@9.9.9.9:/home/wwwroot/</span><br></pre></td></tr></table></figure>

<h4 id="Windows-中使用方式，以类似-cygdrive-d-的方式指定-d-盘"><a href="#Windows-中使用方式，以类似-cygdrive-d-的方式指定-d-盘" class="headerlink" title="Windows 中使用方式，以类似 /cygdrive/d/ 的方式指定 d 盘"></a>Windows 中使用方式，以类似 <code>/cygdrive/d/</code> 的方式指定 d 盘</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -c -r -u -t --timeout=300 -z --password-file C:\rsyncPasswd.txt /cygdrive/d/DATA/ rsync@0.0.0.0::zy/</span><br></pre></td></tr></table></figure>

<h4 id="同步过程中忽略-跳过-指定文件-目录"><a href="#同步过程中忽略-跳过-指定文件-目录" class="headerlink" title="同步过程中忽略(跳过)指定文件(目录)"></a>同步过程中忽略(跳过)指定文件(目录)</h4><p>要排除特定文件，请将文件的相对路径传递给 <code>--exclude</code> 选项</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -a --exclude &#x27;file.txt&#x27; src_dir/ dst_dir/</span><br><span class="line">rsync -a -f &#x27;- file.txt&#x27; src_dir/ dst_dir/</span><br></pre></td></tr></table></figure>

<p>排除特定目录与排除文件相同，只需将目录的相对路径传递给 <code>--exclude</code> 选项</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -a --exclude &#x27;dir1&#x27; src_dir/ dst_dir/</span><br><span class="line">rsync -a -f &#x27;- dir1&#x27; src_dir/ dst_dir/</span><br></pre></td></tr></table></figure>
<p>如果要排除目录内容，但不排除目录本身，请使用 <code>dir1/*</code> 而不是 <code>dir1</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -a --exclude &#x27;dir1/*&#x27; src_dir/ dst_dir/</span><br><span class="line">rsync -a -f &#x27;- dir1/*&#x27; src_dir/ dst_dir/</span><br></pre></td></tr></table></figure>
<p>要排除多个文件或目录，只需指定多个 <code>--exclude</code> 选项, 或使用 <code>&#123;&#125;</code> 包含多个目标项</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -a --exclude &#x27;f1.txt&#x27; --exclude &#x27;dir1/*&#x27; --exclude &#x27;dir2&#x27; src_dir/ dst_dir/</span><br><span class="line">rsync -a --exclude=&#123;&#x27;f1.txt&#x27;,&#x27;dir1/*&#x27;,&#x27;dir2&#x27;&#125; src_dir/ dst_dir/</span><br><span class="line">rsync -a -f &#x27;- f1.txt&#x27; -f &#x27;- dir1/*&#x27; -f &#x27;- dir2&#x27; src_dir/ dst_dir/</span><br></pre></td></tr></table></figure>

<p>通配符排除多个文件，例如要排除所有 <code>jpg</code> 类型的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -a --exclude &#x27;*.jpg*&#x27; src_dir/ dst_dir/</span><br><span class="line">rsync -a -f &#x27;- *.jpg*&#x27; src_dir/ dst_dir/</span><br></pre></td></tr></table></figure>



<h3 id="windows-安装-rsync-客户端"><a href="#windows-安装-rsync-客户端" class="headerlink" title="windows 安装 rsync 客户端"></a>windows 安装 rsync 客户端</h3><p>windows 下 rsync客户端使用 <code>cwRsync</code><br>下载地址：<br><a href="https://www.itefix.net/cwrsync?spm=a2c6h.12873639.article-detail.6.58dd67f17cs3Ta">官网链接</a><br><a href="https://s.csms.tech/file/cwrsync_6.2.4_x64_free.zip">其他地址</a></p>
<p>下载解压安装包后，目录内容如下：<br><img src="https://i.csms.tech/img_22.png"></p>
<p><code>bin</code> 目录下包含常用命令，其中 <code>rsync</code> 命令和 linux 中使用方法相同</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://zhuanlan.zhihu.com/p/441161884">rsync命令过滤规则入门教程</a><br><a href="https://iguoli.github.io/2017/07/03/Rsync.html">Rsync 命令</a></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Rsync</tag>
      </tags>
  </entry>
  <entry>
    <title>sed 命令使用示例</title>
    <url>/202207291520/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="常用选项说明"><a href="#常用选项说明" class="headerlink" title="常用选项说明"></a>常用选项说明</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-n    使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN （例如文件内容）的内容一般都会被列出到屏幕上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来。</span><br><span class="line">-i    直接修改读取的内容，而不是由屏幕输出。</span><br><span class="line">-f    直接将 sed 的动作写在一个文件内， -f filename 则可以执行 filename 内的sed 动作；</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a    追加， a 的后面可以接字符串，而这些字串会在新的一行出现(当前行的下一行)</span><br><span class="line">i    插入， i 的后面可以接字符串，而这些字串会在新的一行出现(目前行的上一行)；</span><br><span class="line">c    替代， c 的后面可以接字符串，替换整行</span><br><span class="line">s    替换， s/a/b/，a 替换成 b</span><br><span class="line">d    删除</span><br><span class="line">p    打印指定行</span><br></pre></td></tr></table></figure>

<h3 id="行定位方法"><a href="#行定位方法" class="headerlink" title="行定位方法"></a>行定位方法</h3><p>根据行号打印出指定行，<code>$</code> 表示最后一行，<code>!</code> 取反，排除行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -n &#x27;1p&#x27; file</span><br><span class="line">sed -n &#x27;1,10p&#x27; file</span><br><span class="line">sed -n &#x27;2,$p&#x27; file</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印除最后一行之外的其他行</span></span><br><span class="line">sed -n &#x27;$!p&#x27; file</span><br></pre></td></tr></table></figure>
<p>打印出搜索匹配到的行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -n &#x27;/root/p&#x27; file</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印出匹配<span class="string">&#x27;begin&#x27;</span>开始的行，到匹配到<span class="string">&#x27;end&#x27;</span>的行结束</span></span><br><span class="line">sed -n &#x27;/begin/,/end/p&#x27;</span><br><span class="line">sed -n &#x27;/begin/,/end/!p&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="常用示例"><a href="#常用示例" class="headerlink" title="常用示例"></a>常用示例</h3><h4 id="搜索包含指定内容的行，并替换整行内容"><a href="#搜索包含指定内容的行，并替换整行内容" class="headerlink" title="搜索包含指定内容的行，并替换整行内容"></a>搜索包含指定内容的行，并替换整行内容</h4><p>使用 <code>c</code> 命令，替换整行内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;/^updated/cupdate=1&#x27; file</span><br></pre></td></tr></table></figure>

<h4 id="每行的行首或行位添加内容"><a href="#每行的行首或行位添加内容" class="headerlink" title="每行的行首或行位添加内容"></a>每行的行首或行位添加内容</h4><p><code>^</code>，<code>$</code> 匹配行首和行尾  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i `s/^/添加内容/g` file</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>sed</tag>
      </tags>
  </entry>
  <entry>
    <title>sftp 服务常用配置说明</title>
    <url>/202207301332/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>sftp 是 Secure File Transfer Protocol 的缩写，安全文件传送协议。可以为传输文件提供一种安全的加密方法。SFTP 为 SSH 的一部分，由于这种传输方式使用了加密&#x2F;解密技术，所以传输效率比普通的 FTP 要低得多，如果您对网络安全性要求更高时，可以使用 SFTP 代替 FTP。默认ssh启用了sftp，只要可登陆系统的用户（&#x2F;bin&#x2F;bash）就可登陆,登陆后目录无限制，可任意切换其他目录。为了安全起见，可以配置sshd以限制sftp登录用户的权限。最好将登陆后用户限制在指定目录，无法切换到外部目录  </p>
<span id="more"></span>

<h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p><strong><code>ChrootDirectory</code> 配置前提</strong>:<br><code>ChrootDirectory</code> 设置的目录权限及其所有的上级文件夹权限，属主和属组必须是 root；<br><code>ChrootDirectory</code> 设置的目录权限及其所有的上级文件夹权限，只有属主能拥有写权限，权限最大设置只能是 755。</p>
<blockquote>
<p><strong>如果权限配置不对，会导致无法登录</strong><br>如果上级目录无法设置为root权限，可以通过<code>ln</code>链接的方式实现<br>限制后的用户无法 <code>ssh</code> 登录系统</p>
</blockquote>
<p>创建相关用户和组</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groupadd sftp</span><br><span class="line">useradd -g sftp -d /data/sftp/sftpuser1 -s /sbin/nologin sftpuser1</span><br><span class="line">echo 123456 | passwd --stdin sftpuser1</span><br><span class="line"></span><br><span class="line">chown root:root /data/sftp/sftpuser1</span><br><span class="line">chmod 755 /data/sftp/sftpuser1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">因为 /data/sftp/sftpuser1 属主和属组都为root，其他用户无写入权限，需要创建sftpuser1可写入的目录</span></span><br><span class="line">mkdir -p /data/sftp/sftpuser1/upload</span><br><span class="line">chown sftpuser1:sftp /data/sftp/sftpuser/upload</span><br><span class="line">chmod 755 /data/sftp/sftpuser1/upload</span><br></pre></td></tr></table></figure>

<p>修改 <code>sshd_config</code> 配置</p>
<figure class="highlight shell"><figcaption><span>/etc/ssh/sshd_config</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Subsystem      sftp    /usr/libexec/openssh/sftp-server</span></span><br><span class="line">Subsystem sftp internal-sftp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拒绝指定用户登录,不能放在Match user中</span></span><br><span class="line">DenyUsers user1 user2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">maxsessions 10</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">针对用户配置sftp, 多个用户可重复配置以下内容，或者通过针对组配置sftp</span></span><br><span class="line">Match user sftpuser1,sftpuser2</span><br><span class="line">    # 该行强制执行内部 sftp，并忽略任何 ~/.ssh/rc 文件中的命令。</span><br><span class="line">   ForceCommand internal-sftp</span><br><span class="line">	</span><br><span class="line">   ChrootDirectory /data/sftp/sftpuser1</span><br><span class="line">	</span><br><span class="line"><span class="meta prompt_">   # </span><span class="language-bash">下面两项是与安全有关</span></span><br><span class="line">    AllowTcpForwarding no</span><br><span class="line">    X11Forwarding no</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">针对用户组配置sftp</span></span><br><span class="line">Match Group sftp,sftp1</span><br><span class="line">    ForceCommand internal-sftp</span><br><span class="line">    </span><br><span class="line">    # %h 代表用户 home 目录，%u 代表用户名。</span><br><span class="line">    ChrootDirectory /data/sftp/%u</span><br></pre></td></tr></table></figure>
<blockquote>
<p>修改配置后，重启 <code>sshd</code> 服务生效<br><code>systemctl restart sshd</code></p>
</blockquote>
<h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><h4 id="Unable-to-open-permission-denied"><a href="#Unable-to-open-permission-denied" class="headerlink" title="Unable to open .: permission denied"></a>Unable to open .: permission denied</h4><p><strong>解决方法</strong>： 如果启动了 <code>selinux</code>， 关闭 <code>selinux</code></p>
<h4 id="Couldn’t-read-packet-Connection-reset-by-peer"><a href="#Couldn’t-read-packet-Connection-reset-by-peer" class="headerlink" title="Couldn’t read packet: Connection reset by peer"></a>Couldn’t read packet: Connection reset by peer</h4><p><strong>问题原因</strong>: <code>ChrootDirectory (/data/sftp/sftpuser1)</code> 目录及所有上级目录的用户和组必须为 <code>root</code>，权限最多为 755, <a href="#%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE">参考说明</a></p>
<h4 id="remote-readdir-“-x2F-“-Permission-denied"><a href="#remote-readdir-“-x2F-“-Permission-denied" class="headerlink" title="remote readdir(“&#x2F;“): Permission denied"></a>remote readdir(“&#x2F;“): Permission denied</h4><p><strong>问题原因</strong>: sftp 用户对 <code>ChrootDirectory (/data/sftp/sftpuser1)</code> 目录要有读取权限，<a href="#%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE">参考说明</a></p>
<h3 id="禁用-sftp-功能"><a href="#禁用-sftp-功能" class="headerlink" title="禁用 sftp 功能"></a>禁用 sftp 功能</h3><p>修改 <code>sshd</code> 配置文件 <code>/etc/ssh/sshd_config</code>,注释以下内容</p>
<figure class="highlight shell"><figcaption><span>/etc/ssh/sshd_config</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Subsystem sftp /usr/libexec/openssh/sftp-server</span></span><br></pre></td></tr></table></figure>
<p>修改配置文件后重启 <code>sshd</code> 服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure>
<p>使用<code>sftp</code>登录时会报错 ： <code>Error:	Could not connect to server</code></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>sftp</tag>
      </tags>
  </entry>
  <entry>
    <title>spinnaker 常见用法</title>
    <url>/202211101344/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Spinnaker 1.29.0</li>
<li>Kubernetes 1.24.7</li>
</ul>
<h1 id="Spinnaker-引用-Kubernetes-中的-Namespace"><a href="#Spinnaker-引用-Kubernetes-中的-Namespace" class="headerlink" title="Spinnaker 引用 Kubernetes 中的 Namespace"></a>Spinnaker 引用 Kubernetes 中的 Namespace</h1><p>Kubernetes 中的 Namespace，对应 Spinnaker 中的 Application，当 <strong>在 Kubernetes 中创建 Namespace ，并在此 Namespace 创建资源后</strong>，Spinnaker 会自动读取到此 Namespace，并显示在 Applications 中。</p>
<h1 id="Pipelines-中引用-Docker-Registry-类型的触发器"><a href="#Pipelines-中引用-Docker-Registry-类型的触发器" class="headerlink" title="Pipelines 中引用 Docker Registry 类型的触发器"></a>Pipelines 中引用 Docker Registry 类型的触发器</h1><p>在 Pipelines 中配置 Docker Registry 类型的触发器，并在后面的 Stage 中自动引用。</p>
<ol>
<li><p>在要配置的 Pipeline 的 <code>Configuration</code> 部分，配置 <code>Automated Triggers</code>，选择 <code>type</code> 为 <code>Docker Registry</code><br> <img src="https://i.csms.tech/img_85.png"></p>
<ul>
<li>Registry Name - 为 <a href="https://csms.tech/202210121639/#添加自建的私有-docker-镜像源">Halyard 中配置的 Docker Registry 的认证信息</a> 的名称</li>
<li>Organization - 对应 Docker Registry （如 Harbor） 中的 Projects</li>
</ul>
</li>
<li><p>Stage 中使用以下方式引用镜像</p>
<p> <code>image: &#39;$&#123;trigger.artifacts[0].reference&#125;&#39;</code></p>
<p> <code>$&#123;trigger&#125;</code> 为镜像名称，当一个镜像名下有多个不同标签的镜像时，<code>$&#123;trigger.artifacts[0]</code> 表示第一个镜像，依此类推。<code>$&#123;trigger.artifacts[0].reference&#125;</code> 值为第一个镜像的完整镜像名加标签。<br> <img src="https://i.csms.tech/img_86.png"></p>
</li>
</ol>
<span id="more"></span>   ]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>Spinnaker</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh 安全防护</title>
    <url>/202208171033/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Centos 7</li>
</ul>
<p>登录服务器，经常遇见以下提示信息，说明有主机一直在尝试暴力破解用户名密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">There were 696 failed login attempts since the last successful login.</span><br></pre></td></tr></table></figure>

<p>查看登录失败的用户名和 ip 地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep <span class="string">&quot;Failed password for invalid user &quot;</span> /var/log/secure | awk <span class="string">&#x27;&#123;print $11,$13&#125;&#x27;</span> | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c | <span class="built_in">sort</span> -k1 -n</span></span><br><span class="line">      3 wangli 47.74.0.77</span><br><span class="line">      3 work 47.74.0.77</span><br><span class="line">      3 yt 47.74.0.77</span><br><span class="line">      3 yx 47.74.0.77</span><br><span class="line">      3 yyz 47.74.0.77</span><br><span class="line">      3 zabbix 47.74.0.77</span><br><span class="line">      3 zd 47.74.0.77</span><br><span class="line">      3 zhangfan 47.74.0.77</span><br><span class="line">      3 zxy 47.74.0.77</span><br><span class="line">      4 client003 47.74.0.77</span><br><span class="line">      4 client004 47.74.0.77</span><br><span class="line">      4 dell 47.74.0.77</span><br><span class="line">      4 ftpuser 47.74.0.77</span><br><span class="line">      4 inspur 47.74.0.77</span><br><span class="line">      4 wang 47.74.0.77</span><br><span class="line">      5 git 47.74.0.77</span><br><span class="line">      5 nagios 47.74.0.77</span><br><span class="line">      5 testuser 47.74.0.77</span><br><span class="line">      6 omnisky 47.74.0.77</span><br><span class="line">      7 oracle 47.74.0.77</span><br><span class="line">      8 jenkins 47.74.0.77</span><br><span class="line">     10 hadoop 47.74.0.77</span><br><span class="line">     10 postgres 47.74.0.77</span><br><span class="line">     11 ubuntu 47.74.0.77</span><br><span class="line">     11 user 47.74.0.77</span><br><span class="line">     12 admin 47.74.0.77</span><br><span class="line">     15 test 47.74.0.77</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="sshd-加固配置"><a href="#sshd-加固配置" class="headerlink" title="sshd 加固配置"></a>sshd 加固配置</h3><p>修改 <code>sshd</code> 配置文件 <code>/etc/ssh/sshd_config</code>，更改以下配置</p>
<ul>
<li><code>sshd</code> 默认端口 22 改为其他端口</li>
<li>禁止 <code>root</code> 用户登录，创建其他普通用户以登录系统，普通用户登录后有需要再切换到 <code>root</code></li>
</ul>
<figure class="highlight shell"><figcaption><span>/etc/ssh/sshd_config</span></figcaption><table><tr><td class="code"><pre><span class="line">Port 30000</span><br><span class="line">PermitRootLogin no</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>修改配置后重启 <code>sshd</code> 服务生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure>

<p>如果可以安全的保存秘钥，也可以使用秘钥登录，禁止用户名密码登录，具体配置可参考：<a href="https://blog.51cto.com/u_15061935/2652298">ssh 秘钥登录</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>常用工具下载链接</title>
    <url>/202302041721/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="https://s.csms.tech/file/">常用工具下载链接</a></p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title>tcp/udp 端口连通性测试</title>
    <url>/202210241127/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Centos-下安装"><a href="#Centos-下安装" class="headerlink" title="Centos 下安装"></a>Centos 下安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y nc</span><br></pre></td></tr></table></figure>

<h3 id="Windows-下安装"><a href="#Windows-下安装" class="headerlink" title="Windows 下安装"></a>Windows 下安装</h3><p>Windows 下需要 <a href="https://eternallybored.org/misc/netcat/">下载 netcat 运行程序</a></p>
<p>下载后直接解压，将 <code>nc.exe</code> 复制到 <code>C:\Windows\System32</code> 目录或将 <code>nc.exe</code> 添加到系统 path 环境变量中</p>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>-v</code></td>
<td>打印详细信息</td>
<td></td>
</tr>
<tr>
<td><code>-u</code></td>
<td>使用 UDP 协议，默认为 TCP 协议</td>
<td></td>
</tr>
</tbody></table>
<h3 id="测试-udp-端口连通性"><a href="#测试-udp-端口连通性" class="headerlink" title="测试 udp 端口连通性"></a>测试 udp 端口连通性</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nc -vuz ip/domain 8472</span></span><br><span class="line">Ncat: Version 7.50 ( https://nmap.org/ncat )</span><br><span class="line">Ncat: Connected to ip:8472.</span><br><span class="line">Ncat: UDP packet sent successfully</span><br><span class="line">Ncat: 1 bytes sent, 0 bytes received in 2.01 seconds.</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>netcat</tag>
      </tags>
  </entry>
  <entry>
    <title>windows 中的 zip 类型压缩文件，linux 中 unzip 解压后文件名乱码</title>
    <url>/202208240911/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>centos 7</li>
</ul>
<p>在 windows 系统添加到 zip 类型的压缩文件，上传到 Linux，使用 <code>unzip</code> 解压后，文件名乱码  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">unzip 测试文档.zip</span></span><br><span class="line">Archive:  测试文档.zip</span><br><span class="line">  inflating: ═°╦▐╫╩╘┤╬┤╝╙├▄├╗╙╨╙├╡╜╡─┴╨▒э.csv</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>主要的原因是因为 <code>unzip</code> 在解压的时候会将编码转化为其内部默认的编码，而默认的编码根本不支持中文 <code>CP936</code> 编码。因此我们需要在解压的时候明确的指定需要使用的编码。  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">unzip -O CP936 测试文档.zip</span> </span><br><span class="line">Archive:  测试文档.zip</span><br><span class="line">  inflating: 测试文档.csv  </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>unzip</tag>
      </tags>
  </entry>
  <entry>
    <title>vim</title>
    <url>/202208181117/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Centos 7</li>
</ul>
<h3 id="vim-配置"><a href="#vim-配置" class="headerlink" title="vim 配置"></a>vim 配置</h3><p><code>vim</code> 启动时会读取 <code>/etc/vimrc</code>（全局配置） 和 <code>~/.vimrc</code> （用户配置）</p>
<p>常用配置如下，使用 <code>&quot;</code> 注释</p>
<figure class="highlight shell"><figcaption><span>/etc/vimrc</span></figcaption><table><tr><td class="code"><pre><span class="line">&quot; 自动缩进 </span><br><span class="line">set ai</span><br><span class="line">set autoindent</span><br><span class="line"></span><br><span class="line">&quot; 保存历史命令数量</span><br><span class="line">set history=50</span><br><span class="line"></span><br><span class="line">&quot; 右下角显示当前鼠标位置（行列数）</span><br><span class="line">set ruler</span><br><span class="line"></span><br><span class="line">&quot; 鼠标位置所在行显示下划线</span><br><span class="line">set cursorline</span><br><span class="line"></span><br><span class="line">&quot; 开启语法高亮</span><br><span class="line">syntax on</span><br><span class="line"></span><br><span class="line">&quot; 高亮搜索结果</span><br><span class="line">set hlsearch</span><br><span class="line"></span><br><span class="line">&quot; 搜索时不区分大小写</span><br><span class="line">set ignorecase</span><br><span class="line"></span><br><span class="line">&quot; 将 tab 转换为空格</span><br><span class="line">set expandtab</span><br><span class="line"></span><br><span class="line">&quot; tab 转换为4个空格</span><br><span class="line">set tabstop=4</span><br><span class="line"></span><br><span class="line">&quot; 删除时，可以一次删除4个空格</span><br><span class="line">set softtabstop=4</span><br><span class="line"></span><br><span class="line">&quot; 显示行数</span><br><span class="line">set nu</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h3 id="vim-常见用法"><a href="#vim-常见用法" class="headerlink" title="vim 常见用法"></a>vim 常见用法</h3><h4 id="读写加解密文件"><a href="#读写加解密文件" class="headerlink" title="读写加解密文件"></a>读写加解密文件</h4><h5 id="创建新的加密文件"><a href="#创建新的加密文件" class="headerlink" title="创建新的加密文件"></a>创建新的加密文件</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim -x mysecfile</span><br></pre></td></tr></table></figure>
<p>使用 <code>vim</code> 的 <code>-x</code> 选项，将创建一个新的文件，并提示需要设置加密密码，输入 2 次密码后，将进入 <code>vim</code> 界面，编辑完内容，保存后，产生的文件为 <code>vim</code> 加密的文件，使用 <code>file</code> 命令查看，显示如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">file mysecfile</span></span><br><span class="line">mysecfile: Vim encrypted file data</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>之后要使用 <code>vim</code> 编辑此文件，都要按照提示输入密码，如果未输入密码或者输入的密码错误，打开的文件内容将显示为乱码，只有输入正确的密码，才能看到正确的文件内容，如果使用其他编辑器，可以直接打开文件，但是内容乱码  </p>
<h5 id="加密已有文件"><a href="#加密已有文件" class="headerlink" title="加密已有文件"></a>加密已有文件</h5><p>对于已经存在的未加密文件，使用 <code>vim</code> 的 <code>-x</code> 选项时，会要求输入密码，此时不输入密码，或者随便输入，都会打开正确的文件内容(因为文件并未被 <code>vim</code> 加密保护)  </p>
<p>对于已经存在的未加密文件，若要使用 <code>vim</code> 进行加密，可以在 <code>vim</code> 打开文件后，使用 <code>vim</code> 的 <code>X</code> 命令对文件进行加密。具体操作为： 在 <code>vim</code> 的一般模式下（按 <code>Esc</code> 进入），输入 </p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">X</span></span><br></pre></td></tr></table></figure>
<p>确定后 <code>vim</code> 会提示输入 2 次密码，完成加密，最后保存文件</p>
<figure class="highlight shell"><figcaption><span>vim</span></figcaption><table><tr><td class="code"><pre><span class="line">:wq</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>对于 <code>vim</code> 已经加密的文件，如果使用 <code>vim</code> 打开时输入错误的密码或者未输入密码，打开文件显示乱码，此时如果对文件进行了保存，会导致乱码被保存为文件内容，导致文件内容丢失</strong></p>
</blockquote>
<h5 id="文件解密"><a href="#文件解密" class="headerlink" title="文件解密"></a>文件解密</h5><p>对 <code>vim</code> 已加密的文件，需要解密的话，在正确打开文件后，可以通过 <a href="#%E5%8A%A0%E5%AF%86%E5%B7%B2%E6%9C%89%E6%96%87%E4%BB%B6">加密已有文件</a> 中的步骤，将文件密码设置为空即可<br>或者正确打开加密文件后，进入一般模式下，执行以下命令</p>
<figure class="highlight shell"><figcaption><span>vim</span></figcaption><table><tr><td class="code"><pre><span class="line">:set key=</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>SoftEther VPN 使用</title>
    <url>/202302070928/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="https://www.softether.org/4-docs">SoftEther VPN 官网手册</a></p>
<h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos7 5.4.221</li>
<li>SoftEther VPN Server 4.41</li>
<li>iptables</li>
</ul>
<p>SoftEther VPN Server 有两种模式，<code>Service Mode</code> 和 <code>User Mode</code>，本文档安装使用 <code>Service Mode</code> <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Operating Modes](https://www.softether.org/4-docs/1-manual/3._SoftEther_VPN_Server_Manual/3.2_Operating_Modes)">[1]</span></a></sup></p>
<ul>
<li><code>Service Mode</code> - 安装之后以系统服务的形式存在（被管理）</li>
<li><code>User Mode</code> - 安装之后不存在对应的服务，（管理员）用户直接通过进程管理，程序启动停止需要（管理员）用户手动停止相应进程</li>
</ul>
<h1 id="安装配置过程"><a href="#安装配置过程" class="headerlink" title="安装配置过程"></a>安装配置过程</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装依赖包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install gcc zlib-devel openssl-devel readline-devel ncurses-devel</span><br></pre></td></tr></table></figure>
<p><a href="https://www.softether.org/">参考链接</a> 下载最新的安装包，本文档使用版本 4.41 版本 <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Install on Linux and Initial Configurations](https://www.softether.org/4-docs/1-manual/7._Installing_SoftEther_VPN_Server/7.3_Install_on_Linux_and_Initial_Configurations)">[2]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://github.com/SoftEtherVPN/SoftEtherVPN_Stable/releases/download/v4.41-9782-beta/softether-vpnserver-v4.41-9782-beta-2022.11.17-linux-x64-64bit.tar.gz</span><br><span class="line"></span><br><span class="line">tar -xf softether-vpnserver-v4.41-9782-beta-2022.11.17-linux-x64-64bit.tar.gz</span><br><span class="line"></span><br><span class="line">cd vpnserver/</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用以下命令编译生成可执行文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
<p>将编译后的目录移动到 <code>/usr/local/</code> 下，并修改权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ..</span><br><span class="line">mv vpnserver /usr/local/</span><br><span class="line"></span><br><span class="line">cd /usr/local/vpnserver/</span><br><span class="line"></span><br><span class="line">chmod 600 *</span><br><span class="line"></span><br><span class="line">chmod 700 vpncmd</span><br><span class="line">chmod 700 vpnserver</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>使用 <code>vpncmd check</code> 命令检查 vpn server 是否可以正常运行。在 <code>/usr/local/vpnserver/</code> 目录下执行 <code>./vpncmd</code>，根据提示选择 3 (<code>3. Use of VPN Tools (certificate creation and Network Traffic Speed Test Tool)</code>)， 然后执行 <code>check</code> 命令进行检查。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./vpncmd</span></span><br><span class="line">By using vpncmd program, the following can be achieved. </span><br><span class="line"></span><br><span class="line">1. Management of VPN Server or VPN Bridge </span><br><span class="line">2. Management of VPN Client</span><br><span class="line">3. Use of VPN Tools (certificate creation and Network Traffic Speed Test Tool)</span><br><span class="line"></span><br><span class="line">Select 1, 2 or 3: 3</span><br><span class="line"></span><br><span class="line">VPN Tools&gt;check</span><br><span class="line">Check command - Check whether SoftEther VPN Operation is Possible</span><br><span class="line">---------------------------------------------------</span><br><span class="line">SoftEther VPN Operation Environment Check Tool</span><br><span class="line"></span><br><span class="line">Copyright (c) SoftEther VPN Project.</span><br><span class="line">All Rights Reserved.</span><br><span class="line"></span><br><span class="line">If this operation environment check tool is run on a system and that system passes, it is most likely that SoftEther VPN software can operate on that system. This check may take a while. Please wait...</span><br><span class="line"></span><br><span class="line">Checking &#x27;Kernel System&#x27;... </span><br><span class="line">              Pass</span><br><span class="line">Checking &#x27;Memory Operation System&#x27;... </span><br><span class="line">              Pass</span><br><span class="line">Checking &#x27;ANSI / Unicode string processing system&#x27;... </span><br><span class="line">              Pass</span><br><span class="line">Checking &#x27;File system&#x27;... </span><br><span class="line">              Pass</span><br><span class="line">Checking &#x27;Thread processing system&#x27;... </span><br><span class="line">              Pass</span><br><span class="line">Checking &#x27;Network system&#x27;... </span><br><span class="line">              Pass</span><br><span class="line"></span><br><span class="line">All checks passed. It is most likely that SoftEther VPN Server / Bridge can operate normally on this system.</span><br><span class="line"></span><br><span class="line">The command completed successfully.</span><br></pre></td></tr></table></figure>
<p>执行检查后输出 <code>All checks passed. It is most likely that SoftEther VPN Server / Bridge can operate normally on this system.</code> ，说明系统可正常满足 vpn server 运行的条件。</p>
<p>根据以下内容生成服务启动脚本，将 vpn server 以 service 的形式运行</p>
<figure class="highlight shell"><figcaption><span>/etc/init.d/softether-vpn-server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">chkconfig: 2345 99 01</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">description: SoftEther VPN Server</span></span><br><span class="line">DAEMON=/usr/local/vpnserver/vpnserver</span><br><span class="line">LOCK=/var/lock/subsys/vpnserver</span><br><span class="line">test -x $DAEMON || exit 0</span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">start)</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">DAEMON start</span></span><br><span class="line">touch $LOCK</span><br><span class="line">;;</span><br><span class="line">stop)</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">DAEMON stop</span></span><br><span class="line">rm $LOCK</span><br><span class="line">;;</span><br><span class="line">restart)</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">DAEMON stop</span></span><br><span class="line">sleep 3</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">DAEMON start</span></span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">echo &quot;Usage: $0 &#123;start|stop|restart&#125;&quot;</span><br><span class="line">exit 1</span><br><span class="line">esac</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>
<p>给服务脚本添加可执行权限，并配置开机启动，之后可以通过 <code>systemctl</code> 管理服务状态。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> 755 /etc/init.d/vpnserver</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl daemon-reload</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl status softether-vpn-server</span></span><br><span class="line">● softether-vpn-server.service - SYSV: SoftEther VPN Server</span><br><span class="line">   Loaded: loaded (/etc/rc.d/init.d/softether-vpn-server; bad; vendor preset: disabled)</span><br><span class="line">   Active: inactive (dead)</span><br><span class="line">     Docs: man:systemd-sysv-generator(8)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl <span class="built_in">enable</span> softether-vpn-server</span></span><br><span class="line">softether-vpn-server.service is not a native service, redirecting to /sbin/chkconfig.</span><br><span class="line">Executing /sbin/chkconfig softether-vpn-server on</span><br></pre></td></tr></table></figure>

<p>防火墙添加以下配置 <sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Listener Ports](https://www.softether.org/4-docs/1-manual/3._SoftEther_VPN_Server_Manual/3.3_VPN_Server_Administration)">[4]</span></a></sup></p>
<figure class="highlight shell"><figcaption><span>/etc/sysconfig/iptables</span></figcaption><table><tr><td class="code"><pre><span class="line">-A INPUT -m comment --comment &quot;vpn&quot; -m multiport -p tcp --dports 443,1194,5555 -j ACCEPT</span><br><span class="line">-A INPUT -m comment --comment &quot;vpn&quot; -m multiport -p udp --dports 4500,500 -j ACCEPT</span><br></pre></td></tr></table></figure>

<h2 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h2><p>安装完 vpn server 之后，可以通过 <code>SoftEther VPN Server Manager</code> 管理 VPN Server。windows 上下载 <a href="https://www.softether-download.com/en.aspx?product=softether"><code>SoftEther VPN Server Manager for Windows</code></a> [] </p>
<p>初次登陆后，建议设置管理员密码<br><img src="https://i.csms.tech/img_116.png"></p>
<p>默认情况下，只存在一个名为 <code>DEFAULT</code> 的 Virtual Hub 注册到了 VPN Server，可以使用此 Virtual Hub，或者删除它重新创建自己的 Virtual Hub。</p>
<p>根据提示选择要创建的的 VPN Server 的类型，普通 VPN 选择 <code>Remote Access VPN Server</code><br><img src="https://i.csms.tech/img_117.png"><br>根据提示，配置要创建的 Virtual Hub 的名称，接着会弹出 <code>Dynamic DNS Function</code> 配置界面。<code>Dynamic DNS Function</code> 的功能，会提供一个 <code>softether.net</code> 域的子域名，通过这个域名，可以解析到 VPN Server 的 IP 地址，如果服务器使用的是动态 IP，此解析会跟着变化。如果服务器只有内网 IP（云主机），此解析会自动解析到公网 IP。<br><img src="https://i.csms.tech/img_118.png"></p>
<p><code>Dynamic DNS Function</code> 配置完成后退出（<code>exit</code>），进入协议配置界面，此处启用所有协议(手机连接 VPN 需要)<br><img src="https://i.csms.tech/img_122.png"></p>
<p>创建 VPN 用户<br><img src="https://i.csms.tech/img_120.png"></p>
<p>回到管理界面后，选择刚刚创建的 Virtual Hub，点击 <code>Manage Virtual Hub</code> 按钮管理配置，选择 <code>Virtual NAT and Virtual DHCP Server(SecureNAT)</code>，启用 <code>SecureNAT</code>，否则客户端可以连接到 VPN Server，但是 VPN Server 不会分配 IP 地址给客户端。<br><img src="https://i.csms.tech/img_121.png"></p>
<h1 id="客户端连接"><a href="#客户端连接" class="headerlink" title="客户端连接"></a>客户端连接</h1><h2 id="android-自带-VPN-客户端连接"><a href="#android-自带-VPN-客户端连接" class="headerlink" title="android 自带 VPN 客户端连接"></a>android 自带 VPN 客户端连接</h2><p>打开手机 VPN 设置，添加 VPN 配置，主要配置以下项：</p>
<ul>
<li><code>Type</code> : <code>L2TP/IPSec PSK</code></li>
<li><code>Server address</code> : 填写 VPN 服务器 IP 或域名</li>
<li><code>IPSec pre-shared key</code> : 填写协议配置界面中配置的 <code>IPsec Pre-shared Key</code> 对应的值，本文档中为<code>vpn</code></li>
<li><code>Username</code> : 填写 VPN 的用户名</li>
<li><code>Password</code> : 填写 VPN 用户密码</li>
</ul>
<h2 id="ios-自带的-VPN-客户端连接"><a href="#ios-自带的-VPN-客户端连接" class="headerlink" title="ios 自带的 VPN 客户端连接"></a>ios 自带的 VPN 客户端连接</h2><p>在 IOS 的 <code>通用</code> –&gt; <code>VPN 与 设备管理</code> –&gt; <code>VPN</code> 中添加 VPN 配置，主要配置以下项：</p>
<ul>
<li><code>类型</code> ： <code>L2TP</code></li>
<li><code>服务器</code> : 填写 VPN 服务器 IP 或域名</li>
<li><code>账户</code> : 填写 VPN 的用户名</li>
<li><code>密码</code> : 填写 VPN 用户密码</li>
<li><code>密钥</code> : 填写协议配置界面中配置的 <code>IPsec Pre-shared Key</code> 对应的值，本文档中为<code>vpn</code></li>
</ul>
<h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><h2 id="VPN-Client-可以连接到-VPN-Server，但是-client-的出口-IP-未变"><a href="#VPN-Client-可以连接到-VPN-Server，但是-client-的出口-IP-未变" class="headerlink" title="VPN Client 可以连接到 VPN Server，但是 client 的出口 IP 未变"></a>VPN Client 可以连接到 VPN Server，但是 client 的出口 IP 未变</h2><p><strong>问题现象</strong></p>
<p>windows 使用 VPN Client 可以正常连接到 VPN Server，但是检查客户端系统的出口 IP，不是 VPN Server 的 IP。检查客户端系统的 IP 地址信息</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ipconfig</span> /all</span><br><span class="line">未知适配器 VPN - VPN Client:</span><br><span class="line"></span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">   描述. . . . . . . . . . . . . . . : VPN Client Adapter - VPN</span><br><span class="line">   物理地址. . . . . . . . . . . . . : <span class="number">5</span>E-<span class="number">7</span>F-<span class="number">99</span>-<span class="number">71</span>-<span class="number">74</span>-AF</span><br><span class="line">   DHCP 已启用 . . . . . . . . . . . : 是</span><br><span class="line">   自动配置已启用. . . . . . . . . . : 是</span><br><span class="line">   本地链接 IPv6 地址. . . . . . . . : fe80::<span class="number">7674</span>:<span class="number">9039</span>:eaca:<span class="number">5976</span>%<span class="number">52</span>(首选)</span><br><span class="line">   自动配置 IPv4 地址  . . . . . . . : <span class="number">169</span>.<span class="number">254</span>.<span class="number">160</span>.<span class="number">75</span>(首选)</span><br><span class="line">   子网掩码  . . . . . . . . . . . . : <span class="number">255</span>.<span class="number">255</span>.<span class="number">0</span>.<span class="number">0</span></span><br><span class="line">   默认网关. . . . . . . . . . . . . :</span><br><span class="line">   DHCPv6 IAID . . . . . . . . . . . : <span class="number">878608281</span></span><br><span class="line">   DHCPv6 客户端 DUID  . . . . . . . : <span class="number">00</span>-<span class="number">01</span>-<span class="number">00</span>-<span class="number">01</span>-<span class="number">29</span>-<span class="number">5</span>D-CA-<span class="number">62</span>-F4-<span class="number">39</span>-<span class="number">09</span>-<span class="number">4</span>B-<span class="number">1</span>C-<span class="number">6</span>A</span><br><span class="line">   DNS 服务器  . . . . . . . . . . . : fec0:<span class="number">0</span>:<span class="number">0</span>:ffff::<span class="number">1</span>%<span class="number">1</span></span><br><span class="line"><span class="function">                                       fec0:0:0:<span class="title">ffff</span>::2%1</span></span><br><span class="line"><span class="function">                                       <span class="title">fec0</span>:0:0:<span class="title">ffff</span>::3%1</span></span><br><span class="line"><span class="function">   <span class="title">TCPIP</span> 上的 <span class="title">NetBIOS</span>  . . . . . . . : 已启用</span></span><br></pre></td></tr></table></figure>
<p>VPN 适配器的 IP 地址为 <code>169.254.160.75</code>，说明客户端未获取 VPN 相应的 IP 地址。检查 VPN Server 配置的 <code>Virtual NAT and Virtual DHCP Server(SecureNAT)</code> 部分，看是否启用了 <code>SecureNAT</code>。启用后重新连接，查看 Windows 系统 IP 地址，看到已经正常分配到 VPN 的 IP，测试公网，变成了 VPN Server 的 IP。 </p>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.softether.org/4-docs/1-manual/3._SoftEther_VPN_Server_Manual/3.2_Operating_Modes">Operating Modes</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.softether.org/4-docs/1-manual/7._Installing_SoftEther_VPN_Server/7.3_Install_on_Linux_and_Initial_Configurations">Install on Linux and Initial Configurations</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.softether.org/4-docs/1-manual/7._Installing_SoftEther_VPN_Server/7.4_Initial_Configurations">Initial Configurations</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.softether.org/4-docs/1-manual/3._SoftEther_VPN_Server_Manual/3.3_VPN_Server_Administration">Listener Ports</a><a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.softether.org/4-docs/1-manual/7._Installing_SoftEther_VPN_Server/7.4_Initial_Configurations">Initial Configurations</a><a href="#fnref:5" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Tools</category>
        <category>VPN</category>
      </categories>
      <tags>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title>vsftpd 服务常见错误</title>
    <url>/202207261304/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="530-Login-incorrect"><a href="#530-Login-incorrect" class="headerlink" title="530 Login incorrect"></a>530 Login incorrect</h3><p><strong>报错信息</strong>： 登录时报错 <code>530 Login incorrect</code><br><strong>错误原因</strong>：</p>
<figure class="highlight shell"><figcaption><span>/etc/pam.d/vsftpd</span></figcaption><table><tr><td class="code"><pre><span class="line">auth  required pam_listfile.so item=user sense=deny file=/etc/vsftpd/ftpusers onerr=succeed </span><br></pre></td></tr></table></figure>
<p>默认情况下，&#x2F;etc&#x2F;vsftpd&#x2F;ftpusers里面的用户是被拒绝登录的，确保要登录的用户不在此文件中</p>
<figure class="highlight shell"><figcaption><span>/etc/pam.d/vsftpd</span></figcaption><table><tr><td class="code"><pre><span class="line">auth       required    pam_shells.so  </span><br></pre></td></tr></table></figure>
<p>此配置指定，只允许登录shell为<code>/etc/shells</code>中的shell的用户登录<br>如果用户shell为<code>/sbin/nologin</code>，则不允许登录，可改为<code>pam_nologin.so</code></p>
<span id="more"></span>

<h3 id="500-OOPS-vsftpd-refusing-to-run-with-writable-root-inside-chroot"><a href="#500-OOPS-vsftpd-refusing-to-run-with-writable-root-inside-chroot" class="headerlink" title="500 OOPS: vsftpd: refusing to run with writable root inside chroot()"></a>500 OOPS: vsftpd: refusing to run with writable root inside chroot()</h3><p><strong>错误原因</strong>: 从2.3.5之后，vsftpd增强了安全检查，如果用户被限定在了其主目录下，则该用户的主目录不能再具有写权限了！如果检查发现还有写权限，就会报该错误。<br><strong>解决方法1</strong>： 用户主目录取消写权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod a-w /data/ftpdir</span><br></pre></td></tr></table></figure>

<p><strong>解决方法2</strong>： 配置文件中增加以下配置</p>
<figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">allow_writeable_chroot=YES</span><br></pre></td></tr></table></figure>

<h3 id="500-OOPS-vsftpd-cannot-locate-user-specified-in-‘guest-username’-ftp"><a href="#500-OOPS-vsftpd-cannot-locate-user-specified-in-‘guest-username’-ftp" class="headerlink" title="500 OOPS: vsftpd: cannot locate user specified in ‘guest_username’:ftp"></a>500 OOPS: vsftpd: cannot locate user specified in ‘guest_username’:ftp</h3><p><strong>错误原因</strong>: 配置文件中启用了匿名用户登录，系统中没有ftp的匿名用户ftp<br><strong>解决方法1</strong>：<br>配置文件中禁用匿名用户登录，同时指定用户</p>
<figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">anonymous_enable=NO</span><br><span class="line">ftp_username=nobody</span><br></pre></td></tr></table></figure>

<h3 id="550-Create-directory-operation-failed"><a href="#550-Create-directory-operation-failed" class="headerlink" title="550 Create directory operation failed"></a>550 Create directory operation failed</h3><p><strong>错误原因</strong>: 匿名登录的用户不允许在ftp根目录下面新建对象，可以在根目录下面创建文件夹，如pub，并给ftp为属主，在pub下面新建文件</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a href="/202207231311/" title="vsftpd 服务常用配置说明">vsftpd 服务常用配置说明</a>  
</li>
<li><a href="/202207251638/" title="vsftpd 虚拟用户配置说明">vsftpd 虚拟用户配置说明</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>Vsftpd</tag>
      </tags>
  </entry>
  <entry>
    <title>vsftpd 服务常用配置说明</title>
    <url>/202207231311/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3></blockquote>
<ul>
<li>Centos 7</li>
<li>vsftpd 3.0.2</li>
</ul>
<span id="more"></span>

<blockquote>
<h3 id="通用配置"><a href="#通用配置" class="headerlink" title="通用配置"></a>通用配置</h3></blockquote>
<figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">匿名用户和本地用户是否能登录，匿名用户使用的登陆名为ftp或anonymous，口令为空，匿名用户不能离开匿名 用户家目录/var/ftp,且只能下载不能上传。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">本地用户的登录名为本地用户名，口令为此本地用户的口令；本地用户可以在自己家目录中进行读写操作；本地用户可以离开自家目录切换至有权限访问的其他目录，并在权限允许的情况下进行上传/下载。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认写在文件/etc/vsftpd.ftpusers中的本地用户禁止登陆。</span></span><br><span class="line">anonymous_enable=YES </span><br><span class="line">local_enable=YES </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">否允许登录用户有写权限。属于全局设置，默认值为YES。</span></span><br><span class="line">write_enable=YES</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果设置为NO，所有的文件都不能下载到本地，文件夹不受影响。默认值为YES。</span></span><br><span class="line">download_enable=YES/NO</span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="匿名用户（anonymous）设置"><a href="#匿名用户（anonymous）设置" class="headerlink" title="匿名用户（anonymous）设置"></a>匿名用户（anonymous）设置</h3></blockquote>
<figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">若是启动这项功能，则使用匿名登入时，不会询问密码。默认值为NO。</span></span><br><span class="line">no_anon_password=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义匿名登入的使用者名称。默认值为ftp。</span></span><br><span class="line">ftp_username=ftp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用匿名登入时，所登入的目录。默认值为/var/ftp。注意ftp目录不能是777的权限属性，即匿名用户的家目录不能有777的权限。</span></span><br><span class="line">anon_root=/var/ftp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果设为YES，则允许匿名登入者有上传文件（非目录）的权限，只有在write_enable=YES时，此项才有效。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当然，匿名用户必须要有对上层目录的写入权。默认值为NO。</span></span><br><span class="line">anon_upload_enable=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果设为YES，则允许匿名登入者下载可阅读的档案（可以下载到本机阅读，不能直接在FTP服务器中打开阅读）。默认值为YES。</span></span><br><span class="line">anon_world_readable_only=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果设为YES，则允许匿名登入者有新增目录的权限，只有在write_enable=YES时，此项才有效。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当然，匿名用户必须要有对上层目录的写入权。默认值为NO。</span></span><br><span class="line">anon_mkdir_write_enable=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果设为YES，则允许匿名登入者更多于上传或者建立目录之外的权限，譬如删除或者重命名。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果anon_upload_enable=NO，则匿名用户 不能上传文件，但可以删除或者重命名已经存在的文件；</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果anon_mkdir_write_enable=NO，则匿名用户不能上传或者新建文件夹，但 可以删除或者重命名已经存在的文件夹。）默认值为NO。</span></span><br><span class="line">anon_other_write_enable=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置是否改变匿名用户上传文件（非目录）的属主。默认值为NO。</span></span><br><span class="line">chown_uploads=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置匿名用户上传文件（非目录）的属主名。建议不要设置为root。</span></span><br><span class="line">chown_username=username</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置匿名登入者新增或上传档案时的<span class="built_in">umask</span> 值。默认值为077，则新建档案的对应权限为700。</span></span><br><span class="line">anon_umask=077</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">若是启动这项功能，则必须提供一个档案/etc/vsftpd/banner_emails，内容为email address。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">若是使用匿名登入，则会要求输入email address，若输入的email address 在此档案内，则不允许进入。默认值为NO。</span></span><br><span class="line">deny_email_enable=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此文件用来输入email address，只有在deny_email_enable=YES时，才会使用到此档案。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">若是使用匿名登入，则会要求输入email address，若输入的email address 在此档案内，则不允许进入。</span></span><br><span class="line">banned_email_file=/etc/vsftpd/banner_emails</span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="本地用户-设置"><a href="#本地用户-设置" class="headerlink" title="本地用户 设置"></a>本地用户 设置</h3></blockquote>
<figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">控制是否允许本地用户登入，默认值为YES。</span></span><br><span class="line">local_enable=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当本地用户登入时，将被更换到定义的目录下。默认值为各用户的家目录</span></span><br><span class="line">local_root=/home/username</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">本地用户新增档案时的<span class="built_in">umask</span> 值。默认值为077。</span></span><br><span class="line">local_umask=022</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">本地用户上传档案后的档案权限，与<span class="built_in">chmod</span> 所使用的数值相同。默认值为0666。</span></span><br><span class="line">file_open_mode=0755</span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="欢迎语设置"><a href="#欢迎语设置" class="headerlink" title="欢迎语设置"></a>欢迎语设置</h3></blockquote>
<figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果启动这个选项，那么使用者第一次进入一个目录时，会检查该目录下是否有.message这个档案</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果有，则会出现此档案的内容，通常这个档案会放置欢迎话语，或是对该目录的说明。默认值为开启。</span></span><br><span class="line">dirmessage_enable=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置目录消息文件，可将要显示的信息写入该文件。默认值为.message。</span></span><br><span class="line">message_file=.message</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当使用者登入时，会显示此设定所在的档案内容，通常为欢迎话语或是说明。默认值为无。如果欢迎信息较多，则使用该配置项。</span></span><br><span class="line">banner_file=/etc/vsftpd/banner</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里用来定义欢迎话语的字符串，banner_file是档案的形式，而ftpd_banner 则是字符串的形式。预设为无。</span></span><br><span class="line">ftpd_banner=Welcome to BOB&#x27;s FTP server</span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="控制用户是否允许切换到上级目录"><a href="#控制用户是否允许切换到上级目录" class="headerlink" title="控制用户是否允许切换到上级目录"></a>控制用户是否允许切换到上级目录</h3></blockquote>
<figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">是否将用户限制在用户主目录。默认值为NO。</span></span><br><span class="line">chroot_local_user=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在默认配置下(chroot_local_user=NO)，本地用户登入FTP后可以使用<span class="built_in">cd</span>命令切换到其他目录，这样会对系统带来安全隐患。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置是否启用chroot_list_file配置项指定的用户列表文件。默认值为NO。</span></span><br><span class="line">chroot_list_enable=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用于指定用户列表文件，该文件用于控制哪些用户可以切换到用户家目录的上级目录。</span></span><br><span class="line">chroot_list_file=/etc/vsftpd.chroot_list</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 通过搭配能实现以下几种效果：</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 当chroot_local_user=YES, chroot_list_enable=YES时，</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在/etc/vsftpd.chroot_list文件中列出的用户，可以切换到其他目录；未在文件中列出的用户，不能切换到其他目录。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. 当chroot_local_user=YES, chroot_list_enable=NO时，</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">所有用户被限制在主目录，不启用chroot_list_file白名单，没有例外</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3. 当chroot_local_user=NO， chroot_list_enable=YES时</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">所有用户不限制在主目录，chroot_list_file中的用户例外，限制切换到主目录之外</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4. 当chroot_local_user=NO， chroot_list_enable=NO时</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">所有用户不限制在主目录,不启用chroot_list_file，没有任何例外</span></span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="数据传输模式设置"><a href="#数据传输模式设置" class="headerlink" title="数据传输模式设置"></a>数据传输模式设置</h3></blockquote>
<figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">FTP在传输数据时，可以使用二进制方式，也可以使用ASCII模式来上传或下载数据。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置是否启用ASCII 模式上传数据。默认值为NO。</span></span><br><span class="line">ascii_upload_enable=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置是否启用ASCII 模式下载数据。默认值为NO。</span></span><br><span class="line">ascii_download_enable=YES/NO</span><br></pre></td></tr></table></figure>
<blockquote>
<h3 id="访问控制设置"><a href="#访问控制设置" class="headerlink" title="访问控制设置"></a>访问控制设置</h3></blockquote>
<figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">两种控制方式：一种控制主机访问，另一种控制用户访问。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置vsftpd是否与tcp wrapper相结合来进行主机的访问控制。默认值为YES。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果启用，则vsftpd服务器会检查/etc/hosts.allow 和/etc/hosts.deny 中的设置，来决定请求连接的主机，是否允许访问该FTP服务器。这两个文件可以起到简易的防火墙功能。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">比如：若要仅允许192.168.0.1—192.168.0.254的用户可以连接FTP服务器，则在/etc/hosts.allow文件中添加以下内容：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">vsftpd:192.168.0. :allow</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">all:all :deny</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">对于用户的访问控制可以通过/etc目录下的vsftpd.user_list和ftpusers文件来实现。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">控制用户访问FTP的文件，里面写着用户名称。一个用户名称一行。</span></span><br><span class="line">userlist_file=/etc/vsftpd.user_list</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">是否启用vsftpd.user_list文件。</span></span><br><span class="line">userlist_enable=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">决定vsftpd.user_list文件中的用户是否能够访问FTP服务器。userlist_enable=YES 才有效</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">若设置为YES，则vsftpd.user_list文件中的用户不允许访问FTP，为黑名单，其他用户可以访问</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">若设置为NO，则vsftpd.user_list文件中的用户能访问FTP，为白名单，其他用户不能访问</span></span><br><span class="line">userlist_deny=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/etc/vsftpd/ftpusers文件专门用于定义不允许访问FTP服务器的用户列表，不受任何配置文件影响，里面的用户始终不允许方法vsftpd</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认情况下vsftpd.user_list和ftpusers，这两个 文件已经预设置了一些不允许访问FTP服务器的系统内部账户。如果系统没有这两个文件，那么新建这两个文件，将用户添加进去即可。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="访问速率设置"><a href="#访问速率设置" class="headerlink" title="访问速率设置"></a>访问速率设置</h3></blockquote>
<figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置匿名登入者使用的最大传输速度，单位为B/s，0 表示不限制速度。默认值为0。</span></span><br><span class="line">anon_max_rate=0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">本地用户使用的最大传输速度，单位为B/s，0 表示不限制速度。预设值为0。</span></span><br><span class="line">local_max_rate=0</span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="超时时间设置"><a href="#超时时间设置" class="headerlink" title="超时时间设置"></a>超时时间设置</h3></blockquote>
<figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置建立FTP连接的超时时间，单位为秒。默认值为60。</span></span><br><span class="line">accept_timeout=60</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">PORT 方式下建立数据连接的超时时间，单位为秒。默认值为60。</span></span><br><span class="line">connect_timeout=60</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置建立FTP数据连接的超时时间，单位为秒。默认值为120。</span></span><br><span class="line">data_connection_timeout=120</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置多长时间不对FTP服务器进行任何操作，则断开该FTP连接，单位为秒。默认值为300 。</span></span><br><span class="line">idle_session_timeout=300</span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="日志文件设置"><a href="#日志文件设置" class="headerlink" title="日志文件设置"></a>日志文件设置</h3></blockquote>
<figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">是否启用上传/下载日志记录。如果启用，则上传与下载的信息将被完整纪录在xferlog_file 所定义的档案中。预设为开启</span></span><br><span class="line">xferlog_enable= YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置日志文件名和路径，默认值为/var/log/vsftpd.log。</span></span><br><span class="line">xferlog_file=/var/log/vsftpd.log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果启用，则日志文件将会写成xferlog的标准格式，如同wu-ftpd 一般。默认值为关闭。</span></span><br><span class="line">xferlog_std_format=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果启用此选项，所有的FTP请求和响应都会被记录到日志中，默认日志文件在/var/log/vsftpd.log。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启用此选项时，xferlog_std_format不能被激活。这个选项有助于调试。默认值为NO。</span></span><br><span class="line">log_ftp_protocol=YES|NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">登录日志</span></span><br><span class="line">dual_log_enable=YES</span><br><span class="line">vsftpd_log_file=/var/log/vsftpd.log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">日志中的时间与系统时间保持一致</span></span><br><span class="line">use_localtime=YES</span><br></pre></td></tr></table></figure>
<blockquote>
<h3 id="FTP的工作方式与端口设置"><a href="#FTP的工作方式与端口设置" class="headerlink" title="FTP的工作方式与端口设置"></a>FTP的工作方式与端口设置</h3></blockquote>
<figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">FTP有两种工作方式：PORT FTP（主动模式）和 PASV FTP（被动模式）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置FTP服务器建立连接所监听的端口，默认值为21。</span></span><br><span class="line">listen_port=21</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定FTP使用20端口进行数据传输，默认值为YES。</span></span><br><span class="line">connect_from_port_20=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置在PORT方式下，FTP数据连接使用的端口，默认值为20。</span></span><br><span class="line">ftp_data_port=20</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">若设置为YES，则使用PASV工作模式；若设置为NO，则使用PORT模式。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认值为YES，即使用PASV工作模式。</span></span><br><span class="line">pasv_enable=YES/NO（YES）</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在PASV工作模式下，数据连接可以使用的端口范围的最大端口，0 表示任意端口。默认值为0。</span></span><br><span class="line">pasv_max_port=0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在PASV工作模式下，数据连接可以使用的端口范围的最小端口，0 表示任意端口。默认值为0。</span></span><br><span class="line">pasv_min_port=0</span><br></pre></td></tr></table></figure>
<blockquote>
<h3 id="与连接相关的设置"><a href="#与连接相关的设置" class="headerlink" title="与连接相关的设置"></a>与连接相关的设置</h3></blockquote>
<figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置vsftpd服务器是否以standalone模式运行。以standalone模式运行是一种较好的方式，此时listen必须设置为YES，此为默认值。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">建议不要更改，有很多与服务器运行相关的配置命令，需要在此模式下才有效。若设置为NO，则vsftpd不是以独立的服务运行，要受到xinetd 服务的管控，功能上会受到限制。</span></span><br><span class="line">listen=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置vsftpd允许的最大连接数，默认值为0，表示不受限制。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">若设置为100时，则同时允许有100个连接，超出的将被拒绝。只有在standalone模式运行才有效。</span></span><br><span class="line">max_clients=0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置每个IP允许与FTP服务器同时建立连接的数目。默认值为0，表示不受限制。只有在standalone模式运行才有效。</span></span><br><span class="line">max_per_ip=0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置FTP服务器在指定的IP地址上侦听用户的FTP请求。若不设置，则对服务器绑定的所有IP地址进行侦听。只有在standalone模式运行才有效。</span></span><br><span class="line">listen_address=IP地址</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置每个与FTP服务器的连接，是否以不同的进程表现出来。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认值为NO，此时使用ps aux |grep ftp只会有一个vsftpd的进程。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">若设置为YES，则每个连接都会有一个vsftpd的进程。</span></span><br><span class="line">setproctitle_enable=YES/NO</span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="虚拟用户相关配置"><a href="#虚拟用户相关配置" class="headerlink" title="虚拟用户相关配置"></a>虚拟用户相关配置</h3></blockquote>
<a href="/202207251638/" title="vsftpd虚拟用户配置过程参考">vsftpd虚拟用户配置过程参考</a>

<figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用虚拟用户功能，必须允许本地用户登录</span></span><br><span class="line">local_enable=YES</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启用虚拟用户配置，所有非匿名用户登录将视为游客，将被映射为guest_username</span></span><br><span class="line">guest_enable=YES</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">虚拟用户映射的本地用户</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">主配置文件中必需有，否则报错</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">500 OOPS: vsftpd: cannot locate user specified <span class="keyword">in</span> <span class="string">&#x27;guest_username&#x27;</span>:ftp</span></span><br><span class="line">guest_username=virftp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">虚拟用户独立配置文件目录</span></span><br><span class="line">user_config_dir=/etc/vsftpd/virtual_user_conf          </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">虚拟用户使用本地用户的权限</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认为NO，虚拟用户具有和匿名用户一样的权限</span></span><br><span class="line">virtual_use_local_privs=YES | NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">虚拟用户加载的pam模块，默认为`/etc/pam.d/vsftpd`</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pam_service_name=vsftpd_vu</span></span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="虚拟用户配置文件"><a href="#虚拟用户配置文件" class="headerlink" title="虚拟用户配置文件"></a>虚拟用户配置文件</h3></blockquote>
<p>每个虚拟用户都需要一个单独的配置文件，虚拟用户配置文件在vsftpd配置中 <code>user_config_dir</code> 对应的目录(<code>/etc/vsftpd/virtual_user_conf</code>)下<br>文件名必须和用户名一样</p>
<figure class="highlight shell"><figcaption><span>user1</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定虚拟用户根目录</span></span><br><span class="line">local_root=/home/ftpsite/user1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">虚拟用户是和本地用户有相同权限;NO：虚拟用户和匿名用户权限相同</span></span><br><span class="line">virtual_use_local_privs=YES</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">虚拟用户对应的系统用户</span></span><br><span class="line">guest_username=virftp</span><br><span class="line"></span><br><span class="line">write_enable=YES</span><br><span class="line">lock_upload_files=NO</span><br><span class="line">anon_umask=022</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">download_enable=NO</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">anon_upload_enable=YES</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">anon_mkdir_write_enable=YES</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">anon_other_write_enable=YES</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">chown_uploads=YES</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">chown_username=nono</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">allow_anon_ssl=YES</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">force_anon_logins_ssl=YES</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">force_anon_data_ssl=YES</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">cmds_allowed=CWD,LIST,MDTM,MKD,NLST,PASS,PASV,PORT,PWD,QUIT,RMD,RETR,SIZE,STOR,TYPE,USER,ACCT,APPE,CDUP,HELP,MODE,NOOP,REIN,STAT,STOU,STRU,SYST</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">虚拟用户将被锁定在自己的宿主目录</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">chroot_local_user=YES</span>            </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>Vsftpd</tag>
      </tags>
  </entry>
  <entry>
    <title>vsftpd 虚拟用户配置说明</title>
    <url>/202207251638/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3></blockquote>
<ul>
<li>Centos 7</li>
<li>Vsftpd 3.0.2</li>
</ul>
<p>vsftpd虚拟用户通过映射系统用户权限的方式，使虚拟用户具有和本地系统用户一样的权限，或者灵活的控制虚拟用户的权限(不和本地用户权限相同，不能高于本地权限)，达到访问权限的灵活控制，同时防止大批vsftpd用户添加到系统账号库中，使系统用户管理变动臃肿。</p>
<span id="more"></span>

<h3 id="创建虚拟用户映射的系统用户"><a href="#创建虚拟用户映射的系统用户" class="headerlink" title="创建虚拟用户映射的系统用户"></a>创建虚拟用户映射的系统用户</h3><p>系统用户virtftp拥有对ftp的读写权限，假设ftp根目录为&#x2F;data&#x2F;vsftpd&#x2F;<br>创建ftp用户组和用户virtftp，ftp相关系统账号属于ftp组  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groupadd ftp</span><br><span class="line">useradd -d /data/vsftpd -M -s /sbin/nologin -g ftp virtftp</span><br><span class="line">mkdir /data/vsftpd</span><br><span class="line">chown -R virtftp:ftp /data/vsftpd</span><br><span class="line">chmod -R 750 /data/vsftpd</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ftp根目录属于用户virtftp,用户组为ftp，设置权限750，使virtftp用户拥有读写权限</p>
</blockquote>
<h3 id="创建虚拟用户的口令库"><a href="#创建虚拟用户的口令库" class="headerlink" title="创建虚拟用户的口令库"></a>创建虚拟用户的口令库</h3><p>需要使用db_load命令根据原始口令文件(<code>/etc/vsftpd/passwd.txt</code>)生成db口令库文件，原始文件中奇数行为用户名，偶数行为密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db_load -T -t hash -f /etc/vsftpd/passwd.txt /etc/vsftpd/passwd.db</span><br><span class="line">chmod 600 /etc/vsftpd/passwd.db</span><br></pre></td></tr></table></figure>
<p>修改pam认证文件&#x2F;etc&#x2F;pam.d&#x2F;vsftpd,只保留以下2行<br>或者重新创建文件&#x2F;etc&#x2F;pam.d&#x2F;vsftpd_vu,并在<code>vsftpd.conf</code>中配置<code>pam_service_name=vsftpd_vu</code>)</p>
<figure class="highlight shell"><figcaption><span>vsftpd_vu</span></figcaption><table><tr><td class="code"><pre><span class="line">auth required /lib64/security/pam_userdb.so db=/etc/vsftpd/passwd</span><br><span class="line">account required /lib64/security/pam_userdb.so db=/etc/vsftpd/passwd  </span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>db=/etc/vsftpd/passwd</code> 为<code>db_load</code>生产的文件，不要带后缀 <code>.db</code><br>如果认证发生错误，可检查日志文件：<code>/var/log/secure</code></p>
</blockquote>
<h3 id="配置-vsftpd-启用虚拟用户"><a href="#配置-vsftpd-启用虚拟用户" class="headerlink" title="配置 vsftpd 启用虚拟用户"></a>配置 vsftpd 启用虚拟用户</h3><p>修改vsftpd配置文件，默认为<code>/etc/vsftpd/vsftpd.conf</code> <a href="/202207231311/" title="vsftpd.conf常用配置文件说明">vsftpd.conf常用配置文件说明</a></p>
<figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用虚拟用户功能，必须允许本地用户</span></span><br><span class="line">local_enable=YES     </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启用虚拟用户配置，所有非匿名用户登录将视为游客，将被映射为guest_username</span>     </span><br><span class="line">guest_enable=YES     </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">主配置文件中必需有，否则报错</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">500 OOPS: vsftpd: cannot locate user specified <span class="keyword">in</span> <span class="string">&#x27;guest_username&#x27;</span>:ftp</span></span><br><span class="line">guest_username=virtftp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">虚拟用户独立配置文件目录,每个虚拟用户有一个同名的配置文件于此目录下</span></span><br><span class="line">user_config_dir=/etc/vsftpd/virtual_user_conf          </span><br><span class="line">                        </span><br></pre></td></tr></table></figure>

<h3 id="配置虚拟用户配置文件"><a href="#配置虚拟用户配置文件" class="headerlink" title="配置虚拟用户配置文件"></a>配置虚拟用户配置文件</h3><p>虚拟用户配置文件位于 <code>vsftpd.conf</code> 配置 <code>user_config_dir</code> 指定的目录下，每个用户一个配置文件，配置文件和用户名同名<br>用户名，配置文件名，必须和口令文件中的用户名保持一致  </p>
<figure class="highlight shell"><figcaption><span>user1</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定虚拟用户根目录</span></span><br><span class="line">local_root=/home/ftpsite/user1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">虚拟用户是和本地用户有相同权限;NO：虚拟用户和匿名用户权限相同</span>        </span><br><span class="line">virtual_use_local_privs=YES         </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">虚拟用户对应的系统用户</span></span><br><span class="line">guest_username=virtftp   </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">虚拟用户将被锁定在自己的宿主目录</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">chroot_local_user=YES</span>    </span><br><span class="line">         </span><br><span class="line">write_enable=YES                               </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">lock_upload_files=NO</span></span><br><span class="line">anon_umask=022</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">download_enable=NO</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">anon_upload_enable=YES</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">anon_mkdir_write_enable=YES</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">anon_other_write_enable=YES</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">chown_uploads=YES</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">chown_username=nono</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">allow_anon_ssl=YES</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">force_anon_logins_ssl=YES</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">force_anon_data_ssl=YES</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">cmds_allowed=CWD,LIST,MDTM,MKD,NLST,PASS,PASV,PORT,PWD,QUIT,RMD,RETR,SIZE,STOR,TYPE,USER,ACCT,APPE,CDUP,HELP,MODE,NOOP,REIN,STAT,STOU,STRU,SYST</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="常用配置说明"><a href="#常用配置说明" class="headerlink" title="常用配置说明"></a>常用配置说明</h3><p>virtual_use_local_privs参数说明<br>当<code>virtual_use_local_privs=YES</code>时，虚拟用户和本地用户有相同的权限；<br>当<code>virtual_use_local_privs=NO</code> 时，虚拟用户和匿名用户有相同的权限，默认是NO。<br>当<code>virtual_use_local_privs=YES</code>，<code>write_enable=YES</code>时，虚拟用户具有写权限（上传、下载、删除、重命名）。<br>当<code>virtual_use_local_privs=NO</code>，<code>write_enable=YES</code>，<code>anon_world_readable_only=YES</code>，<code>anon_upload_enable=YES</code> 时，虚拟用户不能浏览目录，只能上传文件，无其他权限。<br>当<code>virtual_use_local_privs=NO</code>，<code>write_enable=YES</code>，<code>anon_world_readable_only=NO</code>，<code>anon_upload_enable=NO</code> 时，虚拟用户只能下载文件，无其他权限。<br>当<code>virtual_use_local_privs=NO</code>，<code>write_enable=YES</code>，<code>anon_world_readable_only=NO</code>，<code>anon_upload_enable=YES</code> 时，虚拟用户只能上传和下载文件，无其他权限。<br>当<code>virtual_use_local_privs=NO</code>，<code>write_enable=YES</code>，<code>anon_world_readable_only=NO</code>，<code>anon_mkdir_write_enable=YES</code> 时，虚拟用户只能下载文件和创建文件夹，无其他权限。<br>当<code>virtual_use_local_privs=NO</code>，<code>write_enable=YES</code>，<code>anon_world_readable_only=NO</code>，<code>anon_other_write_enable=YES</code> 时，虚拟用户只能下载、删除和重命名文件，无其他权限。  </p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>Vsftpd</tag>
      </tags>
  </entry>
  <entry>
    <title>网宿云 cdn 预热脚本</title>
    <url>/202207251026/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>将源站的内容主动预取到 CDN 节点，用户首次访问可直接命中缓存，即提升首次访问速度，又能有效缓解源站压力。</p>
<ul>
<li>数据格式：请求和响应都支持 json&#x2F;xml，xml 的参数与 json 的参数基本一致，json 的参数是驼峰分隔，xml 的参数是“-”分隔，详见示例。</li>
<li>限制说明：每个账号的预取并发是 10，调高并发会增加回源的压力，请联系技术支持人员评估。</li>
</ul>
<span id="more"></span>

<h3 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h3><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">类型</th>
<th align="center">是否必填</th>
<th align="left">说明</th>
<th align="left">内部备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">urls</td>
<td align="center">Array</td>
<td align="center">是</td>
<td align="left">要预取到 CDN 节点的 url 集合，url 格式说明：<br/>1）URL 必须以’http:&#x2F;&#x2F;‘ 或 ‘https:&#x2F;&#x2F;‘ 开头，输入示例：<a href="http://www.a.com/image/test.png%E3%80%82">http://www.a.com/image/test.png。</a> <br/>2）每个 url 最大长度 2000 字符。<br/>3）每个 url 所在的域名必须是在我司加速的域名且有预取权限。<br/>4）url 中如果包含中文字符，则提交的 url 需要是中文转义后的url，采用 utf-8 方式转义。<br/>5）每日不超过 20000 条，不超过 200G 文件大小（账号粒度可调，联系技术支持人员调整）。<br/>6）每次接口调用 url 的总数不超过 400 条。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">isRange</td>
<td align="center">Int</td>
<td align="center">否</td>
<td align="left">是否需要预取 range 段。<br/>1）默认为 0，表示预取完整的文件；<br/>2）1 表示预取文件 0~512KB 的 range 段（账号粒度可调，联系技术支持人员调整）。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">aliasDomain</td>
<td align="center">String</td>
<td align="center">否</td>
<td align="left">账号开启 ts 解析<br/>有值的话，m3u8 和生成的 ts 文件需要同时生成一份带别名的url</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">parentDir</td>
<td align="center">String</td>
<td align="center">否</td>
<td align="left">一级目录，该参数和 aliasDomain 一起使用<br/>如果有值的话，是做为别名的一级目录</td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="响应参数"><a href="#响应参数" class="headerlink" title="响应参数"></a>响应参数</h3><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">x-cnc-request-id</td>
<td align="center">String</td>
<td align="left">本次请求的唯一标识,当接口调用异常时，可将 requestID 提供给网宿技术支持，便于排查接口的访问日志。</td>
</tr>
<tr>
<td align="center">Code</td>
<td align="center">Int</td>
<td align="left">表示任务创建结果的状态码，1 表示任务提交成功，0 表示任务提交失败</td>
</tr>
<tr>
<td align="center">Message</td>
<td align="center">String</td>
<td align="left">表示任务提交后，系统的响应消息</td>
</tr>
<tr>
<td align="center">itemId</td>
<td align="center">String</td>
<td align="left">调用一次接口并提交任务成功后，将返回一个 itemId，是当次提交任务的唯一标识，通过 itemId 可批量查询任务的状态（成功&#x2F;失败）。</td>
</tr>
</tbody></table>
<h3 id="请求示例"><a href="#请求示例" class="headerlink" title="请求示例"></a>请求示例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">username=&quot;username&quot;</span><br><span class="line">apiKey=&quot;apiKey&quot;</span><br><span class="line">date=`env LANG=&quot;en_US.UTF-8&quot; date -u &quot;+%a, %d %b %Y %H:%M:%S GMT&quot;`</span><br><span class="line">password=`echo -en &quot;$date&quot; | openssl dgst -sha1 -hmac $apiKey -binary | </span><br><span class="line">openssl enc -base64`</span><br><span class="line">curl -i --url &quot;https://open.chinanetcenter.com/ccm/fetch/ItemIdReceiver&quot; -X &quot;POST&quot; -u &quot;$username:$password&quot; \</span><br><span class="line"> -H &quot;Date:$date&quot; -H &quot;Content-Type: application/json&quot; -d &#x27;&#123;</span><br><span class="line"> &quot;urls&quot;: [</span><br><span class="line"> &quot;http://www.testb.com/test/test1.txt&quot;,</span><br><span class="line"> &quot;http://www.testb.com/test/test2.txt&quot;</span><br><span class="line"> ],</span><br><span class="line">&quot;isRange&quot;:0</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://wcs.chinanetcenter.com/document/Tools/GenerateUploadToken"><code>apiKey</code> 生成链接</a></p>
</blockquote>
<p>正确的响应示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Fri, 26 Oct 2012 06:33:26 GMT</span><br><span class="line">Content-Type: application/json;charset=UTF-8 x-cnc-request-id:&#123;id string auto generated by cloud server&#125;</span><br><span class="line">&#123;</span><br><span class="line"> &quot;Code&quot;: 1,</span><br><span class="line"> &quot;Message&quot;: &quot;success&quot;,</span><br><span class="line"> &quot;itemId&quot;: &quot;a2cfcc6fe79c4a8abcab806578f9bada&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://wcs.chinanetcenter.com/document/Tools/GenerateUploadToken">官网说明</a><br><a href="https://s.csms.tech/file/01%E6%8E%A8%E8%8D%90-%E9%A2%84%E5%8F%96%E6%96%87%E4%BB%B6.pdf">网宿cdn预热完整文档</a></p>
]]></content>
      <categories>
        <category>云平台</category>
        <category>网宿</category>
      </categories>
      <tags>
        <tag>云平台</tag>
        <tag>网宿</tag>
      </tags>
  </entry>
  <entry>
    <title>网宿云存储 python sdk 常用操作</title>
    <url>/f63bf868/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li><p>Centos7</p>
</li>
<li><p>Python3</p>
</li>
<li><p>wcs-python3-sdk (5.0.35)</p>
</li>
</ul>
<p># 网宿云python sdk, <code>pip3 install wcs-python3-sdk</code>， 安装后包含cli工具<code>wcscmd</code></p>
<h3 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wcscmd --configure [--config=FILE] </span><br></pre></td></tr></table></figure>

<p><code>--config=FILE  </code>配置文件存储路径，默认<code>~/.wcscfg</code> <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[参考链接](https://github.com/Wangsu-Cloud-Storage/wcs-python-sdk)">[1]</span></a></sup></p>
<h3 id="wcscmd-常用操作"><a href="#wcscmd-常用操作" class="headerlink" title="wcscmd 常用操作"></a>wcscmd 常用操作</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wcscmd listbucket </span><br><span class="line">wcscmd stat wcs://BUCKET/OBJECT  \# 查询文件信息</span><br><span class="line">wcscmd deletePrefix wcs://BUCKET PREFIX  \# 根据前缀（文件路径，必须从头开始匹配，不需要最前面的/）删除目录或文件</span><br><span class="line">wcscmd put wcs://BUCKET/file file</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="python3-sdk-操作"><a href="#python3-sdk-操作" class="headerlink" title="python3 sdk 操作"></a>python3 sdk 操作</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> wcs.commons.config <span class="keyword">import</span> Config</span><br><span class="line"><span class="keyword">from</span> wcs.services.client <span class="keyword">import</span> Client</span><br><span class="line"></span><br><span class="line">config_file = <span class="string">&quot;/root/.wcscfg&quot;</span></span><br><span class="line">cfg = Config(config_file)</span><br><span class="line">cli = Client(cfg)</span><br><span class="line">bucketName = <span class="string">&quot;TestBucket&quot;</span></span><br><span class="line">buckList = cli.bucket_list(bucketName, marker=<span class="string">&#x27;&#x27;</span>)    <span class="comment"># 列出bucket中的文件列表，每次最多获取1000个，第一页 `marker=&#x27;&#x27;`, 请求第一页的响应中marker的值为新的页的marker，可通过新的marker继续发起请求</span></span><br></pre></td></tr></table></figure>

<h4 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h4><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://github.com/Wangsu-Cloud-Storage/wcs-python-sdk">参考链接</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>云平台</category>
        <category>网宿</category>
      </categories>
      <tags>
        <tag>云平台</tag>
        <tag>网宿</tag>
      </tags>
  </entry>
  <entry>
    <title>windows 远程登录失败</title>
    <url>/f5e030ac/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>远程登录 windows 失败，报错:</p>
<blockquote>
<p>由于没有远程桌面授权服务器可以提供许可证，远程会话连接已断开，请跟服务器管理员联系</p>
</blockquote>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ol>
<li>打开 cmd，执行以下命令远程登录无法登录的 Windows 主机<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">mstsc /v:<span class="number">1</span>.<span class="number">1</span>.<span class="number">1</span>.<span class="number">1</span> /admin</span><br></pre></td></tr></table></figure></li>
<li>打开注册表</li>
</ol>
<p><img src="https://i.csms.tech/img_1.png"><br>3. 找到路径： HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\RCM\GracePeriod.如果超过120天后RCM下面会有一个GracePeriod,先备份这项注册表，再删除除了默认的的注册表项。</p>
<ol start="4">
<li>重启电脑后生效.</li>
</ol>
]]></content>
      <categories>
        <category>Window</category>
        <category>常见错误</category>
      </categories>
      <tags>
        <tag>Window</tag>
      </tags>
  </entry>
  <entry>
    <title>wireshark 抓包工具使用</title>
    <url>/202211251613/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="wiresark-显示过滤器使用方法"><a href="#wiresark-显示过滤器使用方法" class="headerlink" title="wiresark 显示过滤器使用方法"></a>wiresark 显示过滤器使用方法</h1><p>Wireshark 提供了两种过滤器</p>
<ul>
<li><strong>捕获过滤器</strong>：在抓包之前就设定好过滤条件，然后只抓取符合条件的数据包。</li>
<li><strong>显示过滤器</strong>：在已捕获的数据包集合中设置过滤条件，隐藏不想显示的数据包，只显示符合条件的数据包。</li>
</ul>
<p>这两种过滤器所使用的语法是完全不同的，捕捉网卡数据的其实并不是 Wireshark，而是 WinPcap，要按 WinPcap 的规则来，显示过滤器就是 Wireshark 对已捕捉的数据进行筛选。</p>
<h2 id="显示过滤器中常用的关系计算符号"><a href="#显示过滤器中常用的关系计算符号" class="headerlink" title="显示过滤器中常用的关系计算符号"></a>显示过滤器中常用的关系计算符号</h2><table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>eq</code><br/><code>==</code></td>
<td>等于</td>
<td><code>ip.src==10.10.10.10</code> <br/><code>ip.src eq 10.10.10.10</code></td>
</tr>
<tr>
<td><code>ne</code><br/><code>!=</code></td>
<td>不等于</td>
<td><code>ip.src!=10.10.10.10</code> <br/><code>ip.src ne 10.10.10.10</code></td>
</tr>
<tr>
<td><code>gt</code><br/><code>&gt;</code></td>
<td>大于</td>
<td></td>
</tr>
<tr>
<td><code>lt</code><br/><code>&lt;</code></td>
<td>小于</td>
<td></td>
</tr>
<tr>
<td><code>ge</code><br/><code>&gt;=</code></td>
<td>大于等于</td>
<td></td>
</tr>
<tr>
<td><code>le</code><br/><code>&lt;=</code></td>
<td>小于等于</td>
<td></td>
</tr>
<tr>
<td><code>contains</code></td>
<td>包含</td>
<td><code>http.host contains com</code></td>
</tr>
</tbody></table>
<h2 id="显示过滤器中常用的逻辑计算符号"><a href="#显示过滤器中常用的逻辑计算符号" class="headerlink" title="显示过滤器中常用的逻辑计算符号"></a>显示过滤器中常用的逻辑计算符号</h2><table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>and</code><br/><code>&amp;&amp;</code></td>
<td>与</td>
<td><code>http.host contains com &amp;&amp; ip.src == 44.199.163.86</code><br/><code>http.host contains com and ip.src == 44.199.163.86</code></td>
</tr>
<tr>
<td><code>or</code><br/><code>||</code></td>
<td>或</td>
<td></td>
</tr>
<tr>
<td><code>not</code><br/><code>!</code></td>
<td>非</td>
<td></td>
</tr>
</tbody></table>
<h2 id="常用示例"><a href="#常用示例" class="headerlink" title="常用示例"></a>常用示例</h2><h3 id="针对-IP-过滤"><a href="#针对-IP-过滤" class="headerlink" title="针对 IP 过滤"></a>针对 IP 过滤</h3><ul>
<li>对源地址进行过滤<br><code>ip.src == 192.168.0.1</code></li>
<li>对目的地址进行过滤<br><code>ip.dst == 192.168.0.1</code></li>
<li>对源地址或者目的地址进行过滤<br><code>ip.addr == 192.168.0.1</code></li>
<li>如果想排除以上的数据包，只需要将其用括号囊括，然后使用 <code>!</code> 即可<br><code>!(ip.addr == 192.168.0.1)</code></li>
</ul>
<h3 id="针对协议过滤"><a href="#针对协议过滤" class="headerlink" title="针对协议过滤"></a>针对协议过滤</h3><p>针对某种协议的数据包，表达式很简单仅仅需要把协议的名字（必须小写）输入即可</p>
<p>常见协议：<br><code>tcp</code><br><code>udp</code><br><code>arp</code><br><code>icmp</code><br><code>http</code><br><code>smtp</code><br><code>ftp</code><br><code>dns</code><br><code>msnms</code><br><code>ip</code><br><code>ssl</code><br><code>oicq</code><br><code>bootp</code></p>
<h3 id="针对端口过滤"><a href="#针对端口过滤" class="headerlink" title="针对端口过滤"></a>针对端口过滤</h3><ul>
<li>捕获某一端口的数据包（以 tcp 协议为例）<br><code>tcp.port == 80</code></li>
<li>捕获多端口的数据包，可以使用 <code>and</code> 来连接，下面是捕获高于某端口的表达式（以 udp 协议为例）<br><code>udp.port &gt;= 2048</code></li>
</ul>
<h3 id="针对-http-请求的一些过滤实例"><a href="#针对-http-请求的一些过滤实例" class="headerlink" title="针对 http 请求的一些过滤实例"></a>针对 http 请求的一些过滤实例</h3><ul>
<li>过滤出请求地址中包含 <code>user</code> 的请求，不包括域名<br><code>http.request.uri contains &quot;User&quot;</code></li>
<li>精确过滤域名<br><code>http.host==baidu.com</code></li>
<li>模糊过滤域名<br><code>http.host contains &quot;baidu&quot;</code></li>
<li>过滤请求的 content_type 类型<br><code>http.content_type ==&quot;text/html&quot;</code><br>-过滤 http 请求方法<br><code>http.request.method==&quot;POST&quot;</code></li>
<li>过滤 tcp 端口<br><code>tcp.port==80</code><br><code>http &amp;&amp; tcp.port==80 or tcp.port==5566</code></li>
<li>过滤 http 响应状态码<br><code>http.response.code==302</code></li>
<li>过滤含有指定 cookie 的 http 数据包<br><code>http.cookie contains &quot;userid&quot;</code></li>
</ul>
]]></content>
      <categories>
        <category>TCPIP</category>
      </categories>
      <tags>
        <tag>wireshark</tag>
      </tags>
  </entry>
  <entry>
    <title>xshell 常用配置</title>
    <url>/202208101059/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>xshell7</li>
</ul>
<h3 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h3><h4 id="字体配置"><a href="#字体配置" class="headerlink" title="字体配置"></a>字体配置</h4><p>(菜单栏)查看 &gt; 工具栏 &gt; 标准按钮  </p>
<p><img src="https://i.csms.tech/img_36.png"></p>
<span id="more"></span>

<h4 id="Meta-键配置"><a href="#Meta-键配置" class="headerlink" title="Meta 键配置"></a>Meta 键配置</h4><p>(菜单栏)文件 &gt; 当前会话属性:<br><img src="https://i.csms.tech/img_37.png"></p>
<p>终端中使用 <code>Alt .</code> 可自动补齐上一条命令的最后一个参数  </p>
<h4 id="配置-选中即复制"><a href="#配置-选中即复制" class="headerlink" title="配置 选中即复制"></a>配置 选中即复制</h4><p>工具-&gt;选项<br><img src="https://i.csms.tech/img_38.png"></p>
<p>选择 <code>键盘和鼠标</code><br><img src="https://i.csms.tech/img_39.png"></p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>xshell</category>
      </categories>
      <tags>
        <tag>xshell</tag>
      </tags>
  </entry>
  <entry>
    <title>yum</title>
    <url>/202208111442/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>CentOS Linux release 7.9.2009 (Core)</li>
<li>yum-3.4.3</li>
</ul>
<h1 id="yum-命令示例"><a href="#yum-命令示例" class="headerlink" title="yum 命令示例"></a>yum 命令示例</h1><h2 id="查询指定命令来自哪个安装包"><a href="#查询指定命令来自哪个安装包" class="headerlink" title="查询指定命令来自哪个安装包"></a>查询指定命令来自哪个安装包</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum whatprovides ip</span></span><br><span class="line">iproute-4.11.0-30.el7.x86_64 : Advanced IP routing and network device configuration tools</span><br><span class="line">Repo        : base</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : /sbin/ip</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>rpm</code> 查询已安装文件来自哪个安装包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rpm -qf /sbin/ip</span></span><br><span class="line">iproute-4.11.0-30.el7.x86_64</span><br></pre></td></tr></table></figure>

<h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><h2 id="The-GPG-keys-listed-for-the-“MySQL-5-7-Community-Server”-repository-are-already-installed-but-they-are-not-correct-for-this-package"><a href="#The-GPG-keys-listed-for-the-“MySQL-5-7-Community-Server”-repository-are-already-installed-but-they-are-not-correct-for-this-package" class="headerlink" title="The GPG keys listed for the “MySQL 5.7 Community Server” repository are already installed but they are not correct for this package"></a>The GPG keys listed for the “MySQL 5.7 Community Server” repository are already installed but they are not correct for this package</h2><p><strong>解救方法</strong></p>
<p>修改对应 <code>yum</code> 源的配置文件，将其中的配置 <code>gpgcheck=1</code> 改为 <code>gpgcheck=0</code>，以此跳过 key 验证</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql 主从复制相关原理简述</title>
    <url>/2207211114/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<h2 id="Mysql-主从同步基本原理"><a href="#Mysql-主从同步基本原理" class="headerlink" title="Mysql 主从同步基本原理"></a>Mysql 主从同步基本原理</h2></blockquote>
<p>复制的基本过程如下：  </p>
<ol>
<li><p>Slave上面的IO进程连接上Master，并请求从指定日志文件的指定位置（或者从最开始的日志）之后的日志内容；</p>
</li>
<li><p>Master接收到来自Slave的IO进程的请求后，通过负责复制的IO进程,根据请求信息,读取指定日志指定位置之后的日志信息，返回给Slave 的IO进程。返回信息中除了日志所包含的信息之外，还包括本次返回的信息已经到Master端的bin-log文件的名称以及bin-log的位置；</p>
</li>
<li><p>Slave的IO进程接收到信息后，将接收到的日志内容依次添加到Slave端的relay-log文件的最末端，并将读取到的Master端的 bin-log的文件名和位置记录到master-info文件中，以便在下一次读取的时候能够清楚的告诉Master“我需要从某个bin-log的哪个位置开始往后的日志内容，请发给我”；</p>
</li>
<li><p>Slave的Sql进程检测到relay-log中新增加了内容后，会马上解析relay-log的内容，获得在Master端真实执行的那些可执行的内容，并在自身执行。</p>
</li>
</ol>
<p>双主情况下，禁止同时写入，建议还是按照主从的方式工作，防止数据冲突。双主场景下，主要是切换主备方便。</p>
<span id="more"></span>

<blockquote>
<h2 id="Mysql-复制方式"><a href="#Mysql-复制方式" class="headerlink" title="Mysql 复制方式"></a>Mysql 复制方式</h2></blockquote>
<blockquote>
<h3 id="异步复制（Asynchronous-replication）"><a href="#异步复制（Asynchronous-replication）" class="headerlink" title="异步复制（Asynchronous replication）"></a>异步复制（Asynchronous replication）</h3></blockquote>
<p>MySQL默认的复制即是异步的，主库在执行完客户端提交的事务后会立即将结果返给给客户端，并不关心从库是否已经接收并处理，这样就会有一个问题，主如果crash掉了，此时主上已经提交的事务可能并没有传到从上，如果此时，强行将从提升为主，可能导致新主上的数据不完整。</p>
<blockquote>
<h3 id="全同步复制（Fully-synchronous-replication）"><a href="#全同步复制（Fully-synchronous-replication）" class="headerlink" title="全同步复制（Fully synchronous replication）"></a>全同步复制（Fully synchronous replication）</h3></blockquote>
<p>指当主库执行完一个事务，所有的从库都执行了该事务才返回给客户端。因为需要等待所有从库执行完该事务才能返回，所以全同步复制的性能必然会收到严重的影响。</p>
<blockquote>
<h3 id="半同步复制（Semisynchronous-replication）"><a href="#半同步复制（Semisynchronous-replication）" class="headerlink" title="半同步复制（Semisynchronous replication）"></a>半同步复制（Semisynchronous replication）</h3></blockquote>
<p>介于异步复制和全同步复制之间，主库在执行完客户端提交的事务后不是立刻返回给客户端，而是等待至少一个从库接收到并写到relay log中才返回给客户端。相对于异步复制，半同步复制提高了数据的安全性，同时它也造成了一定程度的延迟，这个延迟最少是一个TCP&#x2F;IP往返的时间。所以，半同步复制最好在低延时的网络中使用。半同步复制失败(配置超时时间)，自动转为异步复制  </p>
<h4 id="半同步复制配置步骤"><a href="#半同步复制配置步骤" class="headerlink" title="半同步复制配置步骤"></a>半同步复制配置步骤</h4><ol>
<li><p>加载使用的插件<br>主库执行以下命令</p>
<figure class="highlight shell"><figcaption><span>master</span></figcaption><table><tr><td class="code"><pre><span class="line">INSTALL PLUGIN rpl_semi_sync_master SONAME &#x27;semisync_master.so&#x27;;</span><br></pre></td></tr></table></figure>
<p>从库执行以下命令</p>
<figure class="highlight shell"><figcaption><span>slave</span></figcaption><table><tr><td class="code"><pre><span class="line">INSTALL PLUGIN rpl_semi_sync_slave SONAME &#x27;semisync_slave.so&#x27;;</span><br></pre></td></tr></table></figure>
<p>通过 <code>show plugins;</code> 可查看已加载的插件</p>
</li>
<li><p>启动半同步复制<br>主库执行以下命令</p>
<figure class="highlight shell"><figcaption><span>master</span></figcaption><table><tr><td class="code"><pre><span class="line">SET GLOBAL rpl_semi_sync_master_enabled = 1;</span><br></pre></td></tr></table></figure>
<p>从库执行以下命令</p>
<figure class="highlight shell"><figcaption><span>slave</span></figcaption><table><tr><td class="code"><pre><span class="line">SET GLOBAL rpl_semi_sync_slave_enabled = 1;</span><br></pre></td></tr></table></figure>
<p>执行以下命令重启从库上的IO线程</p>
<figure class="highlight shell"><figcaption><span>slave</span></figcaption><table><tr><td class="code"><pre><span class="line">STOP SLAVE IO_THREAD;</span><br><span class="line">START SLAVE IO_THREAD;</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查半同步复制插件是否在运行<br>主库执行以下命令</p>
<figure class="highlight shell"><figcaption><span>master</span></figcaption><table><tr><td class="code"><pre><span class="line">show status like &#x27;Rpl_semi_sync_master_status&#x27;;</span><br></pre></td></tr></table></figure>
<p>从库执行以下命令</p>
<figure class="highlight shell"><figcaption><span>slave</span></figcaption><table><tr><td class="code"><pre><span class="line">show status like &#x27;Rpl_semi_sync_slave_status&#x27;;</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<h2 id="Mysql-复制级别说明"><a href="#Mysql-复制级别说明" class="headerlink" title="Mysql 复制级别说明"></a>Mysql 复制级别说明</h2></blockquote>
<p>不同复制级别的设置会影响到Master端的bin-log记录成不同的形式。<br>配置方式:</p>
<figure class="highlight shell"><figcaption><span>/etc/my.cnf</span></figcaption><table><tr><td class="code"><pre><span class="line">binlog_format=&#x27;row&#x27;</span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="基于sql语句（Statement-level）"><a href="#基于sql语句（Statement-level）" class="headerlink" title="基于sql语句（Statement level）"></a>基于sql语句（Statement level）</h3></blockquote>
<p>每一条会修改数据的sql都会记录到 master的bin-log中。slave在复制的时候，sql进程会解析成和原来master端执行过的相同的sql来再次执行。</p>
<p><strong>优点</strong>：statement level下的优点首先就是解决了<a href="#%E5%9F%BA%E4%BA%8E%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95%EF%BC%88Row-level%EF%BC%89">row level</a>下的缺点，不需要记录每一行数据的变化，减少bin-log日志量，节约IO，提高性能。因为他只需要记录在Master上所执行的语句的细节，以及执行语句时候的上下文的信息。</p>
<p><strong>缺点</strong>：由于他是记录的执行语句，所以，为了让这些语句在slave端也能正确执行，那么他还必须记录每条语句在执行的时候的一些相关信息，也就是上下文信息，以保证所有语句在slave端被执行的时候能够得到和在master端执行时候相同的结果。<br>另外就是，由于Mysql现在发展比较快，很多的新功能不断的加入，使mysql的复制遇到了不小的挑战，复制的时候涉及到越复杂的内容，bug也就越容易出现。在statement level下，目前已经发现的就有不少情况会造成mysql的复制出现问题，主要是修改数据的时候使用了某些特定的函数或者功能的时候会出现，比如：sleep()函数在有些版本中就不能真确复制，在存储过程中使用了last_insert_id()函数，可能会使slave和master上得到不一致的id等等。<br>由于row level是基于每一行来记录的变化，所以不会出现类似的问题。</p>
<blockquote>
<h3 id="基于一条记录（Row-level）"><a href="#基于一条记录（Row-level）" class="headerlink" title="基于一条记录（Row level）"></a>基于一条记录（Row level）</h3></blockquote>
<p>日志中会记录成每一行数据被修改的形式，然后在slave端再对相同的数据进行修改</p>
<p><strong>优点</strong>： 在row level模式下，bin-log中可以不记录执行的sql语句的上下文相关的信息，仅仅只需要记录那一条记录被修改了，修改成什么样了。所以row level的日志内容会非常清楚的记录下每一行数据修改的细节，非常容易理解。而且不会出现某些特定情况下的存储过程，或function，以及 trigger的调用和触发无法被正确复制的问题。<br>任何情况都可以被复制，这对复制来说是最安全可靠的；和其他大多数数据库系统的复制技术一样；多数情况下，从服务器上的表如果有主键的话，复制就会快了很多,更少的锁</p>
<p><strong>缺点</strong>： row level下，所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容，比如有这样一条update语句：update product set owner_member_id &#x3D; ‘b’ where owner_member_id &#x3D; ‘a’，执行之后，日志中记录的不是这条update语句所对应的事件（mysql以事件的形式来记录bin-log日志），而是这条语句所更新的每一条记录的变化情况，这样就记录成很多条记录被更新的很多个事件。自然，bin-log日志的量就会很大。尤其是当执行alter table之类的语句的时候，产生的日志量是惊人的。因为Mysql对于alter table之类的表结构变更语句的处理方式是整个表的每一条记录都需要变动，实际上就是重建了整个表。那么该表的每一条记录都会被记录到日志中。</p>
<blockquote>
<h3 id="Mixed"><a href="#Mixed" class="headerlink" title="Mixed"></a>Mixed</h3></blockquote>
<p>在Mixed模式下，Mysql会根据执行的每一条具体的sql语句,来区分对待记录的日志形式，也就是在Statement和Row之间选择一种。新版本中的Statment level还是和以前一样，仅仅记录执行的语句。而新版本的Mysql中对row level模式也被做了优化，并不是所有的修改都会以row level来记录，像遇到表结构变更的时候就会以statement模式来记录，如果sql语句确实就是update或者delete等修改数据的语句，那么还是会记录所有行的变更。</p>
<blockquote>
<h3 id="GTID模式"><a href="#GTID模式" class="headerlink" title="GTID模式"></a>GTID模式</h3></blockquote>
<p>需要基于row模式，mysql-5.6.2支持,mysql5.6.10后完善</p>
<figure class="highlight shell"><figcaption><span>/etc/my.cnf</span></figcaption><table><tr><td class="code"><pre><span class="line">log_bin=on</span><br><span class="line">binlog_format=&#x27;row&#x27;</span><br><span class="line">gtid_mode=on</span><br><span class="line">enforce-gtid-consistency=on</span><br><span class="line">log-slave-updates=1</span><br></pre></td></tr></table></figure>
<p>限制：</p>
<ol>
<li>不支持非事务引擎(从库报错, stop slave; start slave ; 忽略)</li>
<li>不支持create table … select语句(主库直接报错)</li>
<li>不支持一个sql同时更新一个事务引擎和非事务引擎的表</li>
<li>在一个复制组中,必须要求统一开启gtid或是关闭gtid</li>
<li>开启gtid需要重启</li>
<li>开启gtid后,就不在使用原来传统的复制方式</li>
<li>对于create temporary table和drop temporary table语句不支持</li>
<li>不支持sql_slave_skip_counter</li>
</ol>
<blockquote>
<h2 id="MySQL（主从）配置相关参数"><a href="#MySQL（主从）配置相关参数" class="headerlink" title="MySQL（主从）配置相关参数"></a>MySQL（主从）配置相关参数</h2></blockquote>
<p>master相关配置  </p>
<figure class="highlight shell"><figcaption><span>master my.cnf</span></figcaption><table><tr><td class="code"><pre><span class="line">server-id = 1</span><br><span class="line">log-bin = mysql-bin    #要生成的二进制日志文件名称</span><br><span class="line">binlog_format=statement/row/mixed        ###复制实现模式/级别</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">binlog-do-db = rtzc_pnc_base       <span class="comment">##要同步的库.应该尽可能的在从库上使用replicate_wild_*，不建议在主库上使用</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">binlog-ignore-db = mysql   <span class="comment">#不同步的数据库,应该在从库上尽可能的使用replicate_wild_*</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#### 一般不再主服务器上过滤，虽然可以减少主的开销，但这样会导致二进制日志不完整</span></span></span><br><span class="line">sync_binlog=0</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#######</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">0      表示MySQL 不控制binlog的刷新，由文件系统自己控制它的缓存的刷新。这时候的性能是最好的，但是风险也是最大的。因为一旦系统Crash，在binlog_cache中的所有binlog信息都会被丢失。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sync_binlog&gt;0    表示每N个sync_binlog次事务提交，MySQL调用文件系统的刷新操作将缓存刷下去。最安全的就是sync_binlog=1了，表示每次事务提交，MySQL都会把binlog刷下去，是最安全但是性能损耗最大的设置。这样的话，在数据库所在的主机操作系统损坏或者突然掉电的情况下，系统才有可能丢失1个事务的数据。但是binlog虽然是顺序IO，但是设置sync_binlog=1，多个事务同时提交，同样很大的影响MySQL和IO性能。对于高并发事务的系统来说，“sync_binlog”设置为0和设置为1的系统写入性能差距可能高达5倍甚至更多。</span></span><br><span class="line"></span><br><span class="line">innodb_flush_log_at_trx_commit = 1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##########innodb特有参数</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">N=0     每隔一秒，把事务日志缓存区的数据写到日志文件中，以及把日志文件的数据刷新到磁盘上；在这种情况下，MySQL性能最好，但如果 mysqld 进程崩溃，通常会导致最后 1s 的日志丢失。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">N=1     每个事务提交时候，把事务日志从缓存区写到日志文件中，并且刷新日志文件的数据到磁盘上；每次事务提交时，<span class="built_in">log</span> buffer 会被写入到日志文件并刷写到磁盘。这也是默认值。这是最安全的配置，但由于每次事务都需要进行磁盘I/O，所以也最慢。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">N=2    当取值为 2 时，每次事务提交会写入日志文件，但并不会立即刷写到磁盘，日志文件会每秒刷写一次到磁盘。这时如果 mysqld 进程崩溃，由于日志已经写入到系统缓存，所以并不会丢失数据；在操作系统崩溃的情况下，通常会导致最后 1s 的日志丢失。 对于一些数据一致性和完整性要求不高的应用，配置为 2 就足够了；如果为了最高性能，可以设置为 0。有些应用，如支付服务，对一致性和完整性要求很高，所以即使最慢，也最好设置为 1.</span> </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">replicate-wild-ignore-table=db.*               <span class="comment">###应该在从库上尽可能的使用replicate_wild_</span></span></span><br><span class="line"></span><br><span class="line">max_binlog_size</span><br><span class="line">expire_logs_days = 7          ##日志保存天数</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>slave相关配置</p>
<figure class="highlight shell"><figcaption><span>my.cnf</span></figcaption><table><tr><td class="code"><pre><span class="line">server-id = 2</span><br><span class="line">relay-log = mysql-relay-bin</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">replicate-do-db = rtzc_pnc_base     <span class="comment">##应该在从库上尽可能的使用replicate_wild_*，并不会减少主往从复制数据占用带宽</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">replicate-do-table = db.table      <span class="comment">##表级过滤</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#replicate-ignore-table = db.table</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">replicate_ignore_db=<span class="built_in">test</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">replicate_wild_do_table=DB_NAME.%</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">replicate_wild_ignore_table=DB_NAME.%</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">slave-skip-errors = 1032,1062     <span class="comment">###跳过某些同步错误号</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">log-slave-updates=1          <span class="comment">###从库需要记录binlog，如级联从库场景，级联从库必须有此参数</span></span></span><br><span class="line">log-bin = mysql-bin</span><br><span class="line"></span><br><span class="line">expire_logs_days = 7</span><br><span class="line"></span><br><span class="line">read-only         ###从库Slave中使用read-only参数，确保从库数据不被非法更新。</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">innodb_read_only = 1         <span class="comment">###控制root用户，慎用</span></span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
</search>
