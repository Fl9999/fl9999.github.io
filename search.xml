<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AppScan v10.0.7.28135 安装破解</title>
    <url>/2207220210/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>HCL AppScan（原名IBM Security AppScan）是原IBM的Rational软件部门的一组网络安全测试和监控工具，2019年被HCL技术公司收购。AppScan旨在在开发过程中对Web应用程序的安全漏洞进行测试。  </p>
<span id="more"></span>

<h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Windows Server 2016 Datacenter</li>
<li>AppScan v10.0.7.28135</li>
</ul>
<h3 id="AppScan-安装激活"><a href="#AppScan-安装激活" class="headerlink" title="AppScan 安装激活"></a>AppScan 安装激活</h3><p>下载链接<br><a href="https://www.yunzhongzhuan.com/#sharefile=H51riiWG_46315">www.ddosi.org下载入口</a></p>
<blockquote>
<p>解压密码:<a href="http://www.ddosi.org/">www.ddosi.org</a></p>
</blockquote>
<p><a href="https://s.csms.tech/file/HCL_AppScan_Standard_v10.0.7.28135.rar">其他下载地址</a></p>
<p>下载安装包后，点击文件 <code>Appscan_Setup_v10.0.7.28135.exe</code> 安装</p>
<p>安装完成后，复制Crack目录下的文件 <code>AppScanSDK.dll</code>,<code>HclLicenseProvider.dll</code> 到 APPscan安装目录(默认为 <code>C:\Program Files (x86)\HCL\AppScan Standard</code>) 进行替换，完成破解</p>
<p>成功破解后的截图如下</p>
<p><img src="https://i.csms.tech/img_17.png"> </p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.ddosi.org/appscan-2/">参考链接</a></p>
]]></content>
      <categories>
        <category>安全</category>
        <category>AppScan</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>AppScan</tag>
      </tags>
  </entry>
  <entry>
    <title>Django+uwsgi+nginx 配置示例</title>
    <url>/7d1a39d2/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>centos 7</li>
<li>Python 3.10</li>
<li>Django 4.0</li>
<li>uwsgi 2.0.20</li>
<li>nginx 1.20.1</li>
<li>venv<blockquote>
<p>示例中虚拟环境位于 <code>/opt/vb/</code>, Django工程目录位于 <code>/opt/vb/vb/</code> , 工程名称为vb</p>
</blockquote>
</li>
</ul>
<h3 id="uwsgi配置文件-uwsgi-ini-配置示例"><a href="#uwsgi配置文件-uwsgi-ini-配置示例" class="headerlink" title="uwsgi配置文件 (uwsgi.ini) 配置示例"></a>uwsgi配置文件 (uwsgi.ini) 配置示例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[uwsgi]</span><br><span class="line">socket = 127.0.0.1:8081</span><br><span class="line">chdir = /opt/vb/vb</span><br><span class="line">wsgi-file = ./vb/wsgi.py</span><br><span class="line">master = true         //主进程</span><br><span class="line">vhost = true          //多站模式</span><br><span class="line">no-site = true        //多站模式时不设置入口模块和文件</span><br><span class="line">workers = 2           //子进程数</span><br><span class="line">reload-mercy = 10     </span><br><span class="line">vacuum = true         //退出、重启时清理文件</span><br><span class="line">max-requests = 1000   </span><br><span class="line">limit-as = 512</span><br><span class="line">buffer-size = 30000</span><br><span class="line">pidfile = uwsgi-8081.pid</span><br><span class="line">daemonize = uwsgi-8081.log</span><br><span class="line">pythonpath = /opt/vb/env/lib/python3.10/site-packages/</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h3 id="nginx-配置文件示例"><a href="#nginx-配置文件示例" class="headerlink" title="nginx 配置文件示例"></a>nginx 配置文件示例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">       listen 80;</span><br><span class="line">       server_name csms.tech;</span><br><span class="line"></span><br><span class="line">        location / &#123;            </span><br><span class="line">            include  uwsgi_params;</span><br><span class="line">            uwsgi_pass  127.0.0.1:8081;</span><br><span class="line">            uwsgi_param UWSGI_SCRIPT vb.wsgi;</span><br><span class="line">            uwsgi_param UWSGI_CHDIR /opt/vb/vb;       </span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        location /static/ &#123;</span><br><span class="line">                alias /opt/vb/vb/staticCollects/;</span><br><span class="line">        &#125;</span><br><span class="line">        access_log log/uwsgi.access.log main;</span><br><span class="line">        error_log log/uwsgi.error.log;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a href="/d5da7d5e/" title="Django 常见错误">Django 常见错误</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Nginx</tag>
        <tag>Django</tag>
        <tag>Uwsgi</tag>
      </tags>
  </entry>
  <entry>
    <title>Django 常见错误</title>
    <url>/d5da7d5e/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>centos7</li>
<li>python3</li>
<li>Django 4</li>
</ul>
<h2 id="ModuleNotFoundError-No-module-named-‘MySQLdb’"><a href="#ModuleNotFoundError-No-module-named-‘MySQLdb’" class="headerlink" title="ModuleNotFoundError: No module named ‘MySQLdb’"></a>ModuleNotFoundError: No module named ‘MySQLdb’</h2><blockquote>
<p>ModuleNotFoundError: No module named ‘MySQLdb’<br>…<br>django.core.exceptions.ImproperlyConfigured: Error loading MySQLdb module.</p>
</blockquote>
<p><strong>解决方法</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip3 install pymysql</span><br></pre></td></tr></table></figure>

<p>编辑文件<code>./python36/lib/python3.6/site-packages/django/db/backends/mysql/__init__.py</code>, 输入以下内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql </span><br><span class="line">pymysql.install_as_MySQLdb()</span><br></pre></td></tr></table></figure>
<span id="more"></span>



<h2 id="django-core-exceptions-ImproperlyConfigured"><a href="#django-core-exceptions-ImproperlyConfigured" class="headerlink" title="django.core.exceptions.ImproperlyConfigured"></a>django.core.exceptions.ImproperlyConfigured</h2><p>使用以下命令启动服务时报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">django-admin runserver</span><br></pre></td></tr></table></figure>

<blockquote>
<p>django.core.exceptions.ImproperlyConfigured: Requested setting DEBUG, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings</p>
</blockquote>
<p><strong>解决方法</strong></p>
<p>使用命令<br><code>python3 manage.py runserver</code></p>
<hr>
<h1 id="环境信息-1"><a href="#环境信息-1" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>centos7</li>
<li>python3.10</li>
<li>uwsgi 2.0.20</li>
<li>venv</li>
</ul>
<h2 id="ModuleNotFoundError-No-module-named-‘django’"><a href="#ModuleNotFoundError-No-module-named-‘django’" class="headerlink" title="ModuleNotFoundError: No module named ‘django’"></a>ModuleNotFoundError: No module named ‘django’</h2><p>uwsgi 启动后报错(查看 uwsgi 日志输出)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.wsgi <span class="keyword">import</span> get_wsgi_application  </span><br><span class="line">ModuleNotFoundError: No module named <span class="string">&#x27;django&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方法</strong></p>
<p>uwsgi 配置文件(<code>uwsgi.ini</code> )中添加 python 路径, 在配置文件中添加如下配置：</p>
<figure class="highlight python"><figcaption><span>uwsgi.ini</span></figcaption><table><tr><td class="code"><pre><span class="line">pythonpath = /env/lib/python3<span class="number">.10</span>/site-packages/</span><br></pre></td></tr></table></figure>

<p>完整 uwsgi 配置文件示例(使用 python venv 模块创建虚拟环境情况下)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[uwsgi]</span><br><span class="line">socket = 127.0.0.1:8081</span><br><span class="line">chdir = /opt/vb/vb</span><br><span class="line">wsgi-file = ./vb/wsgi.py</span><br><span class="line">master = true         //主进程</span><br><span class="line">vhost = true          //多站模式</span><br><span class="line">no-site = true        //多站模式时不设置入口模块和文件</span><br><span class="line">workers = 2           //子进程数</span><br><span class="line">reload-mercy = 10     </span><br><span class="line">vacuum = true         //退出、重启时清理文件</span><br><span class="line">max-requests = 1000   </span><br><span class="line">limit-as = 512</span><br><span class="line">buffer-size = 30000</span><br><span class="line">pidfile = uwsgi-8081.pid</span><br><span class="line">daemonize = uwsgi-8081.log</span><br><span class="line">pythonpath = /opt/vb/env/lib/python3.10/site-packages/</span><br></pre></td></tr></table></figure>

<h2 id="unable-to-load-app-0"><a href="#unable-to-load-app-0" class="headerlink" title="unable to load app 0"></a>unable to load app 0</h2><p><code>uwsgi</code> 启动后报错(查看 <code>uwsgi</code> 日志输出)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unable to load app 0 (mountpoint=&#x27;|&#x27;) (callable not found or import error)  </span><br><span class="line">--- no python application found, check your startup logs for errors ---</span><br></pre></td></tr></table></figure>

<p><strong>解决方法</strong> </p>
<p><code>uwsgi</code> 配置文件(<code>uwsgi.ini</code> )中添加 <code>wsgi.py</code> 路径, 在配置文件中添加如下配置：</p>
<figure class="highlight shell"><figcaption><span>uwsgi.ini</span></figcaption><table><tr><td class="code"><pre><span class="line">wsgi-file = ./project/wsgi.py</span><br></pre></td></tr></table></figure>

<h2 id="django-db-utils-OperationalError"><a href="#django-db-utils-OperationalError" class="headerlink" title="django.db.utils.OperationalError"></a>django.db.utils.OperationalError</h2><p>项目根目录执行 <code>python manage.py  migrate</code> 时报错 <code>django.db.utils.OperationalError: (1366, &quot;Incorrect string value: &#39;\\xE6\\x9C\\x8D\\xE5\\x8A\\xA1...&#39; for column &#39;name&#39; at row 1&quot;)</code></p>
<p><strong>排查步骤</strong></p>
<ol>
<li><p>查看数据库编码设置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">show variables like <span class="string">&quot;%char%&quot;</span>;</span></span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| Variable_name            | Value                      |</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| character_set_client     | utf8                       |</span><br><span class="line">| character_set_connection | utf8                       |</span><br><span class="line">| character_set_database   | latin1                     |</span><br><span class="line">| character_set_filesystem | binary                     |</span><br><span class="line">| character_set_results    | utf8                       |</span><br><span class="line">| character_set_server     | latin1                     |</span><br><span class="line">| character_set_system     | utf8                       |</span><br><span class="line">| character_sets_dir       | /usr/share/mysql/charsets/ |</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">8 rows in set (0.01 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>修改数据库编码为 <code>utf8</code></p>
<p>修改数据库配置文件 <code>my.cnf</code>，添加以下配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"></span><br><span class="line">character-set-server = utf8</span><br><span class="line">collation-server=utf8_general_ci</span><br></pre></td></tr></table></figure>
<p>重启数据库，检查编码设置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">show variables like <span class="string">&quot;%char%&quot;</span>;</span></span><br><span class="line"></span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| Variable_name            | Value                      |</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| character_set_client     | utf8                       |</span><br><span class="line">| character_set_connection | utf8                       |</span><br><span class="line">| character_set_database   | utf8                       |</span><br><span class="line">| character_set_filesystem | binary                     |</span><br><span class="line">| character_set_results    | utf8                       |</span><br><span class="line">| character_set_server     | utf8                       |</span><br><span class="line">| character_set_system     | utf8                       |</span><br><span class="line">| character_sets_dir       | /usr/share/mysql/charsets/ |</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">8 rows in set (0.05 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>重新执行 <code>python manage.py  migrate</code> 依旧返回同样的报错，检查之前创建的数据库编码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">show create database mydb;</span></span><br><span class="line">+-----------------+----------------------------------------------------------------------------+</span><br><span class="line">| Database        | Create Database                                                            |</span><br><span class="line">+-----------------+----------------------------------------------------------------------------+</span><br><span class="line">| mydb | CREATE DATABASE `mydb` /*!40100 DEFAULT CHARACTER SET latin1 */ |</span><br><span class="line">+-----------------+----------------------------------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>编码显示为 <code>latin1</code>，删除数据库重新创建</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">drop database mydb;</span></span><br><span class="line">Query OK, 12 rows affected (0.10 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">create database mydb;</span></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">show create database mydb;</span></span><br><span class="line">+-----------------+--------------------------------------------------------------------------+</span><br><span class="line">| Database        | Create Database                                                          |</span><br><span class="line">+-----------------+--------------------------------------------------------------------------+</span><br><span class="line">| mydb | CREATE DATABASE `mydb` /*!40100 DEFAULT CHARACTER SET utf8 */ |</span><br><span class="line">+-----------------+--------------------------------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>新建的数据库编码为 <code>utf8</code>，重新执行 <code>python manage.py  makemigrations</code>，<code>python manage.py  migrate</code>，执行成功。删除数据库重建后，如若使用后台，需要为后台重新生成 superuser。</p>
</li>
</ol>
<hr>
<h1 id="环境信息-2"><a href="#环境信息-2" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Python 3.11.2</li>
<li>Django&#x3D;&#x3D;4.1.7</li>
<li>mysqlclient&#x3D;&#x3D;2.1.1</li>
</ul>
<h2 id="django-db-utils-NotSupportedError-MariaDB-10-3-or-later-is-required-found-5-5-68"><a href="#django-db-utils-NotSupportedError-MariaDB-10-3-or-later-is-required-found-5-5-68" class="headerlink" title="django.db.utils.NotSupportedError: MariaDB 10.3 or later is required (found 5.5.68)"></a>django.db.utils.NotSupportedError: MariaDB 10.3 or later is required (found 5.5.68)</h2><p><strong>解决方法</strong>：</p>
<p>在 <code>/usr/local/lib/python3.11/site-packages/django/db/backends/base/base.py</code> 中搜索 <code>self.check_database_version_supported</code>，然后把这一行注释掉。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;s/self.check_database_version_supported/#self.check_database_version_supported/&#x27; /usr/local/lib/python3.11/site-packages/django/db/backends/base/base.py</span><br></pre></td></tr></table></figure>

<h2 id="Raised-by-django-contrib-admin-sites-catch-all-view"><a href="#Raised-by-django-contrib-admin-sites-catch-all-view" class="headerlink" title="Raised by: django.contrib.admin.sites.catch_all_view"></a>Raised by: django.contrib.admin.sites.catch_all_view</h2><p>在项目的入口 <code>urls.py</code> 文件中按照以下配置，应用 <code>cloud_client</code> 对应的 url （<code>/cloud_client/</code>）无法匹配到，抛出异常信息： <code>Raised by: django.contrib.admin.sites.catch_all_view</code></p>
<figure class="highlight python"><figcaption><span>urls.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, include</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">   path(<span class="string">&#x27;&#x27;</span>, admin.site.urls),</span><br><span class="line">   path(<span class="string">&#x27;cloud_client/&#x27;</span>, include(<span class="string">&#x27;cloud_client.urls&#x27;</span>)),</span><br><span class="line">    </span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><a href="https://stackoverflow.com/questions/68368142/catch-all-view-break-url-patterns-in-django">参考文章说明</a>，修改为以下配置后，应用相关的 url 访问正常，<strong>自定义的 URls 需要在 admin 的 URLs 之前。</strong> <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Catch-all view break URL patterns in Django](https://stackoverflow.com/questions/68368142/catch-all-view-break-url-patterns-in-django)">[1]</span></a></sup></p>
<figure class="highlight python"><figcaption><span>urls.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, include</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">   </span><br><span class="line">   path(<span class="string">&#x27;cloud_client/&#x27;</span>, include(<span class="string">&#x27;cloud_client.urls&#x27;</span>)),</span><br><span class="line">   path(<span class="string">&#x27;&#x27;</span>, admin.site.urls),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="Key-‘id’-not-found-in-‘xxx’-Choices-are-xxx"><a href="#Key-‘id’-not-found-in-‘xxx’-Choices-are-xxx" class="headerlink" title="Key ‘id’ not found in ‘xxx’. Choices are: xxx"></a>Key ‘id’ not found in ‘xxx’. Choices are: xxx</h2><p>Django admin 后台中点击报错，错误原因为模型注册到后台时，<code>fields</code> 配置中包含了 <code>id</code> 字段，因为字段 <code>id</code> 设置的自增 ID 键，在数据库中对应的是 <code>AUTO_INCREMENT</code>，所以这个字段是不允许编辑的，而 <code>fields</code> 这个配置设置是可编辑字段，导致冲突，所以会报错。 <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Django报错: Key 'id' not found in 'xxx'. Choices are: xxx](https://cloud.tencent.com/developer/article/1937434)
">[2]</span></a></sup></p>
<h2 id="Refused-to-execute-script-from-‘‘-because-its-MIME-type-‘text-x2F-html’-is-not-executable-and-strict-MIME-type-checking-is-enabled"><a href="#Refused-to-execute-script-from-‘‘-because-its-MIME-type-‘text-x2F-html’-is-not-executable-and-strict-MIME-type-checking-is-enabled" class="headerlink" title="Refused to execute script from ‘‘ because its MIME type (‘text&#x2F;html’) is not executable, and strict MIME type checking is enabled"></a>Refused to execute script from ‘<URL>‘ because its MIME type (‘text&#x2F;html’) is not executable, and strict MIME type checking is enabled</h2><p>Django 配置 <code>DEBUG = False</code> 后，页面访问异常<br><img src="https://i.csms.tech/img_132.png"></p>
<h2 id="Django-admin-静态资源-404"><a href="#Django-admin-静态资源-404" class="headerlink" title="Django admin 静态资源 404"></a>Django admin 静态资源 404</h2><p>请求中，admin 页面的所有资源显示 404</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot;GET /static/admin/js/core.js HTTP/1.1&quot; 404 179</span><br></pre></td></tr></table></figure>
<p>原因是因为关闭了 <code>DEBUG</code> 模式（通过配置 <code>DEBUG = False</code>），所以导致找不到静态资源。生产环境中需要关闭 <code>DEBUG</code>，需要给 Django 的静态资源配置路由来解决。 <sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Django 静态资源404问题](https://blog.sanxi.info/archives/django-jing-tai-zi-yuan-404-wen-ti)">[3]</span></a></sup></p>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://stackoverflow.com/questions/68368142/catch-all-view-break-url-patterns-in-django">Catch-all view break URL patterns in Django</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://cloud.tencent.com/developer/article/1937434">Django报错: Key 'id' not found in 'xxx'. Choices are: xxx</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://blog.sanxi.info/archives/django-jing-tai-zi-yuan-404-wen-ti">Django 静态资源404问题</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Django 模板中循环嵌套</title>
    <url>/c97b0902/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>模板中需要循环中循环，<code>&#123;% for i in alist %&#125;</code>,假如i是个元组或列表，需要继续循环：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">for</span> i <span class="keyword">in</span> alist %&#125;</span><br><span class="line">	&#123;% <span class="keyword">with</span> temp=I %&#125;</span><br><span class="line">		&#123;% <span class="keyword">for</span> k <span class="keyword">in</span> temp %&#125;</span><br><span class="line">		    …</span><br><span class="line">		&#123;% endfor %&#125;</span><br><span class="line">	&#123;% endwith %&#125;</span><br><span class="line">&#123;%endfor%&#125;</span><br></pre></td></tr></table></figure>
<p>或使用如下方式，data &#x3D; [[1,2],[3,4]]：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">for</span> l <span class="keyword">in</span> data%&#125;</span><br><span class="line"></span><br><span class="line">	&#123;% <span class="keyword">for</span> temp <span class="keyword">in</span> l % &#125;</span><br><span class="line">		&#123;% <span class="keyword">if</span> forloop.first % &#125;</span><br><span class="line">			<span class="string">&#x27;&#123;&#123;temp&#125;&#125;&#x27;</span>,</span><br><span class="line">		&#123;% <span class="keyword">else</span> %&#125;</span><br><span class="line">			&#123;&#123;temp&#125;&#125;</span><br><span class="line">		&#123;% endif %&#125;</span><br><span class="line">	&#123;% endfor %&#125;</span><br><span class="line"></span><br><span class="line">&#123;%endfor%&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Django model 外键的反向引用</title>
    <url>/dcca5850/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Question</span>(models.Model):</span><br><span class="line">	question_text=models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">	pub_date=models.DateTimeField(<span class="string">&#x27;datepublished&#x27;</span>)</span><br><span class="line"></span><br><span class="line">	def__str__(self):</span><br><span class="line">		returnself.question_text</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Choice</span>(models.Model):</span><br><span class="line">	question=models.ForeignKey(Question,on_delete=models.CASCADE)</span><br><span class="line">	choice_text=models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">	votes=models.IntegerField(default=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	def__str__(self):</span><br><span class="line">		returnself.choice_text</span><br><span class="line">  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上例中，Choice引用了Question作为外键，在模板中通过Question对象获取所有引用了Question对象的Choice对象，可以使用以下方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% for choice in question.choice_set.all %&#125;</span><br><span class="line">	&lt;li&gt;&#123;&#123;choice.choice_text&#125;&#125;&lt;/li&gt;</span><br><span class="line">&#123;%endfor%&#125;</span><br></pre></td></tr></table></figure>

<p>使用question.choice_set.all的方式获取所有引用question对象的Choice对象实例</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Python</tag>
        <tag>Model</tag>
      </tags>
  </entry>
  <entry>
    <title>Dockerfile 简介</title>
    <url>/202208050928/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Dockerfile 是一个文本文件，其内包含了一条条的 <code>指令(Instruction)</code>，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p>
<span id="more"></span>

<h1 id="docker-build-命令"><a href="#docker-build-命令" class="headerlink" title="docker build 命令"></a><code>docker build</code> 命令</h1><p><code>docker build</code> 命令使用 <code>Dockerfile</code> 进行镜像构建。其格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build [选项] &lt;上下文路径/URL/-&gt;</span><br></pre></td></tr></table></figure>

<h2 id="docker-build-命令常用选项"><a href="#docker-build-命令常用选项" class="headerlink" title="docker build 命令常用选项"></a><code>docker build</code> 命令常用选项</h2><table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>-t, --tag</code></td>
<td>给新构建的镜像一个新的标签，格式为：<code>name:tag</code></td>
<td><code>docker build -t nginx:v3 .</code></td>
</tr>
<tr>
<td><code>-f, --file string </code></td>
<td><code>Dockerfile</code>的路径（文件名），默认为 <code>上下文（Context）目录/Dockerfile</code></td>
<td></td>
</tr>
</tbody></table>
<h2 id="上下文路径-格式"><a href="#上下文路径-格式" class="headerlink" title="上下文路径 格式"></a><code>上下文路径</code> 格式</h2><p>上下文路径可以是以下方式</p>
<ul>
<li><p>本地路径</p>
</li>
<li><p>用 <code>Git repo</code> 进行构建</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t hello-world https://github.com/docker-library/hello-world.git#master:amd64/hello-world</span><br></pre></td></tr></table></figure>

<p>  这行命令指定了构建所需的 Git repo，并且指定分支为 master，构建目录为 &#x2F;amd64&#x2F;hello-world&#x2F;，然后 Docker 就会自己去 git clone 这个项目、切换到指定分支、并进入到指定目录后开始构建。</p>
</li>
<li><p>用给定的 <code>tar</code> 压缩包构建</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build http://server/context.tar.gz</span><br></pre></td></tr></table></figure>
<p>如果所给出的 URL 不是个 Git repo，而是个 tar 压缩包，那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。</p>
</li>
<li><p>从标准输入中读取 <code>Dockerfile</code> 进行构建</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build - &lt; Dockerfile</span><br></pre></td></tr></table></figure>
<p>或</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat Dockerfile | docker build -</span><br></pre></td></tr></table></figure>
<p>  如果标准输入传入的是文本文件，则将其视为 <code>Dockerfile</code>，并开始构建。这种形式由于直接从标准输入中读取 <code>Dockerfile</code> 的内容，它没有上下文，因此不可以像其他方法那样可以将本地文件 <code>COPY</code> 进镜像之类的事情。  </p>
</li>
<li><p>从标准输入中读取上下文压缩包进行构建</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build - &lt; context.tar.gz</span><br></pre></td></tr></table></figure>
<p>如果发现标准输入的文件格式是 <code>gzip</code>、<code>bzip2</code> 以及 <code>xz</code> 的话，将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。</p>
</li>
</ul>
<h2 id="镜像构建上下文（Context）"><a href="#镜像构建上下文（Context）" class="headerlink" title="镜像构建上下文（Context）"></a>镜像构建上下文（Context）</h2><p>Docker 在运行时分为 <code>Docker 引擎</code>（也就是服务端守护进程）和<code>客户端工具</code>。Docker 的引擎提供了一组 <code>REST API</code>，被称为 <a href="https://docs.docker.com/engine/api/sdk/"><code>Docker Remote API</code></a>，而如 <code>docker</code> 命令这样的客户端工具，则是通过这组 <code>API</code> 与 <code>Docker 引擎</code> 交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 <code>docker</code> 功能，但实际上，一切都是使用的远程调用形式在服务端（<code>Docker 引擎</code>）完成。也因为这种 C&#x2F;S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[使用 Dockerfile 定制镜像](https://yeasy.gitbook.io/docker_practice/image/build)  ">[1]</span></a></sup></p>
<p>当我们进行镜像构建的时候，并非所有定制都会通过 <code>RUN</code> 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 <code>COPY</code> 指令、<code>ADD</code> 指令等。而 <code>docker build</code> 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 <code>Docker 引擎</code> 中构建的。那么在这种客户端&#x2F;服务端的架构中，如何才能让服务端获得本地文件呢？</p>
<p>这就引入了 <code>上下文</code> 的概念。当构建的时候，用户会指定构建镜像上下文的路径，<code>docker build</code> 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 <code>Docker 引擎</code>。这样 <code>Docker 引擎</code> 收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p>
<p>如果在 Dockerfile 中这么写：</p>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">COPY ./package.json /app/</span><br></pre></td></tr></table></figure>

<p>这并不是要复制执行 <code>docker build</code> 命令所在的目录下的 <code>package.json</code>，也不是复制 <code>Dockerfile</code> 所在目录下的 <code>package.json</code>，而是复制 <code>上下文（context）</code> 目录下的 <code>package.json</code>。</p>
<p>因此，<code>COPY</code> 这类指令中的源文件的路径都是相对路径。</p>
<p>一般来说，应该会将 <code>Dockerfile</code> 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 <code>Docker 引擎</code>，那么可以用 <code>.gitignore</code> 一样的语法写一个 <code>.dockerignore</code>，该文件是用于剔除不需要作为上下文传递给 <code>Docker 引擎</code> 的。</p>
<p>默认情况下，如果不额外指定 <code>Dockerfile</code> 的话，会将上下文目录下的名为 <code>Dockerfile</code> 的文件作为 <code>Dockerfile</code>。</p>
<p>这只是默认行为，实际上 <code>Dockerfile</code> 的文件名并不要求必须为 <code>Dockerfile</code>，而且并不要求必须位于上下文目录中，比如可以用 <code>-f ../Dockerfile.php</code> 参数指定某个文件作为 <code>Dockerfile</code>。<br>当然，一般大家习惯性的会使用默认的文件名 <code>Dockerfile</code>，以及会将其置于镜像构建上下文目录中</p>
<h1 id="Dockerfile-指令详解"><a href="#Dockerfile-指令详解" class="headerlink" title="Dockerfile 指令详解"></a>Dockerfile 指令详解</h1><p><code>Dockerfile</code> 文件示例</p>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN echo &#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27; &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure>

<h2 id="FROM-指令"><a href="#FROM-指令" class="headerlink" title="FROM 指令"></a>FROM 指令</h2><p>定制镜像，一定要以一个镜像为基础，在其上进行定制。</p>
<p><code>FROM</code> 就是指定 <code>基础镜像</code>，因此一个 <code>Dockerfile</code> 中 <code>FROM</code> 是<strong>必备的指令</strong>，并且<strong>必须是第一条指令</strong>。<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[使用 Dockerfile 定制镜像](https://yeasy.gitbook.io/docker_practice/image/build)  ">[1]</span></a></sup>  </p>
<p>除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 <code>scratch</code>。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。</p>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">FROM scratch</span><br></pre></td></tr></table></figure>

<p>如果以 <code>scratch</code> 为基础镜像的话，意味着不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。</p>
<h2 id="RUN-指令"><a href="#RUN-指令" class="headerlink" title="RUN 指令"></a>RUN 指令</h2><p><code>RUN</code> 指令是用来执行命令行命令的。由于命令行的强大能力，<code>RUN</code> 指令在定制镜像时是最常用的指令之一。<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[使用 Dockerfile 定制镜像](https://yeasy.gitbook.io/docker_practice/image/build)  ">[1]</span></a></sup> 其格式有两种：</p>
<ul>
<li>shell 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样。<a href="#Dockerfile-%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3">上面</a>写的 <code>Dockerfile</code> 中的 <code>RUN</code> 指令就是这种格式。  </li>
<li>exec 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式。</li>
</ul>
<blockquote>
<p><a href="#shell-%E6%A0%BC%E5%BC%8F%E5%92%8C-exec-%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E">shell 格式和 exec 格式说明</a></p>
</blockquote>
<p>既然 RUN 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样：  </p>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">FROM debian:stretch</span><br><span class="line"></span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install -y gcc libc6-dev make wget</span><br><span class="line">RUN wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span><br><span class="line">RUN mkdir -p /usr/src/redis</span><br><span class="line">RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</span><br><span class="line">RUN make -C /usr/src/redis</span><br><span class="line">RUN make -C /usr/src/redis install</span><br></pre></td></tr></table></figure>

<p><code>Dockerfile</code> 中每一个指令都会建立一层，<code>RUN</code> 也不例外。每一个 <code>RUN</code> 的行为，就和我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，<code>commit</code> 这一层的修改，构成新的镜像。<br>每一个 RUN 都是启动一个容器、执行命令、然后提交存储层文件变更。当前的 <code>RUN</code> 指令和前后的 <code>RUN</code> 指令是<strong>不存在环境变量的共享及关联的</strong></p>
<p>而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。</p>
<p><code>Union FS</code> 是有最大层数限制的，比如 <code>AUFS</code>，曾经是最大不得超过 42 层，现在是不得超过 127 层。</p>
<p>上面的 <code>Dockerfile</code> 正确的写法应该是这样：</p>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">FROM debian:stretch</span><br><span class="line"></span><br><span class="line">RUN set -x; buildDeps=&#x27;gcc libc6-dev make wget&#x27; \</span><br><span class="line">    &amp;&amp; apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y $buildDeps \</span><br><span class="line">    &amp;&amp; wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot; \</span><br><span class="line">    &amp;&amp; mkdir -p /usr/src/redis \</span><br><span class="line">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis install \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/* \</span><br><span class="line">    &amp;&amp; rm redis.tar.gz \</span><br><span class="line">    &amp;&amp; rm -r /usr/src/redis \</span><br><span class="line">    &amp;&amp; apt-get purge -y --auto-remove $buildDeps</span><br></pre></td></tr></table></figure>

<p>首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 <code>RUN</code> 一一对应不同的命令，而是仅仅使用一个 <code>RUN</code> 指令，并使用 <code>&amp;&amp;</code> 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 <code>Dockerfile</code> 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。  </p>
<p>并且，这里为了格式化还进行了换行。<code>Dockerfile</code> 支持 <code>Shell</code> 类的行尾添加 <code>\</code> 的命令换行方式，以及行首 <code>#</code> 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。  </p>
<p>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 apt 缓存文件。这是很重要的一步，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p>
<h2 id="COPY-复制文件指令"><a href="#COPY-复制文件指令" class="headerlink" title="COPY 复制文件指令"></a>COPY 复制文件指令</h2><p><code>COPY</code> 指令将构建上下文目录中的 <code>&lt;源路径&gt;</code> 的文件&#x2F;目录复制到新的一层镜像内的 <code>&lt;目标路径&gt;</code> 位置。<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[COPY 复制文件](https://yeasy.gitbook.io/docker_practice/image/dockerfile/copy)">[2]</span></a></sup></p>
<p>命令格式：</p>
<ul>
<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;</code></li>
<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></li>
</ul>
<p><code>&lt;源路径&gt;</code> 可以是多个，甚至可以是通配符，其通配符规则要满足 <code>Go</code> 的 <a href="https://pkg.go.dev/path/filepath#Match"><code>filepath.Match</code></a> 规则，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">COPY hom* /mydir/</span><br><span class="line">COPY hom?.txt /mydir/</span><br></pre></td></tr></table></figure>

<p>如果源路径为文件夹，复制的时候不是直接复制该文件夹，而是将文件夹中的内容复制到目标路径。  </p>
<p><code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <code>WORKDIR</code> 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p>
<p>使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。  </p>
<p><code>COPY</code> 指令其他选项：</p>
<style>
table th:nth-of-type(1){
width: 10%;
}
table th:nth-of-type(2){
width: 20%;
}
table th:nth-of-type(3){
width: 70%;
}
</style>

<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>--from</code></td>
<td>从其他镜像或构件阶段拷贝文件</td>
<td><code>COPY --from=0 /go/app .</code>  多阶段构建 <sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Dockerfile 多阶段构建](https://yeasy.gitbook.io/docker_practice/image/multistage-builds)">[6]</span></a></sup> 中，从第1阶段的镜像中复制文件<br/><code>COPY --from=step1 /go/app .</code> 多阶段构建中，从名为 <code>step1</code> 的镜像中复制<br/></td>
</tr>
</tbody></table>
<h2 id="CMD-容器启动指令"><a href="#CMD-容器启动指令" class="headerlink" title="CMD 容器启动指令"></a>CMD 容器启动指令</h2><p>镜像启动时默认执行的指令，在启动容器时，容器后面跟其他指令，会替换默认指令</p>
<p><code>CMD</code> 指令<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[CMD 容器启动命令](https://yeasy.gitbook.io/docker_practice/image/dockerfile/cmd)">[3]</span></a></sup>的格式和 <code>RUN</code> 相似，也是两种格式：  </p>
<ul>
<li>shell 格式：<code>CMD &lt;命令&gt;</code>  </li>
<li>exec 格式：<code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code>  </li>
<li>参数列表格式：<code>CMD [&quot;参数1&quot;, &quot;参数2&quot;...]</code>。在指定了 <code>ENTRYPOINT</code> 指令后，用 <code>CMD</code> 指定具体的参数。</li>
</ul>
<blockquote>
<p><a href="#shell-%E6%A0%BC%E5%BC%8F%E5%92%8C-exec-%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E">shell 格式和 exec 格式说明</a></p>
</blockquote>
<p>如果使用 <code>shell</code> 格式的话，实际的命令会被包装为 <code>sh -c</code> 的参数的形式进行执行。比如：</p>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">CMD echo $HOME</span><br></pre></td></tr></table></figure>

<p>在实际执行中，会将其变更为：</p>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</span><br></pre></td></tr></table></figure>

<p>其中主进程是 <code>sh</code> 。Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 <code>systemd</code> 去启动后台服务，容器内没有后台服务的概念。  </p>
<p>比如以下指令：</p>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">CMD service nginx start</span><br></pre></td></tr></table></figure>

<p>容器执行后就会立即退出，对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。</p>
<p>而使用 <code>service nginx start</code> 或 <code>systemctl start nginx</code> 等类似命令，被理解为 <code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;systemctl start nginx&quot;]</code>，因此主进程实际上是 <code>sh</code>, 那么当 <code>systemctl start nginx</code> 命令结束后，<code>sh</code> 也就结束了，<code>sh</code> 作为主进程退出了，自然就会令容器退出。  </p>
<p>正确的做法是直接执行 <code>nginx</code> 可执行文件，并且要求以前台形式运行。比如：</p>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</span><br></pre></td></tr></table></figure>

<h2 id="ENTRYPOINT-容器启动程序指令"><a href="#ENTRYPOINT-容器启动程序指令" class="headerlink" title="ENTRYPOINT 容器启动程序指令"></a>ENTRYPOINT 容器启动程序指令</h2><p><code>ENTRYPOINT</code> 的格式和 <a href="#RUN-%E6%8C%87%E4%BB%A4"><code>RUN</code> 指令格式</a>一样，分为 <code>exec</code> 格式和 <code>shell</code> 格式。 <a href="#shell-%E6%A0%BC%E5%BC%8F%E5%92%8C-exec-%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E">shell 格式和 exec 格式说明</a>  </p>
<p><code>ENTRYPOINT</code> 的目的和 <a href="#CMD-%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%8C%87%E4%BB%A4"><code>CMD</code></a> 一样，都是在指定容器启动程序及参数。<code>ENTRYPOINT</code> 在容器启动时也可以替代，不过比 <code>CMD</code> 要略显繁琐，需要通过 <code>docker run</code> 的参数 <a href="https://csms.tech/202208041317/#运行镜像"><code>--entrypoint</code></a> 来指定。<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[ENTRYPOINT 入口点 | ENTRYPOINT 和 CMD 的不同使用场景](https://yeasy.gitbook.io/docker_practice/image/dockerfile/entrypoint)">[4]</span></a></sup>  </p>
<p>当指定了 <code>ENTRYPOINT</code> 后，<code>CMD</code> (包括 <code>Dockerfile</code> 和 <code>docker run</code> 中的 <code>CMD</code>)的含义就发生了改变，不再是直接的运行其命令，而是将 <code>CMD</code> 的内容作为参数传给 <code>ENTRYPOINT</code> 指令，即实际执行时，将变为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</span><br></pre></td></tr></table></figure>

<h2 id="ENV-设置环境变量指令"><a href="#ENV-设置环境变量指令" class="headerlink" title="ENV 设置环境变量指令"></a>ENV 设置环境变量指令</h2><p>设置环境变量，无论是后面的其它指令，如 <code>RUN</code>，还是运行时的应用，都可以直接使用这里定义的环境变量。</p>
<p>当使用生成的镜像运行容器时，使用 <code>ENV</code> 设置的环境变量将持久存在于容器内。 你可以使用 <code>docker inspect</code> 查看这些值，并使用 <code>docker run --env &lt;key&gt;=&lt;value&gt;</code> 修改它们</p>
<blockquote>
<p>环境变量持久性可能会导致意想不到的副作用。 例如，设置 <code>ENV DEBIAN_FRONTEND=noninteractive</code> 会改变 <code>apt-get</code> 的行为，并可能让使用镜像的用户感到困惑。<br>如果只在构建过程中需要环境变量，而不是在最终镜像中使用，可以使用 <a href="#ARG-%E6%9E%84%E5%BB%BA%E5%8F%82%E6%95%B0"><code>ARG</code></a>，它不会在最终镜像中持久存在</p>
</blockquote>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">ENV VERSION=1.0 DEBUG=on \</span><br><span class="line">    NAME=&quot;Happy Feet&quot;</span><br></pre></td></tr></table></figure>

<p>调用方式：</p>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">RUN echo $VERSION</span><br></pre></td></tr></table></figure>

<h2 id="ARG-构建参数"><a href="#ARG-构建参数" class="headerlink" title="ARG 构建参数"></a>ARG 构建参数</h2><p>格式：<code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code>  </p>
<p>构建参数和 <code>ENV</code> 的效果一样，都是设置环境变量。所不同的是，<code>ARG</code> 所设置的是<strong>构建环境的环境变量，在将来容器运行时是不会存在</strong>这些环境变量的。但是不要因此就使用 ARG 保存密码之类的信息，因为 <code>docker history</code> 还是可以看到所有值的。  </p>
<p><code>Dockerfile</code> 中的 <code>ARG</code> 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 <code>docker build</code> 中用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖。</p>
<p><code>ARG</code> 指令有生效范围，如果在 <code>FROM</code> 指令之前指定，那么只能用于 <code>FROM</code> 指令中。  </p>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">ARG DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line">FROM $&#123;DOCKER_USERNAME&#125;/alpine</span><br><span class="line"></span><br><span class="line">RUN set -x ; echo $&#123;DOCKER_USERNAME&#125;</span><br></pre></td></tr></table></figure>
<p>使用上述 <code>Dockerfile</code> 会发现无法输出 <code>$&#123;DOCKER_USERNAME&#125;</code> 变量的值，要想正常输出，你必须在 <code>FROM</code> 之后再次指定 <code>ARG</code>  </p>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只在 FROM 中生效</span></span><br><span class="line">ARG DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line">FROM $&#123;DOCKER_USERNAME&#125;/alpine</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">要想在 FROM 之后使用，必须再次指定</span></span><br><span class="line">ARG DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line">RUN set -x ; echo $&#123;DOCKER_USERNAME&#125;</span><br></pre></td></tr></table></figure>

<h2 id="VOLUME-定义匿名卷指令"><a href="#VOLUME-定义匿名卷指令" class="headerlink" title="VOLUME 定义匿名卷指令"></a>VOLUME 定义匿名卷指令</h2><p>容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。  </p>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">VOLUME /data</span><br></pre></td></tr></table></figure>

<p>这里的 <code>/data</code> 目录就会在容器运行时自动挂载为匿名卷，任何向 <code>/data</code> 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行容器时可以覆盖这个挂载设置。比如：  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -v mydata:/data xxxx</span><br></pre></td></tr></table></figure>

<p>在这行命令中，就使用了 <code>mydata</code> 这个命名卷挂载到了 <code>/data</code> 这个位置，替代了 <code>Dockerfile</code> 中定义的匿名卷的挂载配置。  </p>
<h2 id="EXPOSE-暴露端口指令"><a href="#EXPOSE-暴露端口指令" class="headerlink" title="EXPOSE 暴露端口指令"></a>EXPOSE 暴露端口指令</h2><p>格式为 <code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code>。</p>
<p><code>EXPOSE</code> 指令是声明容器运行时提供服务的端口，这<strong>只是一个声明</strong>，在容器运行时并<strong>不会因为这个声明，应用就会开启这个端口</strong>的服务。在 <code>Dockerfile</code> 中写入这样的声明有两个好处:</p>
<ul>
<li>一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；</li>
<li>另一个用处则是在运行时使用随机端口映射时，也就是 <code>docker run -P</code> 时，会自动随机映射 <code>EXPOSE</code> 的端口。</li>
</ul>
<p>要将 <code>EXPOSE</code> 和在运行时使用 <code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 区分开来。<code>-p</code>，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 <code>EXPOSE</code> 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p>
<h2 id="WORKDIR-指定工作目录指令"><a href="#WORKDIR-指定工作目录指令" class="headerlink" title="WORKDIR 指定工作目录指令"></a>WORKDIR 指定工作目录指令</h2><p>格式为 <code>WORKDIR &lt;工作目录路径&gt;</code>。  </p>
<p>使用 <code>WORKDIR</code> 指令可以来指定工作目录（或者称为当前目录），<strong>以后各层</strong>的当前目录就被改为指定的目录，如该目录不存在，<code>WORKDIR</code> 会帮你建立目录。  </p>
<p>如果 <code>WORKDIR</code> 指令使用的是<code>相对路径</code>，那么所切换的路径与之前的 <code>WORKDIR</code> 有关</p>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">WORKDIR /a</span><br><span class="line">WORKDIR b</span><br><span class="line">WORKDIR c</span><br><span class="line"></span><br><span class="line">RUN pwd</span><br></pre></td></tr></table></figure>

<p><code>RUN pwd</code> 的工作目录为 &#x2F;a&#x2F;b&#x2F;c。</p>
<h2 id="USER-指定当前用户指令"><a href="#USER-指定当前用户指令" class="headerlink" title="USER 指定当前用户指令"></a>USER 指定当前用户指令</h2><p>格式：<code>USER &lt;用户名&gt;[:&lt;用户组&gt;]</code></p>
<p><code>USER</code> 指令和 <a href="#WORKDIR-%E6%8C%87%E5%AE%9A%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%E6%8C%87%E4%BB%A4"><code>WORKDIR</code></a> 相似，都是改变环境状态并影响以后的层。<code>WORKDIR</code> 是改变工作目录，<code>USER</code> 则是改变之后层的执行 <code>RUN</code>, <code>CMD</code> 以及 <code>ENTRYPOINT</code> 这类命令的身份。 <code>USER</code> 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。</p>
<h2 id="HEALTHCHECK-健康状态检查命令"><a href="#HEALTHCHECK-健康状态检查命令" class="headerlink" title="HEALTHCHECK 健康状态检查命令"></a>HEALTHCHECK 健康状态检查命令</h2><p>格式：<br><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>：设置检查容器健康状况的命令 <sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[HEALTHCHECK 健康检查](https://yeasy.gitbook.io/docker_practice/image/dockerfile/healthcheck)">[5]</span></a></sup><br><code>HEALTHCHECK NONE</code>：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令  </p>
<p>HEALTHCHECK 支持下列选项：</p>
<style>
table th:nth-of-type(1){
width: 15%;
}
table th:nth-of-type(2){
width: 40%;
}
table th:nth-of-type(3){
width: 35%;
}
</style>

<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>--interval=&lt;30s&gt;</code></td>
<td>两次健康检查的间隔，默认为 30 秒</td>
<td></td>
</tr>
<tr>
<td><code>--timeout=&lt;30s&gt;</code></td>
<td>健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；</td>
<td></td>
</tr>
<tr>
<td><code>--retries=&lt;次数&gt;</code></td>
<td>当连续失败指定次数后，则将容器状态视为 <code>unhealthy</code>，默认 3 次。</td>
<td></td>
</tr>
</tbody></table>
<p>当在一个镜像指定了 <code>HEALTHCHECK</code> 指令后，用其启动容器，初始状态会为 <code>starting</code>，在 <code>HEALTHCHECK</code> 指令检查成功后变为 <code>healthy</code>，如果连续一定次数失败，则会变为 <code>unhealthy</code>。  </p>
<p>和 <code>CMD</code>, <code>ENTRYPOINT</code> 一样，<code>HEALTHCHECK</code> 只可以出现一次，如果写了多个，只有最后一个生效。  </p>
<p>在 <code>HEALTHCHECK [选项] CMD</code> 后面的命令，格式和 <code>ENTRYPOINT</code> 一样，分为 <code>shell</code> 格式，和 <code>exec</code> 格式。命令的返回值决定了该次健康检查的成功与否：  </p>
<ul>
<li>0：成功；</li>
<li>1：失败；</li>
<li>2：保留，不要使用这个值。</li>
</ul>
<p>假设我们有个镜像是个最简单的 Web 服务，我们希望增加健康检查来判断其 Web 服务是否在正常工作，我们可以用 <code>curl</code> 来帮助判断，其 <code>Dockerfile</code> 的 <code>HEALTHCHECK</code> 可以这么写：  </p>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN yum install -y curl &amp;&amp; yum clean all</span><br><span class="line">HEALTHCHECK --interval=5s --timeout=3s CMD \</span><br><span class="line">  curl -fs http://localhost/ || exit 1</span><br></pre></td></tr></table></figure>

<h1 id="shell-格式和-exec-格式说明"><a href="#shell-格式和-exec-格式说明" class="headerlink" title="shell 格式和 exec 格式说明"></a>shell 格式和 exec 格式说明</h1><p>在 Dockerfile 中，<code>RUN</code>、<code>CMD</code>、<code>ENTRYPOINT</code> 指令都支持 <code>shell</code> 格式和 <code>exec</code> 两种格式，格式分别如下</p>
<ul>
<li>shell 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样。<a href="#Dockerfile-%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3">上面</a>写的 <code>Dockerfile</code> 中的 <code>RUN</code> 指令就是这种格式。  </li>
<li>exec 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式。</li>
</ul>
<p>此处演示两种格式的具体区别。</p>
<ol>
<li>使用以下内容的 Dockerfile 构建镜像并运行，使用 <code>shell</code> 格式，假设镜像名称为 <code>centos7:dockerfile-cmd-shell</code> <figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">FROM centos:centos7.9.2009</span><br><span class="line"></span><br><span class="line">CMD ping 127.0.0.1</span><br></pre></td></tr></table></figure></li>
<li>使用以下内容的 Dockerfile 构建镜像并运行，使用 <code>exec</code> 格式，假设镜像名称为 <code>centos7:dockerfile-cmd-exec</code> <figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">FROM centos:centos7.9.2009</span><br><span class="line"></span><br><span class="line">CMD [ &quot;ping&quot;,&quot;127.0.0.1&quot; ]</span><br></pre></td></tr></table></figure></li>
<li>运行以上 Dockerfile 构建出来的镜像，容器信息如下，镜像 <code>dockerfile-cmd-exec</code> 和 <code>dockerfile-cmd-shell</code> 分别使用 <code>exec</code> 格式和 <code>shell</code> 格式 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker ps</span> </span><br><span class="line">CONTAINER ID   IMAGE                          COMMAND                  CREATED          STATUS          PORTS                                 NAMES</span><br><span class="line">f2168d2dba94   centos7:dockerfile-cmd-exec    &quot;ping 127.0.0.1&quot;         5 minutes ago    Up 5 minutes                                          funny_rubin</span><br><span class="line">70738995509f   centos7:dockerfile-cmd-shell   &quot;/bin/sh -c &#x27;ping 12…&quot;   16 minutes ago   Up 16 minutes                                         magical_cannon</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>分别查看 2 个容器的 <code>docker inspect</code> 输出信息中的运行的进程信息 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker inspect f2168d2dba94</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: &quot;f2168d2dba94d549bf70185d9d41e52d482be6f56a7c0d392f625e3721d1c07e&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2023-05-12T03:15:15.860200728Z&quot;,</span><br><span class="line">        &quot;Path&quot;: &quot;ping&quot;,</span><br><span class="line">        &quot;Args&quot;: [</span><br><span class="line">            &quot;127.0.0.1&quot;</span><br><span class="line">        ],</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker inspect 70738995509f</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: &quot;70738995509f12b0f4099c765cea3d2655076865f2a380b9cb7b1763bac58808&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2023-05-12T03:05:10.112279195Z&quot;,</span><br><span class="line">        &quot;Path&quot;: &quot;/bin/sh&quot;,</span><br><span class="line">        &quot;Args&quot;: [</span><br><span class="line">            &quot;-c&quot;,</span><br><span class="line">            &quot;ping 127.0.0.1&quot;</span><br><span class="line">        ],</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
由此可见，<code>shell</code> 格式的命令，在容器运行时会先启动 <code>shell</code>，然后在 <code>shell</code> 中执行命令。<code>exec</code> 格式则在容器启动时直接执行命令，未使用 <code>shell</code> 启动。</li>
</ol>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://yeasy.gitbook.io/docker_practice/">docker 从入门到实践</a>  </p>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://yeasy.gitbook.io/docker_practice/image/build">使用 Dockerfile 定制镜像</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/copy">COPY 复制文件</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/cmd">CMD 容器启动命令</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/entrypoint">ENTRYPOINT 入口点 | ENTRYPOINT 和 CMD 的不同使用场景</a><a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/healthcheck">HEALTHCHECK 健康检查</a><a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://yeasy.gitbook.io/docker_practice/image/multistage-builds">Dockerfile 多阶段构建</a><a href="#fnref:6" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo Next 安装部署及配置示例</title>
    <url>/202207241754/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Hexo 6.2.0</li>
<li>Next 8.12.2</li>
</ul>
<blockquote>
<p>Hexo 查看版本方式： <code>npm list</code><br>Next 版本信息可在文件 <code>themes/next/package.json </code> 中查看</p>
</blockquote>
<span id="more"></span>

<h1 id="Hexo-常用配置"><a href="#Hexo-常用配置" class="headerlink" title="Hexo 常用配置"></a>Hexo 常用配置</h1><h2 id="首页按照更新时间排序"><a href="#首页按照更新时间排序" class="headerlink" title="首页按照更新时间排序"></a>首页按照更新时间排序</h2><p>更改主配置文件 <code>_config.yml</code> 中的以下部分(<code>index_generator.order_by</code>):  </p>
<figure class="highlight shell"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">index_generator:</span><br><span class="line">  path: &#x27;&#x27;</span><br><span class="line">  per_page: 10</span><br><span class="line">  order_by: -updated</span><br></pre></td></tr></table></figure>

<h2 id="代码块不显示行号"><a href="#代码块不显示行号" class="headerlink" title="代码块不显示行号"></a>代码块不显示行号</h2><p>更改 <code>Hexo</code> 配置文件 <code>_config.yml</code>，修改以下配置</p>
<figure class="highlight shell"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">highlight:</span><br><span class="line">  enable: true</span><br><span class="line">  line_number: false </span><br></pre></td></tr></table></figure>

<p>将 <code>line_number</code> 值改为 <code>false</code></p>
<h2 id="配置站点地图"><a href="#配置站点地图" class="headerlink" title="配置站点地图"></a>配置站点地图</h2><p>通过设置站点地图( sitemap )，可以让搜索引擎获取你的页面信息，这样可以增加别人搜索到你的几率，具体配置参考官网步骤<br><a href="https://hexo-next.readthedocs.io/zh_CN/latest/next/advanced/Baidu-Google-%E7%AB%99%E7%82%B9%E5%9C%B0%E5%9B%BE/">官网说明</a></p>
<h1 id="Next-主题常用配置"><a href="#Next-主题常用配置" class="headerlink" title="Next 主题常用配置"></a>Next 主题常用配置</h1><h2 id="调整页面显示宽度"><a href="#调整页面显示宽度" class="headerlink" title="调整页面显示宽度"></a>调整页面显示宽度</h2><p>针对 Next 中的主题方案<code>Pisces</code>或<code>Gemini</code>, 更改 Next 主题中的文件 <code>themes/next/source/css/_variables/Pisces.styl</code> <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[官网说明](https://hexo-next.readthedocs.io/zh_CN/latest/next/advanced/%E8%B0%83%E6%95%B4%E9%A1%B5%E9%9D%A2%E5%AE%BD%E5%BA%A6/)">[1]</span></a></sup> </p>
<figure class="highlight shell"><figcaption><span>Pisces.styl</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">content-desktop-large        = 90em;</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">content-desktop-largest      = 90%;</span></span><br></pre></td></tr></table></figure>

<h2 id="启用-gitalk-评论系统"><a href="#启用-gitalk-评论系统" class="headerlink" title="启用 gitalk 评论系统"></a>启用 gitalk 评论系统</h2><p>具体配置 <a href="https://www.cnblogs.com/qisi007/p/13731562.html">参考文章</a></p>
<h2 id="修改默认图标"><a href="#修改默认图标" class="headerlink" title="修改默认图标"></a>修改默认图标</h2><h3 id="修改菜单图标"><a href="#修改菜单图标" class="headerlink" title="修改菜单图标"></a>修改菜单图标</h3><p>修改默认的菜单图标为以下图标<br><img src="https://i.csms.tech/img_123.png"><br>Next 使用的图标来自 <code>Font Awesome</code>。</p>
<blockquote>
<p>Font Awesome 是一套绝佳的图标字体库和CSS框架。 <sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[fontawesome](https://fontawesome.com/start)">[3]</span></a></sup></p>
<p>Font Awesome 字体为您提供可缩放矢量图标,它可以被定制大小、颜色、阴影以及任何可以用CSS的样式。</p>
</blockquote>
<p>在主题配置文件 <code>_config.next.yml</code> 中，菜单配置由三部分构成: <code>菜单的显示名称： 菜单的访问链接 || 菜单使用的图标</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || fa fa-earth-americas</span><br><span class="line">  categories: /categories/ || fa fa-folder-tree</span><br><span class="line">  tags: /tags/ || fa fa-tornado</span><br><span class="line">  archives: /archives/ || fa fa-rectangle-list </span><br></pre></td></tr></table></figure>
<p>要修改菜单的图标，可以在 <code>Font Awesome</code> 官网搜索到对应的图标，修改主题配置文件中的图标名称为如上所示。</p>
<blockquote>
<p><code>fa</code> : 使用此种图标，<code>菜单的显示名称</code> 和图标中间会包含空格，如 <code>fa fa-folder-tree</code></p>
<p><code>fa-solid</code> : 使用此种图标，<code>菜单的显示名称</code> 和图标中间<strong>不包含空格</strong>，如 <code>fa-solid fa-folder-tree</code></p>
<p>有些图标直接使用时，如 <code>fa-brands fa-docker</code> Docker 图标，菜单的显示名称会和图标紧贴在一起，中间无空格，可以再添加 <code>fa</code> 样式，使菜单名称和图标之间有空格，比如 <code>fa fa-brands fa-docker</code></p>
</blockquote>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://hexo-next.readthedocs.io/zh_CN/latest/next/advanced/%E8%B0%83%E6%95%B4%E9%A1%B5%E9%9D%A2%E5%AE%BD%E5%BA%A6/">官网说明</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.cnblogs.com/ywang-wnlo/p/16110411.html">Next 主题配置记录</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://fontawesome.com/start">fontawesome</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://finisky.github.io/customizecategorybyextension/">Hexo添加自定义分类菜单项并定制页面布局(简洁版)</a><a href="#fnref:4" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo markdown常用语法</title>
    <url>/2215beeb/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="url-链接"><a href="#url-链接" class="headerlink" title="url 链接"></a>url 链接</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[这是一个链接](https://csms.tech [title])</span><br></pre></td></tr></table></figure>
<p><a href="https://csms.tech/">这是一个链接</a></p>
<h3 id="图片链接"><a href="#图片链接" class="headerlink" title="图片链接"></a>图片链接</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![图片名称](https://i.csms.tech/img_10.png [title])</span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_10.png" alt="图片名称"></p>
<span id="more"></span>

<h3 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;https://csms.tech&gt;</span><br></pre></td></tr></table></figure>
<p><a href="https://csms.tech/">https://csms.tech</a><br><a href="https://csms.tech/">https://csms.tech</a></p>
<h3 id="链接到文章内的标题"><a href="#链接到文章内的标题" class="headerlink" title="链接到文章内的标题"></a>链接到文章内的标题</h3><p><code>Hexo</code> 会自动为各个层级的标题添加锚点，锚点 id 为标题名称，如果标题名称中有 <strong><code>空格</code> <code>)</code> <code>(</code> <code>.</code> 会被替换成<code>-</code>，多个空格合并成一个</strong>。如果标题开头**中包含 <code>/</code>，会被替换成 <code>x2F-</code>**，如果标题中间出现 <code>/</code>，会被替换成 <code>-x2F-</code>。要查看标签的具体值，也可以通过查看网页源代码的方式查找对应 id 。使用示例如下</p>
<table>
<thead>
<tr>
<th>标题</th>
<th>锚点 id</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>### 三级标题</td>
<td><code>id=&quot;三级标题&quot;</code></td>
<td></td>
</tr>
<tr>
<td>### this is  title</td>
<td><code>id=&quot;this-is-title&quot;</code></td>
<td>多个空格会合并成一个</td>
</tr>
<tr>
<td>### &#x2F;home&#x2F;dir</td>
<td><code>id=&quot;x2F-home-x2F-dir&quot;</code></td>
<td></td>
</tr>
</tbody></table>
<p>在文章中要跳转到指定的锚点，可以使用以下方式：  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[这是一个锚点](#this-is-title)</span><br></pre></td></tr></table></figure>

<h3 id="链接到本站其他文章的指定标题"><a href="#链接到本站其他文章的指定标题" class="headerlink" title="链接到本站其他文章的指定标题"></a>链接到本站其他文章的指定标题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[名称](https://csms.tech&#123;% post_path &#x27;文章文件名&#x27; %&#125;#id)</span><br></pre></td></tr></table></figure>
<p><code>&#123;% post_path 'Hexo-markdown-grammar' %&#125;</code> 的值为： <code>/2022/07/Hexo-markdown-grammar/</code><br><a href="https://csms.tech/2215beeb/#图片链接">跳转</a></p>
<h3 id="链接到标题之外的锚点"><a href="#链接到标题之外的锚点" class="headerlink" title="链接到标题之外的锚点"></a>链接到标题之外的锚点</h3><p>可以使用html标签先创建对应锚点，如<code>&lt;div id=&#39;1&#39;&gt;这是一个文章锚点&lt;/div&gt;</code></p>
<div id='1'>这是一个文章锚点</div>

<p><a href="#1">跳转到id&#x3D;1的锚点</a></p>
<h3 id="站内文章链接"><a href="#站内文章链接" class="headerlink" title="站内文章链接"></a>站内文章链接</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% post_link &#x27;文章文件名&#x27; [&#x27;显示的名称, 默认为文章title&#x27;] %&#125;</span><br></pre></td></tr></table></figure>
<p>本篇文章 <a href="/2215beeb/" title="hexo markdown常用语法">hexo markdown常用语法</a></p>
<h3 id="note标签"><a href="#note标签" class="headerlink" title="note标签"></a>note标签</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;% note class %&#125;</span><br><span class="line">文本内容 (支持行内标签)</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
<p>支持的class包括：<code>default</code> <code>primary</code> <code>success</code> <code>info</code> <code>warning</code> <code>danger</code></p>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><figure class="highlight shell"><figcaption><span>代码块示例</span><a href="https://csms.tech">主页</a></figcaption><table><tr><td class="code"><pre><span class="line">```shell name url urlshowname</span><br><span class="line">log-bin=binlog</span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| title1 | title2  | title3 |</span><br><span class="line">|:------|:-------:|-------:|</span><br><span class="line">| 第1列 |第2列     |第3列  |</span><br><span class="line">|左对齐| 居中对齐   | 右对齐|</span><br><span class="line">| 竖线 &amp;#124; |竖线 &amp;#x7C; |</span><br><span class="line">|Hexo中竖线使用 `\|`||</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="left">title1</th>
<th align="center">title2</th>
<th align="right">title3</th>
</tr>
</thead>
<tbody><tr>
<td align="left">第1列</td>
<td align="center">第2列</td>
<td align="right">第3列</td>
</tr>
<tr>
<td align="left">左对齐</td>
<td align="center">居中对齐</td>
<td align="right">右对齐</td>
</tr>
<tr>
<td align="left">竖线 <code>&amp;#124;</code></td>
<td align="center">竖线 <code>&amp;#x7C;</code></td>
<td align="right"></td>
</tr>
<tr>
<td align="left">Hexo中竖线使用 <code>|</code></td>
<td align="center"></td>
<td align="right"></td>
</tr>
</tbody></table>
<blockquote>
<p>要在表格中使用<code>|</code>, 可用以下2中之一代替</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&amp;#124;</span><br><span class="line">&amp;#x7C;</span><br></pre></td></tr></table></figure>
<p>Hexo 表格中需要使用 <code>\|</code> 方式输出 <code>|</code></p>
</blockquote>
<p>设置表格宽度，在表格之前使用以下 <code>style</code>：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line"><span class="selector-tag">table</span> <span class="selector-tag">th</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">10%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">table</span> <span class="selector-tag">th</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">2</span>)&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">70%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">table</span> <span class="selector-tag">th</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">3</span>)&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">20%</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">table th:nth-of-type(1)&#123;</span><br><span class="line">width: 10%;</span><br><span class="line">&#125;</span><br><span class="line">table th:nth-of-type(2)&#123;</span><br><span class="line">width: 70%;</span><br><span class="line">&#125;</span><br><span class="line">table th:nth-of-type(3)&#123;</span><br><span class="line">width: 20%;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">| 选项      | 说明    |示例|</span><br><span class="line">|:--------|--------|---|</span><br><span class="line">|第一列：10%|第二列：70%|第三列：20%|</span><br></pre></td></tr></table></figure>

<p>以上输出显示效果如下：</p>
<style>
table th:nth-of-type(1){
width: 10%;
}
table th:nth-of-type(2){
width: 70%;
}
table th:nth-of-type(3){
width: 20%;
}
</style>

<table>
<thead>
<tr>
<th align="left">选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">第一列：10%</td>
<td>第二列：70%</td>
<td>第三列：20%</td>
</tr>
</tbody></table>
<blockquote>
<p>一个文档中出现多次，以最后一个 <code>style</code> 配置为最终效果</p>
</blockquote>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://hexo.io/zh-cn/docs/writing">Hexo Markdown 语法手册</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql 从库提升为主库，原来的其他从库成为新的主库的从库</title>
    <url>/b12589a5/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Mysql 5.7</li>
</ul>
<h3 id="场景说明"><a href="#场景说明" class="headerlink" title="场景说明"></a>场景说明</h3><p>Mysql 一主多从的情况下，主库宕机（或其他无法使用的情况），将其中一台从库提升为主库，同时将原来其他的从库配置为新的主库的从库。  </p>
<blockquote>
<p>主从恢复正常之前，数据库不应该有新的数据写入</p>
</blockquote>
<span id="more"></span>

<h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><h4 id="确保所有从库已经执行了relay-log中的全部更新"><a href="#确保所有从库已经执行了relay-log中的全部更新" class="headerlink" title="确保所有从库已经执行了relay log中的全部更新"></a>确保所有从库已经执行了relay log中的全部更新</h4><p>登录mysql从库，在每个从库上，执行<code>stop slave io_thread</code>,停止IO线程, 通过以下2个命令之一检查从库relay log的执行情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">show processlist;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_6.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">show slave status\G</span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_7.png">  </p>
<p>当输出中<code>Slave_SQL_Running_State</code> 为 <code>Slave has read all relay log; waiting for more updates</code>，表示更新都执行完毕。  </p>
<blockquote>
<ul>
<li>正常情况下，此时在每个从库上面查看slave状态(<code>show slave status\G</code>), 每个从库读取的主库的<code>Master_Log_File</code>和<code>Read_Master_Log_Pos</code>都应该是一样的，意味着所有的从库都已经更新到了主库宕机时的状态。此种情况下，可随便选择从库作为新的主库。<br><img src="https://i.csms.tech/img_8.png"></li>
<li>如果，从库上面查看slave状态，各个从库读取的主库的<code>Master_Log_File</code>和<code>Read_Master_Log_Pos</code>不一致，说明主库宕机之前各个从库和主库的主从延迟情况可能不一，导致各个从库的状态不一致，此种情况下，从数据完整性的角度考虑，应该选择position最大的一个从库，作为新选定的主库。对其他从库，应该通过从binlog中读取缺失的数据，补足数据。或者直接通过<a href="/94ee2c23/" title="备份恢复">备份恢复</a>的方式，和新选定的主库，重新建立主从连接。</li>
</ul>
</blockquote>
<h4 id="更新新的主库的配置"><a href="#更新新的主库的配置" class="headerlink" title="更新新的主库的配置"></a>更新新的主库的配置</h4><p>在新选定的主库上，配置文件(默认<code>/etc/my.cnf</code>)中开启binlog，如已配置，跳过</p>
<figure class="highlight shell"><figcaption><span>/etc/my.cnf</span></figcaption><table><tr><td class="code"><pre><span class="line">log-bin=mysql-bin</span><br></pre></td></tr></table></figure>
<p>新选定的主库上，如果配置了readonly，在配置文件(默认<code>/etc/my.cnf</code>)中取消readonly配置</p>
<figure class="highlight shell"><figcaption><span>/etc/my.cnf</span></figcaption><table><tr><td class="code"><pre><span class="line">read_only=0</span><br></pre></td></tr></table></figure>
<blockquote>
<p>更改mysql配置文件后，重启mysql生效</p>
</blockquote>
<p>在新选定的主库上，执行以下命令，重置从库配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">stop slave;  </span><br><span class="line">reset master;</span><br><span class="line">reset slave all;  </span><br></pre></td></tr></table></figure>
<p>在新选定的主库上，执行以下命令，创建具有同步权限的账号，如果已存在，跳过</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grant replication slave on *.* to &#x27;repl&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
<p>在新选定的主库上，执行以下命令，查看当前主库的master位置信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">show master status\G</span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_9.png"></p>
<blockquote>
<p>在主从重新建立之前，不应该有新的数据写入数据库，在此前提之下，多次查看master status，显示的<code>File</code>和<code>Position</code> 应该是确定不变的值，后续可根据此值，让其他从库和新选定的主库建立主从连接。  </p>
</blockquote>
<h4 id="建立新的主从"><a href="#建立新的主从" class="headerlink" title="建立新的主从"></a>建立新的主从</h4><p>在其他从库上，执行以下命令，和新选定的主库，建立主从连接，其中需要的<code>master_log_file</code>和<code>master_log_pos</code>从<a href="#%E6%9B%B4%E6%96%B0%E6%96%B0%E7%9A%84%E4%B8%BB%E5%BA%93%E7%9A%84%E9%85%8D%E7%BD%AE">上一步</a>中获得。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">stop slave;</span><br><span class="line">change master to master_host=&#x27;1.1.1.1&#x27;,master_user=&#x27;repl&#x27;,master_password=&#x27;123456&#x27;,master_port=3306,master_log_file=&#x27;mysql-bin.000982&#x27;,master_log_pos=638932979;</span><br><span class="line">start slave</span><br></pre></td></tr></table></figure>

<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3>]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Spinnaker 安装配置</title>
    <url>/202210121639/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos-7 3.10.0-1160</li>
<li>Docker Engine 19.03.15</li>
<li>Kubernetes 1.21.2</li>
</ul>
<blockquote>
<p><strong>本文档中涉及服务器的操作，都是在 Kubernetes 集群的 Master 节点上进行。如果在其他服务器启动 Halyard 容器，需要确保容器中可以访问到 Kubernetes 集群的 API Server</strong></p>
</blockquote>
<h1 id="安装部署步骤"><a href="#安装部署步骤" class="headerlink" title="安装部署步骤"></a>安装部署步骤</h1><h2 id="Install-Halyard-on-Docker-and-Choose-Cloud-Providers-Kubernetes"><a href="#Install-Halyard-on-Docker-and-Choose-Cloud-Providers-Kubernetes" class="headerlink" title="Install Halyard on Docker and Choose Cloud Providers - Kubernetes"></a>Install Halyard on Docker and Choose Cloud Providers - Kubernetes</h2><h3 id="宿主机准备容器数据目录"><a href="#宿主机准备容器数据目录" class="headerlink" title="宿主机准备容器数据目录"></a>宿主机准备容器数据目录</h3><p>宿主机创建 local Halyard config directory <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Install Halyard on Docker](https://spinnaker.io/docs/setup/install/halyard/#install-halyard-on-docker)">[1]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /root/spinnaker_data</span><br><span class="line">mkdir /root/spinnaker_data/.kube</span><br><span class="line">mkdir /root/spinnaker_data/.hal</span><br></pre></td></tr></table></figure>
<p>Spinnaker 的部署配置会写入容器目录 <code>/home/spinnaker/.hal</code>，将此配置映射到宿主机，可保证配置持久化。</p>
<p>拷贝 Kubernetes 集群管理配置文件到 <code>/root/spinnaker_data/.kube/config</code> <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[You need a Kubernetes cluster and its credentials](https://spinnaker.io/docs/setup/install/providers/kubernetes/#you-need-a-kubernetes-cluster-and-its-credentials)">[2]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /etc/kubernetes/admin.conf /root/spinnaker_data/.kube/config</span><br><span class="line">chmod 777 /root/spinnaker_data/.kube/config</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h3 id="启动-Halyard-容器"><a href="#启动-Halyard-容器" class="headerlink" title="启动 Halyard 容器"></a>启动 Halyard 容器</h3><p>启动 Halyard 容器，并挂载 Halyard 本地配置目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run  \</span><br><span class="line">    --name halyard --rm \</span><br><span class="line">    -v /root/spinnaker_data/.hal:/home/spinnaker/.hal \</span><br><span class="line">    -v /root/spinnaker_data/.kube:/home/spinnaker/.kube \</span><br><span class="line">    -it \</span><br><span class="line">    us-docker.pkg.dev/spinnaker-community/docker/halyard:stable</span><br></pre></td></tr></table></figure>

<h3 id="配置-Spinnaker-关联-Kubernetes-集群"><a href="#配置-Spinnaker-关联-Kubernetes-集群" class="headerlink" title="配置 Spinnaker 关联 Kubernetes 集群"></a>配置 Spinnaker 关联 Kubernetes 集群</h3><h4 id="配置并验证-Halyard-容器可以和-kubernetes-Api-Server-通信"><a href="#配置并验证-Halyard-容器可以和-kubernetes-Api-Server-通信" class="headerlink" title="配置并验证 Halyard 容器可以和 kubernetes Api Server 通信"></a>配置并验证 Halyard 容器可以和 kubernetes Api Server 通信</h4><p>进入 Halyard 容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it halyard bash</span><br></pre></td></tr></table></figure>
<p>修改 <code>/home/spinnaker/.kube/config</code>，将配置中的 Kubernetes API Server 改为正确的 IP </p>
<figure class="highlight shell"><figcaption><span>/home/spinnaker/.kube/config</span></figcaption><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">clusters:</span><br><span class="line">- cluster:</span><br><span class="line">    certificate-authority-data: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUM1ekNDQWMrZ0F3SUJBZ0lCQURBTkJna3Foa2lHOXcwQk</span><br><span class="line">    server: https://10.150.0.21:6443</span><br><span class="line">  name: kubernetes</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p>进入 Halyard 容器，验证 Halyard 容器可以和 Kubernetes API Server 通信：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">exec</span> -it halyard bash</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get nodes</span></span><br><span class="line">NAME                  STATUS   ROLES                  AGE   VERSION</span><br><span class="line">k8s-master   Ready    control-plane,master   24h   v1.21.2</span><br><span class="line">k8s-work1    Ready    &lt;none&gt;                 24h   v1.21.2</span><br><span class="line">k8s-work2    Ready    &lt;none&gt;                 24h   v1.21.2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="启用-Cloud-Provider-kubernetes"><a href="#启用-Cloud-Provider-kubernetes" class="headerlink" title="启用 Cloud Provider : kubernetes"></a>启用 Cloud Provider : kubernetes</h4><p>在 Halyard 容器中，执行以下命令，启用 Cloud Provider : kubernetes <sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Adding an account](https://spinnaker.io/docs/setup/install/providers/kubernetes-v2/#adding-an-account)">[3]</span></a></sup>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hal config provider kubernetes <span class="built_in">enable</span></span></span><br><span class="line">+ Get current deployment</span><br><span class="line">  Success</span><br><span class="line">+ Edit the kubernetes provider</span><br><span class="line">  Success</span><br><span class="line">Validation in default:</span><br><span class="line">- WARNING You have not yet selected a version of Spinnaker to</span><br><span class="line">  deploy.</span><br><span class="line">? Options include: </span><br><span class="line">  - 1.29.0</span><br><span class="line">  - 1.28.1</span><br><span class="line">  - 1.27.1</span><br><span class="line">  - 1.26.7</span><br><span class="line"></span><br><span class="line">Validation in default.provider.kubernetes:</span><br><span class="line">- WARNING Provider kubernetes is enabled, but no accounts have been</span><br><span class="line">  configured.</span><br><span class="line"></span><br><span class="line">+ Successfully enabled kubernetes</span><br></pre></td></tr></table></figure>
<h4 id="添加-kubernetes-账号"><a href="#添加-kubernetes-账号" class="headerlink" title="添加 kubernetes 账号"></a>添加 kubernetes 账号</h4><p>在 Halyard 容器中，执行以下命令，添加账号 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">CONTEXT=$(kubectl config current-context)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hal config provider kubernetes account add my-k8s-account --context <span class="variable">$CONTEXT</span></span></span><br><span class="line">+ Get current deployment</span><br><span class="line">  Success</span><br><span class="line">+ Add the my-k8s-account account</span><br><span class="line">  Success</span><br><span class="line">Validation in default:</span><br><span class="line">- WARNING You have not yet selected a version of Spinnaker to</span><br><span class="line">  deploy.</span><br><span class="line">? Options include: </span><br><span class="line">  - 1.29.0</span><br><span class="line">  - 1.28.1</span><br><span class="line">  - 1.27.1</span><br><span class="line">  - 1.26.7</span><br><span class="line"></span><br><span class="line">+ Successfully added account my-k8s-account for provider</span><br><span class="line">  kubernetes.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Choose-Environment"><a href="#Choose-Environment" class="headerlink" title="Choose Environment"></a>Choose Environment</h2><p>选择如何安装 Spinnaker，此处选择 <code>Distributed installation on Kubernetes</code> <sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Choose your Environment](https://spinnaker.io/docs/setup/install/environment/)">[4]</span></a></sup></p>
<p>在 Halyard 容器中，执行以下命令，配置 <code>Distributed installation on Kubernetes</code>，其中 <code>--account-name</code> 的值为 <a href="#%E6%B7%BB%E5%8A%A0-kubernetes-%E8%B4%A6%E5%8F%B7">添加 kubernetes 账号</a> 中指定的名称</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hal config deploy edit --<span class="built_in">type</span> distributed --account-name my-k8s-account</span></span><br><span class="line"></span><br><span class="line">+ Get current deployment</span><br><span class="line">  Success</span><br><span class="line">+ Get the deployment environment</span><br><span class="line">  Success</span><br><span class="line">+ Edit the deployment environment</span><br><span class="line">  Success</span><br><span class="line">Validation in default:</span><br><span class="line">- WARNING You have not yet selected a version of Spinnaker to</span><br><span class="line">  deploy.</span><br><span class="line">? Options include: </span><br><span class="line">  - 1.29.0</span><br><span class="line">  - 1.28.1</span><br><span class="line">  - 1.27.1</span><br><span class="line">  - 1.26.7</span><br><span class="line"></span><br><span class="line">+ Successfully updated your deployment environment.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="External-Storage"><a href="#External-Storage" class="headerlink" title="External Storage"></a>External Storage</h2><p>外部存储用来持久化 Spinnaker 的配置数据 <sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[External Storage](https://spinnaker.io/docs/setup/install/storage/)">[5]</span></a></sup></p>
<p>在 Halyard 容器中，执行以下命令，配置 AWS S3 连接信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hal config storage s3 edit \</span></span><br><span class="line"><span class="language-bash">    --access-key-id <span class="variable">$YOUR_ACCESS_KEY_ID</span> \</span></span><br><span class="line"><span class="language-bash">    --secret-access-key \</span></span><br><span class="line"><span class="language-bash">    --region <span class="variable">$REGION</span> \</span></span><br><span class="line"><span class="language-bash">    --bucket <span class="variable">$BUCKET</span></span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Your AWS Secret Key.: </span><br><span class="line">+ Get current deployment</span><br><span class="line">  Success</span><br><span class="line">+ Get persistent store</span><br><span class="line">  Success</span><br><span class="line">+ Edit persistent store</span><br><span class="line">  Success</span><br><span class="line">Validation in default.persistentStorage:</span><br><span class="line">- WARNING Your deployment will most likely fail until you configure</span><br><span class="line">  and enable a persistent store.</span><br><span class="line"></span><br><span class="line">Validation in default:</span><br><span class="line">- WARNING You have not yet selected a version of Spinnaker to</span><br><span class="line">  deploy.</span><br><span class="line">? Options include: </span><br><span class="line">  - 1.29.0</span><br><span class="line">  - 1.28.1</span><br><span class="line">  - 1.27.1</span><br><span class="line">  - 1.26.7</span><br><span class="line"></span><br><span class="line">+ Successfully edited persistent store &quot;s3&quot;.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在 Halyard 容器中，执行以下命令，配置存储源为 AWS S3</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hal config storage edit --<span class="built_in">type</span> s3</span></span><br><span class="line">+ Get current deployment</span><br><span class="line">  Success</span><br><span class="line">+ Get persistent storage settings</span><br><span class="line">  Success</span><br><span class="line">+ Edit persistent storage settings</span><br><span class="line">  Success</span><br><span class="line">Validation in default:</span><br><span class="line">- WARNING You have not yet selected a version of Spinnaker to</span><br><span class="line">  deploy.</span><br><span class="line">? Options include: </span><br><span class="line">  - 1.29.0</span><br><span class="line">  - 1.28.1</span><br><span class="line">  - 1.27.1</span><br><span class="line">  - 1.26.7</span><br><span class="line"></span><br><span class="line">+ Successfully edited persistent storage.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Deploy-Spinnaker"><a href="#Deploy-Spinnaker" class="headerlink" title="Deploy Spinnaker"></a>Deploy Spinnaker</h2><p>部署 Spinnaker，并连接 Deck <sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Deploy Spinnaker and Connect to the UI](https://spinnaker.io/docs/setup/install/deploy/)">[6]</span></a></sup></p>
<h3 id="Deploy-Spinnaker-1"><a href="#Deploy-Spinnaker-1" class="headerlink" title="Deploy Spinnaker"></a>Deploy Spinnaker</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看可用的版本</span><br><span class="line">$ hal version list</span><br><span class="line"></span><br><span class="line"># 指定要部署的版本</span><br><span class="line">$ hal config version edit --version 1.29.0</span><br><span class="line"></span><br><span class="line"># 执行部署</span><br><span class="line">$ hal deploy apply</span><br><span class="line"></span><br><span class="line">+ Get current deployment</span><br><span class="line">  Success</span><br><span class="line">+ Prep deployment</span><br><span class="line">  Success</span><br><span class="line">Validation in default.stats:</span><br><span class="line">- INFO Stats are currently ENABLED. Usage statistics are being</span><br><span class="line">  collected. Thank you! These stats inform improvements to the product, and that</span><br><span class="line">  helps the community. To disable, run `hal config stats disable`. To learn more</span><br><span class="line">  about what and how stats data is used, please see</span><br><span class="line">  https://spinnaker.io/docs/community/stay-informed/stats.</span><br><span class="line"></span><br><span class="line">Validation in default.security:</span><br><span class="line">- WARNING Your UI or API domain does not have override base URLs</span><br><span class="line">  set even though your Spinnaker deployment is a Distributed deployment on a</span><br><span class="line">  remote cloud provider. As a result, you will need to open SSH tunnels against</span><br><span class="line">  that deployment to access Spinnaker.</span><br><span class="line">? We recommend that you instead configure an authentication</span><br><span class="line">  mechanism (OAuth2, SAML2, or x509) to make it easier to access Spinnaker</span><br><span class="line">  securely, and then register the intended Domain and IP addresses that your</span><br><span class="line">  publicly facing services will be using.</span><br><span class="line"></span><br><span class="line">+ Preparation complete... deploying Spinnaker</span><br><span class="line">+ Get current deployment</span><br><span class="line">  Success</span><br><span class="line">- Apply deployment</span><br><span class="line">_ Apply deployment</span><br><span class="line">^ Apply deployment</span><br><span class="line">* Apply deployment</span><br><span class="line">_ Apply deployment</span><br><span class="line">+ Apply deployment</span><br><span class="line">  Success</span><br><span class="line">+ Deploy spin-redis</span><br><span class="line">  Success</span><br><span class="line">+ Deploy spin-clouddriver</span><br><span class="line">  Success</span><br><span class="line">+ Deploy spin-front50</span><br><span class="line">  Success</span><br><span class="line">+ Deploy spin-orca</span><br><span class="line">  Success</span><br><span class="line">+ Deploy spin-deck</span><br><span class="line">  Success</span><br><span class="line">+ Deploy spin-echo</span><br><span class="line">  Success</span><br><span class="line">+ Deploy spin-gate</span><br><span class="line">  Success</span><br><span class="line">+ Deploy spin-rosco</span><br><span class="line">  Success</span><br><span class="line">+ Run `hal deploy connect` to connect to Spinnaker.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用 kubernetes 做为 Cloud Provider，选择分布式部署后，会在 kubernetes 集群中创建命名空间：<code>spinnaker</code>，并创建相关的 <code>Deployment</code>，<code>Service</code> 等资源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get deployment,services,pods -n spinnaker</span></span><br><span class="line">NAME                               READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">deployment.apps/spin-clouddriver   1/1     1            1           33m</span><br><span class="line">deployment.apps/spin-deck          1/1     1            1           33m</span><br><span class="line">deployment.apps/spin-echo          1/1     1            1           33m</span><br><span class="line">deployment.apps/spin-front50       1/1     1            1           33m</span><br><span class="line">deployment.apps/spin-gate          1/1     1            1           33m</span><br><span class="line">deployment.apps/spin-orca          1/1     1            1           33m</span><br><span class="line">deployment.apps/spin-redis         1/1     1            1           33m</span><br><span class="line">deployment.apps/spin-rosco         1/1     1            1           33m</span><br><span class="line"></span><br><span class="line">NAME                       TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE</span><br><span class="line">service/spin-clouddriver   ClusterIP   10.103.217.2     &lt;none&gt;        7002/TCP   33m</span><br><span class="line">service/spin-deck          ClusterIP   10.100.138.37    &lt;none&gt;        9000/TCP   33m</span><br><span class="line">service/spin-echo          ClusterIP   10.109.141.10    &lt;none&gt;        8089/TCP   33m</span><br><span class="line">service/spin-front50       ClusterIP   10.97.63.108     &lt;none&gt;        8080/TCP   33m</span><br><span class="line">service/spin-gate          ClusterIP   10.107.160.202   &lt;none&gt;        8084/TCP   33m</span><br><span class="line">service/spin-orca          ClusterIP   10.101.53.110    &lt;none&gt;        8083/TCP   33m</span><br><span class="line">service/spin-redis         ClusterIP   10.97.51.27      &lt;none&gt;        6379/TCP   33m</span><br><span class="line">service/spin-rosco         ClusterIP   10.96.45.179     &lt;none&gt;        8087/TCP   33m</span><br><span class="line"></span><br><span class="line">NAME                                    READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/spin-clouddriver-7b8d55598c-cnzbz   1/1     Running   0          33m</span><br><span class="line">pod/spin-deck-64bb7f4b7-mpvpr           1/1     Running   0          33m</span><br><span class="line">pod/spin-echo-645cdd8749-l2krj          1/1     Running   0          33m</span><br><span class="line">pod/spin-front50-5d84b48775-7j462       1/1     Running   0          33m</span><br><span class="line">pod/spin-gate-64589485b-cxpkh           1/1     Running   0          33m</span><br><span class="line">pod/spin-orca-7f665ccdcb-4cnvg          1/1     Running   0          33m</span><br><span class="line">pod/spin-redis-55b7dd654c-q9d8k         1/1     Running   0          33m</span><br><span class="line">pod/spin-rosco-6458964f46-gsdqc         1/1     Running   0          33m</span><br></pre></td></tr></table></figure>

<h3 id="Connect-to-the-Spinnaker-UI"><a href="#Connect-to-the-Spinnaker-UI" class="headerlink" title="Connect to the Spinnaker UI"></a>Connect to the Spinnaker UI</h3><p>使用 kubernetes 做为 Cloud Provider，<strong>无需执行以下命令</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hal deploy connect</span><br></pre></td></tr></table></figure>
<p>为了连接 UI，需要在 kubernetes 集群中为 spin-deck 创建相应的 <code>Ingress</code> 资源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: spinnaker-deck</span><br><span class="line">  namespace: spinnaker</span><br><span class="line">spec:</span><br><span class="line">  ingressClassName: nginx</span><br><span class="line">  rules:</span><br><span class="line">  - host: deck.my.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - backend:</span><br><span class="line">          service:</span><br><span class="line">            name: spin-deck</span><br><span class="line">            port:</span><br><span class="line">              number: 9000</span><br><span class="line">        path: /</span><br><span class="line">        pathType: Prefix</span><br></pre></td></tr></table></figure>
<p>通过 Ingress 绑定的域名，可以访问到 Spinnaker UI，此时 Web UI 中会无法获取到资源，因为默认的 Gate Endpoint 为 <code>http://localhost:8084</code>，浏览器页面会报错 ： <code>Error fetching applications. Check that your gate endpoint is accessible. Further information on troubleshooting this error is available here</code>。因此需要执行以下命令配置 UI 和 Gate Api 的域名 <sup id="fnref:7"><a href="#fn:7" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[I can’t load the Applications screen](https://spinnaker.io/docs/setup/install/faq/#i-cant-load-the-applications-screen)">[7]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hal config security ui edit --override-base-url http://deck.my.com</span><br><span class="line">hal config security api edit --override-base-url http://spin-gate.my.com</span><br></pre></td></tr></table></figure>
<p>执行以下命令，使配置生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hal deploy apply</span><br></pre></td></tr></table></figure>
<p>在 kubernetes 集群中为 spin-gate 创建相应的 <code>Ingress</code> 资源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: spinnaker-gate</span><br><span class="line">  namespace: spinnaker</span><br><span class="line">spec:</span><br><span class="line">  ingressClassName: nginx</span><br><span class="line">  rules:</span><br><span class="line">  - host: spin-gate.my.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - backend:</span><br><span class="line">          service:</span><br><span class="line">            name: spin-gate</span><br><span class="line">            port:</span><br><span class="line">              number: 8084</span><br><span class="line">        path: /</span><br><span class="line">        pathType: Prefix</span><br></pre></td></tr></table></figure>
<p>重新访问 Web UI，可以看到正确的内容<br><img src="https://i.csms.tech/img_63.png"></p>
<h1 id="Spinnaker-其他配置"><a href="#Spinnaker-其他配置" class="headerlink" title="Spinnaker 其他配置"></a>Spinnaker 其他配置</h1><h2 id="添加自建的私有-docker-镜像源"><a href="#添加自建的私有-docker-镜像源" class="headerlink" title="添加自建的私有 docker 镜像源"></a>添加自建的私有 docker 镜像源</h2><p>启用 <code>docker-registry</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hal config provider docker-registry <span class="built_in">enable</span></span></span><br><span class="line">+ Get current deployment</span><br><span class="line">  Success</span><br><span class="line">+ Edit the dockerRegistry provider</span><br><span class="line">  Success</span><br><span class="line">Validation in default.provider.dockerRegistry:</span><br><span class="line">- WARNING Provider dockerRegistry is enabled, but no accounts have</span><br><span class="line">  been configured.</span><br><span class="line"></span><br><span class="line">+ Successfully enabled dockerRegistry</span><br></pre></td></tr></table></figure>
<p>配置认证信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hal config provider docker-registry account add my-docker-registry \</span></span><br><span class="line"><span class="language-bash">                                --address http://54.236.1.2:5000 \</span></span><br><span class="line"><span class="language-bash">                                --username <span class="variable">$USER</span> \</span></span><br><span class="line"><span class="language-bash">                                --password <span class="variable">$PASSWD</span></span></span><br><span class="line"></span><br><span class="line">+ Get current deployment</span><br><span class="line">  Success</span><br><span class="line">+ Add the my-docker-registry account</span><br><span class="line">  Success</span><br><span class="line">+ Successfully added account my-docker-registry for provider</span><br><span class="line">  dockerRegistry.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="配置-Jenkins-信息"><a href="#配置-Jenkins-信息" class="headerlink" title="配置 Jenkins 信息"></a>配置 Jenkins 信息</h2><p>启用 Jenkins</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hal config ci jenkins enable</span><br></pre></td></tr></table></figure>
<p>配置 Jenkins 认证信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hal config ci jenkins master add my-jenkins-master-01 \ </span><br><span class="line">                 --address http://34.150.227.175:8080 \ </span><br><span class="line">                 --username admin \ </span><br><span class="line">                 --password 32366490694c4af4</span><br></pre></td></tr></table></figure>
<p>启用 csrf</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hal config ci jenkins master edit my-jenkins-master-01 --csrf true</span><br></pre></td></tr></table></figure>

<h2 id="配置-LDAP-认证"><a href="#配置-LDAP-认证" class="headerlink" title="配置 LDAP 认证"></a>配置 LDAP 认证</h2><p>先配置 ldap 服务相关信息，再启用 ldap 认证，否则会报错： <code>! ERROR LDAP url missing.</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hal config security authn ldap edit \</span><br><span class="line">--user-search-base &#x27;dc=example,dc=org&#x27; \</span><br><span class="line">--url &#x27;ldap://10.4.7.12:389&#x27; \</span><br><span class="line">--user-search-filter &#x27;cn=&#123;0&#125;&#x27; \</span><br><span class="line">--manager-dn &#x27;cn=admin,dc=example,dc=org&#x27; \</span><br><span class="line">--manager-password &#x27;admin&#x27;</span><br></pre></td></tr></table></figure>

<p>启用 ldap 认证</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hal config security authn ldap enable</span><br></pre></td></tr></table></figure>
<p>重新部署，以使配置生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hal deploy apply</span><br></pre></td></tr></table></figure>

<h2 id="使用-Nginx-反代-Spinnaker"><a href="#使用-Nginx-反代-Spinnaker" class="headerlink" title="使用 Nginx 反代 Spinnaker"></a>使用 Nginx 反代 Spinnaker</h2><p>Spinnaker 部署于 Kubernetes 集群中，为了让集群中的服务不直接接收外部流量，需要使用 Nginx 反代访问 Spinnaker 服务。本示例中 Spinnaker 为配置 https，为 http 服务。使用的 Nginx 配置如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">upstream ingress-nginx-controller-https &#123;</span><br><span class="line">    server 172.31.22.9:443;</span><br><span class="line">    server 172.31.16.4:443;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">upstream ingress-nginx-controller-http &#123;</span><br><span class="line">    server 172.31.22.9:80;</span><br><span class="line">    server 172.31.16.4:80;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用来对 用户 ip 进行映射，以便后面做访问控制</span></span><br><span class="line">map $clientRealIp $k8s_admin_access &#123;</span><br><span class="line">         default false;</span><br><span class="line">         include k8s_admin_access.list;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name deck.test.com spin-gate.test.com;</span><br><span class="line">    access_log /home/logs/nginx/access/spinnaker.access.log main;</span><br><span class="line">    error_log /home/logs/nginx/error/spinnaker.error.log;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">                if ($k8s_admin_access = false) &#123;</span><br><span class="line">                    return 403;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        proxy_pass http://ingress-nginx-controller-http;     # 此处需要使用 http，不能使用 https</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header REMOTE-HOST $remote_addr;</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">        proxy_set_header Connection $connection_upgrade;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><h2 id="Spinnaker-无法自动读取到-Kubernetes-中的命名空间"><a href="#Spinnaker-无法自动读取到-Kubernetes-中的命名空间" class="headerlink" title="Spinnaker 无法自动读取到 Kubernetes 中的命名空间"></a>Spinnaker 无法自动读取到 Kubernetes 中的命名空间</h2><p>登陆 Spinnaker 后，查看 <code>Applications</code> 中的内容，无任何 <code>Applications</code> 显示，手动添加应用后，pipeline 部署失败，返回以下错误</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Exception ( Deploy Manifest )</span><br><span class="line">deployKubernetesManifest.deployKubernetesManifest.deployment.Error reading kind [deployment]. Please check connectivity and access permissions to the cluster</span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_108.png"></p>
<p>检查 <code>spin-clouddriver</code> 的日志，日志中显示无法连接到 <code>kube-api-server</code> ，解决 <code>spin-clouddriver</code> 到 <code>kube-api-server</code> 的通信异常，问题解决。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://spinnaker.io/docs/setup/install/">Install and Configure Spinnaker</a></p>
<p><a href="https://spinnaker.io/docs/setup/install/faq/">Halyard FAQ</a></p>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://spinnaker.io/docs/setup/install/halyard/#install-halyard-on-docker">Install Halyard on Docker</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://spinnaker.io/docs/setup/install/providers/kubernetes/#you-need-a-kubernetes-cluster-and-its-credentials">You need a Kubernetes cluster and its credentials</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://spinnaker.io/docs/setup/install/providers/kubernetes-v2/#adding-an-account">Adding an account</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://spinnaker.io/docs/setup/install/environment/">Choose your Environment</a><a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://spinnaker.io/docs/setup/install/storage/">External Storage</a><a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://spinnaker.io/docs/setup/install/deploy/">Deploy Spinnaker and Connect to the UI</a><a href="#fnref:6" rev="footnote"> ↩</a></span></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://spinnaker.io/docs/setup/install/faq/#i-cant-load-the-applications-screen">I can’t load the Applications screen</a><a href="#fnref:7" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Spinnaker</tag>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP 协议</title>
    <url>/202211251549/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="TCP-协议抓包分析"><a href="#TCP-协议抓包分析" class="headerlink" title="TCP 协议抓包分析"></a>TCP 协议抓包分析</h1><h2 id="TCP-通信过程中-seq-和-ACK-值说明"><a href="#TCP-通信过程中-seq-和-ACK-值说明" class="headerlink" title="TCP 通信过程中 seq 和 ACK 值说明"></a>TCP 通信过程中 seq 和 ACK 值说明</h2><p><img src="https://i.csms.tech/img_96.png"></p>
<ul>
<li><p>TCP 连接通信过程中，client 和 server 端各自维护自己的 <code>seq</code>。后面一个数据包的 <code>seq</code> 是前面一个数据包的 <code>seq</code> 加上前面一个数据包的大小。表示发送的字节位置。 </p>
<p>  假如当前连接中，之前一个包 <code>seq = 100</code>，其发送数据包大小为 0，则当前要发送的数据包的 <code>seq = 0</code></p>
<p>  假如当前连接中，之前一个包 <code>seq = 100</code>，其发送数据包大小为 20，则当前要发送的数据包的 <code>seq = 120</code></p>
</li>
<li><p>TCP 连接通信过程中，client 和 server 端要发送给对方的包的 <code>ACK</code> 的值为：收到的包的 <code>seq</code> + 收到的包的 <code>Len</code>，此值告知发送方，接收方希望接收到的下一个包的序列号。</p>
<p>  假如接收方接收到了 <code>seq = 100</code> ，<code>Len = 0</code> 的包，接收方需要发送的 <code>ACK = 100 + 1</code></p>
<p>  假如接收方接收到了 <code>seq = 100</code> ，<code>Len = 20</code> 的包，接收方需要发送的 <code>ACK = 100 + 20</code></p>
</li>
</ul>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://xiaolincoding.com/network/3_tcp/tcp_tcpdump.html#%E6%98%BE%E5%BD%A2-%E4%B8%8D%E5%8F%AF%E8%A7%81-%E7%9A%84%E7%BD%91%E7%BB%9C%E5%8C%85">TCP 实战抓包分析</a></p>
<p><a href="https://www.cnblogs.com/163yun/p/9552368.html">wireshark抓包分析——TCP&#x2F;IP协议</a></p>
]]></content>
      <categories>
        <category>TCPIP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>akamai cdn api 使用</title>
    <url>/202302011153/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="https://techdocs.akamai.com/developer/docs/make-your-first-api-call">Akamai CDN API 说明文档</a>，调用 API 之前需要先根据官方文档说明 <code>Create API Client</code></p>
<h1 id="Python-SDK-使用"><a href="#Python-SDK-使用" class="headerlink" title="Python SDK 使用"></a>Python SDK 使用</h1><p>根据官方文档说明安装 <code>edgegrid-python</code>，并配置 <code>Create API Client Key</code> 信息 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Create a basic API client](https://techdocs.akamai.com/developer/docs/make-your-first-api-call)">[1]</span></a></sup>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install edgegrid-python</span><br></pre></td></tr></table></figure>

<p><a href="https://techdocs.akamai.com/developer/docs/python">Python SDK 使用官方示例</a></p>
<h2 id="获取账号信息"><a href="#获取账号信息" class="headerlink" title="获取账号信息"></a>获取账号信息</h2><p>大多数 API 使用都需要提供 <code>groupId</code>，<code>accountId</code>，<code>contractIds</code>，通过以下接口获取这些信息 <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[List groups](https://techdocs.akamai.com/property-mgr/reference/get-groups)">[2]</span></a></sup></p>
<figure class="highlight shell"><figcaption><span>python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import requests</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from akamai.edgegrid import EdgeGridAuth, EdgeRc</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from urllib.parse import urljoin</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; edgerc = EdgeRc(<span class="string">&#x27;~/.edgerc&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; section = <span class="string">&#x27;default&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; baseurl = <span class="string">&#x27;https://%s&#x27;</span> % edgerc.get(section, <span class="string">&#x27;host&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; s = requests.Session()</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; s.auth = EdgeGridAuth.from_edgerc(edgerc, section)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; result = s.get(urljoin(baseurl, <span class="string">&#x27;/papi/v1/groups&#x27;</span>))</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; result.json()</span></span><br><span class="line">&#123;&#x27;accountId&#x27;: &#x27;act_F-AC-488298736&#x27;, &#x27;accountName&#x27;: &#x27;Guangzhou kl Network Technology Co., Ltd&#x27;, &#x27;groups&#x27;: &#123;&#x27;items&#x27;: [&#123;&#x27;groupName&#x27;: &#x27;Guangzhou extreme-G-8HGkt-DSA&#x27;, &#x27;groupId&#x27;: &#x27;grp_186987767&#x27;, &#x27;contractIds&#x27;: [&#x27;ctr_G-3JDoujhh&#x27;]&#125;]&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果 <code>Property</code> 中存在分组，每个分组都有一个独立的 <code>groupId</code></p>
</blockquote>
<span id="more"></span>
<h2 id="获取-CPCode"><a href="#获取-CPCode" class="headerlink" title="获取 CPCode"></a>获取 CPCode</h2><p>通过以下接口及参数获取 CPCode <sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[List CP codes](https://techdocs.akamai.com/property-mgr/reference/get-cpcodes)">[3]</span></a></sup></p>
<figure class="highlight shell"><figcaption><span>python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import requests</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from akamai.edgegrid import EdgeGridAuth, EdgeRc</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from urllib.parse import urljoin</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; edgerc = EdgeRc(<span class="string">&#x27;~/.edgerc&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; section = <span class="string">&#x27;default&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; baseurl = <span class="string">&#x27;https://%s&#x27;</span> % edgerc.get(section, <span class="string">&#x27;host&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; s = requests.Session()</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; s.auth = EdgeGridAuth.from_edgerc(edgerc, section)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; result = s.get(urljoin(baseurl, <span class="string">&#x27;/papi/v1/cpcodes&#x27;</span>), params=&#123;<span class="string">&#x27;contractId&#x27;</span>: <span class="string">&#x27;ctr_G-ctr_G-3JDoujhh&#x27;</span>, <span class="string">&#x27;groupId&#x27;</span>: <span class="string">&#x27;grp_186987767&#x27;</span>&#125;, headers=&#123;<span class="string">&#x27;PAPI-Use-Prefixes&#x27;</span>: <span class="string">&#x27;True&#x27;</span>&#125;)</span></span><br></pre></td></tr></table></figure>

<h2 id="获取指定-CPCode-的流量信息"><a href="#获取指定-CPCode-的流量信息" class="headerlink" title="获取指定 CPCode 的流量信息"></a>获取指定 CPCode 的流量信息</h2><p>此处主要演示获取指标 <code>edgeBytes</code> 的流量，具体 API 使用方式可参考官方文档 <sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[bytes-by-cpcode](https://techdocs.akamai.com/reporting/reference/bytes-by-cpcode)">[4]</span></a></sup></p>
<h3 id="查询所有-CPCode-的流量"><a href="#查询所有-CPCode-的流量" class="headerlink" title="查询所有 CPCode 的流量"></a>查询所有 CPCode 的流量</h3><figure class="highlight shell"><figcaption><span>python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import requests</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from akamai.edgegrid import EdgeGridAuth, EdgeRc</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from urllib.parse import urljoin</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; edgerc = EdgeRc(<span class="string">&#x27;~/.edgerc&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; section = <span class="string">&#x27;default&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; baseurl = <span class="string">&#x27;https://%s&#x27;</span> % edgerc.get(section, <span class="string">&#x27;host&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; s = requests.Session()</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; s.auth = EdgeGridAuth.from_edgerc(edgerc, section)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; params = &#123;<span class="string">&#x27;start&#x27;</span>: <span class="string">&#x27;2022-12-31T00:00:00Z&#x27;</span>, <span class="string">&#x27;end&#x27;</span>: <span class="string">&#x27;2023-01-01T00:00:00Z&#x27;</span>, <span class="string">&#x27;allObjectIds&#x27;</span>: True, <span class="string">&#x27;metrics&#x27;</span>: <span class="string">&#x27;edgeBytes&#x27;</span>&#125;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; result = s.get(urljoin(baseurl, <span class="string">&#x27;/reporting-api/v1/reports/bytes-by-cpcode/versions/1/report-data&#x27;</span>), params=params)</span></span><br></pre></td></tr></table></figure>

<h3 id="获取指定-CPCode-的流量信息-1"><a href="#获取指定-CPCode-的流量信息-1" class="headerlink" title="获取指定 CPCode 的流量信息"></a>获取指定 CPCode 的流量信息</h3><figure class="highlight shell"><figcaption><span>python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; s = requests.Session()</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; s.auth = EdgeGridAuth.from_edgerc(edgerc, section)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; params = &#123;<span class="string">&#x27;start&#x27;</span>: <span class="string">&#x27;2022-12-01T00:00:00Z&#x27;</span>, <span class="string">&#x27;end&#x27;</span>: <span class="string">&#x27;2023-01-01T00:00:00Z&#x27;</span>, <span class="string">&#x27;objectIds&#x27;</span>: <span class="string">&#x27;1335489&#x27;</span>, <span class="string">&#x27;metrics&#x27;</span>: <span class="string">&#x27;edgeBytes&#x27;</span>&#125;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; result = s.get(urljoin(baseurl, <span class="string">&#x27;/reporting-api/v1/reports/bytes-by-cpcode/versions/1/report-data&#x27;</span>), params=params)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="获取-property"><a href="#获取-property" class="headerlink" title="获取 property"></a>获取 property</h3><p>要获取 Property 信息，参考代码 <sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[List properties](https://techdocs.akamai.com/property-mgr/reference/get-properties)">[5]</span></a></sup></p>
<p>要获取指定 Property 信息，参考代码 <sup id="fnref:7"><a href="#fn:7" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Get a property](https://techdocs.akamai.com/property-mgr/reference/get-property)">[7]</span></a></sup></p>
<h3 id="获取-Property-的-rule-信息"><a href="#获取-Property-的-rule-信息" class="headerlink" title="获取 Property 的 rule 信息"></a>获取 Property 的 rule 信息</h3><p>参考文档 <sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Get a property's rule tree](https://techdocs.akamai.com/property-mgr/reference/get-property-version-rules)">[6]</span></a></sup></p>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://techdocs.akamai.com/developer/docs/make-your-first-api-call">Create a basic API client</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://techdocs.akamai.com/property-mgr/reference/get-groups">List groups</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://techdocs.akamai.com/property-mgr/reference/get-cpcodes">List CP codes</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://techdocs.akamai.com/reporting/reference/bytes-by-cpcode">bytes-by-cpcode</a><a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://techdocs.akamai.com/property-mgr/reference/get-properties">List properties</a><a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://techdocs.akamai.com/property-mgr/reference/get-property-version-rules">Get a property's rule tree</a><a href="#fnref:6" rev="footnote"> ↩</a></span></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://techdocs.akamai.com/property-mgr/reference/get-property">Get a property</a><a href="#fnref:7" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>云平台</category>
        <category>Akamai</category>
      </categories>
      <tags>
        <tag>云平台</tag>
      </tags>
  </entry>
  <entry>
    <title>AlertManager 使用</title>
    <url>/202306141005/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>AlertManager 0.24.0</li>
</ul>
<h1 id="部署配置-AlertManager"><a href="#部署配置-AlertManager" class="headerlink" title="部署配置 AlertManager"></a>部署配置 AlertManager</h1><p>AlertManager 是一个专门用于实现告警的工具，可以实现接收 Prometheus 或其它应用发出的告警信息，并对这些告警信息进行 <strong>分组</strong>、<strong>抑制</strong> 以及 <strong>静默</strong> 等操作，然后通过 <strong>路由</strong> 的方式，根据不同的告警规则配置，分发到不同的告警路由策略中。 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Kubernetes 部署告警工具 AlertManager](http://www.mydlq.club/article/123/)">[1]</span></a></sup></p>
<p>AlertManager 常用的功能主要有:</p>
<ul>
<li><strong>抑制</strong> - 抑制是一种机制，指的是当某一告警信息发送后，可以停止由此告警引发的其它告警，避免相同的告警信息重复发送。</li>
<li><strong>静默</strong> - 静默也是一种机制，指的是依据设置的标签，对告警行为进行静默处理。如果 AlertManager 接收到的告警符合静默配置，则 Alertmanager 就不会发送该告警通知。</li>
<li><strong>发送告警</strong> - 支持配置多种告警规则，可以根据不同的路由配置，采用不同的告警方式发送告警通知。</li>
<li><strong>告警分组</strong> - 分组机制可以将详细的告警信息合并成一个通知。在某些情况下，如系统宕机导致大量的告警被同时触发，在这种情况下分组机制可以将这些被触发的告警信息合并为一个告警通知，从而避免一次性发送大量且属于相同问题的告警，导致无法对问题进行快速定位。</li>
</ul>
<h2 id="部署-AlertManager"><a href="#部署-AlertManager" class="headerlink" title="部署 AlertManager"></a>部署 AlertManager</h2><p>本文部署配置基于 <a href="/202212141608/" title="K8S 上安装 Prometheus 并监控 K8S 集群">K8S 上安装 Prometheus 并监控 K8S 集群</a></p>
<p>在名为 <code>prometheus-server-conf</code> 的 <code>ConfigMap</code> 中为 AlertManager 创建配置文件 <code>alertmanager.yml</code>，并将其挂载到 AlertManager 容器中</p>
<figure class="highlight shell"><figcaption><span>alertmanager.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">global:</span><br><span class="line">  resolve_timeout: 5m</span><br><span class="line"></span><br><span class="line">route:</span><br><span class="line">  group_by: [&#x27;alertname&#x27;]</span><br><span class="line">  group_wait: 10s</span><br><span class="line">  group_interval: 10s</span><br><span class="line">  repeat_interval: 5m</span><br><span class="line">  receiver: &#x27;web.hook&#x27;</span><br><span class="line">receivers:</span><br><span class="line">- name: &#x27;web.hook&#x27;</span><br><span class="line">  webhook_configs:</span><br><span class="line">  - url: &#x27;http://localhost:8080/alert_manager_webhook&#x27;</span><br><span class="line">    send_resolved: true</span><br><span class="line">inhibit_rules:</span><br><span class="line">  - source_match:</span><br><span class="line">      severity: &#x27;critical&#x27;</span><br><span class="line">    target_match:</span><br><span class="line">      severity: &#x27;warning&#x27;</span><br><span class="line">    equal: [&#x27;alertname&#x27;, &#x27;dev&#x27;, &#x27;instance&#x27;]</span><br></pre></td></tr></table></figure>

<p>使用为 Prometheus 创建的 PVC 作为 AlertManager 的持久存储，参考以下配置部署 AlertManager</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus-pod</span><br><span class="line">  namespace: prometheus</span><br><span class="line">  labels:</span><br><span class="line">    app: prometheus-server</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: prometheus-server</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: prometheus-server</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">        - name: prometheus</span><br><span class="line">          image: prom/prometheus</span><br><span class="line">          args:</span><br><span class="line">            - &quot;--storage.tsdb.retention.time=12h&quot;</span><br><span class="line">            - &quot;--config.file=/etc/prometheus/prometheus.yml&quot;</span><br><span class="line">            - &quot;--storage.tsdb.path=/prometheus/&quot;</span><br><span class="line">          ports:</span><br><span class="line">            - containerPort: 9090</span><br><span class="line">          resources:</span><br><span class="line">            requests:</span><br><span class="line">              cpu: 500m</span><br><span class="line">              memory: 500M</span><br><span class="line">            limits:</span><br><span class="line">              cpu: 1</span><br><span class="line">              memory: 1Gi</span><br><span class="line">          volumeMounts:</span><br><span class="line">            - name: prometheus-config-volume</span><br><span class="line">              mountPath: /etc/prometheus/</span><br><span class="line">            - name: prometheus-storage-volume</span><br><span class="line">              mountPath: /prometheus/</span><br><span class="line">              subPath: prometheus</span><br><span class="line">        - name: grafana</span><br><span class="line">          image: grafana/grafana</span><br><span class="line">          ports:</span><br><span class="line">            - containerPort: 3000</span><br><span class="line">          volumeMounts:</span><br><span class="line">            - name: prometheus-storage-volume</span><br><span class="line">              mountPath: /var/lib/grafana</span><br><span class="line">              subPath: grafana</span><br><span class="line">        - image: prom/alertmanager:v0.24.0</span><br><span class="line">          name: alert-manager</span><br><span class="line">          ports:</span><br><span class="line">            - containerPort: 9093</span><br><span class="line">          args:</span><br><span class="line">            - &quot;--config.file=/etc/alertmanager/alertmanager.yml&quot;</span><br><span class="line">            - &quot;--web.external-url=http://alert-manager.example.com/&quot;</span><br><span class="line">            - &#x27;--cluster.advertise-address=0.0.0.0:9093&#x27;</span><br><span class="line">            - &quot;--storage.path=/alertmanager&quot;</span><br><span class="line">          resources:</span><br><span class="line">            limits:</span><br><span class="line">              cpu: 1000m</span><br><span class="line">              memory: 512Mi</span><br><span class="line">            requests:</span><br><span class="line">              cpu: 1000m</span><br><span class="line">              memory: 512Mi</span><br><span class="line">          readinessProbe:</span><br><span class="line">            httpGet:</span><br><span class="line">              path: /-/ready</span><br><span class="line">              port: 9093</span><br><span class="line">            initialDelaySeconds: 5</span><br><span class="line">            timeoutSeconds: 10</span><br><span class="line">          livenessProbe:</span><br><span class="line">            httpGet:</span><br><span class="line">              path: /-/healthy</span><br><span class="line">              port: 9093</span><br><span class="line">            initialDelaySeconds: 30</span><br><span class="line">            timeoutSeconds: 30</span><br><span class="line">          volumeMounts:</span><br><span class="line">          - name: prometheus-storage-volume</span><br><span class="line">            mountPath: /alertmanager </span><br><span class="line">            subPath: alertmanager</span><br><span class="line">          - name: prometheus-config-volume</span><br><span class="line">            mountPath: /etc/alertmanager</span><br><span class="line">      volumes:</span><br><span class="line">        - name: prometheus-config-volume</span><br><span class="line">          configMap:</span><br><span class="line">            defaultMode: 420</span><br><span class="line">            name: prometheus-server-conf</span><br><span class="line">  </span><br><span class="line">        - name: prometheus-storage-volume</span><br><span class="line">          persistentVolumeClaim:</span><br><span class="line">            claimName: prometheus-pvc</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus-service</span><br><span class="line">  namespace: prometheus</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">    - name: prometheus-port</span><br><span class="line">      port: 8090</span><br><span class="line">      protocol: TCP</span><br><span class="line">      targetPort: 9090</span><br><span class="line">    - name: grafana-port</span><br><span class="line">      port: 3000</span><br><span class="line">      targetPort: 3000</span><br><span class="line">    - name: alert-manager-port</span><br><span class="line">      port: 9093</span><br><span class="line">      targetPort: 9093</span><br><span class="line">  selector:</span><br><span class="line">    app: prometheus-server</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus-ui</span><br><span class="line">  namespace: prometheus</span><br><span class="line"></span><br><span class="line">spec:</span><br><span class="line">  ingressClassName: nginx</span><br><span class="line">  rules:</span><br><span class="line">  - host: prometheus.example.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - backend:</span><br><span class="line">          service:</span><br><span class="line">            name: prometheus-service</span><br><span class="line">            port: </span><br><span class="line">              number: 8090</span><br><span class="line">        path: /</span><br><span class="line">        pathType: Prefix</span><br><span class="line">  - host: grafana.example.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - backend:</span><br><span class="line">          service:</span><br><span class="line">            name: prometheus-service</span><br><span class="line">            port:</span><br><span class="line">              number: 3000</span><br><span class="line">        path: /</span><br><span class="line">        pathType: Prefix</span><br><span class="line">  - host: alert-manager.example.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - backend:</span><br><span class="line">          service:</span><br><span class="line">            name: prometheus-service</span><br><span class="line">            port:</span><br><span class="line">              number: 9093</span><br><span class="line">        path: /</span><br><span class="line">        pathType: Prefix</span><br></pre></td></tr></table></figure>
<p>部署成功后，从 AlertManager 的域名访问，可以看到 AlertManager 的 web UI<br><img src="https://i.csms.tech/img_162.png"></p>
<span id="more"></span>

<h2 id="配置-Prometheus-关联-AlertManager"><a href="#配置-Prometheus-关联-AlertManager" class="headerlink" title="配置 Prometheus 关联 AlertManager"></a>配置 Prometheus 关联 AlertManager</h2><p>要使 Prometheus 能够通过 AlertManager 发送告警信息，需要在 Prometheus 中配置 AlertManager 相关的配置信息，Prometheus 涉及 AlertManager 的主要配置如下</p>
<figure class="highlight shell"><figcaption><span>prometheus.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">alerting:</span><br><span class="line">  alertmanagers:</span><br><span class="line">    - static_configs:</span><br><span class="line">        - targets: [&#x27;localhost:9093&#x27;]</span><br></pre></td></tr></table></figure>

<p>配置后，重启 Prometheus 使配置生效。可以从 AlertManager 的 UI 中查看到 Prometheus 中的告警信息<br><img src="https://i.csms.tech/img_163.png"></p>
<h1 id="AlertManager-配置概述"><a href="#AlertManager-配置概述" class="headerlink" title="AlertManager 配置概述"></a>AlertManager 配置概述</h1><p>Alertmanager 主要负责对 Prometheus 产生的告警进行统一处理，因此在 Alertmanager 配置中一般会包含以下几个主要部分： <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Alertmanager 配置概述](https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/alert/alert-manager-config)
">[2]</span></a></sup></p>
<ul>
<li><strong>全局配置（<code>global</code>）</strong> - 用于定义一些全局的公共参数，如全局的 SMTP 配置，Slack 配置等内容；</li>
<li><strong>模板（<code>templates</code>）</strong> - 用于定义告警通知时的模板，如 HTML 模板，邮件模板等；</li>
<li><strong>告警路由（<code>route</code>）</strong> - 根据标签匹配，确定当前告警应该如何处理；</li>
<li><strong>接收人（<code>receivers</code>）</strong> - 接收人是一个抽象的概念，它可以是一个邮箱也可以是微信，Slack 或者 Webhook 等，接收人一般配合告警路由使用；</li>
<li><strong>抑制规则（<code>inhibit_rules</code>）</strong> - 合理设置抑制规则可以减少垃圾告警的产生</li>
</ul>
<p>其完整配置格式如下</p>
<figure class="highlight shell"><figcaption><span>alertmanager.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">global:</span><br><span class="line">  [ resolve_timeout: &lt;duration&gt; | default = 5m ]</span><br><span class="line">  [ smtp_from: &lt;tmpl_string&gt; ] </span><br><span class="line">  [ smtp_smarthost: &lt;string&gt; ] </span><br><span class="line">  [ smtp_hello: &lt;string&gt; | default = &quot;localhost&quot; ]</span><br><span class="line">  [ smtp_auth_username: &lt;string&gt; ]</span><br><span class="line">  [ smtp_auth_password: &lt;secret&gt; ]</span><br><span class="line">  [ smtp_auth_identity: &lt;string&gt; ]</span><br><span class="line">  [ smtp_auth_secret: &lt;secret&gt; ]</span><br><span class="line">  [ smtp_require_tls: &lt;bool&gt; | default = true ]</span><br><span class="line">  [ slack_api_url: &lt;secret&gt; ]</span><br><span class="line">  [ victorops_api_key: &lt;secret&gt; ]</span><br><span class="line">  [ victorops_api_url: &lt;string&gt; | default = &quot;https://alert.victorops.com/integrations/generic/20131114/alert/&quot; ]</span><br><span class="line">  [ pagerduty_url: &lt;string&gt; | default = &quot;https://events.pagerduty.com/v2/enqueue&quot; ]</span><br><span class="line">  [ opsgenie_api_key: &lt;secret&gt; ]</span><br><span class="line">  [ opsgenie_api_url: &lt;string&gt; | default = &quot;https://api.opsgenie.com/&quot; ]</span><br><span class="line">  [ hipchat_api_url: &lt;string&gt; | default = &quot;https://api.hipchat.com/&quot; ]</span><br><span class="line">  [ hipchat_auth_token: &lt;secret&gt; ]</span><br><span class="line">  [ wechat_api_url: &lt;string&gt; | default = &quot;https://qyapi.weixin.qq.com/cgi-bin/&quot; ]</span><br><span class="line">  [ wechat_api_secret: &lt;secret&gt; ]</span><br><span class="line">  [ wechat_api_corp_id: &lt;string&gt; ]</span><br><span class="line">  [ http_config: &lt;http_config&gt; ]</span><br><span class="line"></span><br><span class="line">templates:</span><br><span class="line">  [ - &lt;filepath&gt; ... ]</span><br><span class="line"></span><br><span class="line">route: &lt;route&gt;</span><br><span class="line"></span><br><span class="line">receivers:</span><br><span class="line">  - &lt;receiver&gt; ...</span><br><span class="line"></span><br><span class="line">inhibit_rules:</span><br><span class="line">  [ - &lt;inhibit_rule&gt; ... ]</span><br></pre></td></tr></table></figure>
<h2 id="global-常用参数说明"><a href="#global-常用参数说明" class="headerlink" title="global 常用参数说明"></a>global 常用参数说明</h2><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>resolve_timeout</code></td>
<td>当 AlertManager 持续多久未接收到告警后就标记告警状态为 <code>resolved</code><br/>默认为 5m</td>
<td></td>
</tr>
</tbody></table>
<h2 id="route-常用参数说明"><a href="#route-常用参数说明" class="headerlink" title="route 常用参数说明"></a>route 常用参数说明</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">route:</span><br><span class="line">      group_by: [<span class="string">&#x27;alertname&#x27;</span>, <span class="string">&#x27;cluster&#x27;</span>]</span><br><span class="line">      group_wait: 30s</span><br><span class="line"></span><br><span class="line">      group_interval: 30s</span><br><span class="line"></span><br><span class="line">      repeat_interval: 1h</span><br><span class="line"></span><br><span class="line">      receiver: default</span><br><span class="line"></span><br><span class="line">      routes:</span><br><span class="line">      - receiver: email</span><br><span class="line">        group_wait: 10s</span><br><span class="line">        <span class="keyword">match</span>:</span><br><span class="line">          team: node</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>group_by</code></td>
<td>接收到报警信息后按照标签重新分组的标签</td>
<td></td>
</tr>
<tr>
<td><code>repeat_interval: 1h</code></td>
<td>发送一个告警后多久再继续发送告警消息，默认 <code>4h</code></td>
<td></td>
</tr>
<tr>
<td><code>group_wait: 30s</code></td>
<td>当一个新的报警分组被创建后，需要等待至少 group_wait 时间来初始化通知，这种方式可以确保有足够的时间为同一分组获取多个警报，然后一起触发这个报警信息</td>
<td></td>
</tr>
<tr>
<td><code>group_interval: 30s</code></td>
<td>相同的 group 之间发送告警通知的时间间隔</td>
<td></td>
</tr>
<tr>
<td><code>receiver: default</code></td>
<td>默认的receiver：如果一个报警没有被一个route匹配，则发送给默认的接收器</td>
<td></td>
</tr>
<tr>
<td><code>routes</code></td>
<td>配置子路由，子路由会继承所有 <code>route</code> 中的配置 ，并且可以在每个子路由上进行覆盖。<br/>告警的路由选择由 <code>match</code> 指令计算</td>
<td></td>
</tr>
</tbody></table>
<h2 id="receivers-常用参数说明"><a href="#receivers-常用参数说明" class="headerlink" title="receivers 常用参数说明"></a>receivers 常用参数说明</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">receivers:</span><br><span class="line">- name: <span class="string">&#x27;web.hook&#x27;</span></span><br><span class="line">  webhook_configs:</span><br><span class="line">  - url: <span class="string">&#x27;http://172.31.2.6:65535/alert_manager_webhook&#x27;</span></span><br><span class="line">    send_resolved: true</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>send_resolved: true   </code></td>
<td>接受告警恢复的通知</td>
<td></td>
</tr>
</tbody></table>
<h2 id="AlertManager-配置示例"><a href="#AlertManager-配置示例" class="headerlink" title="AlertManager 配置示例"></a>AlertManager 配置示例</h2><p>本示例使用以下 配置</p>
<figure class="highlight shell"><figcaption><span>alertmanager.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">global:</span><br><span class="line">  resolve_timeout: 5m</span><br><span class="line"></span><br><span class="line">route:</span><br><span class="line">  group_by: [&#x27;alertname&#x27;]</span><br><span class="line">  group_wait: 10s</span><br><span class="line">  group_interval: 10s</span><br><span class="line">  repeat_interval: 5m</span><br><span class="line">  receiver: &#x27;web.hook&#x27;</span><br><span class="line">receivers:</span><br><span class="line">- name: &#x27;web.hook&#x27;</span><br><span class="line">  webhook_configs:</span><br><span class="line">  - url: &#x27;http://localhost:8080/alert_manager_webhook&#x27;</span><br><span class="line">    send_resolved: true</span><br><span class="line">inhibit_rules:</span><br><span class="line">  - source_match:</span><br><span class="line">      severity: &#x27;critical&#x27;</span><br><span class="line">    target_match:</span><br><span class="line">      severity: &#x27;warning&#x27;</span><br><span class="line">    equal: [&#x27;alertname&#x27;, &#x27;dev&#x27;, &#x27;instance&#x27;]</span><br></pre></td></tr></table></figure>

<p>webhook 代码使用 <a href="/202306011739/" title="Django 视图函数实现转发告警到 Telegram">Django 视图函数实现转发告警到 Telegram</a> ，主体代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="keyword">import</span> telegram</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line">alert_message_template = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">报警项目: %s</span></span><br><span class="line"><span class="string">报警摘要：%s</span></span><br><span class="line"><span class="string">报警状态：%s</span></span><br><span class="line"><span class="string">报警内容：%s</span></span><br><span class="line"><span class="string">触发时间：%s</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">tg_chatgroup_id = -<span class="number">992711111</span></span><br><span class="line">tg_bot_token = <span class="string">&#x27;yEXcs2I&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">alert_manager_webhook</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; 从 AlertManager 接收回调告警数据，并将其转发到第三方 </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    post_data = <span class="built_in">eval</span>(request.body)</span><br><span class="line">    <span class="built_in">print</span>(post_data)</span><br><span class="line">    status = post_data[<span class="string">&#x27;status&#x27;</span>]</span><br><span class="line">    <span class="keyword">for</span> alert <span class="keyword">in</span> post_data[<span class="string">&#x27;alerts&#x27;</span>]:</span><br><span class="line">        alert_labels = alert[<span class="string">&#x27;labels&#x27;</span>]</span><br><span class="line">        alert_name = alert_labels[<span class="string">&#x27;alertname&#x27;</span>]</span><br><span class="line">        alert_job = alert_labels[<span class="string">&#x27;job&#x27;</span>]</span><br><span class="line">        alert_instance = alert_labels[<span class="string">&#x27;instance&#x27;</span>]</span><br><span class="line">        alert_status = alert[<span class="string">&#x27;status&#x27;</span>]</span><br><span class="line">        alert_startAs = alert[<span class="string">&#x27;startsAt&#x27;</span>]</span><br><span class="line">        alert_annotations = alert[<span class="string">&#x27;annotations&#x27;</span>]</span><br><span class="line">        alert_summary = alert_annotations[<span class="string">&#x27;summary&#x27;</span>]</span><br><span class="line">        alert_description = alert_annotations[<span class="string">&#x27;description&#x27;</span>]</span><br><span class="line"></span><br><span class="line">        alert_project = <span class="string">&#x27;%s-%s-%s&#x27;</span> %(alert_job, alert_name, alert_instance)</span><br><span class="line">        send_message_to_tg(chat_id=tg_chatgroup_id, text=alert_message_template %(alert_project, alert_summary, alert_status, alert_description, alert_startAs))</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;ok&#x27;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_message_to_tg</span>(<span class="params">chat_id: <span class="built_in">int</span>, text: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; 发送消息到 tg&#x27;&#x27;&#x27;</span></span><br><span class="line">    bot = telegram.Bot(token=tg_bot_token)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">send_telegram_message</span>():</span><br><span class="line">        response = <span class="keyword">await</span> bot.send_message(chat_id=chat_id, text=text)</span><br><span class="line">        <span class="built_in">print</span>(response)</span><br><span class="line">    <span class="comment"># loop = asyncio.get_event_loop()</span></span><br><span class="line">    <span class="comment"># loop.run_until_complete(send_telegram_message()) </span></span><br><span class="line">    asyncio.run(send_telegram_message())</span><br></pre></td></tr></table></figure>

<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="http://www.mydlq.club/article/123/">Kubernetes 部署告警工具 AlertManager</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/alert/alert-manager-config">Alertmanager 配置概述</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>aliyun 相关配置</title>
    <url>/202305101732/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="cmd-工具"><a href="#cmd-工具" class="headerlink" title="cmd 工具"></a>cmd 工具</h1><h2 id="ossutil-工具"><a href="#ossutil-工具" class="headerlink" title="ossutil 工具"></a>ossutil 工具</h2><p><a href="https://help.aliyun.com/document_detail/44075.html?spm=a2c4g.120052.0.0.3b587786PQJ64i">阿里云云存储 OSS 相关工具汇总</a></p>
<p><a href="https://help.aliyun.com/document_detail/50452.htm?spm=a2c4g.44075.0.0.20d17d73gZwhGF#concept-cnr-3d4-vdb">ossutil 概述、安装、配置、常用命令</a></p>
<h3 id="列出-oss-中的所有对象"><a href="#列出-oss-中的所有对象" class="headerlink" title="列出 oss 中的所有对象"></a>列出 oss 中的所有对象</h3><p>命令格式 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[列举账号级别下的资源](https://help.aliyun.com/document_detail/120052.htm?spm=a2c4g.50452.0.0.70267a47ABgZAh#concept-303804)
">[1]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./ossutil64 ls oss://bucketname[/prefix] [-s] [-d] [--limited-num] [--marker] [--include] [--exclude]  [--version-id-marker] [--all-versions]</span><br></pre></td></tr></table></figure>

<h1 id="CDN-加速域名配置缓存共享"><a href="#CDN-加速域名配置缓存共享" class="headerlink" title="CDN 加速域名配置缓存共享"></a>CDN 加速域名配置缓存共享</h1><p><a href="https://s.csms.tech/file/dogjois.pdf">CDN 加速域名配置缓存共享参考文档</a></p>
<h2 id="CDN-加速域名配置缓存共享验证方法"><a href="#CDN-加速域名配置缓存共享验证方法" class="headerlink" title="CDN 加速域名配置缓存共享验证方法"></a>CDN 加速域名配置缓存共享验证方法</h2><p>比如 A 域名使用 B 域名的共享缓存，测试的时候先访问一条 B 域名中的新资源，使用 B 域名查看对应的缓存状态响应头，第一次访问应该是 <code>X-Cache: MISS</code>，重新访问一次，应该变成 <code>X-Cache: HIT</code>。接下来使用 A 域名访问，如果首次访问结果即为 <code>HIT</code>，说明共享缓存配置成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -v -I B/test.png</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">User-Agent: curl/7.29.0</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Host: B</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Accept: */*</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">&lt; HTTP/1.1 200 OK</span></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">&lt; Server: Tengine</span><br><span class="line">Server: Tengine</span><br><span class="line">&lt; Content-Type: binary/octet-stream</span><br><span class="line">Content-Type: binary/octet-stream</span><br><span class="line">...</span><br><span class="line">&lt; X-Cache: MISS TCP_MISS dirn:-2:-2</span><br><span class="line">X-Cache: MISS TCP_MISS dirn:-2:-2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -v -I B/test.png</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">User-Agent: curl/7.29.0</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Host: B</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Accept: */*</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">&lt; HTTP/1.1 200 OK</span></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">&lt; Server: Tengine</span><br><span class="line">Server: Tengine</span><br><span class="line">&lt; Content-Type: binary/octet-stream</span><br><span class="line">Content-Type: binary/octet-stream</span><br><span class="line">...</span><br><span class="line">&lt; X-Cache: HIT TCP_MISS dirn:-2:-2</span><br><span class="line">X-Cache: HIT TCP_MISS dirn:-2:-2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -v -I A/test.png</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">User-Agent: curl/7.29.0</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Host: B</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Accept: */*</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">&lt; HTTP/1.1 200 OK</span></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">&lt; Server: Tengine</span><br><span class="line">Server: Tengine</span><br><span class="line">&lt; Content-Type: binary/octet-stream</span><br><span class="line">Content-Type: binary/octet-stream</span><br><span class="line">...</span><br><span class="line">&lt; X-Cache: HIT TCP_MISS dirn:-2:-2</span><br><span class="line">X-Cache: HIT TCP_MISS dirn:-2:-2</span><br></pre></td></tr></table></figure>

<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://help.aliyun.com/document_detail/120052.htm?spm=a2c4g.50452.0.0.70267a47ABgZAh#concept-303804">列举账号级别下的资源</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://help.aliyun.com/document_detail/31837.html">OSS Region和Endpoint对照表</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>云平台</category>
        <category>Aliyun</category>
      </categories>
      <tags>
        <tag>云平台</tag>
      </tags>
  </entry>
  <entry>
    <title>Alpine linux apk 命令使用</title>
    <url>/202210201436/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="更新索引"><a href="#更新索引" class="headerlink" title="更新索引"></a>更新索引</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">apk update</span></span><br><span class="line"></span><br><span class="line">fetch https://dl-cdn.alpinelinux.org/alpine/v3.14/main/x86_64/APKINDEX.tar.gz</span><br><span class="line">fetch https://dl-cdn.alpinelinux.org/alpine/v3.14/community/x86_64/APKINDEX.tar.gz</span><br><span class="line">fetch http://nl.alpinelinux.org/alpine/edge/main/x86_64/APKINDEX.tar.gz</span><br><span class="line">fetch http://nl.alpinelinux.org/alpine/edge/testing/x86_64/APKINDEX.tar.gz</span><br><span class="line">fetch http://nl.alpinelinux.org/alpine/edge/community/x86_64/APKINDEX.tar.gz</span><br><span class="line">v3.14.8-65-g0f3285f2cf [https://dl-cdn.alpinelinux.org/alpine/v3.14/main]</span><br><span class="line">v3.14.8-66-ge9853dea68 [https://dl-cdn.alpinelinux.org/alpine/v3.14/community]</span><br><span class="line">v20220809-6223-gb7f2956912 [http://nl.alpinelinux.org/alpine/edge/main]</span><br><span class="line">v20220809-6223-gb7f2956912 [http://nl.alpinelinux.org/alpine/edge/testing]</span><br><span class="line">v20220809-6223-gb7f2956912 [http://nl.alpinelinux.org/alpine/edge/community]</span><br><span class="line">OK: 38705 distinct packages available</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从远程镜像源中更新本地镜像源索引，<code>update</code> 命令会从各个镜像源列表下载 <code>APKINDEX.tar.gz</code> 并存储到本地缓存，一般在 <code>/var/cache/apk/</code> (Alpine 在该目录下)</p>
<span id="more"></span>

<h2 id="安装软件包"><a href="#安装软件包" class="headerlink" title="安装软件包"></a>安装软件包</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apk add vim openssh</span><br><span class="line"></span><br><span class="line">apk add --no-cache mysql-client</span><br><span class="line"></span><br><span class="line">apk add docker --update-cache \</span><br><span class="line">           --repository http://mirrors.ustc.edu.cn/alpine/v3.4/main/ --allow-untrusted</span><br></pre></td></tr></table></figure>

<p>安装指定版本软件包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apk add asterisk=1.6.0.21-r0</span><br><span class="line"></span><br><span class="line">apk add &#x27;asterisk&lt;1.6.1&#x27;</span><br><span class="line"></span><br><span class="line">apk add &#x27;asterisk&gt;1.6.1</span><br></pre></td></tr></table></figure>

<h2 id="卸载软件包"><a href="#卸载软件包" class="headerlink" title="卸载软件包"></a>卸载软件包</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apk del openssh openntp vim</span><br></pre></td></tr></table></figure>

<h2 id="搜索软件包"><a href="#搜索软件包" class="headerlink" title="搜索软件包"></a>搜索软件包</h2><p>搜索所有可用软件包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apk search</span><br><span class="line">apk search -v</span><br></pre></td></tr></table></figure>
<p>通过软件包名称搜索</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apk search -v &#x27;acf*&#x27;</span><br></pre></td></tr></table></figure>
<p>通过描述文件查找特定的软件包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apk search -v -d &#x27;docker&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="查看包信息"><a href="#查看包信息" class="headerlink" title="查看包信息"></a>查看包信息</h2><p>列出所有已安装的软件包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apk info </span><br></pre></td></tr></table></figure>
<p>显示完整的软件包信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apk info -a zlib</span><br></pre></td></tr></table></figure>
<p>显示指定文件属于的包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apk info --who-owns /sbin/lbu</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
        <category>Alpine</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Alpine</tag>
      </tags>
  </entry>
  <entry>
    <title>Apollo 配置中心服务使用说明</title>
    <url>/202211021332/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos 7 kernel 5.4</li>
<li>Apollo 2.0.1</li>
<li>Mysql 5.7</li>
<li>Java 1.8</li>
</ul>
<h1 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h1><h2 id="分布式部署"><a href="#分布式部署" class="headerlink" title="分布式部署"></a>分布式部署</h2><h3 id="部署服务器信息说明"><a href="#部署服务器信息说明" class="headerlink" title="部署服务器信息说明"></a>部署服务器信息说明</h3><table>
<thead>
<tr>
<th>环境</th>
<th>服务器</th>
<th>服务</th>
<th>端口</th>
</tr>
</thead>
<tbody><tr>
<td><code>pro</code></td>
<td>172.31.88.1</td>
<td>apollo-portal</td>
<td>8070</td>
</tr>
<tr>
<td><code>pro</code></td>
<td>172.31.88.1</td>
<td>数据库 ApolloPortalDB</td>
<td>3306</td>
</tr>
<tr>
<td><code>pro</code></td>
<td>172.31.88.1</td>
<td>apollo-configservice</td>
<td>8080</td>
</tr>
<tr>
<td><code>pro</code></td>
<td>172.31.88.1</td>
<td>apollo-adminservice</td>
<td>8090</td>
</tr>
<tr>
<td><code>pro</code></td>
<td>172.31.88.1</td>
<td>数据库ApolloConfigDB</td>
<td>3306</td>
</tr>
<tr>
<td><code>pro</code></td>
<td>172.31.82.2</td>
<td>apollo-configservice</td>
<td>8080</td>
</tr>
<tr>
<td><code>pro</code></td>
<td>172.31.82.2</td>
<td>apollo-adminservice</td>
<td>8090</td>
</tr>
<tr>
<td><code>uat</code></td>
<td>172.31.83.3</td>
<td>apollo-configservice</td>
<td>8080</td>
</tr>
<tr>
<td><code>uat</code></td>
<td>172.31.83.3</td>
<td>apollo-adminservice</td>
<td>8090</td>
</tr>
<tr>
<td><code>uat</code></td>
<td>172.31.83.3</td>
<td>数据库ApolloConfigDB</td>
<td>3306</td>
</tr>
</tbody></table>
<p>其中 <code>172.31.88.1</code>、<code>172.31.82.2</code> 为 <code>pro</code> 环境的高可用节点。<code>172.31.83.3</code> 为 <code>uat</code> 环境的单节点。</p>
<p><code>apollo-portal</code> 和 <code>ApolloPortalDB</code> 部署在 <code>pro</code> 环境，<code>uat</code> 环境共用 <code>apollo-portal</code> 和 <code>ApolloPortalDB</code>。</p>
<span id="more"></span>
<h3 id="安装-Java"><a href="#安装-Java" class="headerlink" title="安装 Java"></a>安装 Java</h3><p>在所有节点上安装 java-1.8.0</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y java-1.8.0-openjdk</span><br></pre></td></tr></table></figure>
<p>验证 java 安装成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java -version</span></span><br><span class="line">openjdk version &quot;1.8.0_352&quot;</span><br><span class="line">OpenJDK Runtime Environment (build 1.8.0_352-b08)</span><br><span class="line">OpenJDK 64-Bit Server VM (build 25.352-b08, mixed mode)</span><br></pre></td></tr></table></figure>

<h3 id="下载-Apollo-源码包"><a href="#下载-Apollo-源码包" class="headerlink" title="下载 Apollo 源码包"></a>下载 Apollo 源码包</h3><p><a href="https://github.com/apolloconfig/apollo/releases/tag/v2.0.1">下载地址</a>，<code>apollo-portal</code> 只需要在 portal 服务器下载，<code>apollo-adminservice</code> 和 <code>apollo-configservice</code> 需要在所有节点上下载<br><img src="https://i.csms.tech/img_79.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://github.com/apolloconfig/apollo/releases/download/v2.0.1/apollo-adminservice-2.0.1-github.zip </span><br><span class="line">wget https://github.com/apolloconfig/apollo/releases/download/v2.0.1/apollo-configservice-2.0.1-github.zip</span><br><span class="line">wget https://github.com/apolloconfig/apollo/releases/download/v2.0.1/apollo-portal-2.0.1-github.zip</span><br></pre></td></tr></table></figure>

<p>解压源码包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unzip apollo-adminservice-2.0.1-github.zip -d apollo-adminservice-2.0.1</span><br><span class="line">unzip apollo-configservice-2.0.1-github.zip -d apollo-configservice-2.0.1</span><br><span class="line">unzip apollo-portal-2.0.1-github.zip -d apollo-portal-2.0.1</span><br></pre></td></tr></table></figure>


<h3 id="准备数据库"><a href="#准备数据库" class="headerlink" title="准备数据库"></a>准备数据库</h3><p>Apollo 服务端共需要两个数据库：<code>ApolloPortalDB</code> 和 <code>ApolloConfigDB</code> <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[创建数据库](https://www.apolloconfig.com/#/zh/deployment/distributed-deployment-guide?id=_21-%e5%88%9b%e5%bb%ba%e6%95%b0%e6%8d%ae%e5%ba%93)">[1]</span></a></sup></p>
<p>需要注意的是 <code>ApolloPortalDB</code> 只需要在 <code>pro</code> 环境部署一个即可，而 <code>ApolloConfigDB</code> 需要在每个环境部署一套，如 <code>fat</code>、<code>uat</code> 和 <code>pro</code> 分别部署 3 套 <code>ApolloConfigDB</code>。</p>
<p>在 <code>pro</code> 环境的数据库服务器上下载 <code>apolloportaldb.sql</code> 并导入数据库 </p>
<p>在 <code>pro</code> 环境的数据库服务器上下载 <code>apolloconfigdb.sql</code> 并导入数据库 <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[apolloportaldb.sql](https://www.apolloconfig.com/#/zh/deployment/distributed-deployment-guide?id=_21-%e5%88%9b%e5%bb%ba%e6%95%b0%e6%8d%ae%e5%ba%93)
">[2]</span></a></sup></p>
<p>在 <code>uat</code> 环境的数据库服务器上下载 <code>apolloconfigdb.sql</code> 并导入数据库</p>
<p>调整 <code>ApolloPortalDB.ServerConfig</code> 表的数据，<code>portal</code> 默认支持的环境是 <code>DEV</code>，若需要支持其它环境，需要修改 <code>apollo.portal.envs</code> 的值，默认值是 <code>DEV</code>，修改为以下值，表示支持 <code>UAT</code>、<code>PRO</code><br><img src="https://i.csms.tech/img_80.png"></p>
<p>因为 <code>PRO</code> 环境有多个节点，需要调整 <code>PRO</code> 环境的数据库表 <code>ApolloConfigDB.ServerConfig</code>，修改 <code>eureka.service.url</code> 的值为当前 <code>PRO</code> 环境的 <code>apollo-configservice</code> 的地址和端口，注意多个地址之间用英文逗号隔开。<br><img src="https://i.csms.tech/img_81.png"><br><code>UAT</code> 环境只有一个节点，<code>eureka.service.url</code> 使用默认的 <code>localhost</code> 即可。 </p>
<h3 id="部署-Apollo"><a href="#部署-Apollo" class="headerlink" title="部署 Apollo"></a>部署 Apollo</h3><h4 id="部署-apollo-configservice"><a href="#部署-apollo-configservice" class="headerlink" title="部署 apollo-configservice"></a>部署 apollo-configservice</h4><h5 id="配置数据库连接"><a href="#配置数据库连接" class="headerlink" title="配置数据库连接"></a>配置数据库连接</h5><p>修改各节点上的 <code>apollo-configservice-2.0.1/config/application-github.properties</code> 文件，修改其中的数据库连接为当前环境的数据库信息。</p>
<figure class="highlight shell"><figcaption><span>apollo-configservice-2.0.1/config/application-github.properties</span></figcaption><table><tr><td class="code"><pre><span class="line">spring.datasource.url = jdbc:mysql://apollo.mysql:3306/ApolloConfigDB?characterEncoding=utf8</span><br><span class="line">spring.datasource.username = root</span><br><span class="line">spring.datasource.password = WayWb+5Pw==</span><br></pre></td></tr></table></figure>

<h5 id="启动-apollo-configservice"><a href="#启动-apollo-configservice" class="headerlink" title="启动 apollo-configservice"></a>启动 apollo-configservice</h5><p>默认的启动端口是 <code>8080</code>，若要修改，则将 <code>scripts/startup.sh</code> 中的 <code>SERVER_PORT=$&#123;SERVER_PORT:=8080&#125;</code> 的 <code>8080</code> 改成指定的端口即可。</p>
<p>执行 <code>scripts/startup.sh</code> 启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./scripts/startup.sh</span></span><br><span class="line">Thu Nov  3 09:56:08 CST 2022 ==== Starting ==== </span><br><span class="line">Application is running as root (UID 0). This is considered insecure.</span><br><span class="line">Started [22197]</span><br><span class="line">Waiting for server startup...</span><br><span class="line">Thu Nov  3 09:56:23 CST 2022 Server started in 15 seconds!</span><br></pre></td></tr></table></figure>

<p>启动之后检查端口 <code>8080</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">netstat -anutp | grep LIST</span></span><br><span class="line">tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN      612/rpcbind         </span><br><span class="line">tcp        0      0 0.0.0.0:30000           0.0.0.0:*               LISTEN      2595/sshd           </span><br><span class="line">tcp6       0      0 :::3306                 :::*                    LISTEN      21960/mysqld        </span><br><span class="line">tcp6       0      0 :::111                  :::*                    LISTEN      612/rpcbind         </span><br><span class="line">tcp6       0      0 :::8080                 :::*                    LISTEN      22197/java          </span><br><span class="line">tcp6       0      0 :::30000                :::*                    LISTEN      2595/sshd</span><br></pre></td></tr></table></figure>

<h4 id="部署-apollo-adminservice"><a href="#部署-apollo-adminservice" class="headerlink" title="部署 apollo-adminservice"></a>部署 apollo-adminservice</h4><h5 id="配置数据库连接-1"><a href="#配置数据库连接-1" class="headerlink" title="配置数据库连接"></a>配置数据库连接</h5><p>修改各节点上的 <code>apollo-adminservice-2.0.1/config/application-github.properties</code>，修改其中的数据库连接为当前环境的数据库信息。</p>
<figure class="highlight shell"><figcaption><span>apollo-adminservice-2.0.1/config/application-github.properties</span></figcaption><table><tr><td class="code"><pre><span class="line">spring.datasource.url = jdbc:mysql://apollo.mysql:3306/ApolloConfigDB?characterEncoding=utf8</span><br><span class="line">spring.datasource.username = root</span><br><span class="line">spring.datasource.password = 1roAYNg==</span><br></pre></td></tr></table></figure>
<h5 id="启动-apollo-adminservice"><a href="#启动-apollo-adminservice" class="headerlink" title="启动 apollo-adminservice"></a>启动 apollo-adminservice</h5><p>默认的启动端口是 <code>8090</code>，若要修改，则将 <code>scripts/startup.sh</code> 中的 <code>SERVER_PORT=$&#123;SERVER_PORT:=8090&#125;</code> 的 <code>8090</code> 改成指定的端口即可。</p>
<p>执行 <code>scripts/startup.sh</code> 启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./scripts/startup.sh</span></span><br><span class="line">Thu Nov  3 10:06:05 CST 2022 ==== Starting ==== </span><br><span class="line">Application is running as root (UID 0). This is considered insecure.</span><br><span class="line">Started [22818]</span><br><span class="line">Waiting for server startup...</span><br><span class="line">Thu Nov  3 10:06:21 CST 2022 Server started in 15 seconds!</span><br></pre></td></tr></table></figure>

<h4 id="部署-apollo-portal"><a href="#部署-apollo-portal" class="headerlink" title="部署 apollo-portal"></a>部署 apollo-portal</h4><h5 id="配置数据库连接-2"><a href="#配置数据库连接-2" class="headerlink" title="配置数据库连接"></a>配置数据库连接</h5><p>修改 <code>apollo-portal</code> 节点上的 <code>apollo-portal-2.0.1/config/application-github.properties</code>，修改其中的数据库连接为 <code>ApolloPortalDB</code> 的数据库信息。</p>
<figure class="highlight shell"><figcaption><span>apollo-portal-2.0.1/config/application-github.properties</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">DataSource</span></span><br><span class="line">spring.datasource.url = jdbc:mysql://pro.env.apollo.mysql:3306/ApolloPortalDB?characterEncoding=utf8</span><br><span class="line">spring.datasource.username = root</span><br><span class="line">spring.datasource.password = WayWwRDNEb+5Pw==</span><br></pre></td></tr></table></figure>

<h5 id="配置-meta-service-信息"><a href="#配置-meta-service-信息" class="headerlink" title="配置 meta service 信息"></a>配置 meta service 信息</h5><p><code>meta service</code> 的地址和端口，默认就是 <code>apollo-configservice</code> 的地址和端口。</p>
<p>修改 <code>apollo-portal-2.0.1/config/apollo-env.properties</code>，填写当前的 <code>apollo-portal</code> 要管理的环境的 <code>apollo-configservice</code> 的地址和端口，多个地址之间用英文逗号隔开</p>
<figure class="highlight shell"><figcaption><span>apollo-portal-2.0.1/config/apollo-env.properties</span></figcaption><table><tr><td class="code"><pre><span class="line">pro.meta=http://172.31.81.1:8080,http://172.31.82.2:8080</span><br><span class="line">uat.meta=http://172.31.83.3:8080</span><br></pre></td></tr></table></figure>

<h5 id="启动-apollo-portal"><a href="#启动-apollo-portal" class="headerlink" title="启动 apollo-portal"></a>启动 apollo-portal</h5><p>默认的启动端口是 <code>8070</code> ，若要修改，则将 <code>scripts/startup.sh</code> 中的 <code>SERVER_PORT=$&#123;SERVER_PORT:=8070&#125;</code> 的 <code>8070</code> 改成指定的端口即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./scripts/startup.sh</span> </span><br><span class="line">Thu Nov  3 10:23:32 CST 2022 ==== Starting ==== </span><br><span class="line">Application is running as root (UID 0). This is considered insecure.</span><br><span class="line">Started [23044]</span><br><span class="line">Waiting for server startup...</span><br><span class="line">Thu Nov  3 10:23:47 CST 2022 Server started in 15 seconds!</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="部署后检查是否成功"><a href="#部署后检查是否成功" class="headerlink" title="部署后检查是否成功"></a>部署后检查是否成功</h3><h4 id="apollo-configservice-和-apollo-adminservice-检查"><a href="#apollo-configservice-和-apollo-adminservice-检查" class="headerlink" title="apollo-configservice 和 apollo-adminservice 检查"></a>apollo-configservice 和 apollo-adminservice 检查</h4><ol>
<li><p>在浏览器上登录当前环境的其中一个 <code>apollo-configservice</code> 的 <code>http://ip:port</code></p>
</li>
<li><p>查看该环境的 <code>apollo-configservice</code> 和 <code>apollo-adminservice</code> 的节点数是否正常。<br> 比如 <code>PRO</code> 环境有 2 个节点，输出中正常情况下会显示 2 个正常的节点<br> <img src="https://i.csms.tech/img_82.png"></p>
</li>
</ol>
<h4 id="apollo-portal-检查"><a href="#apollo-portal-检查" class="headerlink" title="apollo-portal 检查"></a>apollo-portal 检查</h4><ol>
<li>浏览器登录 <code>apollo-portal</code> 的 <code>http://ip:port</code>，默认账号 <code>apollo</code>，密码 <code>admin</code>。</li>
</ol>
<h1 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h1><h2 id="修改默认管理员-apollo-的密码"><a href="#修改默认管理员-apollo-的密码" class="headerlink" title="修改默认管理员 apollo 的密码"></a>修改默认管理员 apollo 的密码</h2><p>默认管理员 <code>apollo</code> 的密码为 <code>admin</code>，要修改此密码，在 <code>管理员工具</code> -&gt; <code>用户管理</code> 中输入用户名和密码，如果用户已存在，更新用户信息，用户不存在，则创建新用户。</p>
<h2 id="创建部门"><a href="#创建部门" class="headerlink" title="创建部门"></a>创建部门</h2><p>只有管理员才能创建部门，在 <code>管理员工具</code> -&gt; <code>系统参数</code> 中查询 <code>organizations</code>，会输出当前的部门信息<br><img src="https://i.csms.tech/img_83.png"><br>修改此参数并保存，即可更新部门信息。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.apolloconfig.com/#/zh/design/apollo-introduction">Apollo 配置中心介绍</a></p>
<p><a href="https://blog.csdn.net/werewolf2017/article/details/109120336">Apollo分布式配置中心集群部署</a></p>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.apolloconfig.com/#/zh/deployment/distributed-deployment-guide?id=_21-%e5%88%9b%e5%bb%ba%e6%95%b0%e6%8d%ae%e5%ba%93">创建数据库</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.apolloconfig.com/#/zh/deployment/distributed-deployment-guide?id=_21-%e5%88%9b%e5%bb%ba%e6%95%b0%e6%8d%ae%e5%ba%93">apolloportaldb.sql</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Apollo</tag>
      </tags>
  </entry>
  <entry>
    <title>awk 使用示例</title>
    <url>/202208031132/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>awk 是一种编程语言，用于在linux&#x2F;unix下对文本和数据进行处理。数据可以来自标准输入(stdin)、一个或多个文件，或其它命令的输出。它支持用户自定义函数和动态正则表达式等先进功能，是linux&#x2F;unix下的一个强大编程工具。它在命令行中使用，但更多是作为脚本来使用。awk有很多内建的功能，比如数组、函数等，这是它和C语言的相同之处，灵活性是awk最大的优势。  </p>
<span id="more"></span>

<h3 id="awk-脚本基本结构"><a href="#awk-脚本基本结构" class="headerlink" title="awk 脚本基本结构"></a>awk 脚本基本结构</h3><p><code>awk &#39;BEGIN&#123; commands &#125; pattern&#123; commands &#125; END&#123; commands &#125;&#39;</code>  </p>
<p>一个awk脚本通常由：<strong>BEGIN语句块</strong>、<strong>能够使用模式匹配的通用语句块</strong>、<strong>END语句块</strong> 3部分组成，这三个部分是可选的。任意一个部分都可以不出现在脚本中，脚本通常是被放置在 <strong>单引号</strong> 中  </p>
<h3 id="awk-的工作原理"><a href="#awk-的工作原理" class="headerlink" title="awk 的工作原理"></a>awk 的工作原理</h3><ol>
<li>执行 <code>BEGIN&#123; commands &#125;</code> 语句块中的语句；  </li>
<li>从文件或标准输入(stdin)读取一行，然后执行 <code>pattern&#123; commands &#125;</code> 语句块，它逐行扫描文件，从第一行到最后一行重复这个过程，直到文件全部被读取完毕。  </li>
<li>当读至输入流末尾时，执行 <code>END&#123; commands &#125;</code> 语句块。</li>
</ol>
<p><code>BEGIN语句块</code> 在awk开始从输入流中读取行 <strong>之前</strong> 被执行，这是一个可选的语句块，比如变量初始化、打印输出表格的表头等语句通常可以写在BEGIN语句块中  </p>
<p><code>END语句块</code> 在awk从输入流中读取完所有的行 <strong>之后</strong> 即被执行，比如打印所有行的分析结果这类信息汇总都是在END语句块中完成，它也是一个可选语句块。  </p>
<p><code>pattern语句块</code> 中的通用命令是最重要的部分，它也是可选的。如果没有提供<code>pattern语句块</code>，则默认执行 <code>&#123; print &#125;</code>，即打印每一个读取到的行，<strong>awk读取的每一行都会执行该语句块</strong>。 </p>
<h3 id="awk-内置变量（预定义变量）"><a href="#awk-内置变量（预定义变量）" class="headerlink" title="awk 内置变量（预定义变量）"></a>awk 内置变量（预定义变量）</h3><table>
<thead>
<tr>
<th align="left">变量</th>
<th align="left">说明</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$0</td>
<td align="left">当前行的整行内容</td>
<td align="left"><code>&#39;&#123;print $0&#125;&#39;</code> 打印出当前处理行的整行内容</td>
</tr>
<tr>
<td align="left">$n</td>
<td align="left">当前记录（行）的第n个字段</td>
<td align="left"><code>&#39;&#123;print $1&#125;&#39;</code> 打印出当前行的第1个字段</td>
</tr>
<tr>
<td align="left">NR</td>
<td align="left">当前处理行的行号（第多少行）</td>
<td align="left"><code>&#39;&#123;print NR,$1&#125;&#39; END&#123;print NR&#125;</code> 打印出当前处理行的行号和第1列，最后打印出总的行号</td>
</tr>
<tr>
<td align="left">FNR</td>
<td align="left">当前处理行在当前处理文件中的行号，只有1个输入文件时，NR&#x3D;FNR</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">NF</td>
<td align="left">当前行的字段数</td>
<td align="left"><code>&#39;&#123;print NF,$NF,$(NF-1)&#125;&#39;</code>  输出当前行的字段数，最后一个字段 ,倒数第2个字段</td>
</tr>
<tr>
<td align="left">FILENAME</td>
<td align="left">当前输入文件的文件名，<code>-</code>表示stdin</td>
<td align="left"><code>&#39;&#123;print FILENAME,FNR&#125;&#39;</code> 打印当前处理的文件名及当前行号</td>
</tr>
<tr>
<td align="left">FS</td>
<td align="left">输入字段分隔符，等同于选项 <code>-F</code> ,默认为空格</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">OFS</td>
<td align="left">输出字段的分隔符，默认为空格</td>
<td align="left"><code>&#39;BEGIN&#123;OFS=&quot;|&quot;&#125; &#123;print FILENAME,FS,NR,NF,$2,$NF&#125;&#39;</code> 输出结果将会以 <code>|</code> 分割</td>
</tr>
<tr>
<td align="left">RS</td>
<td align="left">输入记录分隔符（行分隔符），默认为换行</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">ORS</td>
<td align="left">输出记录分隔符（行分隔符），默认为换行</td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="awk-常用选项"><a href="#awk-常用选项" class="headerlink" title="awk 常用选项"></a>awk 常用选项</h3><table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>-F&quot;sep&quot;</code><br/><code>-F&quot;[,.]&quot;</code></td>
<td>等同于内置变量 <code>FS</code>，有2种格式：<br/><code>-F&quot;sep&quot;</code> 使用 <code>sep</code> 整体作为字段分隔符<br/> <code>-F[,.]</code>  <code>[]</code>其中的每个字符都可以作为分隔符<br/>等同于<code>BEGIN</code>预定义变量<code>FS</code></td>
<td></td>
</tr>
<tr>
<td><code>-v var=1</code></td>
<td>传递用户自定义变量给awk</td>
<td><code>awk -va=1 -vb=2 &#39;&#123;print a+b&#125;&#39;</code></td>
</tr>
</tbody></table>
<h3 id="awk-常用运算符"><a href="#awk-常用运算符" class="headerlink" title="awk 常用运算符"></a>awk 常用运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;<br/>+&#x3D;<br/> -&#x3D;<br/> *&#x3D;<br/> &#x2F;&#x3D;<br/> %&#x3D;<br/> ^&#x3D;<br/> **&#x3D;</td>
<td>赋值</td>
<td></td>
</tr>
<tr>
<td><code>~</code><br/><code>!~</code></td>
<td>匹配正则表达式<br/>不匹配正则表达式</td>
<td><code>awk &#39;$2 ~ /th/ &#123;print $2,$4&#125;&#39; log.txt</code> 第2列中包含’th’，则输出第2,4列<br/><code>awk &#39;BEGIN&#123;IGNORECASE=1&#125; /this/&#39; log.txt</code>    忽略大小写匹配 <br/><code>awk &#39;$2 !~ /th/ &#123;print $2,$4&#125;&#39; log.txt</code> 不匹配正则表达式</td>
</tr>
<tr>
<td>&lt; <br/>&lt;&#x3D;<br/> &gt;<br/> &gt;&#x3D;<br/> !&#x3D; <br/>&#x3D;&#x3D;</td>
<td>关系运算符</td>
<td><code>awk &#39;$1&gt;2&#39; log.txt</code>  第1列的值大于2，输出整行<br/><code>awk &#39;$1==2 &#123;print $1,$3&#125;&#39; log.txt</code> 第1列的值等于2，则输出第1,3列</td>
</tr>
<tr>
<td>+<br/>-<br/>*<br/>&#x2F;<br/>%<br/></td>
<td>加，减，乘，除与求余</td>
<td></td>
</tr>
<tr>
<td>+ <br/>- <br/>!</td>
<td>一元加，减和逻辑非</td>
<td></td>
</tr>
<tr>
<td>| |</td>
<td>逻辑或</td>
<td></td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>逻辑与</td>
<td><code>awk &#39;$1&gt;2 &amp;&amp; $2==&quot;Are&quot; &#123;print $1,$2,$3&#125;&#39; log.txt </code>  第1列大于2，并且第2列等于”Are”,则输出第1,2,3列</td>
</tr>
</tbody></table>
<h3 id="awk-常用用法示例"><a href="#awk-常用用法示例" class="headerlink" title="awk 常用用法示例"></a>awk 常用用法示例</h3><h4 id="每一行中第个字段值累加"><a href="#每一行中第个字段值累加" class="headerlink" title="每一行中第个字段值累加"></a>每一行中第个字段值累加</h4><figure class="highlight shell"><figcaption><span>awk</span></figcaption><table><tr><td class="code"><pre><span class="line">seq 1 10 | awk &#x27;BEGIN&#123;sum=0;print &quot;第1列求和&quot;&#125;&#123;sum+=$1&#125;END&#123;print &quot;sum=&quot;sum&#125;&#x27;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第1列求和<br>sum&#x3D;55</p>
</blockquote>
<h4 id="判断2列的内容是否相同"><a href="#判断2列的内容是否相同" class="headerlink" title="判断2列的内容是否相同"></a>判断2列的内容是否相同</h4><figure class="highlight shell"><figcaption><span>awk</span></figcaption><table><tr><td class="code"><pre><span class="line">awk &#x27;&#123;if($1==$2)&#123;print $1&#125;&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="找出字段数-列数-大于3的行"><a href="#找出字段数-列数-大于3的行" class="headerlink" title="找出字段数(列数)大于3的行"></a>找出字段数(列数)大于3的行</h4><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;NF&gt;3&#123;print $0&#125;&#x27;</span> </span><br></pre></td></tr></table></figure>

<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://wangchujiang.com/linux-command/c/awk.html">参考文章</a></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>awk</tag>
      </tags>
  </entry>
  <entry>
    <title>aws cli 命令用法</title>
    <url>/202301171752/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>aws-cli&#x2F;2.9.15</li>
</ul>
<p><a href="https://docs.aws.amazon.com/zh_cn/cli/latest/userguide/getting-started-install.html">aws cli 安装更新说明</a></p>
<p><a href="https://docs.aws.amazon.com/zh_cn/cli/latest/userguide/cli-configure-quickstart.html">aws cli 基础配置及说明</a></p>
<h1 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h1><p>查看 <code>aws</code> 帮助信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">aws help</span><br></pre></td></tr></table></figure>
<p>查看子命令帮助信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">aws ec2 help</span><br></pre></td></tr></table></figure>

<p><code>aws</code> 命令常用选项</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>--region</code></td>
<td>指定区域，<a href="https://docs.aws.amazon.com/zh_cn/general/latest/gr/rande.html">aws 区域列表</a></td>
<td><code>aws --region ap-east-1 ec2 describe-instances</code></td>
</tr>
</tbody></table>
<span id="more"></span>
<h2 id="EC2"><a href="#EC2" class="headerlink" title="EC2"></a>EC2</h2><h3 id="获取实例信息"><a href="#获取实例信息" class="headerlink" title="获取实例信息"></a>获取实例信息</h3><p>此操作至少需要以下权限：</p>
<ul>
<li><code>EC2.DescribeInstances</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">aws --region ap-east-1 ec2 describe-instances</span><br></pre></td></tr></table></figure>

<p>筛选输出，只获取 <code>instance-id</code>，使用 <code>--query</code> 选项可能造成部分机器无法被包含在输出中，导致统计机器缺失，最好使用 <code>aws --region ap-east-1 ec2 describe-instances</code> 获取指定区域的所有机器后手动进行筛选。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">aws ec2 describe-instances --region ap-east-1 --query Reservations[*].Instances[*].InstanceId --output text</span><br></pre></td></tr></table></figure>

<p>通过选项 <code>--query</code> 可以对输出进行筛选，只输出指定内容。<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[aws cli 输出结果筛选](https://docs.aws.amazon.com/zh_cn/cli/latest/userguide/cli-usage-filter.html)">[2]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">aws ec2 describe-instances --region ap-east-1 \</span></span><br><span class="line"><span class="language-bash">        --query Reservations[*].Instances[*].[InstanceId,InstanceType,KeyName,PublicIpAddress] --output text</span></span><br><span class="line">i-0904c5ba08     c5.large        t1  16.162.77.1</span><br><span class="line">i-09f7765e86     c5.large        t2  16.162.181.4</span><br><span class="line">i-0bc892a5b0     c5.xlarge       t3  16.162.229.5 </span><br></pre></td></tr></table></figure>

<p>通过选项 <code>--query</code> 获取实例 Name</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">aws ec2 describe-instances --region ap-east-1 \</span></span><br><span class="line"><span class="language-bash">             --query Reservations[*].Instances[*].[InstanceId,Tags[*],PublicIpAddress,BlockDeviceMappings[*].Ebs.VolumeId][0] --output json</span></span><br><span class="line">             </span><br><span class="line">[</span><br><span class="line">    [</span><br><span class="line">        &quot;i-0904c5ba087f0b07c&quot;,</span><br><span class="line">        [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Key&quot;: &quot;name&quot;,</span><br><span class="line">                &quot;Value&quot;: &quot;t1&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Key&quot;: &quot;Name&quot;,</span><br><span class="line">                &quot;Value&quot;: &quot;test1&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;16.162.77.243&quot;,</span><br><span class="line">        [</span><br><span class="line">            &quot;vol-05940c72f51db924c&quot;</span><br><span class="line">        ]</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        &quot;i-09f7765e863bbc0f0&quot;,</span><br><span class="line">        [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Key&quot;: &quot;Name&quot;,</span><br><span class="line">                &quot;Value&quot;: &quot;t2&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Key&quot;: &quot;luodiye1&quot;,</span><br><span class="line">                &quot;Value&quot;: &quot;test2&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;16.162.181.48&quot;,</span><br><span class="line">        [</span><br><span class="line">            &quot;vol-09ac77986ac07cbfb&quot;</span><br><span class="line">        ]</span><br><span class="line">    ],</span><br><span class="line">]         </span><br></pre></td></tr></table></figure>

<h3 id="获取-EC2-实例的存储-Volume-信息"><a href="#获取-EC2-实例的存储-Volume-信息" class="headerlink" title="获取 EC2 实例的存储 (Volume) 信息"></a>获取 EC2 实例的存储 (Volume) 信息</h3><p>此操作至少需要以下权限：</p>
<ul>
<li><code>EC2.DescribeInstances</code></li>
<li><code>EC2.DescribeVolumes</code></li>
</ul>
<p>根据已知的 <code>volume-id</code>，查询卷的详细信息，比如磁盘类型和大小</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">aws ec2 describe-volumes --region ap-east-1 \</span></span><br><span class="line"><span class="language-bash">          --volume-ids vol-03f727ba5534b23f1 \</span></span><br><span class="line"><span class="language-bash">          --query Volumes[*].[VolumeType,Size] --output text</span></span><br><span class="line">gp2     500</span><br></pre></td></tr></table></figure>
<h2 id="cloudwatch"><a href="#cloudwatch" class="headerlink" title="cloudwatch"></a>cloudwatch</h2><h3 id="获取指定实例的网卡流出流量"><a href="#获取指定实例的网卡流出流量" class="headerlink" title="获取指定实例的网卡流出流量"></a>获取指定实例的网卡流出流量</h3><p>此操作至少需要以下权限：</p>
<ul>
<li><code>Cloudwatch.CloudWatchReadOnlyAccess</code></li>
<li><code>EC2.DescribeInstances</code></li>
</ul>
<p>通过 cloudwatch 获取 ec2 实例的监控数据 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[aws cloudwatch 命令说明](https://awscli.amazonaws.com/v2/documentation/api/latest/reference/cloudwatch/get-metric-statistics.html)">[1]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">aws cloudwatch get-metric-statistics</span> </span><br><span class="line">               --metric-name NetworkOut \</span><br><span class="line">               --start-time &quot;2023-01-01T00:00:00.000Z&quot; \</span><br><span class="line">               --end-time &quot;2023-01-10T00:00:00.000Z&quot; \</span><br><span class="line">               --period 86400 \</span><br><span class="line">               --namespace AWS/EC2 \</span><br><span class="line">               --statistics Sum \</span><br><span class="line">               --dimensions Name=InstanceId,Value=i-0904c5ba087f0b07c \</span><br><span class="line">               --region ap-east-1 --output text</span><br><span class="line">NetworkOut</span><br><span class="line">DATAPOINTS      4437779515.0    2023-01-05T00:00:00+00:00       Bytes</span><br><span class="line">DATAPOINTS      4289284683.0    2023-01-08T00:00:00+00:00       Bytes</span><br><span class="line">DATAPOINTS      4771646359.0    2023-01-01T00:00:00+00:00       Bytes</span><br><span class="line">DATAPOINTS      4634477427.0    2023-01-04T00:00:00+00:00       Bytes</span><br><span class="line">DATAPOINTS      4794193904.0    2023-01-07T00:00:00+00:00       Bytes</span><br><span class="line">DATAPOINTS      4403050407.0    2023-01-03T00:00:00+00:00       Bytes</span><br><span class="line">DATAPOINTS      4802329953.0    2023-01-06T00:00:00+00:00       Bytes</span><br><span class="line">DATAPOINTS      4527451078.0    2023-01-09T00:00:00+00:00       Bytes</span><br><span class="line">DATAPOINTS      4179191429.0    2023-01-02T00:00:00+00:00       Bytes</span><br></pre></td></tr></table></figure>

<h3 id="获取-cloudFront-CDN-域名的流量信息"><a href="#获取-cloudFront-CDN-域名的流量信息" class="headerlink" title="获取 cloudFront (CDN) 域名的流量信息"></a>获取 cloudFront (CDN) 域名的流量信息</h3><p>此操作至少需要以下权限：</p>
<ul>
<li><code>Cloudwatch.CloudWatchReadOnlyAccess</code></li>
<li><code>CloudFrontReadOnlyAccess</code></li>
</ul>
<p>通过以下命令列出所有的 <code>distributions</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">aws cloudfront list-distributions</span><br></pre></td></tr></table></figure>

<p>通过以下命令可查询指定的 CloudFront 中的 distribution 的流量统计信息，区域必须使用美国东部（弗吉尼亚北部）区域 (<code>us-east-1</code>)，<code>--dimensions Name=DistributionId,Value=E5MHZ8YUS8CUR Name=Region,Value=Global</code> 中同时需要指定 CloudFront 的 Region 为 <code>Global</code> <sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[使用 CloudWatch API 获取指标](https://docs.aws.amazon.com/zh_cn/AmazonCloudFront/latest/DeveloperGuide/programming-cloudwatch-metrics.html)">[3]</span></a></sup> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">aws cloudwatch get-metric-statistics --region us-east-1 --metric-name BytesDownloaded \</span></span><br><span class="line"><span class="language-bash">                                       --start-time 2023-01-01T00:00:00.000Z --end-time 2023-01-31T23:59:59.000Z --period 86400 \</span></span><br><span class="line"><span class="language-bash">                                       --namespace AWS/CloudFront --statistics Sum \ </span></span><br><span class="line">                                       --dimensions Name=DistributionId,Value=E5MHZ8YUS8CUR Name=Region,Value=Global \</span><br><span class="line">                                       --output json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;Label&quot;: &quot;BytesDownloaded&quot;,</span><br><span class="line">    &quot;Datapoints&quot;: []</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="s3"><a href="#s3" class="headerlink" title="s3"></a>s3</h2><p>查看 s3 命令用法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">aws s3 <span class="built_in">help</span></span></span><br></pre></td></tr></table></figure>

<h3 id="不同区域的桶之间同步数据"><a href="#不同区域的桶之间同步数据" class="headerlink" title="不同区域的桶之间同步数据"></a>不同区域的桶之间同步数据</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">aws s3 <span class="built_in">sync</span> --source-region ap-southeast-1 --region us-west-1 s3://my-bucket1 s3://my-bucket</span></span><br></pre></td></tr></table></figure>

<h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><h2 id="Errno-2-No-such-file-or-directory-‘less’"><a href="#Errno-2-No-such-file-or-directory-‘less’" class="headerlink" title="[Errno 2] No such file or directory: ‘less’"></a>[Errno 2] No such file or directory: ‘less’</h2><p>使用命令报错：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">aws --region ap-east-1 ec2 describe-instances</span></span><br><span class="line"></span><br><span class="line">Unable to redirect output to pager. Received the following error when opening pager:</span><br><span class="line">[Errno 2] No such file or directory: &#x27;less&#x27;</span><br><span class="line"></span><br><span class="line">Learn more about configuring the output pager by running &quot;aws help config-vars&quot;.</span><br></pre></td></tr></table></figure>
<p><strong>错误原因</strong>:</p>
<p>系统未安装 <code>less</code> 命令，安装 <code>less</code> 命令 (<code>yum install -y less</code>) 后正常。</p>
<h2 id="An-error-occurred-InvalidClientTokenId-when-calling-the-GetMetricStatistics-operation-The-security-token-included-in-the-request-is-invalid"><a href="#An-error-occurred-InvalidClientTokenId-when-calling-the-GetMetricStatistics-operation-The-security-token-included-in-the-request-is-invalid" class="headerlink" title="An error occurred (InvalidClientTokenId) when calling the GetMetricStatistics operation: The security token included in the request is invalid."></a>An error occurred (InvalidClientTokenId) when calling the GetMetricStatistics operation: The security token included in the request is invalid.</h2><p>使用命令报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">aws cloudwatch get-metric-statistics --metric-name Requests --start-time <span class="string">&#x27;2022-12-01T00:00:00.000Z&#x27;</span> --end-time <span class="string">&#x27;2022-12-31T23:59:59.000Z&#x27;</span> --period 2678400 \</span></span><br><span class="line"><span class="language-bash">                                       --namespace AWS/CloudFront --statistics Sum --dimensions Name=DistributionId,Value=E15 --output json</span></span><br><span class="line">                                       </span><br><span class="line">An error occurred (InvalidClientTokenId) when calling the GetMetricStatistics operation: The security token included in the request is invalid.                           </span><br></pre></td></tr></table></figure>
<p><strong>错误原因</strong></p>
<p>通过 CloudWatch 调用 CloudFront 的统计数据时，区域必须指定为 <code>美国东部（弗吉尼亚北部）区域 (us-east-1)</code>，使用选项 <code>--region us-east-1</code></p>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://awscli.amazonaws.com/v2/documentation/api/latest/reference/cloudwatch/get-metric-statistics.html">aws cloudwatch 命令说明</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://docs.aws.amazon.com/zh_cn/cli/latest/userguide/cli-usage-filter.html">aws cli 输出结果筛选</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://docs.aws.amazon.com/zh_cn/AmazonCloudFront/latest/DeveloperGuide/programming-cloudwatch-metrics.html">使用 CloudWatch API 获取指标</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>云平台</category>
        <category>Aws</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Aws</tag>
      </tags>
  </entry>
  <entry>
    <title>aws python sdk 常用操作</title>
    <url>/202207251345/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>centos 7</li>
<li>Python3.10</li>
<li>boto3 1.23.2 <blockquote>
<p>(<code>pip3 install boto3</code>)</p>
</blockquote>
</li>
</ul>
<span id="more"></span>

<h1 id="S3-相关操作"><a href="#S3-相关操作" class="headerlink" title="S3 相关操作"></a>S3 相关操作</h1><h2 id="获取-s3-中文件大小"><a href="#获取-s3-中文件大小" class="headerlink" title="获取 s3 中文件大小"></a>获取 s3 中文件大小</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> boto3.session <span class="keyword">import</span> Session</span><br><span class="line"></span><br><span class="line">ak = <span class="string">&#x27;XXXXXXX&#x27;</span></span><br><span class="line">sk = <span class="string">&#x27;XXXXXXXXXX&#x27;</span></span><br><span class="line">region = <span class="string">&#x27;us-west-1&#x27;</span></span><br><span class="line">bucketName = <span class="string">&#x27;testBucket&#x27;</span></span><br><span class="line"></span><br><span class="line">session = Session(aws_access_key_id=ak, aws_secret_access_key=sk, region_name=region)</span><br><span class="line">s3 = session.resource(<span class="string">&#x27;s3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">bucket = s3.Bucket(bucketName)</span><br><span class="line">obj = bucket.objects.<span class="built_in">filter</span>(Prefix=<span class="string">&#x27;filename&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> obj:</span><br><span class="line">    <span class="keyword">if</span> i.size:</span><br><span class="line">        <span class="keyword">return</span> i.size</span><br></pre></td></tr></table></figure>

<h1 id="EC2-相关操作"><a href="#EC2-相关操作" class="headerlink" title="EC2 相关操作"></a>EC2 相关操作</h1><h2 id="获取-EC2-instances"><a href="#获取-EC2-instances" class="headerlink" title="获取 EC2 instances"></a>获取 EC2 instances</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">import boto3</span><br><span class="line"></span><br><span class="line">client = boto3.client(&#x27;ec2&#x27;,region_name=&#x27;ap-east-1&#x27;,aws_access_key_id=&#x27;AK&#x27;,aws_secret_access_key=&#x27;ty&#x27;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出所有 Instances</span></span><br><span class="line">client.describe_instances()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>云平台</category>
        <category>Aws</category>
      </categories>
      <tags>
        <tag>云平台</tag>
        <tag>Aws</tag>
      </tags>
  </entry>
  <entry>
    <title>aws 云平台常见操作</title>
    <url>/202302230924/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="S3"><a href="#S3" class="headerlink" title="S3"></a>S3</h1><h2 id="s3-配置跨域"><a href="#s3-配置跨域" class="headerlink" title="s3 配置跨域"></a>s3 配置跨域</h2><p>当使用 aws 的 cloudfront 或其他第三方 cdn （如 cdn77）为域名加速，资源是回源到 aws s3 的情况下，一般都需要配置 <strong>允许跨域</strong>，此种情况需要在 aws s3 存储桶中配置允许跨域 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[CORS 配置](https://docs.aws.amazon.com/zh_cn/AmazonS3/latest/userguide/ManageCorsUsing.html#cors-example-1)">[1]</span></a></sup></p>
<p>配置步骤如下：</p>
<ol>
<li><p>定位到目标 s3 桶，进入 <code>权限</code> 管理页面</p>
</li>
<li><p>找到 <code>CORS</code> 配置，配置以下 JSON 格式内容，允许所有源的跨域</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line"> &#123;</span><br><span class="line">     &quot;AllowedHeaders&quot;: [</span><br><span class="line">         &quot;*&quot;</span><br><span class="line">     ],</span><br><span class="line">     &quot;AllowedMethods&quot;: [</span><br><span class="line">         &quot;POST&quot;,</span><br><span class="line">         &quot;GET&quot;</span><br><span class="line">     ],</span><br><span class="line">     &quot;AllowedOrigins&quot;: [</span><br><span class="line">         &quot;*&quot;</span><br><span class="line">     ],</span><br><span class="line">     &quot;ExposeHeaders&quot;: []</span><br><span class="line"> &#125;</span><br><span class="line"> ]</span><br></pre></td></tr></table></figure>
<p> <img src="https://i.csms.tech/img_126.png"></p>
</li>
<li><p>Cloudfront 中，回源到此 S3 的加速域名配置中，<code>行为</code> 按照下图配置，主要为开启 <code>OPTIONS</code> 缓存，并在响应标头策略中选择： <code>CORS-with-preflight-and-SecurityHeadersPolicy</code> <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[将 CloudFront 配置为遵守 CORS 设置](https://docs.aws.amazon.com/zh_cn/AmazonCloudFront/latest/DeveloperGuide/header-caching.html#header-caching-web-cors)">[2]</span></a></sup><br><img src="https://i.csms.tech/img_127.png"><br>此配置为可选配置，可以解决客户端偶尔会遇到的因跨域问题而导致的资源获取失败问题。</p>
<span id="more"></span></li>
</ol>
<h2 id="存储桶同步数据"><a href="#存储桶同步数据" class="headerlink" title="存储桶同步数据"></a>存储桶同步数据</h2><p><a href="https://www.amazonaws.cn/solutions/data-transfer-hub/?nc1=h_ls">Data Transfer Hub 数据在线传输解决方案</a> 。</p>
<ol>
<li>海外账号选择 <a href="https://us-east-1.console.aws.amazon.com/cloudformation/home?region=us-east-1#/stacks/create/template?stackName=DataTransferHub&templateURL=https://solutions-reference.s3.amazonaws.com/data-transfer-hub/latest/DataTransferHub-cognito.template"><code>从亚马逊云科技海外区域控制台中启动方案</code></a></li>
<li>弹出页面中点击下一步，在 <code>指定堆栈详细信息</code> 页面配置 <code>堆栈名称</code> 以及 <code>AdminEmail</code>（<strong>后面登陆 Potal 需要发送到邮箱的初始密码，要确保邮箱可登录</strong>）<br> <img src="https://i.csms.tech/img_149.png"></li>
<li>后面步骤使用默认选项，一直下一步，直到点击 <code>提交</code></li>
<li>等待 5-10 分钟后，全部资源创建完成，点击刚刚创建的堆栈的  <code>输出</code> 页面，其中有 <code>数据在线传输</code> 配置的 Potal 链接(<code>PortalUrl</code>)，点击此 url，使用堆栈配置的邮箱中的密码登陆，第一次登陆后需要改密码。<br> <img src="https://i.csms.tech/img_150.png"></li>
<li>登陆后，创建迁移任务。任务创建并运行后，可以在监控页面看到迁移时的相关监控数据</li>
</ol>
<blockquote>
<p>如果同步目标存储桶中的数据量太大，建议关闭 <code>是否需要数据比对</code> 选项，开启此选项，执行真正的数据同步前，需要完成对目标存储桶中数据的扫描，数据量越大，耗时越久</p>
<p><img src="https://i.csms.tech/img_151.png"><br>此同步工具会产生费用</p>
</blockquote>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://docs.aws.amazon.com/zh_cn/AmazonS3/latest/userguide/ManageCorsUsing.html#cors-example-1">CORS 配置</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://docs.aws.amazon.com/zh_cn/AmazonCloudFront/latest/DeveloperGuide/header-caching.html#header-caching-web-cors">将 CloudFront 配置为遵守 CORS 设置</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>云平台</category>
        <category>Aws</category>
      </categories>
      <tags>
        <tag>Aws</tag>
      </tags>
  </entry>
  <entry>
    <title>Awvs 破解版14.6.211213163 安装破解</title>
    <url>/2207221019/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Acunetix Web Vulnerability Scanner（简称AWVS）是一款知名的网络漏洞扫描工具，它通过网络爬虫测试你的网站安全，检测流行安全漏洞。  </p>
<span id="more"></span>

<h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Windows Server 2016 Datacenter</li>
<li>14.6.211213163</li>
</ul>
<h3 id="AWVS-安装激活"><a href="#AWVS-安装激活" class="headerlink" title="AWVS 安装激活"></a>AWVS 安装激活</h3><p>官方版本需要License才能下载，可通过如下链接下载破解版及补丁<br><a href="https://yzzpan.com/#sharefile=Nh2pQnaW_22930">www.ddosi.org下载入口</a><br><a href="https://yzzpan.com/#sharefile=DXt5k9dh_22034">www.ddosi.org破解工具下载入口</a></p>
<blockquote>
<p>解压密码均为: <a href="http://www.ddosi.org/">www.ddosi.org</a></p>
</blockquote>
<p><a href="https://s.csms.tech/file/acunetix_14.6.211213163.exe.rar">其他下载地址</a><br><a href="https://s.csms.tech/file/awvs_crack.rar">其他下载地址-破解工具</a> </p>
<p>下载后，双击文件 <code>acunetix_14.6.211213163.exe</code> 进行安装，按照提示，一直点击<code>下一步</code>，直到安装完成。<br>安装完成，打开登录后，处于未激活状态，显示如下图：<br><img src="https://i.csms.tech/img_14.png">  </p>
<p>复制 <code>awvs_crack</code> 目录下的文件 <code>license_info.json</code> 和 <code>wa_data.dat</code> </p>
<p><img src="https://i.csms.tech/img_15.png"> </p>
<p>覆盖目录 <code>C:\ProgramData\Acunetix\shared\license</code> 下的文件</p>
<p>修改hosts文件(<code>C:\Windows\System32\drivers\etc</code>), 添加以下内容：</p>
<figure class="highlight plaintext"><figcaption><span>C:\Windows\System32\drivers\etc</span></figcaption><table><tr><td class="code"><pre><span class="line">127.0.0.1 updates.acunetix.com</span><br><span class="line">127.0.0.1 erp.acunetix.com</span><br></pre></td></tr></table></figure>

<p>返回页面刷新，即可激活成功<br><img src="https://i.csms.tech/img_16.png"> </p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.ddosi.org/awvs-14-6/">Awvs破解版14.6.211213163|可扫Log4j RCE漏洞</a><br><a href="https://www.ddosi.org/awvs-14-5-2/">Awvs破解版14.5.211115146 Windows+Linux+Mac cracked</a></p>
]]></content>
      <categories>
        <category>安全</category>
        <category>Awvs</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>Awvs</tag>
        <tag>Acunetix</tag>
      </tags>
  </entry>
  <entry>
    <title>cdn77 api 使用</title>
    <url>/202302011016/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文档示例使用 Python3 调用 CDN77 API 的常用方法，CDN77 目前未提供 SDK，只有 REST API。 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[CDN77 api 官网说明文档](https://client.cdn77.com/support/api-reference/v3/introduction)">[1]</span></a></sup></p>
<h1 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h1><h2 id="创建调用-API-时需要的-API-Token"><a href="#创建调用-API-时需要的-API-Token" class="headerlink" title="创建调用 API 时需要的 API Token"></a>创建调用 API 时需要的 API Token</h2><p><a href="https://client.cdn77.com/support/api-reference/v3/introduction">参考文档创建 API Token</a></p>
<h2 id="读取-CDN-resources-列表"><a href="#读取-CDN-resources-列表" class="headerlink" title="读取 CDN resources 列表"></a>读取 CDN resources 列表</h2><figure class="highlight shell"><figcaption><span>python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; api_token = <span class="string">&#x27;sliJJYTUikbdg9798384Kbbj0kj&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; r = requests.get(<span class="string">&#x27;https://api.cdn77.com/v3/cdn&#x27;</span>, headers=&#123;<span class="string">&#x27;Authorization&#x27;</span>: f<span class="string">&#x27;Bearer &#123;api_token&#125;&#x27;</span>&#125;)</span></span><br></pre></td></tr></table></figure>

<h2 id="根据-cdn-resource-id-获取流量统计数据"><a href="#根据-cdn-resource-id-获取流量统计数据" class="headerlink" title="根据 cdn resource id 获取流量统计数据"></a>根据 cdn resource id 获取流量统计数据</h2><figure class="highlight shell"><figcaption><span>python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; url = <span class="string">&#x27;https://api.cdn77.com/v3/stats/cdns/traffic&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; headers = &#123;<span class="string">&#x27;Authorization&#x27;</span>: f<span class="string">&#x27;Bearer &#123;api_token&#125;&#x27;</span>&#125;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; data = json.dumps(&#123;<span class="string">&quot;cdn_ids&quot;</span>: [1991249093], <span class="string">&quot;aggregation&quot;</span>: <span class="string">&quot;1-month&quot;</span>, <span class="string">&quot;from&quot;</span>: 1669824000, <span class="string">&quot;to&quot;</span>: 1672502400&#125;)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; r = requests.post(url, headers=headers, data=data)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; r.json()</span></span><br><span class="line">&#123;&#x27;1991249093&#x27;: &#123;&#x27;1667260800&#x27;: &#123;&#x27;sizeCached&#x27;: 83745364388, &#x27;sizeNonCached&#x27;: 899336049&#125;, &#x27;1669852800&#x27;: &#123;&#x27;sizeCached&#x27;: 76503199334, &#x27;sizeNonCached&#x27;: 758547845&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>


<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://client.cdn77.com/support/api-reference/v3/introduction">CDN77 api 官网说明文档</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>云平台</category>
        <category>cdn77</category>
      </categories>
      <tags>
        <tag>云平台</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos 7 升级内核</title>
    <url>/202209140931/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Centos 7 内核版本由 3.10 升级到 5.4.212-1</p>
<h3 id="环境息息"><a href="#环境息息" class="headerlink" title="环境息息"></a>环境息息</h3><ul>
<li>Centos7 3.10.0-1062.9.1.el7.x86_64</li>
</ul>
<h3 id="升级步骤"><a href="#升级步骤" class="headerlink" title="升级步骤"></a>升级步骤</h3><h4 id="安装-elrepo-源"><a href="#安装-elrepo-源" class="headerlink" title="安装 elrepo 源"></a>安装 elrepo 源</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</span><br><span class="line">rpm -Uvh https://www.elrepo.org/elrepo-release-7.el7.elrepo.noarch.rpm</span><br><span class="line">yum --disablerepo=&quot;*&quot; --enablerepo=&quot;elrepo-kernel&quot; repolist</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h4 id="安装新版本内核"><a href="#安装新版本内核" class="headerlink" title="安装新版本内核"></a>安装新版本内核</h4><p>查看可用的内核版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum --disablerepo=<span class="string">&quot;*&quot;</span> --enablerepo=<span class="string">&quot;elrepo-kernel&quot;</span> list available</span></span><br><span class="line">Available Packages</span><br><span class="line">kernel-lt-doc.noarch                                      5.4.212-1.el7.elrepo                          elrepo-kernel</span><br><span class="line">kernel-lt-headers.x86_64                                  5.4.212-1.el7.elrepo                          elrepo-kernel</span><br><span class="line">kernel-lt-tools.x86_64                                    5.4.212-1.el7.elrepo                          elrepo-kernel</span><br><span class="line">kernel-lt-tools-libs.x86_64                               5.4.212-1.el7.elrepo                          elrepo-kernel</span><br><span class="line">kernel-lt-tools-libs-devel.x86_64                         5.4.212-1.el7.elrepo                          elrepo-kernel</span><br><span class="line">kernel-ml.x86_64                                          5.19.8-1.el7.elrepo                           elrepo-kernel</span><br><span class="line">kernel-ml-devel.x86_64                                    5.19.8-1.el7.elrepo                           elrepo-kernel</span><br><span class="line">kernel-ml-doc.noarch                                      5.19.8-1.el7.elrepo                           elrepo-kernel</span><br><span class="line">kernel-ml-headers.x86_64                                  5.19.8-1.el7.elrepo                           elrepo-kernel</span><br><span class="line">kernel-ml-tools.x86_64                                    5.19.8-1.el7.elrepo                           elrepo-kernel</span><br><span class="line">kernel-ml-tools-libs.x86_64                               5.19.8-1.el7.elrepo                           elrepo-kernel</span><br><span class="line">kernel-ml-tools-libs-devel.x86_64                         5.19.8-1.el7.elrepo                           elrepo-kernel</span><br><span class="line">perf.x86_64                                               5.19.8-1.el7.elrepo                           elrepo-kernel</span><br><span class="line">python-perf.x86_64                                        5.19.8-1.el7.elrepo                           elrepo-kernel</span><br></pre></td></tr></table></figure>
<blockquote>
<p>kernel-lt 和 kernel-ml 二者的区别：  </p>
<ul>
<li>kernel-ml 软件包是根据 Linux Kernel Archives 的主线稳定分支提供的源构建的。 内核配置基于默认的 RHEL-7 配置，并根据需要启用了添加的功能。 这些软件包有意命名为 kernel-ml，以免与 RHEL-7 内核发生冲突，因此，它们可以与常规内核一起安装和更新。  </li>
<li>kernel-lt 包是从 Linux Kernel Archives 提供的源代码构建的，就像 kernel-ml 软件包一样。 不同之处在于 kernel-lt 基于长期支持分支，而 kernel-ml 基于主线稳定分支。</li>
</ul>
<p>在 ELRepo 中有两个内核选项，一个是 kernel-lt（长期支持版），一个是 kernel-ml（主线最新版本），采用长期支持版本（kernel-lt），更加稳定一些。</p>
</blockquote>
<p>安装最新的长期支持版</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum --disablerepo=&quot;*&quot; --enablerepo=&quot;elrepo-kernel&quot; install kernel-lt kernel-lt-devel</span><br></pre></td></tr></table></figure>

<p>查看系统上可用的内核</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk -F\<span class="string">&#x27; &#x27;</span><span class="variable">$1</span>==<span class="string">&quot;menuentry &quot;</span> &#123;<span class="built_in">print</span> <span class="variable">$2</span>&#125;<span class="string">&#x27; /etc/grub2.cfg</span></span></span><br><span class="line">CentOS Linux (5.4.212-1.el7.elrepo.x86_64) 7 (Core)</span><br><span class="line">CentOS Linux (3.10.0-1062.9.1.el7.x86_64) 7 (Core)</span><br><span class="line">CentOS Linux (0-rescue-ed7b5ef29925468cbc59b47c142c26b8) 7 (Core)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="设置开机从新内核启动"><a href="#设置开机从新内核启动" class="headerlink" title="设置开机从新内核启动"></a>设置开机从新内核启动</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grub2-set-default 0</span><br></pre></td></tr></table></figure>

<h4 id="生成grub-配置文件"><a href="#生成grub-配置文件" class="headerlink" title="生成grub 配置文件"></a>生成grub 配置文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grub2-mkconfig -o /boot/grub2/grub.cfg</span></span><br><span class="line"></span><br><span class="line">Generating grub configuration file ...</span><br><span class="line">Found linux image: /boot/vmlinuz-5.4.212-1.el7.elrepo.x86_64</span><br><span class="line">Found initrd image: /boot/initramfs-5.4.212-1.el7.elrepo.x86_64.img</span><br><span class="line">Found linux image: /boot/vmlinuz-3.10.0-1062.9.1.el7.x86_64</span><br><span class="line">Found initrd image: /boot/initramfs-3.10.0-1062.9.1.el7.x86_64.img</span><br><span class="line">Found linux image: /boot/vmlinuz-0-rescue-ed7b5ef29925468cbc59b47c142c26b8</span><br><span class="line">Found initrd image: /boot/initramfs-0-rescue-ed7b5ef29925468cbc59b47c142c26b8.img</span><br><span class="line">done</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="重启系统并验证"><a href="#重启系统并验证" class="headerlink" title="重启系统并验证"></a>重启系统并验证</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">reboot</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者</span></span><br><span class="line">shutdown -r now</span><br></pre></td></tr></table></figure>
<p>重启后查看内核版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">uname</span> -r</span></span><br><span class="line">5.4.212-1.el7.elrepo.x86_64</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="查看系统中已安装的内核"><a href="#查看系统中已安装的内核" class="headerlink" title="查看系统中已安装的内核"></a>查看系统中已安装的内核</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rpm -qa | grep kernel</span></span><br><span class="line">kernel-lt-5.4.212-1.el7.elrepo.x86_64</span><br><span class="line">kernel-tools-libs-3.10.0-1062.9.1.el7.x86_64</span><br><span class="line">kernel-lt-devel-5.4.212-1.el7.elrepo.x86_64</span><br><span class="line">kernel-3.10.0-1062.9.1.el7.x86_64</span><br><span class="line">kernel-headers-3.10.0-1160.76.1.el7.x86_64</span><br><span class="line">kernel-tools-3.10.0-1062.9.1.el7.x86_64</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="删除旧内核，这一步是可选的"><a href="#删除旧内核，这一步是可选的" class="headerlink" title="删除旧内核，这一步是可选的"></a>删除旧内核，这一步是可选的</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum remove -y  kernel-devel-3.10.0   kernel-3.10.0  kernel-headers-3.10.0 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看已安装内核</span></span><br><span class="line">rpm -qa | grep kernel</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">也可以安装 yum-utils 工具，当系统安装的内核大于3个时，会自动删除旧的内核版本</span></span><br><span class="line">yum install -y  yum-utils</span><br></pre></td></tr></table></figure>

<h4 id="升级内核工具包"><a href="#升级内核工具包" class="headerlink" title="升级内核工具包"></a>升级内核工具包</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除旧版本工具包--可选</span></span><br><span class="line">yum remove kernel-tools-libs.x86_64 kernel-tools.x86_64</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装新版本工具包</span></span><br><span class="line">yum --disablerepo=&quot;*&quot; --enablerepo=elrepo-kernel install -y kernel-lt-tools.x86_64</span><br></pre></td></tr></table></figure>
<p>查看已安装内核</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ rpm -qa | grep kernel</span><br><span class="line"></span><br><span class="line">kernel-lt-5.4.212-1.el7.elrepo.x86_64</span><br><span class="line">kernel-lt-devel-5.4.212-1.el7.elrepo.x86_64</span><br><span class="line">kernel-lt-tools-libs-5.4.212-1.el7.elrepo.x86_64</span><br><span class="line">kernel-lt-tools-5.4.212-1.el7.elrepo.x86_64</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>内核升级完成后可再次重启系统进行验证</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.cnblogs.com/yanjieli/p/14839445.html">CentOS7 内核升级</a><br><a href="https://zhuanlan.zhihu.com/p/368879345">CentOS7 内核升级</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Centos</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos VNC server 配置</title>
    <url>/202208191637/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos 7</li>
</ul>
<p><code>VNC</code> 是一个图形桌面共享系统，可以通过远程连接的方式连接到服务器的图形系统以控制操作系统<br><code>VNC</code> 包括以下四个部分 ： <code>vncserver</code>，<code>vncviewer</code>，<code>vncpassword</code> 及 <code>vncconnect</code>。<br><code>VNC client</code> 端通过 <code>VNC</code> 协议远程连接到 <code>vnc server</code> 端，进行桌面共享及交互；  </p>
<h1 id="安装-tigervnc"><a href="#安装-tigervnc" class="headerlink" title="安装 tigervnc"></a>安装 tigervnc</h1><p>安装之前首先要确保系统已安装图形系统，本文以 <code>GNOME Desktop</code> 为图形桌面系统，执行以下命令检查是否已安装 <code>GNOME Desktop</code>，如果未安装，使用命令 <code>yum groupinstall &quot;GNOME Desktop&quot;</code> 安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum grouplist</span></span><br><span class="line">Loaded plugins: fastestmirror, langpacks</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line">Installed Environment Groups:</span><br><span class="line">   GNOME Desktop</span><br><span class="line">Available Environment Groups:</span><br><span class="line">   Minimal Install</span><br><span class="line">   Compute Node</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>桌面系统安装后，使用以下命令，安装 <code>tigervnc</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y tigervnc-server</span><br></pre></td></tr></table></figure>

<p>可以参考 <code>/lib/systemd/system/vncserver@.service</code> 中的指示，生成服务配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /lib/systemd/system/vncserver@.service /etc/systemd/system/vncserver@:1.service</span><br><span class="line">vim /etc/systemd/system/vncserver@\:1.service</span><br></pre></td></tr></table></figure>
<p>修改以下行，将其中的 <code>&lt;USER&gt;</code> 改为要远程登录的用户名，例如 <code>root</code></p>
<figure class="highlight shell"><figcaption><span>/etc/systemd/system/vncserver@\:1.service</span></figcaption><table><tr><td class="code"><pre><span class="line">ExecStart=/usr/bin/vncserver_wrapper root %i</span><br></pre></td></tr></table></figure>

<p>如果有多个用户需要远程连接，可以重复以上步骤，建立多个配置文件，如 <code>/etc/systemd/system/vncserver@:2.service</code>，各个服务之间互不影响，关闭一个服务，不影响其他的 <code>vnc</code> 服务 (如关闭： <code>vncserver@:2.service</code>，<code>vncserver@:1.service</code>的 <code>vnc</code> 远程依旧可以使用)  </p>
<p>修改服务文件后，使用以下命令重新加载服务启动脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure>

<p>启动服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start vncserver@:1.service</span><br></pre></td></tr></table></figure>
<p>服务启动后，会监听 5901 端口，如果有第二个服务，会监听在 5902 端口，以此类推，防火墙需要放通此端口<br><img src="https://i.csms.tech/img_41.png"></p>
<p>切换到需要 vnc 远程登录的用户，使用以下命令配置 <code>vnc</code> 远程登录用户的密码(只是 vnc 登录时使用的密码，非系统用户密码)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# su - USER</span><br><span class="line">[USER@localhost ~]$ vncpasswd</span><br></pre></td></tr></table></figure>
<p>设置 <code>vncpasswd</code> 密码后，在账号的家目录里就会自动建立 .vnc 文件，其中包括对应用户的 <code>vnc</code> 相关的日志</p>
<p>配置完成后，<a href="https://www.realvnc.com/en/connect/download/viewer/">下载客户端</a> 进行远程登录</p>
<h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><h2 id="getpassword-error-Inappropriate-ioctl-for-device"><a href="#getpassword-error-Inappropriate-ioctl-for-device" class="headerlink" title="getpassword error: Inappropriate ioctl for device"></a>getpassword error: Inappropriate ioctl for device</h2><p><code>vncserver@:1.service</code> 服务启动失败，端口未监听</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">netstat -anutp | grep LIST</span></span><br><span class="line">tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN      735/rpcbind         </span><br><span class="line">tcp6       0      0 :::30000                :::*                    LISTEN      1251/sshd           </span><br><span class="line">tcp6       0      0 :::80                   :::*                    LISTEN      17064/nginx: master </span><br><span class="line">tcp6       0      0 :::8181                 :::*                    LISTEN      17064/nginx: master </span><br><span class="line">tcp6       0      0 :::8443                 :::*                    LISTEN      14032/nginx-ingress </span><br><span class="line">tcp6       0      0 :::443                  :::*                    LISTEN      17064/nginx: master </span><br><span class="line">tcp6       0      0 :::10254                :::*                    LISTEN      14032/nginx-ingress </span><br><span class="line">tcp6       0      0 :::111                  :::*                    LISTEN      735/rpcbind</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl status vncserver@:1.service</span></span><br><span class="line">● vncserver@:1.service - Remote desktop service (VNC)</span><br><span class="line">   Loaded: loaded (/etc/systemd/system/vncserver@:1.service; disabled; vendor preset: disabled)</span><br><span class="line">   Active: failed (Result: exit-code) since Tue 2023-05-02 13:29:44 CST; 14s ago</span><br><span class="line">  Process: 28040 ExecStart=/usr/bin/vncserver_wrapper root %i (code=exited, status=2)</span><br><span class="line">  Process: 28037 ExecStartPre=/bin/sh -c /usr/bin/vncserver -kill %i &gt; /dev/null 2&gt;&amp;1 || : (code=exited, status=0/SUCCESS)</span><br><span class="line"> Main PID: 28040 (code=exited, status=2)</span><br><span class="line"></span><br><span class="line">May 02 13:29:44 test systemd[1]: Starting Remote desktop service (VNC)...</span><br><span class="line">May 02 13:29:44 test systemd[1]: Started Remote desktop service (VNC).</span><br><span class="line">May 02 13:29:44 test vncserver_wrapper[28040]: You will require a password to access your desktops.</span><br><span class="line">May 02 13:29:44 test vncserver_wrapper[28040]: getpassword error: Inappropriate ioctl for device</span><br><span class="line">May 02 13:29:44 test vncserver_wrapper[28040]: Password:FATAL: &#x27;runuser -l root&#x27; failed!</span><br><span class="line">May 02 13:29:44 test systemd[1]: vncserver@:1.service: main process exited, code=exited, status=2/INVALIDARGUMENT</span><br><span class="line">May 02 13:29:44 test systemd[1]: Unit vncserver@:1.service entered failed state.</span><br><span class="line">May 02 13:29:44 test systemd[1]: vncserver@:1.service failed.    </span><br></pre></td></tr></table></figure>

<p><strong>解决方法</strong> 配置登陆用的 VNC 密码，重启服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su - root</span><br><span class="line">vncpasswd</span><br><span class="line"></span><br><span class="line">systemctl start vncserver@:1.service</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7 安装使用 Fiddler</title>
    <url>/202302091320/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Centos 7 上面安装 Fiddler，需要先安装 <code>mono</code>，并且需要图形桌面系统支持。</p>
<blockquote>
<p>Mono(<a href="https://github.com/mono/mono">https://github.com/mono/mono</a>) is an open source implementation of Microsoft’s .NET Framework based on the ECMA standards for C# and the Common Language Runtime.<br>The Mono project is part of the .NET Foundation(<a href="https://github.com/dotnet">https://github.com/dotnet</a>)</p>
</blockquote>
<h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos 7 3.10.0-1160</li>
<li>mono-complete-6.8.0</li>
<li>Fiddler</li>
<li>Gnome</li>
</ul>
<h1 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h1><h2 id="安装-mono"><a href="#安装-mono" class="headerlink" title="安装 mono"></a>安装 mono</h2><p>首先安装 <code>mono-complete</code>，<code>yum</code> 源 <code>epel</code> 中包含了此安装包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum info  mono-complete</span></span><br><span class="line">Loaded plugins: fastestmirror, langpacks</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line">Installed Packages</span><br><span class="line">Name        : mono-complete</span><br><span class="line">Arch        : x86_64</span><br><span class="line">Version     : 6.8.0</span><br><span class="line">Release     : 2.el7</span><br><span class="line">Size        : 0.0  </span><br><span class="line">Repo        : installed</span><br><span class="line">From repo   : epel</span><br><span class="line">Summary     : Install everything built from the mono source tree</span><br><span class="line">URL         : http://www.mono-project.com</span><br><span class="line">License     : MIT</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum  install mono-complete</span></span><br></pre></td></tr></table></figure>

<h2 id="安装-Fiddler"><a href="#安装-Fiddler" class="headerlink" title="安装 Fiddler"></a>安装 Fiddler</h2><p>下载 Fiddler 安装包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://www.telerik.com/docs/default-source/fiddler/fiddler-linux.zip</span><br></pre></td></tr></table></figure>
<p><a href="!--swig%EF%BF%BC3--">其他参考下载链接</a></p>
<p>解压运行 Fiddler</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unzip fiddler-linux.zip -d fiddler-linux</span><br><span class="line">cd fiddler-linux</span><br><span class="line">mono ./Fiddler.exe</span><br></pre></td></tr></table></figure>

<h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><h2 id="ERROR-FATAL-UNHANDLED-EXCEPTION-System-TypeInitializationException-The-type-initializer-for-‘System-Windows-Forms-XplatUI’-threw-an-exception-—-gt-System-ArgumentNullException-Could-not-open-display-X-Server-required-Check-your-DISPLAY-environment-variable"><a href="#ERROR-FATAL-UNHANDLED-EXCEPTION-System-TypeInitializationException-The-type-initializer-for-‘System-Windows-Forms-XplatUI’-threw-an-exception-—-gt-System-ArgumentNullException-Could-not-open-display-X-Server-required-Check-your-DISPLAY-environment-variable" class="headerlink" title="[ERROR] FATAL UNHANDLED EXCEPTION: System.TypeInitializationException: The type initializer for ‘System.Windows.Forms.XplatUI’ threw an exception. —&gt; System.ArgumentNullException: Could not open display (X-Server required. Check your DISPLAY environment variable)"></a>[ERROR] FATAL UNHANDLED EXCEPTION: System.TypeInitializationException: The type initializer for ‘System.Windows.Forms.XplatUI’ threw an exception. —&gt; System.ArgumentNullException: Could not open display (X-Server required. Check your DISPLAY environment variable)</h2><p>启动过程中报错，原因为需要桌面系统支持。可以在图形桌面系统中开启 shell，执行启动命令 <code>mono ./Fiddler.exe</code></p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Fiddler</tag>
      </tags>
  </entry>
  <entry>
    <title>SSL 证书格式说明</title>
    <url>/202210211124/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>常见的 SSL 证书格式主要有：</p>
<ul>
<li><code>.DER</code>  <code>.CER</code> - 文件是二进制格式，只保存证书，不保存私钥。</li>
<li><code>.PEM</code> - 一般是文本格式，可保存证书，可保存私钥。</li>
<li><code>.CRT</code> - 可以是二进制格式，可以是文本格式，一般均为文本格式，与 <code>.DER</code> 格式相同，不保存私钥。</li>
<li><code>.PFX</code>  <code>.P12</code> - 二进制格式，同时包含证书和私钥，一般有密码保护。</li>
<li><code>.JK</code> - 二进制格式，同时包含证书和私钥，一般有密码保护。</li>
</ul>
<h1 id="证书格式说明"><a href="#证书格式说明" class="headerlink" title="证书格式说明"></a>证书格式说明</h1><h2 id="DER-和-CER"><a href="#DER-和-CER" class="headerlink" title="DER 和 CER"></a>DER 和 CER</h2><p>该格式是二进制文件内容，Java 和 Windows 服务器偏向于使用这种编码格式。只含有证书信息，不包含私钥</p>
<p>OpenSSL 查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl x509 -in certificate.der -inform der -text -noout</span><br></pre></td></tr></table></figure>
<p>转换为 PEM：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl x509 -in cert.crt -inform der -outform pem -out cert.pem</span><br></pre></td></tr></table></figure>

<h2 id="PEM"><a href="#PEM" class="headerlink" title="PEM"></a>PEM</h2><p>Privacy Enhanced Mail，一般为文本格式，以 <code>-----BEGIN...</code> 开头，以 <code>-----END...</code> 结尾。中间的内容是 BASE64 编码。这种格式可以保存证书和私钥，有时我们也把 PEM 格式的私钥的后缀改为 <code>.key</code> 以区别证书与私钥。</p>
<p>这种格式常用于 Apache 和 Nginx 服务器。</p>
<p>OpenSSL 查看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl x509 -in certificate.pem -text -noout</span><br></pre></td></tr></table></figure>
<p>转换为 DER：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl x509 -in cert.crt -outform der -out cert.der</span><br></pre></td></tr></table></figure>

<h2 id="CRT"><a href="#CRT" class="headerlink" title="CRT"></a>CRT</h2><p>Certificate 的简称，有可能是 PEM 编码格式，也有可能是 DER 编码格式。如何查看请参考前两种格式。</p>
<h2 id="PFX"><a href="#PFX" class="headerlink" title="PFX"></a>PFX</h2><p>Predecessor of PKCS#12，这种格式是二进制格式，且证书和私钥存在一个 PFX 文件中。一般用于 Windows 上的 IIS 服务器。该格式的文件一般会有一个密码用于保证私钥的安全。</p>
<p>OpenSSL 查看：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl pkcs12 -in for-iis.pfx</span><br></pre></td></tr></table></figure>

<p>转换为 PEM：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl pkcs12 -in for-iis.pfx -out for-iis.pem -nodes</span><br></pre></td></tr></table></figure>

<h2 id="JKS"><a href="#JKS" class="headerlink" title="JKS"></a>JKS</h2><p>Java Key Storage，很容易知道这是 JAVA 的专属格式，利用 JAVA 的一个叫 keytool 的工具可以进行格式转换。一般用于 Tomcat 服务器。</p>
<p>可以到这里进行 <a href="https://myssl.com/cert_convert.html">格式转换</a></p>
<span id="more"></span>

<h1 id="证书格式转换"><a href="#证书格式转换" class="headerlink" title="证书格式转换"></a>证书格式转换</h1><p>以下证书格式之间是可以互相转换的<br><img src="https://i.csms.tech/img_65.png"></p>
<h2 id="将-JKS-格式证书转换成-PFX-格式"><a href="#将-JKS-格式证书转换成-PFX-格式" class="headerlink" title="将 JKS 格式证书转换成 PFX 格式"></a>将 JKS 格式证书转换成 PFX 格式</h2><p>使用 JDK 中自带的 Keytool 工具，将 JKS 格式证书文件转换成 PFX 格式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">keytool -v -importkeystore -srckeystore D:\apk\Helloworld.jks -srcstoretype jks -srcstorepass 18738892937lyj \</span><br><span class="line">           -destkeystore Helloworld.pfx -deststoretype pkcs12 -deststorepass 18738892937lyj -destkeypass 18738892937lyj</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="将-PFX-格式证书转换为-JKS-格式"><a href="#将-PFX-格式证书转换为-JKS-格式" class="headerlink" title="将 PFX 格式证书转换为 JKS 格式"></a>将 PFX 格式证书转换为 JKS 格式</h2><p>使用 JDK 中自带的 Keytool 工具，将 PFX 格式证书文件转换成 JKS 格式。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">keytool -importkeystore -srckeystore xxx.pfx \</span><br><span class="line">        -destkeystore xxx.jks -srcstoretype PKCS12 -deststoretype JKS</span><br></pre></td></tr></table></figure>

<h2 id="将-PEM-x2F-KEY-x2F-CRT-格式证书转换为-PFX-格式"><a href="#将-PEM-x2F-KEY-x2F-CRT-格式证书转换为-PFX-格式" class="headerlink" title="将 PEM&#x2F;KEY&#x2F;CRT 格式证书转换为 PFX 格式"></a>将 PEM&#x2F;KEY&#x2F;CRT 格式证书转换为 PFX 格式</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl pkcs12 -export -out server.pfx -inkey server.key -in server.crt</span><br></pre></td></tr></table></figure>

<h2 id="将PFX转换为PEM-x2F-KEY-x2F-CRT"><a href="#将PFX转换为PEM-x2F-KEY-x2F-CRT" class="headerlink" title="将PFX转换为PEM&#x2F;KEY&#x2F;CRT"></a>将PFX转换为PEM&#x2F;KEY&#x2F;CRT</h2><p>可以使用 OpenSSL工具，将 PFX 格式证书文件转化为 KEY 格式密钥文件和 CRT 格式公钥文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl pkcs12 -in server.pfx -nodes -out server.pem</span><br><span class="line">openssl rsa -in server.pem -out server.key</span><br><span class="line">openssl x509 -in server.pem -out server.crt</span><br></pre></td></tr></table></figure>

<h1 id="openssl-命令说明"><a href="#openssl-命令说明" class="headerlink" title="openssl 命令说明"></a>openssl 命令说明</h1><p>常用命令选项</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>-in</code></td>
<td>输入文件</td>
<td></td>
</tr>
<tr>
<td><code>-out</code></td>
<td>输出文件，默认为 <code>stdout</code></td>
<td></td>
</tr>
<tr>
<td><code>-inform</code></td>
<td>输入文件格式</td>
<td><code>DER</code> or <code>PEM</code></td>
</tr>
<tr>
<td><code>-outform</code></td>
<td>输出文件格式</td>
<td><code>DER</code> or <code>PEM</code></td>
</tr>
<tr>
<td><code>-keyform</code></td>
<td><code>key</code> 的格式，默认为 <code>PEM</code></td>
<td></td>
</tr>
<tr>
<td><code>-text</code></td>
<td>输出文本格式的内容</td>
<td><code>openssl x509  -text -in sverver.crt</code> 打印证书文本内容</td>
</tr>
<tr>
<td><code>-noout</code></td>
<td>不输出 REQ</td>
<td><code>openssl x509 -noout -text -in sverver.crt</code> <br/>打印证书文本格式的详情，不包括证书内容</td>
</tr>
</tbody></table>
<h2 id="查看证书内容"><a href="#查看证书内容" class="headerlink" title="查看证书内容"></a>查看证书内容</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl x509 -text -noout -in server.crt</span><br></pre></td></tr></table></figure>

<h2 id="使用-openssl-生成随机密码"><a href="#使用-openssl-生成随机密码" class="headerlink" title="使用 openssl 生成随机密码"></a>使用 openssl 生成随机密码</h2><p>几乎所有 Linux 发行版都包含 openssl。我们可以利用它的随机功能来生成可以用作密码的随机字母字符串。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl rand -base64 8</span><br></pre></td></tr></table></figure>
<p><code>openssl rand </code> 命令帮助信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">openssl rand</span> </span><br><span class="line">Usage: rand [options] num</span><br><span class="line">where options are</span><br><span class="line">-out file             - write to file</span><br><span class="line">-engine e             - use engine e, possibly a hardware device.</span><br><span class="line">-rand file:file:... - seed PRNG from files</span><br><span class="line">-base64               - base64 encode output</span><br><span class="line">-hex                  - hex encode output</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>SSL</tag>
        <tag>openssl</tag>
      </tags>
  </entry>
  <entry>
    <title>Confluence 常用基本操作</title>
    <url>/202208250937/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Confluence 是一个专业的企业知识管理与协同软件，也可以用于构建企业 <a href="https://zh.m.wikipedia.org/zh/Wiki"><code>wiki</code></a>。通过它可以实现团队成员之间的协作和知识共享。在这里，团队成员齐心协力，各擅其能，协同地编写文档和管理项目。从此打破不同团队、不同部门以及个人之间信息孤岛的僵局，Confluence 真正实现了组织资源共享。Confluence 使用简单，但它强大的编辑和站点管理特征能够帮助团队成员之间共享信息、文档协作、集体讨论。</p>
<span id="more"></span>

<h3 id="根据标题生成文章目录"><a href="#根据标题生成文章目录" class="headerlink" title="根据标题生成文章目录"></a>根据标题生成文章目录</h3><p>在 confluence 中编写文章时，可以根据不同级别的 <code>标题</code> 对文章内容进行分层，如下图所示    </p>
<p><img src="https://i.csms.tech/img_44.png"></p>
<p>在此情况之下，可以根据文章中的标题，生成文章目录，在文章内容过长或过多的情况下，可以根据目录轻松快速的定位到需要的内容章节，操作过长如下：<br>编辑需要生成目录的文章，按照下图所示的位置选择 <code>插入目录宏</code>  </p>
<p><img src="https://i.csms.tech/img_45.png"></p>
<p>在弹出的 <code>编辑‘目录’宏</code> 页面中配置相关参数，配置完成后，点击 <code>保存</code>，将会在页面中生成文章目录<br><img src="https://i.csms.tech/img_46.png"><br><img src="https://i.csms.tech/img_47.png"></p>
<p>如果要在特点的地方显示文章目录，可以使用 <code>页面布局</code> 操作，比如选择 <code>页面布局</code> 中的 <code>包含侧边栏的两列节</code> 并将目录放置在右边的侧边栏，示例及效果如下图<br><img src="https://i.csms.tech/img_48.png"><br><img src="https://i.csms.tech/img_49.png"></p>
<h3 id="链接到文章内的锚点"><a href="#链接到文章内的锚点" class="headerlink" title="链接到文章内的锚点"></a>链接到文章内的锚点</h3><h4 id="创建锚点"><a href="#创建锚点" class="headerlink" title="创建锚点"></a>创建锚点</h4><p>在需要创建 <code>锚点</code> 的地方，选择 <code>插入 ‘锚’ 宏</code>，输入 <code>锚名称</code>，插入后产生对应 <code>锚点</code><br><img src="https://i.csms.tech/img_50.png"></p>
<h4 id="链接到同一文章内锚点"><a href="#链接到同一文章内锚点" class="headerlink" title="链接到同一文章内锚点"></a>链接到同一文章内锚点</h4><p>在需要链接 <code>锚点</code> 的地方，选择 <code>插入链接</code>，链接中 <code>锚点</code> 使用 <code>#锚点名称</code> 进行链接<br><img src="https://i.csms.tech/img_51.png"></p>
<h4 id="链接到其他文章内的锚点"><a href="#链接到其他文章内的锚点" class="headerlink" title="链接到其他文章内的锚点"></a>链接到其他文章内的锚点</h4><p><code>confluence</code> 的同一个空间内不允许存在同名的页面（文章），因此所有页面（文章）名具有独一性，当需要链接到其他页面中的锚点时，可以参照以下配置。比如要链接到页面 <code>cs</code> 中的 <code>test</code> 锚点，按照以下配置，在需要链接的地方插入链接<br><img src="https://i.csms.tech/img_52.png"></p>
<blockquote>
<p>这种方式下，锚点所在的页面改名，锚点依然生效，使用锚点的链接中页面名也会随之改变  </p>
</blockquote>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Confluence</tag>
      </tags>
  </entry>
  <entry>
    <title>containerd 使用方法</title>
    <url>/202212011355/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos 7</li>
<li>containerd.io-1.4.13-3</li>
</ul>
<h1 id="containerd-相关配置"><a href="#containerd-相关配置" class="headerlink" title="containerd 相关配置"></a>containerd 相关配置</h1><h2 id="默认配置文件"><a href="#默认配置文件" class="headerlink" title="默认配置文件"></a>默认配置文件</h2><p><code>containerd</code> 服务默认配置文件为 <code>/etc/containerd/config.toml</code></p>
<figure class="highlight shell"><figcaption><span>/etc/containerd/config.toml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">root = <span class="string">&quot;/var/lib/containerd&quot;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">state = <span class="string">&quot;/run/containerd&quot;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">subreaper = <span class="literal">true</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">oom_score = 0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Containerd 有两个不同的存储路径，一个用来保存持久化数据，一个用来保存运行时状态。 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Containerd 的前世今生和保姆级入门教程](https://blog.51cto.com/u_15127639/3256557)">[1]</span></a></sup></p>
<figure class="highlight shell"><figcaption><span>/etc/containerd/config.toml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">root = <span class="string">&quot;/var/lib/containerd&quot;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">state = <span class="string">&quot;/run/containerd&quot;</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>root</code> - 用来保存持久化数据，包括 Snapshots, Content, Metadata 以及各种插件的数据。每一个插件都有自己单独的目录，Containerd 本身不存储任何数据，它的所有功能都来自于已加载的插件。</li>
<li><code>state</code> - 用来保存临时数据，包括 <code>sockets</code>、<code>pid</code>、<code>挂载点</code>、<code>运行时状态</code> 以及不需要持久化保存的插件数据。</li>
</ul>
<figure class="highlight shell"><figcaption><span>/etc/containerd/config.toml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">oom_score = 0</span></span><br></pre></td></tr></table></figure>
<p>Containerd 是容器的守护者，一旦发生内存不足的情况，理想的情况应该是先杀死容器，而不是杀死 Containerd。所以需要调整 Containerd 的 OOM 权重，减少其被 OOM Kill 的几率。<code>oom_score</code> 其取值范围为 <code>-1000</code> 到 <code>1000</code>，如果将该值设置为 <code>-1000</code>，则进程永远不会被杀死，建议 Containerd 将该值设置为 <code>-999</code> 到 <code>0</code> 之间。如果作为 Kubernetes 的 Worker 节点，可以考虑设置为 <code>-999</code>。</p>
<h2 id="containerd-服务配置文件"><a href="#containerd-服务配置文件" class="headerlink" title="containerd 服务配置文件"></a>containerd 服务配置文件</h2><p>默认的 <code>containerd</code> 服务的配置为 <code>/usr/lib/systemd/system/containerd.service</code></p>
<figure class="highlight shell"><figcaption><span>/usr/lib/systemd/system/containerd.service</span></figcaption><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=containerd container runtime</span><br><span class="line">Documentation=https://containerd.io</span><br><span class="line">After=network.target local-fs.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStartPre=-/sbin/modprobe overlay</span><br><span class="line">ExecStart=/usr/bin/containerd</span><br><span class="line"></span><br><span class="line">Type=notify</span><br><span class="line">Delegate=yes</span><br><span class="line">KillMode=process</span><br><span class="line">Restart=always</span><br><span class="line">RestartSec=5</span><br><span class="line"></span><br><span class="line">LimitNPROC=infinity</span><br><span class="line">LimitCORE=infinity</span><br><span class="line">LimitNOFILE=1048576</span><br><span class="line"></span><br><span class="line">TasksMax=infinity</span><br><span class="line">OOMScoreAdjust=-999</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong><code>Delegate</code></strong> - 这个选项允许 Containerd 以及运行时自己管理自己创建的容器的 cgroups。如果不设置这个选项，<code>systemd</code> 就会将进程移到自己的 cgroups 中，从而导致 Containerd 无法正确获取容器的资源使用情况。</p>
</li>
<li><p><strong><code>KillMode</code></strong> - 这个选项用来处理 Containerd 进程被杀死的方式。默认情况下，<code>systemd</code> 会在进程的 cgroup 中查找并杀死 Containerd 的所有子进程，这肯定不是我们想要的。<code>KillMode</code> 字段可以设置的值如下:</p>
<ul>
<li><strong><code>control-group</code></strong> -（默认值）当前控制组里面的所有子进程，都会被杀掉</li>
<li><strong><code>process</code></strong> - 只杀主进程。</li>
<li><strong><code>mixed</code></strong> - 主进程将收到 <code>SIGTERM</code> 信号，子进程收到 <code>SIGKILL</code> 信号</li>
<li><strong><code>none</code></strong> - 没有进程会被杀掉，只是执行服务的 stop 命令。</li>
</ul>
<p>  需要将 <code>KillMode</code> 的值设置为<code> process</code>，这样可以确保升级或重启 Containerd 时不杀死现有的容器。</p>
</li>
</ul>
<h1 id="客户端工具-ctr-使用"><a href="#客户端工具-ctr-使用" class="headerlink" title="客户端工具 ctr 使用"></a>客户端工具 ctr 使用</h1><h2 id="ctr-管理镜像"><a href="#ctr-管理镜像" class="headerlink" title="ctr 管理镜像"></a>ctr 管理镜像</h2><h3 id="镜像下载"><a href="#镜像下载" class="headerlink" title="镜像下载"></a>镜像下载</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ctr image pull docker.io/library/nginx:alpine</span><br></pre></td></tr></table></figure>

<h3 id="列出本地镜像"><a href="#列出本地镜像" class="headerlink" title="列出本地镜像"></a>列出本地镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ctr image <span class="built_in">ls</span></span></span><br><span class="line">REF                            TYPE                                                      DIGEST                                                                  SIZE    PLATFORMS                                                                                LABELS </span><br><span class="line">docker.io/library/nginx:alpine application/vnd.docker.distribution.manifest.list.v2+json sha256:455c39afebd4d98ef26dd70284aa86e6810b0485af5f4f222b19b89758cabf1e 9.8 MiB linux/386,linux/amd64,linux/arm/v6,linux/arm/v7,linux/arm64/v8,linux/ppc64le,linux/s390x -</span><br></pre></td></tr></table></figure>
<h3 id="将镜像挂载到本地目录"><a href="#将镜像挂载到本地目录" class="headerlink" title="将镜像挂载到本地目录"></a>将镜像挂载到本地目录</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ctr image mount docker.io/library/nginx:alpine /mnt</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> /mnt</span></span><br><span class="line">bin  docker-entrypoint.d   etc   lib    mnt  proc  run   srv  tmp  var</span><br><span class="line">dev  docker-entrypoint.sh  home  media  opt  root  sbin  sys  usr</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>卸载已挂载的镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ctr image unmount /mnt</span><br></pre></td></tr></table></figure>

<h2 id="ctr-管理-容器"><a href="#ctr-管理-容器" class="headerlink" title="ctr 管理 容器"></a>ctr 管理 容器</h2><h3 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ctr container create docker.io/library/nginx:alpine nginx</span><br></pre></td></tr></table></figure>
<p>容器创建后，并没有开始运行，只是分配了容器运行所需的资源及配置的数据结构，这意味着 <code>namespaces</code>、<code>rootfs</code> 和容器的配置都已经初始化成功了，只是用户进程(这里是 <code>nginx</code>)还没有启动，容器（进程）状态的变化由 <code>Task</code> 对象实现，通过命令 <code>ctr task</code> 来管理。</p>
<p>启动 <code>ctr container create</code> 创建的容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ctr task start nginx</span><br></pre></td></tr></table></figure>
<p>以上命令启动之前创建的容器 <code>nginx</code>，未指定其他参数时，容器中的进程在系统前台运行，如需后台运行，可以使用选项 <code>-d</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ctr task start nginx -d</span><br></pre></td></tr></table></figure>

<p>也可以直接使用 <code>run</code> 命令，创建并启动容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ctr run --rm -d docker.io/library/nginx:alpine nginx1</span><br></pre></td></tr></table></figure>

<h3 id="列出容器"><a href="#列出容器" class="headerlink" title="列出容器"></a>列出容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ctr container ls</span><br></pre></td></tr></table></figure>

<p>查看容器中进程的状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ctr task <span class="built_in">ls</span></span></span><br><span class="line">TASK      PID     STATUS    </span><br><span class="line">nginx1    5495    RUNNING</span><br></pre></td></tr></table></figure>
<p>查看容器中运行的所有的进程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ctr task ps nginx1</span></span><br><span class="line">PID     INFO</span><br><span class="line">5495    -</span><br><span class="line">5531    -</span><br><span class="line">5532    -</span><br><span class="line">5533    -</span><br><span class="line">5534    -</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>这里的 PID 是宿主机看到的 PID，不是容器中看到的 PID。</strong></p>
<h3 id="查看容器详细信息"><a href="#查看容器详细信息" class="headerlink" title="查看容器详细信息"></a>查看容器详细信息</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ctr container info nginx</span><br></pre></td></tr></table></figure>

<h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p>停止&#x2F;删除容器中的进程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ctr task delete nginx -f</span><br><span class="line"></span><br><span class="line">ctr task pause nginx</span><br></pre></td></tr></table></figure>
<p>以上命令<strong>删除&#x2F;停止容器中的进程，但是并不删除容器</strong>，执行以上命令后再执行以下命令，可删除容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ctr container delete nginx</span><br></pre></td></tr></table></figure>
<p><strong>ctr 没有 stop 容器的功能，只能暂停或者杀死容器。</strong></p>
<h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ctr task exec -t --exec-id 1 nginx1 sh</span><br></pre></td></tr></table></figure>
<p>执行 <code>ctr task exec</code> 进入容器，必须制定 <code>--exec-id</code>，值可以随便指定。</p>
<h3 id="namespace-管理"><a href="#namespace-管理" class="headerlink" title="namespace 管理"></a>namespace 管理</h3><p>Containerd 相比于 Docker ，多了 Namespace 的概念，使用以下命令，查看所有的 Namespace</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ctr ns <span class="built_in">ls</span></span></span><br><span class="line">NAME    LABELS </span><br><span class="line">default        </span><br><span class="line">moby     </span><br></pre></td></tr></table></figure>
<p><code>docker</code> 默认使用 <code>moby</code> 的 Namespace，要使用 <code>ctr</code> 命令查看 <code>docker</code> 创建的容器，需要使用选项 <code>-n moby</code> 指定命名空间，否则 <code>ctr</code> 默认使用 <code>default</code> 命名空间，无法看到 <code>moby</code> 命名空间中的资源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ctr -n moby container ls</span><br><span class="line">CONTAINER                                                           IMAGE    RUNTIME                           </span><br><span class="line">17b16c3699cdb88a1ff80d8a7c84724eff393c42186775b58418c90bd178600f    -        io.containerd.runtime.v1.linux    </span><br><span class="line">27fc19226baa91251d63a375a7b1309122334cfb5ceb39aeb67ab1701b708464    -        io.containerd.runtime.v1.linux</span><br></pre></td></tr></table></figure>

<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://blog.51cto.com/u_15127639/3256557">Containerd 的前世今生和保姆级入门教程</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>containerd</tag>
      </tags>
  </entry>
  <entry>
    <title>Django admin 配置</title>
    <url>/202209021312/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Django 自带的 <code>Admin Site</code> 管理页面可以方便用户快速构建一个简单的后台管理系统，少量代码即可快速实现对数据库中的数据进行展示、修改、保存的可视化页面和功能。当需要对后台展示的数据进行配置时，只需要在 <code>app</code> 的代码文件 <code>admin.py</code> 中进行相应配置即可。</p>
<h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>centos 7</li>
<li>python 3.10</li>
<li>django 4.0</li>
</ul>
<h1 id="为-model-配置-admin-管理页面"><a href="#为-model-配置-admin-管理页面" class="headerlink" title="为 model 配置 admin 管理页面"></a>为 model 配置 admin 管理页面</h1><p>要为 model 启用 admin 管理接口，<a href="https://csms.tech/202301191014/#model-注册到后台">参考配置</a></p>
<span id="more"></span>
<h1 id="常用配置说明"><a href="#常用配置说明" class="headerlink" title="常用配置说明"></a>常用配置说明</h1><h2 id="配置登录页面和-web-页面中显示的-title"><a href="#配置登录页面和-web-页面中显示的-title" class="headerlink" title="配置登录页面和 web 页面中显示的 title"></a>配置登录页面和 web 页面中显示的 title</h2><p>修改 APP 对应的 <code>admin.py</code></p>
<figure class="highlight shell"><figcaption><span>admin.py</span></figcaption><table><tr><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line"></span><br><span class="line">admin.site.site_header = &quot;My Admin Site&quot;</span><br><span class="line">admin.site.site_title = &quot;My Admin Site&quot;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_53.png"></p>
<h2 id="常用配置示例"><a href="#常用配置示例" class="headerlink" title="常用配置示例"></a>常用配置示例</h2><p>admin 中的配置大多来自 <code>ModelAdmin</code> 对象的选项 <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[ModelAdmin 对象](https://docs.djangoproject.com/zh-hans/4.1/ref/contrib/admin/#modeladmin-options)">[2]</span></a></sup></p>
<figure class="highlight shell"><figcaption><span>admin.py</span></figcaption><table><tr><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">假如 app 为 servers，导入 models</span></span><br><span class="line">from servers import models</span><br><span class="line"></span><br><span class="line">@admin.register(models.Servers)</span><br><span class="line">class ServersAdmin(admin.ModelAdmin):</span><br><span class="line">    # list_display 定义model 中要显示的列</span><br><span class="line">    # list_display_links 定义了哪些列可以点击(链接)跳转到对象的修改页面</span><br><span class="line">    list_display = (&#x27;inVender&#x27;, &#x27;contacter&#x27;, &#x27;name&#x27;, &#x27;ip&#x27;, &#x27;type&#x27;, &#x27;zone&#x27;, &#x27;diskSize&#x27;, &#x27;diskType&#x27;, &#x27;dataTransfer&#x27;)</span><br><span class="line">    list_display_links = (&#x27;inVender&#x27;, &#x27;name&#x27;, &#x27;ip&#x27;)</span><br><span class="line"></span><br><span class="line">    # fields 定义修改页面中显示哪些修改项, 未出现在此的列,添加或修改对象时不显示.</span><br><span class="line">    # fieldsets 对要编辑的部分进行分组显示, &#x27;classes&#x27;: (&#x27;collapse&#x27;,) 为 CSS 格式定义隐藏和显示</span><br><span class="line">    fields = (&#x27;inVender&#x27;, )</span><br><span class="line">    </span><br><span class="line">    fieldsets = (</span><br><span class="line">        [&#x27;Main&#x27;,&#123;</span><br><span class="line">            &#x27;fields&#x27;:(&#x27;name&#x27;,&#x27;ip&#x27;),</span><br><span class="line">        &#125;],</span><br><span class="line">        [&#x27;Advance&#x27;,&#123;</span><br><span class="line">            &#x27;classes&#x27;: (&#x27;collapse&#x27;,), # CSS</span><br><span class="line">            &#x27;fields&#x27;: (&#x27;inVender&#x27;,),</span><br><span class="line">        &#125;]</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    # search_fields  定义哪些列可以被搜索，假如搜索的列是外键或其他关连列，要使用关联列中的字符类型或数字类型为搜索对象，如 &#x27;inVender__name&#x27;</span><br><span class="line">    # 要自定义搜索多个内容，可参考本文后续内容</span><br><span class="line">    search_fields = (&#x27;name&#x27;, &#x27;inVender__name&#x27;)</span><br><span class="line">    </span><br><span class="line">    # 显示默认的搜索内容, Djanog 4 不可用</span><br><span class="line">    placeholder = &#x27;输入搜索内容&#x27;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    # actions 要在变更列表页上提供的动作列表</span><br><span class="line">    actions = [&#x27;startCheck&#x27;]</span><br><span class="line">    </span><br><span class="line">    # actions_on_top actions_on_bottom 定义控制动作栏在页面的哪个位置出现，默认在顶部</span><br><span class="line">    actions_on_top = True</span><br><span class="line">    actions_on_bottom = False</span><br><span class="line">    </span><br><span class="line">    # readonly_fields 定义只读列，此处里面的项不可编辑，不在此列表中的项可以编辑</span><br><span class="line">    # 同时存在于 readonly_fields 和 fields/fieldsets 中的列，不可编辑</span><br><span class="line">    readonly_fields = (&#x27;name&#x27;,)</span><br><span class="line">    </span><br><span class="line">    # 控制每个分页的管理变更列表页面上出现多少个项目。默认情况下，设置为 100</span><br><span class="line">    # 可以将 list_per_page 属性设置为一个列表，以便在Admin页面上提供不同的页面大小选项。</span><br><span class="line">    list_per_page = 100</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    # 配置 filter, 可以在列表页的右侧显示筛选选项。当筛选的列只包含一个对象时，此筛选列会隐藏不显示</span><br><span class="line">    list_filter = (&#x27;name&#x27;,)</span><br><span class="line">    </span><br><span class="line">    # 允许在列表上直接编辑字段</span><br><span class="line">    list_editable = [&#x27;account&#x27;]</span><br></pre></td></tr></table></figure>

<!-- more -->
<h3 id="list-display-中自定义列"><a href="#list-display-中自定义列" class="headerlink" title="list_display 中自定义列"></a>list_display 中自定义列</h3><p>以下示例中，<code>project_series</code> 不属于 <code>Info</code> 模型中已有的字段，属于 <code>Info</code> 模型中的外键 <code>project</code> 中的字段，要在后台对应模型中添加显示此列，可以参考以下配置</p>
<figure class="highlight python"><figcaption><span>admin.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@admin.register(<span class="params">models.Info</span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InfoAdmin</span>(admin.ModelAdmin):</span><br><span class="line">    list_display = (<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;project_series&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">project_series</span>(<span class="params">self, obj</span>):</span><br><span class="line">        <span class="keyword">return</span> obj.project.project_series</span><br><span class="line">    </span><br><span class="line">    project_series.short_description = <span class="string">&#x27;项目系列&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义-actions"><a href="#自定义-actions" class="headerlink" title="自定义 actions"></a>自定义 actions</h3><p><code>actions</code> 定义要在变更列表页上提供的动作列表 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[管理 actions](https://docs.djangoproject.com/zh-hans/4.1/ref/contrib/admin/actions/#admin-actions)">[1]</span></a></sup> </p>
<p>以下示例代码中，添加了 3 个动作： <code>export_as_excel</code>，<code>change_payStatusToPay</code>，<code>change_payStatusToUnPay</code>，分别完成导出选中数据到 Excel、修改支付状态为支付&#x2F;未支付</p>
<p>其中，每个方法函数的 <code>short_description</code> 属性定义了显示在 admin 页面上的功能名称，<code>allowed_permissions</code> 定义了执行此操作需要的权限。</p>
<figure class="highlight python"><figcaption><span>admin.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="keyword">import</span> openpyxl</span><br><span class="line"></span><br><span class="line"><span class="meta">@admin.register(<span class="params">models.Servers</span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServersAdmin</span>(admin.ModelAdmin):</span><br><span class="line"></span><br><span class="line">    actions = [<span class="string">&quot;export_as_excel&quot;</span>,<span class="string">&#x27;change_payStatusToPay&#x27;</span>,<span class="string">&#x27;change_payStatusToUnPay&#x27;</span>]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">export_as_excel</span>(<span class="params">self,request,queryset</span>):</span><br><span class="line">        meta = self.model._meta</span><br><span class="line">        field_names = [<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;inDeparMent&#x27;</span>, <span class="string">&#x27;inVender&#x27;</span>, <span class="string">&#x27;inOwner&#x27;</span>, <span class="string">&#x27;usedFor&#x27;</span>, <span class="string">&#x27;financeCode&#x27;</span>, <span class="string">&#x27;ip&#x27;</span>, <span class="string">&#x27;price&#x27;</span>, <span class="string">&#x27;validDateTo&#x27;</span>,<span class="string">&#x27;status&#x27;</span>]</span><br><span class="line">        response = HttpResponse(content_type=<span class="string">&#x27;application/msexcel&#x27;</span>)</span><br><span class="line">        filename = <span class="string">&quot;servers&quot;</span> + <span class="built_in">str</span>(time.time()).replace(<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;&#x27;</span>) + <span class="string">&#x27;.xlsx&#x27;</span></span><br><span class="line">        response[<span class="string">&#x27;Content-Disposition&#x27;</span>] = <span class="string">&#x27;attachment; filename=%s&#x27;</span> %(filename)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            wb = openpyxl.load_workbook(filename)</span><br><span class="line">        <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">            wb = openpyxl.Workbook()</span><br><span class="line">        ws = wb.active</span><br><span class="line">        ws.append(field_names)</span><br><span class="line">        <span class="keyword">for</span> obj <span class="keyword">in</span> queryset:</span><br><span class="line">            data = []</span><br><span class="line">            data.append(<span class="built_in">getattr</span>(obj,<span class="string">&#x27;id&#x27;</span>))</span><br><span class="line">            data.append(<span class="built_in">getattr</span>(obj,<span class="string">&#x27;inDeparMent&#x27;</span>).shortName)</span><br><span class="line">            data.append(<span class="built_in">getattr</span>(obj, <span class="string">&#x27;inVender&#x27;</span>).vender_shortName)</span><br><span class="line">            data.append(<span class="built_in">getattr</span>(obj, <span class="string">&#x27;inOwner&#x27;</span>).name)</span><br><span class="line">            data.append(<span class="built_in">getattr</span>(obj, <span class="string">&#x27;usedFor&#x27;</span>))</span><br><span class="line">            data.append(<span class="built_in">getattr</span>(obj, <span class="string">&#x27;financeCode&#x27;</span>))</span><br><span class="line">            data.append(<span class="built_in">getattr</span>(obj, <span class="string">&#x27;ip&#x27;</span>))</span><br><span class="line">            data.append(<span class="built_in">getattr</span>(obj, <span class="string">&#x27;price&#x27;</span>))</span><br><span class="line">            data.append(<span class="built_in">getattr</span>(obj, <span class="string">&#x27;validDateTo&#x27;</span>))</span><br><span class="line">            data.append(<span class="built_in">getattr</span>(obj,<span class="string">&#x27;status&#x27;</span>))</span><br><span class="line">            ws.append(data)</span><br><span class="line">        wb.save(response)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">    export_as_excel.short_description = <span class="string">&quot;导出到Excel&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">change_payStatusToPay</span>(<span class="params">self,request,queryset</span>):</span><br><span class="line">        queryset.update(payStatus=<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 执行完成后向 admin web 返回相应消息</span></span><br><span class="line">        self.message_user(request, _(<span class="string">&#x27;刷新完成&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    change_payStatusToPay.short_description = <span class="string">&quot;更改支付状态--&gt;已支付&quot;</span></span><br><span class="line">    change_payStatusToPay.allowed_permissions = (<span class="string">&#x27;change&#x27;</span>,)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">change_payStatusToUnPay</span>(<span class="params">self,request,queryset</span>):</span><br><span class="line">        queryset.update(payStatus=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    change_payStatusToUnPay.short_description = <span class="string">&quot;更改支付状态--&gt;未支付&quot;</span></span><br><span class="line">    change_payStatusToUnPay.allowed_permissions = (<span class="string">&#x27;change&#x27;</span>,)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="自定义-filter"><a href="#自定义-filter" class="headerlink" title="自定义 filter"></a>自定义 filter</h3><p>要自定义 <code>filter</code>，可以通过继承 <code>django.contrib.admin.SimpleListFilter</code> 类来实现 <sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Using a SimpleListFilter](https://docs.djangoproject.com/zh-hans/4.1/ref/contrib/admin/filters/#using-a-simplelistfilter)">[3]</span></a></sup></p>
<p>以下代码示例创建自定义的 <code>filter</code>，用来筛选域名过期时间</p>
<figure class="highlight python"><figcaption><span>admin.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> domains_collect <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> django.utils.translation <span class="keyword">import</span> gettext_lazy <span class="keyword">as</span> _</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> calendar</span><br><span class="line"></span><br><span class="line"><span class="meta">@admin.register(<span class="params">models.RawDomains</span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RawDomainsAdmin</span>(admin.ModelAdmin):</span><br><span class="line">    list_display = (<span class="string">&#x27;domain&#x27;</span>, <span class="string">&#x27;status&#x27;</span>, <span class="string">&#x27;domain_created_time&#x27;</span>, <span class="string">&#x27;expire&#x27;</span>)</span><br><span class="line">    search_fields = (<span class="string">&#x27;domain&#x27;</span>,)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">DomainExpireTimeFilter</span>(admin.SimpleListFilter):</span><br><span class="line">        title = _(<span class="string">&#x27;域名过期时间&#x27;</span>)</span><br><span class="line">        parameter_name = <span class="string">&#x27;expire&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">lookups</span>(<span class="params">self, request, model_admin</span>):</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">                (<span class="string">&#x27;already_expired&#x27;</span>, _(<span class="string">&#x27;已到期&#x27;</span>)),</span><br><span class="line">                (<span class="string">&#x27;today_expired&#x27;</span>, _(<span class="string">&#x27;今天到期&#x27;</span>)),</span><br><span class="line">                (<span class="string">&#x27;m_expired&#x27;</span>, _(<span class="string">&#x27;本月到期&#x27;</span>)),</span><br><span class="line">                (<span class="string">&#x27;nm_expired&#x27;</span>, _(<span class="string">&#x27;下月到期&#x27;</span>)),</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">queryset</span>(<span class="params">self, request, queryset</span>):</span><br><span class="line">            <span class="keyword">if</span> self.value() == <span class="string">&#x27;already_expired&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> queryset.<span class="built_in">filter</span>(expire__lt=datetime.datetime.now(tz=datetime.timezone.utc))</span><br><span class="line">            <span class="keyword">if</span> self.value() == <span class="string">&#x27;today_expired&#x27;</span>:</span><br><span class="line">                today_date = datetime.date.today()</span><br><span class="line">                y, m, d = today_date.year, today_date.month, today_date.day</span><br><span class="line">                today_start = datetime.datetime(y, m, d, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">                today_end = datetime.datetime(y, m, d, <span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>)</span><br><span class="line">                <span class="keyword">return</span> queryset.<span class="built_in">filter</span>(expire__lt=today_end, expire__gt=today_start)</span><br><span class="line">            <span class="keyword">if</span> self.value() == <span class="string">&#x27;m_expired&#x27;</span>:</span><br><span class="line">                today_data = datetime.date.today()</span><br><span class="line">                y, m = today_data.year, today_data.month</span><br><span class="line">                last_day_this_month = calendar.monthrange(y, m)[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">                day_start = datetime.datetime(y, m, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">                day_end = datetime.datetime(y, m, last_day_this_month, <span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>)</span><br><span class="line">                <span class="keyword">return</span> queryset.<span class="built_in">filter</span>(expire__lt=day_end, expire__gt=day_start)</span><br><span class="line">            <span class="keyword">if</span> self.value() == <span class="string">&#x27;nm_expired&#x27;</span>:</span><br><span class="line">                today_data = datetime.date.today()</span><br><span class="line">                y, m = today_data.year, today_data.month</span><br><span class="line">                last_day_this_month = calendar.monthrange(y, m)[<span class="number">1</span>]</span><br><span class="line">                next_m_1d = datetime.date(y, m, <span class="number">1</span>) + datetime.timedelta(last_day_this_month)</span><br><span class="line">                y, m = next_m_1d.year, next_m_1d.month</span><br><span class="line">                last_day_next_month = calendar.monthrange(y, m)[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">                day_start = datetime.datetime(y, m, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">                day_end = datetime.datetime(y, m, last_day_next_month, <span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>)</span><br><span class="line">                <span class="keyword">return</span> queryset.<span class="built_in">filter</span>(expire__lt=day_end, expire__gt=day_start)</span><br><span class="line"></span><br><span class="line">    list_filter = (<span class="string">&#x27;status&#x27;</span>, DomainExpireTimeFilter)</span><br></pre></td></tr></table></figure>
<h3 id="自定义搜索功能"><a href="#自定义搜索功能" class="headerlink" title="自定义搜索功能"></a>自定义搜索功能</h3><p>Admin 后台默认只能搜索一个目标，本实例配置允许搜索 <strong>以空格分割的</strong> 多个目标内容。此功能主要是通过重写方法 <code>get_search_results</code> 实现。</p>
<figure class="highlight python"><figcaption><span>admin.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Q</span><br><span class="line"><span class="keyword">from</span> domains_collect <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RawDomainsAdmin</span>(admin.ModelAdmin):</span><br><span class="line">    search_fields = (<span class="string">&#x27;domain&#x27;</span>,)</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">get_search_results</span>(<span class="params">self, request, queryset, search_term</span>):</span><br><span class="line">        <span class="comment"># 如果没有查询字符串，则返回所有内容</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> search_term:</span><br><span class="line">            <span class="keyword">return</span> queryset, <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 获取搜索参数并分割为多个搜索项</span></span><br><span class="line">        search_terms = search_term.split()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 构建查询表达式</span></span><br><span class="line">        q_objects = Q()</span><br><span class="line">        <span class="keyword">for</span> term <span class="keyword">in</span> search_terms:</span><br><span class="line">            q_objects |= Q(domain__icontains=term)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 执行搜索操作</span></span><br><span class="line">        queryset = queryset.<span class="built_in">filter</span>(q_objects)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> queryset, <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3 id="内联"><a href="#内联" class="headerlink" title="内联"></a>内联</h3><p>管理界面可以在同一页面上与父模型编辑模型。这些被称为内联 <sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[InlineModelAdmin ](https://docs.djangoproject.com/zh-hans/4.1/ref/contrib/admin/#inlinemodeladmin-objects)">[4]</span></a></sup></p>
<p>以下示例中，<code>RawDomainsAdmin</code> 存放域名相关信息</p>
<figure class="highlight python"><figcaption><span>models.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RawDomains</span>(models.Model):</span><br><span class="line">    domain = models.CharField(max_length=<span class="number">64</span>, unique=<span class="literal">True</span>, blank=<span class="literal">False</span>, help_text=<span class="string">&quot;域名&quot;</span>, verbose_name=<span class="string">&#x27;域名&#x27;</span>)</span><br><span class="line">    expire = models.DateTimeField(help_text=<span class="string">&quot;域名过期时间&quot;</span>, verbose_name=<span class="string">&#x27;域名过期时间&#x27;</span>)</span><br><span class="line">    domain_created_time = models.DateTimeField(help_text=<span class="string">&quot;域名注册时间&quot;</span>, verbose_name=<span class="string">&#x27;域名注册时间&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><code>DomainProjectInfo</code> 存放项目和域名的关联信息，其中 <code>domain</code> 是和 <code>RawDomains</code> 的 <code>OneToOneField</code> 的关系。</p>
<figure class="highlight python"><figcaption><span>models.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DomainProjectInfo</span>(models.Model):</span><br><span class="line">    domain = models.OneToOneField(RawDomains, on_delete=models.CASCADE, help_text=<span class="string">&quot;域名&quot;</span>, verbose_name=<span class="string">&quot;域名&quot;</span>)</span><br><span class="line">    project = models.ForeignKey(<span class="string">&#x27;Project&#x27;</span>, on_delete=models.CASCADE, help_text=<span class="string">&quot;项目&quot;</span>, verbose_name=<span class="string">&quot;项目&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>在 admin 页面中配置项目信息内联到域名信息中</p>
<figure class="highlight python"><figcaption><span>admin.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@admin.register(<span class="params">models.RawDomains</span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RawDomainsAdmin</span>(admin.ModelAdmin):</span><br><span class="line">    list_display = (<span class="string">&#x27;domain&#x27;</span>, <span class="string">&#x27;status&#x27;</span>, <span class="string">&#x27;domain_created_time&#x27;</span>, <span class="string">&#x27;expire&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">DomainProjectDetails</span>(admin.StackedInline):</span><br><span class="line">        model = models.DomainProjectInfo</span><br><span class="line"></span><br><span class="line">    inlines = [DomainProjectDetails]</span><br></pre></td></tr></table></figure>
<p>实现效果如下<br><img src="https://i.csms.tech/img_128.png"></p>
<p><a href="https://www.cnblogs.com/yoyoketang/p/10511220.html">其他示例参考</a></p>
<p>如果要在 <code>RawDomains</code> 列表中展示和筛选 <code>DomainProjectInfo</code> 中的信息，可以使用以下方法实现</p>
<figure class="highlight python"><figcaption><span>admin.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@admin.register(<span class="params">models.RawDomains</span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RawDomainsAdmin</span>(admin.ModelAdmin):</span><br><span class="line">    list_display = (<span class="string">&#x27;domain&#x27;</span>, <span class="string">&#x27;status&#x27;</span>, <span class="string">&#x27;domain_created_time&#x27;</span>, <span class="string">&#x27;expire&#x27;</span>, <span class="string">&#x27;use_status&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">use_status</span>(<span class="params">self, obj</span>):</span><br><span class="line">        <span class="keyword">return</span> obj.domainprojectinfo.status</span><br><span class="line">       </span><br><span class="line">    list_filter = (<span class="string">&#x27;domain&#x27;</span>, <span class="string">&#x27;status&#x27;</span>,  <span class="string">&#x27;domainprojectinfo__status&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><code>list_display</code> 中的 <code>use_status</code> 属于自定义字段，其值来自 <code>OneToOneField</code> 表的 <code>status</code> 字段。</p>
<p><code>list_filter</code> 中的值通过 <code>model__属性</code> 的方式引用 <code>OneToOneField</code> 中的字段。</p>
<p>要查看 <code>OneToOneField</code> 对应的表，可以查看 model 的属性值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>RawDomains.domainprojectinfo</span><br><span class="line">&lt;django.db.models.fields.related_descriptors.ReverseOneToOneDescriptor <span class="built_in">object</span> at <span class="number">0x7f920ced2810</span>&gt;</span><br></pre></td></tr></table></figure>
<h3 id="修改后台页面中显示的-APP-名称"><a href="#修改后台页面中显示的-APP-名称" class="headerlink" title="修改后台页面中显示的 APP 名称"></a>修改后台页面中显示的 APP 名称</h3><p>APP 是通过 <code>python manage.py startapp</code> 创建的，创建后 APP 项目所在目录下包含 <code>apps.py</code>，其中有 APP 相关的配置。默认 APP 在后台页面显示的名称为创建 APP 时指定的 APP 名称，要修改在 admin 页面上面显示的名称，可以在 <code>apps.py</code> 中添加 <code>verbose_name = &#39;Myname&#39;&#39;</code></p>
<figure class="highlight python"><figcaption><span>apps.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.apps <span class="keyword">import</span> AppConfig</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DomainsCollectConfig</span>(<span class="title class_ inherited__">AppConfig</span>):</span><br><span class="line">    default_auto_field = <span class="string">&#x27;django.db.models.BigAutoField&#x27;</span></span><br><span class="line">    name = <span class="string">&#x27;domains_collect&#x27;</span></span><br><span class="line">    verbose_name = <span class="string">&#x27;域名统计&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="admin-显示操作日志"><a href="#admin-显示操作日志" class="headerlink" title="admin 显示操作日志"></a>admin 显示操作日志</h3><p><code>ModelAdmin</code> 本身就有日志记录功能，<code>LogEntry</code> 类可以跟踪通过管理界面完成的对象的添加、更改和删除。 <sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[LogEntry 对象](https://docs.djangoproject.com/zh-hans/4.1/ref/contrib/admin/#logentry-objects)">[5]</span></a></sup></p>
<p>在项目 APP 的 <code>admin.py</code> 文件中增加以下内容，可以展示后台操作日志</p>
<figure class="highlight python"><figcaption><span>admin.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.admin.models <span class="keyword">import</span> LogEntry</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@admin.register(<span class="params">LogEntry</span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogEntryAdmin</span>(admin.ModelAdmin):</span><br><span class="line">    list_display = [<span class="string">&#x27;action_time&#x27;</span>, <span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;object_repr&#x27;</span>, <span class="string">&#x27;object_id&#x27;</span>, <span class="string">&#x27;action_flag&#x27;</span>, <span class="string">&#x27;content_type&#x27;</span>,<span class="string">&#x27;change_message&#x27;</span>]</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>其中</p>
<ul>
<li><code>object_repr</code>, <code>object_id</code> 分别指被操作对象的 ID 和字符串表示。</li>
<li>‘content_type’ - 表示被操作对象的所属 model</li>
</ul>
<h3 id="根据不同的登陆用户显示不同的列"><a href="#根据不同的登陆用户显示不同的列" class="headerlink" title="根据不同的登陆用户显示不同的列"></a>根据不同的登陆用户显示不同的列</h3><p>在需要权限控制的场景中，不同用户拥有的权限或者安全级别可能不一样，被允许看到的信息也会不一样。以下示例可以实现超级管理员用户和其他用户登陆后展示不同的列</p>
<p>主要的实现思路是重写 <code>get_list_display</code> 方法，根据不同用户返回不同列 <sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[get_list_display](https://docs.djangoproject.com/zh-hans/4.1/ref/contrib/admin/#django.contrib.admin.ModelAdmin.get_list_display)">[6]</span></a></sup></p>
<figure class="highlight python"><figcaption><span>admin.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@admin.register(<span class="params">models.Servers</span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServersAdmin</span>(admin.ModelAdmin):</span><br><span class="line">    list_display = (<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;inDeparMent&#x27;</span>,<span class="string">&#x27;inVender&#x27;</span>,<span class="string">&#x27;inOwner&#x27;</span>,<span class="string">&#x27;get_app&#x27;</span>,<span class="string">&#x27;usedFor&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;financeCode&#x27;</span>,<span class="string">&#x27;ip&#x27;</span>,<span class="string">&#x27;price&#x27;</span>,<span class="string">&#x27;validDateTo&#x27;</span>,<span class="string">&#x27;status&#x27;</span>,<span class="string">&#x27;payStatus&#x27;</span>,<span class="string">&#x27;hwInfo&#x27;</span>,<span class="string">&#x27;comment&#x27;</span>,<span class="string">&#x27;createTime&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    date_hierarchy = <span class="string">&quot;createTime&quot;</span></span><br><span class="line">    list_per_page = <span class="number">200</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_list_display</span>(<span class="params">self,request</span>):</span><br><span class="line">        user = request.user</span><br><span class="line">        <span class="keyword">if</span> user.is_superuser:</span><br><span class="line">            <span class="keyword">return</span> [<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;inDeparMent&#x27;</span>, <span class="string">&#x27;inVender&#x27;</span>, <span class="string">&#x27;inOwner&#x27;</span>,<span class="string">&#x27;get_app&#x27;</span>, <span class="string">&#x27;usedFor&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;financeCode&#x27;</span>, <span class="string">&#x27;ip&#x27;</span>, <span class="string">&#x27;price&#x27;</span>, <span class="string">&#x27;validDateTo&#x27;</span>, <span class="string">&#x27;status&#x27;</span>, <span class="string">&#x27;payStatus&#x27;</span>, <span class="string">&#x27;hwInfo&#x27;</span>, <span class="string">&#x27;comment&#x27;</span>, <span class="string">&#x27;createTime&#x27;</span>]</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            group = Group.objects.get(user=user)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;group = %s&quot;</span> %(group))</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">dir</span>(group))</span><br><span class="line">            <span class="keyword">if</span> group.name == <span class="string">&quot;ops&quot;</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;group mached&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> [<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;inDeparMent&#x27;</span>, <span class="string">&#x27;inVender&#x27;</span>, <span class="string">&#x27;inOwner&#x27;</span>, <span class="string">&#x27;get_app&#x27;</span>, <span class="string">&#x27;usedFor&#x27;</span>,</span><br><span class="line">                        <span class="string">&#x27;financeCode&#x27;</span>, <span class="string">&#x27;ip&#x27;</span>, <span class="string">&#x27;price&#x27;</span>, <span class="string">&#x27;validDateTo&#x27;</span>, <span class="string">&#x27;status&#x27;</span>, <span class="string">&#x27;payStatus&#x27;</span>, <span class="string">&#x27;hwInfo&#x27;</span>, <span class="string">&#x27;comment&#x27;</span>, <span class="string">&#x27;createTime&#x27;</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> ObjectDoesNotExist:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;inDeparMent&#x27;</span>, <span class="string">&#x27;inVender&#x27;</span>, <span class="string">&#x27;inOwner&#x27;</span>,<span class="string">&#x27;get_app&#x27;</span>,</span><br><span class="line">                   <span class="string">&#x27;ip&#x27;</span>,  <span class="string">&#x27;validDateTo&#x27;</span>, <span class="string">&#x27;status&#x27;</span>,</span><br><span class="line">                     <span class="string">&#x27;hwInfo&#x27;</span>, <span class="string">&#x27;comment&#x27;</span>, <span class="string">&#x27;createTime&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="admin-后台实现批量修改带外键的字段"><a href="#admin-后台实现批量修改带外键的字段" class="headerlink" title="admin 后台实现批量修改带外键的字段"></a>admin 后台实现批量修改带外键的字段</h3><p>本示例演示实现在 admin 后台批量修改 model 状态（通过自定义 action 实现），其中 model 的状态是外键到了其他 model，示例 models 如下</p>
<figure class="highlight python"><figcaption><span>models.py</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Status</span>(models.Model):</span><br><span class="line">    status = models.CharField(max_length=<span class="number">32</span>, unique=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.status</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Project</span>(models.Model):</span><br><span class="line">    status = models.ForeignKey(<span class="string">&#x27;Status&#x27;</span>, on_delete=models.CASCADE)</span><br><span class="line">    project = models.CharField(max_length=<span class="number">128</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.project</span><br></pre></td></tr></table></figure>
<p>为了实现可以在后台批量修改 <code>status</code>，需要在 <code>Project</code> 的后台注册类中编写自定义的 <code>action</code>，用户选择多个对象, 点击执行后, 会跳转到中间页面, 在中间页面中下拉选择要更改的状态, 主要代码如下</p>
<figure class="highlight python"><figcaption><span>admin.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@admin.register(<span class="params">models.Project</span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProjectAdmin</span>(admin.ModelAdmin):</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">update_status</span>(<span class="params">self, request, queryset</span>):</span><br><span class="line">            <span class="comment"># 用户可选择的状态</span></span><br><span class="line">            status_choices = [(status.<span class="built_in">id</span>, status.status) <span class="keyword">for</span> status <span class="keyword">in</span> Status.objects.<span class="built_in">all</span>()]</span><br><span class="line">            context = &#123;</span><br><span class="line">                <span class="string">&#x27;queryset&#x27;</span>: queryset,</span><br><span class="line">                <span class="string">&#x27;status_choices&#x27;</span>: status_choices,</span><br><span class="line">                <span class="string">&#x27;action_name&#x27;</span>: <span class="string">&#x27;update_status&#x27;</span>,</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> render(request, <span class="string">&#x27;admin/change_status.html&#x27;</span>, context)</span><br><span class="line"></span><br><span class="line">    update_domain_status.short_description = <span class="string">&#x27;批量修改状态&#x27;</span></span><br><span class="line"></span><br><span class="line">    actions = [<span class="string">&#x27;update_domain_status&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>以上代码中, 中间页面的 html 文件位于 <code>admin/change_status.html</code>，此文件主要实现用户选择状态，然后提交一个表单到指定的 url，进行实际状态的修改动作，文件内容如下</p>
<figure class="highlight html"><figcaption><span>admin/change_status.html</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;% extends &#x27;admin/base_site.html&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;&#123;% url &#x27;my_app:update_status&#x27; %&#125;&quot;</span>&gt;</span></span><br><span class="line">        &#123;% csrf_token %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;target&quot;</span>&gt;</span>修改对象:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;results&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">table</span> <span class="attr">id</span>=<span class="string">&quot;result_list&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">                &#123;% for query in queryset %&#125;</span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; query &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                &#123;% endfor %&#125;</span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;status&quot;</span>&gt;</span>Status:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;status&quot;</span> <span class="attr">required</span>&gt;</span></span><br><span class="line">            &#123;% for choice in status_choices %&#125;</span><br><span class="line">                <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123; choice.0 &#125;&#125;&quot;</span>&gt;</span>&#123;&#123; choice.1 &#125;&#125;<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            &#123;% endfor %&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;queryset&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123; queryset &#125;&#125;&quot;</span> <span class="attr">hidden</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Change status&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>
<p><code>&lt;input name=&quot;queryset&quot; value=&quot;&#123;&#123; queryset &#125;&#125;&quot; hidden=&quot;true&quot;&gt;</code> 的主要作用是将用户选择的 QuerySet 提交到要处理状态变更的 url</p>
<p>用户选择状态并提交，数据会被提交给 <code>&#123;% url 'my_app:update_status' %&#125;</code>，因此需要实现此 url，以接收数据并执行实际的状态变更的动作</p>
<p>在 <code>urls.py</code> 中定义以下内容</p>
<figure class="highlight python"><figcaption><span>urls.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> .views <span class="keyword">import</span> update_status_view</span><br><span class="line"></span><br><span class="line">app_name = <span class="string">&#x27;my_app&#x27;</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;update_status/&#x27;</span>, update_status_view, name=<span class="string">&#x27;update_status&#x27;</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>在 <code>views.py</code> 文件中定义视图函数 <code>update_status_view</code>，接收用户提交的数据，并更新状态，最后重定向到列表页面</p>
<figure class="highlight python"><figcaption><span>views.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> redirect</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> reverse</span><br><span class="line"><span class="keyword">from</span> django.apps <span class="keyword">import</span> apps</span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> messages</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update_status_view</span>(<span class="params">request</span>):</span><br><span class="line">    </span><br><span class="line">    status = post_data[<span class="string">&#x27;status&#x27;</span>]</span><br><span class="line">    queryset_string = post_data[<span class="string">&#x27;queryset&#x27;</span>]</span><br><span class="line">    model_name = <span class="string">&quot;Project&quot;</span></span><br><span class="line">    model = apps.get_model(app_label=<span class="string">&quot;my_app&quot;</span>, model_name=model_name)</span><br><span class="line">    obj_str_list = queryset_string.replace(<span class="string">&#x27;&lt;QuerySet&#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;&lt;DomainProjectInfo: &#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;[&#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;&#x27;</span>).split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    queryset_list = []</span><br><span class="line">    <span class="keyword">for</span> obj_str <span class="keyword">in</span> obj_str_list:</span><br><span class="line">        obj = model.objects.get(project=obj_str)</span><br><span class="line">        queryset_list.append(obj)</span><br><span class="line"></span><br><span class="line">    queryset = model.objects.<span class="built_in">filter</span>(pk__in=[obj.pk <span class="keyword">for</span> obj <span class="keyword">in</span> queryset_list])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> obj <span class="keyword">in</span> queryset:</span><br><span class="line">        obj.status_id = <span class="built_in">int</span>(status)</span><br><span class="line">        obj.save()</span><br><span class="line"></span><br><span class="line">    messages.add_message(request, messages.SUCCESS, <span class="string">&#x27;Changes saved successfully.&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> redirect(reverse(<span class="string">&#x27;admin:my_app_project_changelist&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h3 id="自定义页面或者视图中，向-admin-添加显示消息"><a href="#自定义页面或者视图中，向-admin-添加显示消息" class="headerlink" title="自定义页面或者视图中，向 admin 添加显示消息"></a>自定义页面或者视图中，向 admin 添加显示消息</h3><p>在 Django 中，可以使用 <code>messages</code> 框架在重定向后向用户显示消息。在视图函数中使用 <code>messages.add_message()</code> 函数将消息添加到消息框架中，并使用 <code>messages.SUCCESS</code>，<code>messages.ERROR</code> 或 <code>messages.WARNING</code> 等常量指定消息的级别。</p>
<p>下面是一个示例视图函数，演示如何重定向到 <code>myapp_model</code> 的更改列表并显示成功消息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> messages</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> redirect, reverse</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_view</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="comment"># Do some processing here</span></span><br><span class="line">    messages.add_message(request, messages.SUCCESS, <span class="string">&#x27;Changes saved successfully.&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> redirect(reverse(<span class="string">&#x27;admin:myapp_model_changelist&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>这将 <code>Changes saved successfully.</code> 消息添加到消息框架中，并重定向到 <code>myapp_model</code> 的更改列表视图。当用户从消息框架中看到消息时，它将以绿色背景突出显示，因为我们在这里使用了 <code>messages.SUCCESS</code> 常量。</p>
<h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><h2 id="Related-Field-got-invalid-lookup-icontains"><a href="#Related-Field-got-invalid-lookup-icontains" class="headerlink" title="Related Field got invalid lookup: icontains"></a>Related Field got invalid lookup: icontains</h2><p><a href="https://stackoverflow.com/questions/24569687/searching-by-related-fields-in-django-admin">此问题说明示例</a></p>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://docs.djangoproject.com/zh-hans/4.1/ref/contrib/admin/actions/#admin-actions">管理 actions</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://docs.djangoproject.com/zh-hans/4.1/ref/contrib/admin/#modeladmin-options">ModelAdmin 对象</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://docs.djangoproject.com/zh-hans/4.1/ref/contrib/admin/filters/#using-a-simplelistfilter">Using a SimpleListFilter</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://docs.djangoproject.com/zh-hans/4.1/ref/contrib/admin/#inlinemodeladmin-objects">InlineModelAdmin </a><a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://docs.djangoproject.com/zh-hans/4.1/ref/contrib/admin/#logentry-objects">LogEntry 对象</a><a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://docs.djangoproject.com/zh-hans/4.1/ref/contrib/admin/#django.contrib.admin.ModelAdmin.get_list_display">get_list_display</a><a href="#fnref:6" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django admin 模板分析及使用</title>
    <url>/202303241020/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Python 3.11</li>
<li>Django 4.1</li>
</ul>
<h1 id="admin-模板解析"><a href="#admin-模板解析" class="headerlink" title="admin 模板解析"></a>admin 模板解析</h1><p>Django 模板之间存在各种复杂的继承关系，最基础的模板为 <code>base.html</code>，文件位于 <code>python3.11/site-packages/django/contrib/admin/templates/admin/base.html</code>。下面以 Admin 页面中的各个模块来解析实现对应模块的模板及代码。</p>
<h2 id="title"><a href="#title" class="headerlink" title="title"></a>title</h2><p><code>title</code> 指网页标题，以 Admin 站点的首页为例，首页的模板文件 <code>index.html</code> 中未定义 <code>title</code> 信息，而是继承自 <code>base_site.html</code></p>
<figure class="highlight python"><figcaption><span>base_site.html</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;% extends <span class="string">&quot;admin/base.html&quot;</span> %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block title %&#125;&#123;% <span class="keyword">if</span> subtitle %&#125;&#123;&#123; subtitle &#125;&#125; | &#123;% endif %&#125;&#123;&#123; title &#125;&#125; | &#123;&#123; site_title|default:_(<span class="string">&#x27;Django site admin&#x27;</span>) &#125;&#125;&#123;% endblock </span><br><span class="line">%&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>base_site.html</code> 模板继承了模板 <code>base.html</code>，并使用 <code>&#123;% block title %&#125;</code> 标签复写了继承自 <code>base.html</code> 模板的 <code>title</code> 信息。默认显示 <code>Django site admin</code>，如果应用的 <code>admin.py</code> 中定义了 <code>admin.site.site_title</code>，则显示其内容</p>
<figure class="highlight python"><figcaption><span>base.html</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;% load i18n static %&#125;&lt;!DOCTYPE html&gt;</span><br><span class="line">&#123;% get_current_language <span class="keyword">as</span> LANGUAGE_CODE %&#125;&#123;% get_current_language_bidi <span class="keyword">as</span> LANGUAGE_BIDI %&#125;</span><br><span class="line">&lt;html lang=<span class="string">&quot;&#123;&#123; LANGUAGE_CODE|default:&quot;</span>en-us<span class="string">&quot; &#125;&#125;&quot;</span> <span class="built_in">dir</span>=<span class="string">&quot;&#123;&#123; LANGUAGE_BIDI|yesno:&#x27;rtl,ltr,auto&#x27; &#125;&#125;&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125;&lt;/title&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>基础模板 <code>base.html</code> 中 <code>title</code> 信息默认为空。</p>
<h2 id="Django-管理或站点标题"><a href="#Django-管理或站点标题" class="headerlink" title="Django 管理或站点标题"></a>Django 管理或站点标题</h2><p>Admin 管理页面最顶部左上角会展示默认的 <code>Django 管理</code> 或者站点标题，如果应用的 <code>admin.py</code> 中配置了 <code>admin.site.site_header</code>，则显示站点标题，这是一个链接，点击后会跳转首页。<br><img src="https://i.csms.tech/img_130.png"></p>
<p>这部分的实现是通过继承 <code>base_site.html</code> 实现，其中的 <code>&#123;% block branding %&#125;</code> 定义了这部分内容。</p>
<figure class="highlight python"><figcaption><span>base_site.html</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;% extends <span class="string">&quot;admin/base.html&quot;</span> %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block title %&#125;&#123;% <span class="keyword">if</span> subtitle %&#125;&#123;&#123; subtitle &#125;&#125; | &#123;% endif %&#125;&#123;&#123; title &#125;&#125; | &#123;&#123; site_title|default:_(<span class="string">&#x27;Django site admin&#x27;</span>) &#125;&#125;&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block branding %&#125;</span><br><span class="line">&lt;h1 <span class="built_in">id</span>=<span class="string">&quot;site-name&quot;</span>&gt;&lt;a href=<span class="string">&quot;&#123;% url &#x27;admin:index&#x27; %&#125;&quot;</span>&gt;&#123;&#123; site_header|default:_(<span class="string">&#x27;Django administration&#x27;</span>) &#125;&#125;&lt;/a&gt;&lt;/h1&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block nav-<span class="keyword">global</span> %&#125;&#123;% endblock %&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="用户欢迎信息"><a href="#用户欢迎信息" class="headerlink" title="用户欢迎信息"></a>用户欢迎信息</h2><p>Django admin 站点默认会显示如下的欢饮信息及修改密码、注销等链接<br><img src="https://i.csms.tech/img_131.png"><br>此处的配置位于 <code>base.html</code> 中的 <code>&#123;% block usertools %&#125;</code> 块内，<code>&#123;% block usertools %&#125;</code> 块位于 <code> &#123;% block header %&#125;</code> 块内。</p>
<figure class="highlight python"><figcaption><span>base.html</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;% block header %&#125;</span><br><span class="line">&lt;div <span class="built_in">id</span>=<span class="string">&quot;header&quot;</span>&gt;</span><br><span class="line">    &lt;div <span class="built_in">id</span>=<span class="string">&quot;branding&quot;</span>&gt;</span><br><span class="line">    &#123;% block branding %&#125;&#123;% endblock %&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &#123;% block usertools %&#125;</span><br><span class="line"> &#123;% <span class="keyword">if</span> has_permission %&#125;</span><br><span class="line">    &lt;div <span class="built_in">id</span>=<span class="string">&quot;user-tools&quot;</span>&gt;</span><br><span class="line">        &#123;% block welcome-msg %&#125;</span><br><span class="line">            &#123;% translate <span class="string">&#x27;Welcome,&#x27;</span> %&#125;</span><br><span class="line">            &lt;strong&gt;&#123;% firstof user.get_short_name user.get_username %&#125;&lt;/strong&gt;.</span><br><span class="line">        &#123;% endblock %&#125;</span><br><span class="line">        &#123;% block userlinks %&#125;</span><br><span class="line">            &#123;% <span class="keyword">if</span> site_url %&#125;</span><br><span class="line">                &lt;a href=<span class="string">&quot;&#123;&#123; site_url &#125;&#125;&quot;</span>&gt;&#123;% translate <span class="string">&#x27;View site&#x27;</span> %&#125;&lt;/a&gt; /</span><br><span class="line">            &#123;% endif %&#125;</span><br><span class="line">            &#123;% <span class="keyword">if</span> user.is_active <span class="keyword">and</span> user.is_staff %&#125;</span><br><span class="line">                &#123;% url <span class="string">&#x27;django-admindocs-docroot&#x27;</span> <span class="keyword">as</span> docsroot %&#125;</span><br><span class="line">                &#123;% <span class="keyword">if</span> docsroot %&#125;</span><br><span class="line">                    &lt;a href=<span class="string">&quot;&#123;&#123; docsroot &#125;&#125;&quot;</span>&gt;&#123;% translate <span class="string">&#x27;Documentation&#x27;</span> %&#125;&lt;/a&gt; /</span><br><span class="line">                &#123;% endif %&#125;</span><br><span class="line">            &#123;% endif %&#125;</span><br><span class="line">            &#123;% <span class="keyword">if</span> user.has_usable_password %&#125;</span><br><span class="line">            &lt;a href=<span class="string">&quot;&#123;% url &#x27;admin:password_change&#x27; %&#125;&quot;</span>&gt;&#123;% translate <span class="string">&#x27;Change password&#x27;</span> %&#125;&lt;/a&gt; /</span><br><span class="line">            &#123;% endif %&#125;</span><br><span class="line">            &lt;a href=<span class="string">&quot;&#123;% url &#x27;admin:logout&#x27; %&#125;&quot;</span>&gt;&#123;% translate <span class="string">&#x27;Log out&#x27;</span> %&#125;&lt;/a&gt;</span><br><span class="line">        &#123;% endblock %&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"> &#123;% endif %&#125; </span><br><span class="line">    &#123;% endblock %&#125;</span><br><span class="line">    &#123;% block nav-<span class="keyword">global</span> %&#125;&#123;% endblock %&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>

<h1 id="自定义页面"><a href="#自定义页面" class="headerlink" title="自定义页面"></a>自定义页面</h1><h2 id="自定义和-Django-admin-风格一样的页面"><a href="#自定义和-Django-admin-风格一样的页面" class="headerlink" title="自定义和 Django admin 风格一样的页面"></a>自定义和 Django admin 风格一样的页面</h2><p>如果要自定义自己的页面，并实现和 Django admin 一致的风格，比如一样的 branding 和用户欢迎信息，可以使用如下代码实现</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% extends &quot;admin/base_site.html&quot; %&#125;</span><br><span class="line">&#123;% load i18n static %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block title %&#125;</span><br><span class="line">My Customize Site</span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block extrastyle %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block branding %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;site-name&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;% url &#x27;admin:index&#x27; %&#125;&quot;</span>&gt;</span>My Customize Site<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block usertools %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;user-tools&quot;</span>&gt;</span></span><br><span class="line">            &#123;% block welcome-msg %&#125;</span><br><span class="line">                &#123;% translate &#x27;Welcome,&#x27; %&#125;</span><br><span class="line">                <span class="tag">&lt;<span class="name">strong</span>&gt;</span>&#123;% firstof user.get_short_name user.get_username %&#125;<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>.</span><br><span class="line">            &#123;% endblock %&#125;</span><br><span class="line">            &#123;% block userlinks %&#125;</span><br><span class="line">                &#123;% if site_url %&#125;</span><br><span class="line">                    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;&#123; site_url &#125;&#125;&quot;</span>&gt;</span>&#123;% translate &#x27;View site&#x27; %&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span> /</span><br><span class="line">                &#123;% endif %&#125;</span><br><span class="line">                &#123;% if user.is_active and user.is_staff %&#125;</span><br><span class="line">                    &#123;% url &#x27;django-admindocs-docroot&#x27; as docsroot %&#125;</span><br><span class="line">                    &#123;% if docsroot %&#125;</span><br><span class="line">                        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;&#123; docsroot &#125;&#125;&quot;</span>&gt;</span>&#123;% translate &#x27;Documentation&#x27; %&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span> /</span><br><span class="line">                    &#123;% endif %&#125;</span><br><span class="line">                &#123;% endif %&#125;</span><br><span class="line">                &#123;% if user.has_usable_password %&#125;</span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;% url &#x27;admin:password_change&#x27; %&#125;&quot;</span>&gt;</span>&#123;% translate &#x27;Change password&#x27; %&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span> /</span><br><span class="line">                &#123;% endif %&#125;</span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;% url &#x27;admin:logout&#x27; %&#125;&quot;</span>&gt;</span>&#123;% translate &#x27;Log out&#x27; %&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            &#123;% endblock %&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block breadcrumbs %&#125;&#123;% endblock %&#125;</span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">hello world</span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>django-bootstrap5 使用</title>
    <url>/202303221624/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Python3.11</li>
<li>Django4</li>
</ul>
<h1 id="django-bootstrap5-安装配置"><a href="#django-bootstrap5-安装配置" class="headerlink" title="django-bootstrap5 安装配置"></a>django-bootstrap5 安装配置</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install django-bootstrap5</span><br></pre></td></tr></table></figure>

<p>在项目配置文件 <code>settings.py</code> 中添加应用名</p>
<figure class="highlight shell"><figcaption><span>settings.py</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    ...</span><br><span class="line">    &#x27;django_bootstrap5&#x27;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h1 id="bootstrap5-使用"><a href="#bootstrap5-使用" class="headerlink" title="bootstrap5 使用"></a>bootstrap5 使用</h1>]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>django 定时任务</title>
    <url>/202208170917/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>centos 7</li>
<li>python 3.10</li>
<li>django 4.0</li>
<li>django-crontab</li>
</ul>
<p><code>django-crontab</code> 依赖 <code>Linux</code> 系统中的 <code>crontab</code>，因此只能在 <code>Linux</code> 系统中使用</p>
<span id="more"></span>

<h3 id="安装-django-crontab"><a href="#安装-django-crontab" class="headerlink" title="安装 django-crontab"></a>安装 django-crontab</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install django-crontab</span><br></pre></td></tr></table></figure>

<p><code>django-crontab</code> 插件是以 <code>app</code> 的方式存在， 将 <code>django-crontab</code> 添加到 <code>django</code> 工程配置文件 <code>settings.py</code> 中的 <code>INSTALLED_APPS</code></p>
<figure class="highlight shell"><figcaption><span>settings.py</span></figcaption><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    &#x27;django.contrib.admin&#x27;,</span><br><span class="line">    &#x27;django.contrib.auth&#x27;,</span><br><span class="line">    &#x27;django.contrib.contenttypes&#x27;,</span><br><span class="line">    &#x27;django.contrib.sessions&#x27;,</span><br><span class="line">    &#x27;django.contrib.messages&#x27;,</span><br><span class="line">    &#x27;django.contrib.staticfiles&#x27;,</span><br><span class="line">    ...</span><br><span class="line">    &#x27;django_crontab&#x27;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="配置定时任务"><a href="#配置定时任务" class="headerlink" title="配置定时任务"></a>配置定时任务</h3><p>假设定时任务路径为 <code>myapp.cron.scheduled_job</code><br>编写好定时任务后，要启用定时任务，需要在 <code>django</code> 工程配置文件 <code>settings.py</code> 中配置以下内容</p>
<figure class="highlight shell"><figcaption><span>settings.py</span></figcaption><table><tr><td class="code"><pre><span class="line">CRONJOBS = [</span><br><span class="line">    (&#x27;* * * * *&#x27;, &#x27;myapp.cron.scheduled_job&#x27;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>如果定时任务需要参数，可以使用如下格式</p>
<figure class="highlight shell"><figcaption><span>settings.py</span></figcaption><table><tr><td class="code"><pre><span class="line">CRONJOBS = [</span><br><span class="line">    (&#x27;* * * * *&#x27;, &#x27;myapp.cron.scheduled_job&#x27;, &#x27;&gt;&gt; run.log 2&gt;&amp;1&#x27;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>以上定时任务，会将任务执行过程中的标准输出和标准错误输出写入到文件 <code>run.log</code></p>
<p>也可以使用列表参数</p>
<figure class="highlight shell"><figcaption><span>settings.py</span></figcaption><table><tr><td class="code"><pre><span class="line">CRONJOBS = [</span><br><span class="line">    (&#x27;* * * * *&#x27;, &#x27;myapp.cron.scheduled_job&#x27;, [&#x27;list_args1&#x27;, &#x27;list_args2&#x27;], &#123;&#x27;dict_args1&#x27;: v1, &#x27;dict_args2&#x27;: v2&#125;),</span><br><span class="line">    (&#x27;* * * * *&#x27;, &#x27;myapp.cron.scheduled_job&#x27;, [&#x27;list_args1&#x27;])</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>其中，定时任务的第一部分（<code>* * * * *</code>），语法和 <code>Linux</code> 系统 <code>crontab</code> 一致，具体语法可参考： <a href="https://www.runoob.com/linux/linux-comm-crontab.html">linux crontab 语法</a></p>
<p>配置好定时任务之后，执行以下命令添加定时任务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 manage.py crontab add</span><br></pre></td></tr></table></figure>


<p>运行定时任务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 manage.py crontab run </span><br></pre></td></tr></table></figure>
<p>运行定时任务后，会在系统 <code>crontab</code> 中追加一个定时任务，可使用 <code>crontab -l</code> 命令查看定时任务  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">crontab -l</span></span><br><span class="line">* * * * * python3 /django/project/manage.py crontab run b4564bdabd9dcb16a9b69d79a612430f &gt;&gt; run.log 2&gt;&amp;1   # django-cronjobs for project</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>显示定时任务列表</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 manage.py crontab show</span><br></pre></td></tr></table></figure>
<p>删除定时任务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 manage.py crontab remove b4564bdabd9dc</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意事项</strong>： <code>CRONJOBS</code> 中配置的定时任务及所有参数不能有变量值，比如以下配置，在第二天时，不会再执行。</p>
<figure class="highlight shell"><figcaption><span>settings.py</span></figcaption><table><tr><td class="code"><pre><span class="line">CRONJOBS = [</span><br><span class="line">(&#x27;0 7 * * *&#x27;, &#x27;myapp.cron.scheduled_job&#x27;, &#x27;&gt;&gt; %s&#x27; time.time())</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>因为，<code>CRONJOBS</code> 生成任务时，会生成对应的哈希值（hashes），标识每个任务。所以，当文件名变更时，<code>CRONJOBS</code> 中的值每天都在变化，导致不同的定时任务哈希值（hashes）。而系统 <code>crontab</code> 定时任务中的任务哈希值还是第一次执行 <code>python3 manage.py crontab add</code> 时的值</p>
</blockquote>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://cloud.tencent.com/developer/article/1599968">django 定时任务 django-crontab 的使用</a><br><a href="https://www.runoob.com/linux/linux-comm-crontab.html">Linux crontab 命令</a></p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>django logging 模块</title>
    <url>/202208151622/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>python 3.10</li>
<li>django 4.0</li>
</ul>
<h1 id="Python-logging-模块说明"><a href="#Python-logging-模块说明" class="headerlink" title="Python logging 模块说明"></a>Python logging 模块说明</h1><p><code>Django</code> 使用 <code>Python</code> 内置的 <code>logging</code> 模块处理系统日志，一份 <code>Python logging</code> 配置由下面四个部分组成：</p>
<ul>
<li>Loggers</li>
<li>Handlers</li>
<li>Filters</li>
<li>Formatters</li>
</ul>
<h2 id="Loggers"><a href="#Loggers" class="headerlink" title="Loggers"></a>Loggers</h2><p><code>logger</code> 是日志系统的入口。每个 <code>logger</code> 都是命名了的 <code>bucket</code>， 消息写入 <code>bucket</code> 以便进一步处理<br><code>logger</code> 可以配置 <code>日志级别</code>。日志级别描述了由该 <code>logger</code> 处理的消息的严重性。<code>Python</code> 定义了下面几种日志级别：</p>
<ul>
<li><code>DEBUG</code>：排查故障时使用的低级别系统信息</li>
<li><code>INFO</code>：一般的系统信息</li>
<li><code>WARNING</code>：描述系统发生了一些小问题的信息</li>
<li><code>ERROR</code>：描述系统发生了大问题的信息</li>
<li><code>CRITICAL</code>：描述系统发生严重问题的信息</li>
</ul>
<p>每一条写入 <code>logger</code> 的消息都是一条 <code>日志记录</code>。每一条日志记录也包含 <code>日志级别</code>，代表对应消息的严重程度。日志记录还包含有用的元数据，来描述被记录了日志的事件细节，例如堆栈跟踪或者错误码。  </p>
<p>当 <code>logger</code> 处理一条消息时，会将自己的 <code>日志级别</code> 和这条消息的 <code>日志级别</code> 做对比。如果消息的日志级别匹配或者高于 <code>logger</code> 的日志级别，它就会被进一步处理。否则这条消息就会被忽略掉。  </p>
<p>当 <code>logger</code> 确定了一条消息需要处理之后，会把它传给 <code>Handler</code>。</p>
<span id="more"></span>

<h2 id="Handlers"><a href="#Handlers" class="headerlink" title="Handlers"></a>Handlers</h2><p><code>Handler</code> 是决定如何处理 <code>logger</code> 中每一条消息的引擎。它描述特定的日志行为，比如把消息输出到<code>屏幕(stdout)</code>、<code>文件</code>或<code>网络 socket</code>。<br>和 <code>logger</code> 一样，<code>handler</code> 也有 <code>日志级别</code> 的概念。如果一条日志记录的级别不匹配或者低于 <code>handler</code> 的日志级别，对应的消息会被 <code>handler</code> 忽略。</p>
<p>一个 <code>logger</code> 可以有多个 <code>handler</code>，每一个 <code>handler</code> 可以有不同的日志级别。这样就可以根据消息的重要性不同，来提供不同格式的输出。例如，你可以添加一个 <code>handler</code> 把 <code>ERROR</code> 和 <code>CRITICAL</code> 消息发送短消息，再添加另一个 <code>handler</code> 把所有的消息（包括 <code>ERROR</code> 和 <code>CRITICAL</code> 消息）保存到文件里以便日后分析。</p>
<h2 id="Filters"><a href="#Filters" class="headerlink" title="Filters"></a>Filters</h2><p>在日志记录从 <code>logger</code> 传到 <code>handler</code> 的过程中，使用 <code>Filter</code> 来做额外的控制。<br>默认情况下，只要级别匹配，任何日志消息都会被处理。不过，也可以通过添加 <code>filter</code> 来给日志处理的过程增加额外条件。例如，可以添加一个 <code>filter</code> 只允许某个特定来源的 <code>ERROR</code> 消息输出。  </p>
<p><code>Filter</code> 还被用来在日志输出之前对日志记录做修改。例如，可以写一个 <code>filter</code>，当满足一定条件时，把日志记录从 <code>ERROR</code> 降到 <code>WARNING</code> 级别。  </p>
<p><code>Filter</code> 在 <code>logger</code> 和 <code>handler</code> 中都可以添加；多个 <code>filter</code> 可以链接起来使用，来做多重过滤操作。</p>
<h2 id="Formatters"><a href="#Formatters" class="headerlink" title="Formatters"></a>Formatters</h2><p>日志记录最终是需要以文本来呈现的。<code>Formatter</code> 描述了文本的格式。一个 <code>formatter</code> 通常由包含 <a href="https://docs.python.org/3/library/logging.html#logrecord-attributes"><code>LogRecord attributes</code></a> 的 <code>Python 格式化字符串</code> 组成，不过你也可以为特定的格式来配置自定义的 formatter。</p>
<h1 id="Python-logging-模块使用方式介绍"><a href="#Python-logging-模块使用方式介绍" class="headerlink" title="Python logging 模块使用方式介绍"></a>Python logging 模块使用方式介绍</h1><p><code>logging</code> 模块提供了两种记录日志的方式：</p>
<ul>
<li>第一种方式是使用 <code>logging</code> 提供的模块级别的方法</li>
<li>第二种方式是使用 <code>Logging</code> 日志系统的四大组件</li>
</ul>
<h2 id="logging-模块级别方法使用说明"><a href="#logging-模块级别方法使用说明" class="headerlink" title="logging 模块级别方法使用说明"></a>logging 模块级别方法使用说明</h2><p><code>logging</code> 提供的模块级别常用方法有：  </p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>logging.basicConfig(**kwargs)</code></td>
<td>对 <code>root logger</code> 进行一次性配置</td>
<td></td>
</tr>
<tr>
<td><code>logging.debug(msg, args, *kwargs)</code></td>
<td>记录级别为 <code>DEBUG</code> 的日志</td>
<td><code>logging.debug(&#39;debug msg&#39;)</code></td>
</tr>
<tr>
<td><code>logging.info(msg, args, *kwargs)</code></td>
<td>记录级别为 <code>INFO</code> 的日志</td>
<td></td>
</tr>
<tr>
<td><code>logging.warning(msg, args, *kwargs)	</code></td>
<td>记录级别为 <code>WARNING</code> 的日志</td>
<td></td>
</tr>
<tr>
<td><code>logging.error(msg, args, *kwargs)	</code></td>
<td>记录级别为 <code>ERROR</code> 的日志</td>
<td></td>
</tr>
<tr>
<td><code>logging.critical(msg, args, *kwargs)	</code></td>
<td>记录级别为 <code>CRITICAL</code> 的日志</td>
<td></td>
</tr>
<tr>
<td><code>logging.log(level, args, *kwargs)	</code></td>
<td>记录级别为 <code>level</code> 的日志</td>
<td><code>logging.log(logging.DEBUG, &#39;debug msg&#39;)</code></td>
</tr>
</tbody></table>
<h3 id="logging-basicConfig-方法说明"><a href="#logging-basicConfig-方法说明" class="headerlink" title="logging.basicConfig() 方法说明"></a>logging.basicConfig() 方法说明</h3><p>该方法用于为 <code>logging</code> 日志系统做一些基本配置，<code>logging.basicConfig()</code> 函数是一个一次性的简单配置工具使，也就是说只有在第一次调用该函数时会起作用，后续再次调用该函数时完全不会产生任何操作的，多次调用的设置并不是累加操作。方法定义如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">logging.basicConfig(**kwargs)</span><br></pre></td></tr></table></figure>

<p>该方法可接收的关键字参数如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>filename</code></td>
<td>写入日志的文件名</td>
</tr>
<tr>
<td><code>filemode</code></td>
<td>打开日志文件的模式，默认为 <code>a</code>，该选项在 <code>filename</code> 指定时才生效</td>
</tr>
<tr>
<td><code>format</code></td>
<td>日志格式字符串, 指定日志输出时所包含的字段信息以及它们的顺序</td>
</tr>
<tr>
<td><code>datefmt</code></td>
<td>指定日期&#x2F;时间格式。该选项要在 <code>format</code> 中包含时间字段 <code>%(asctime)s</code> 时才有效</td>
</tr>
<tr>
<td><code>level</code></td>
<td>指定日志级别</td>
</tr>
<tr>
<td><code>stream</code></td>
<td>指定日志输出目标 stream，如 <code>sys.stdout</code>、<code>sys.stderr</code>以及 <code>网络stream</code>。需要说明的是，<code>stream</code> 和 <code>filename </code>不能同时提供，否则会引发 <code>ValueError</code> 异常</td>
</tr>
<tr>
<td><code>style</code></td>
<td><code>Python 3.2</code> 中新添加的配置项。指定 <code>format</code> 格式字符串的风格，可取值为 <code>%</code>、<code>&#123;</code> 和 <code>$</code>，默认为 <code>%</code></td>
</tr>
<tr>
<td><code>handlers</code></td>
<td><code>Python 3.3</code> 中新添加的配置项。该选项如果被指定，它应该是一个创建了多个 <code>Handler</code> 的可迭代对象，这些 <code>handler</code> 将会被添加到 <code>root logger</code> 。需要说明的是：<code>filename</code>、s<code>tream</code> 和 <code>handlers</code> 这三个配置项只能有一个存在，不能同时出现2个或3个，否则会引发 <code>ValueError</code> 异常。</td>
</tr>
</tbody></table>
<p><code>logging</code> 模块中定义好的可以用于 <code>format</code> 日志格式字符串的字段主要有  </p>
<table>
<thead>
<tr>
<th>字段名称</th>
<th>使用格式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>asctime</code></td>
<td><code>%(asctime)s</code></td>
<td>日志事件发生的时间(可读时间)，如：2003-07-08 16:49:45,896</td>
</tr>
<tr>
<td><code>created</code></td>
<td><code>%(created)f	</code></td>
<td>日志事件发生的时间(时间戳)</td>
</tr>
<tr>
<td><code>levelname</code></td>
<td><code>%(levelname)s</code></td>
<td>日志级别</td>
</tr>
<tr>
<td><code>levelno</code></td>
<td><code>%(levelno)s	</code></td>
<td>日志记录的数字形式的日志级别（10, 20, 30, 40, 50）</td>
</tr>
<tr>
<td><code>name</code></td>
<td><code>%(name)s	</code></td>
<td>所使用的日志器名称，默认是 <code>root</code>，因为默认使用的是 <code>rootLogger</code></td>
</tr>
<tr>
<td><code>message</code></td>
<td><code>%(message)s	</code></td>
<td>日志记录的文本内容</td>
</tr>
<tr>
<td><code>pathname</code></td>
<td><code>%(pathname)s	</code></td>
<td>调用日志记录方法的源码文件的全路径</td>
</tr>
<tr>
<td><code>filename</code></td>
<td><code>%(filename)s	</code></td>
<td><code>pathname</code> 的文件名部分，包含文件后缀</td>
</tr>
<tr>
<td><code>module</code></td>
<td><code>%(module)s	</code></td>
<td>filename的名称部分，不包含后缀</td>
</tr>
<tr>
<td><code>lineno</code></td>
<td><code>%(lineno)d	</code></td>
<td>调用日志记录方法的源代码所在的行号</td>
</tr>
<tr>
<td><code>funcName</code></td>
<td><code>%(funcName)s	</code></td>
<td>调用日志记录方法的函数名</td>
</tr>
<tr>
<td><code>process</code></td>
<td><code>%(process)d	</code></td>
<td>进程ID</td>
</tr>
<tr>
<td><code>processName</code></td>
<td><code>%(processName)s	</code></td>
<td>进程名称，Python 3.1新增</td>
</tr>
<tr>
<td><code>thread</code></td>
<td><code>%(thread)d	</code></td>
<td>线程ID</td>
</tr>
<tr>
<td><code>threadName</code></td>
<td><code>%(thread)s	</code></td>
<td>线程名称</td>
</tr>
</tbody></table>
<h3 id="logging-模块级别方法中的-kwargs-参数说明"><a href="#logging-模块级别方法中的-kwargs-参数说明" class="headerlink" title="logging 模块级别方法中的 kwargs 参数说明"></a>logging 模块级别方法中的 kwargs 参数说明</h3><p><code>logging.debug()</code>, <code>logging.info()</code> 等方法的定义中，除了 <code>msg</code> 和 <code>args</code> 参数外，还有一个 <code>**kwargs</code> 参数。它们支持3个关键字参数: <code>exc_info</code>, <code>stack_info</code>, <code>extra</code></p>
<ul>
<li><code>exc_info</code> : 布尔值，如果该参数的值设置为 <code>True</code>，则会将异常异常信息添加到日志消息中。如果没有异常信息则添加 <code>None</code> 到日志信息中。</li>
<li><code>stack_info</code> : 布尔值，默认值为 <code>False</code>。如果该参数的值设置为 <code>True</code>，栈信息将会被添加到日志信息中。</li>
<li><code>extra</code> : 这是一个字典（<code>dict</code>）参数，它可以用来自定义消息格式中所包含的字段，但是它的 <code>key</code> 不能与 <code>logging</code> 模块定义的字段冲突</li>
</ul>
<p><code>exc_info</code> 使用示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="number">1</span> / <span class="number">0</span></span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span>:</span><br><span class="line"><span class="meta">... </span>    logging.error(<span class="string">&#x27;except occor&#x27;</span>, exc_info=<span class="literal">True</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">ERROR:root:<span class="keyword">except</span> occor</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ZeroDivisionError: division by zero</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>stack_info</code> 使用示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="number">1</span> / <span class="number">0</span></span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span>:</span><br><span class="line"><span class="meta">... </span>    logging.error(<span class="string">&#x27;except&#x27;</span>, stack_info=<span class="literal">True</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">ERROR:root:<span class="keyword">except</span></span><br><span class="line">Stack (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">4</span>, <span class="keyword">in</span> &lt;module&gt;</span><br></pre></td></tr></table></figure>

<h1 id="Django-配置-logging"><a href="#Django-配置-logging" class="headerlink" title="Django 配置 logging"></a>Django 配置 logging</h1><p>在 <code>Django</code> 配置文件( <code>settings.py</code> ) 中添加以下配置  </p>
<figure class="highlight django"><figcaption><span>settings.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="language-xml">LOGGING = &#123;</span></span><br><span class="line"><span class="language-xml">    &#x27;version&#x27;: 1,</span></span><br><span class="line"><span class="language-xml">    &#x27;disable_existing_loggers&#x27;: False,</span></span><br><span class="line"><span class="language-xml">    &#x27;formatters&#x27;: &#123;</span></span><br><span class="line"><span class="language-xml">        &#x27;verbose&#x27;: &#123;</span></span><br><span class="line"><span class="language-xml">            &#x27;format&#x27;: &#x27;[%(asctime)s][%(levelname)s][%(pathname)s %(module)s %(lineno)s %(process)d %(thread)d] %(message)s&#x27;</span></span><br><span class="line"><span class="language-xml">        &#125;</span></span><br><span class="line"><span class="language-xml">    &#125;,</span></span><br><span class="line"><span class="language-xml">    &#x27;handlers&#x27;: &#123;</span></span><br><span class="line"><span class="language-xml">        &#x27;file&#x27;: &#123;</span></span><br><span class="line"><span class="language-xml">            &#x27;level&#x27;: &#x27;INFO&#x27;,</span></span><br><span class="line"><span class="language-xml">            &#x27;class&#x27;: &#x27;logging.handlers.RotatingFileHandler&#x27;,</span></span><br><span class="line"><span class="language-xml">            &#x27;filename&#x27;: &#x27;default.log&#x27;,</span></span><br><span class="line"><span class="language-xml">            &#x27;maxBytes&#x27;: 1024 * 1024 * 5,</span></span><br><span class="line"><span class="language-xml">            &#x27;backupCount&#x27;: 5,</span></span><br><span class="line"><span class="language-xml">            &#x27;formatter&#x27;: &#x27;verbose&#x27;,</span></span><br><span class="line"><span class="language-xml">        &#125;,</span></span><br><span class="line"><span class="language-xml">        &#x27;console&#x27;: &#123;</span></span><br><span class="line"><span class="language-xml">            &#x27;class&#x27;: &#x27;logging.StreamHandler&#x27;,</span></span><br><span class="line"><span class="language-xml">            &#x27;formatter&#x27;: &#x27;verbose&#x27;,</span></span><br><span class="line"><span class="language-xml">        &#125;,</span></span><br><span class="line"><span class="language-xml">        &#x27;django.server&#x27;: &#123;</span></span><br><span class="line"><span class="language-xml">            &#x27;level&#x27;: &#x27;INFO&#x27;,</span></span><br><span class="line"><span class="language-xml">            &#x27;class&#x27;: &#x27;logging.StreamHandler&#x27;,</span></span><br><span class="line"><span class="language-xml">            &#x27;formatter&#x27;: &#x27;verbose&#x27;,</span></span><br><span class="line"><span class="language-xml">        &#125;,</span></span><br><span class="line"><span class="language-xml">    &#125;,</span></span><br><span class="line"><span class="language-xml">    &#x27;loggers&#x27;: &#123;</span></span><br><span class="line"><span class="language-xml">        &#x27;django&#x27;: &#123;</span></span><br><span class="line"><span class="language-xml">            &#x27;handlers&#x27;: [&#x27;console&#x27;, &#x27;file&#x27;],</span></span><br><span class="line"><span class="language-xml">            &#x27;level&#x27;: &#x27;INFO&#x27;,</span></span><br><span class="line"><span class="language-xml">        &#125;,</span></span><br><span class="line"><span class="language-xml">        &#x27;django.server&#x27;: &#123;</span></span><br><span class="line"><span class="language-xml">            &#x27;handlers&#x27;: [&#x27;django.server&#x27;],</span></span><br><span class="line"><span class="language-xml">            &#x27;level&#x27;: &#x27;INFO&#x27;,</span></span><br><span class="line"><span class="language-xml">            &#x27;propagate&#x27;: False,</span></span><br><span class="line"><span class="language-xml">        &#125;,</span></span><br><span class="line"><span class="language-xml">    &#125;</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br></pre></td></tr></table></figure>

<p>代码中可以通过以下方式写入日志到对应 <code>logger</code>:  </p>
<figure class="highlight python"><figcaption><span>views.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logger = logging.getLogger(`django.server`)</span><br><span class="line">logger.info(<span class="string">&#x27;aaa&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p> <code>loggers</code> 类型 为 <code>django</code> 将处理所有类型的日志</p>
<h2 id="Django-简单使用示例"><a href="#Django-简单使用示例" class="headerlink" title="Django 简单使用示例"></a>Django 简单使用示例</h2><p>以下配置为 Django 中使用 <code>logging</code> 模块的简单示例，配置后在 Django 项目代码中直接使用 <code>logging</code> 方法即可写入日志</p>
<figure class="highlight python"><figcaption><span>settings.py</span></figcaption><table><tr><td class="code"><pre><span class="line">LOGGING = &#123;</span><br><span class="line">    <span class="string">&#x27;version&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;disable_existing_loggers&#x27;</span>: <span class="literal">False</span>,</span><br><span class="line">    <span class="string">&#x27;formatters&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;verbose&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;format&#x27;</span>: <span class="string">&#x27;[%(asctime)s][%(levelname)s][%(pathname)s %(module)s %(lineno)s %(process)d %(thread)d] %(message)s&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;handlers&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;file&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;INFO&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;logging.handlers.RotatingFileHandler&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;filename&#x27;</span>: <span class="string">&#x27;default.log&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;maxBytes&#x27;</span>: <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">5</span>,</span><br><span class="line">            <span class="string">&#x27;backupCount&#x27;</span>: <span class="number">5</span>,</span><br><span class="line">            <span class="string">&#x27;formatter&#x27;</span>: <span class="string">&#x27;verbose&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;console&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;logging.StreamHandler&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;formatter&#x27;</span>: <span class="string">&#x27;verbose&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;root&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;handlers&#x27;</span>: [<span class="string">&#x27;file&#x27;</span>, <span class="string">&#x27;console&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;DEBUG&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://docs.djangoproject.com/zh-hans/4.0/topics/logging/">django logging 模块官网说明</a></p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Django model 使用</title>
    <url>/202301191014/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Python 3.10</li>
<li>Django 4.1</li>
</ul>
<p>在 Project&#x2F;App 的 <code>models.py</code> 文件中创建 <code>model</code>，当 model 定义完成，Django 会自动生产一个后台管理接口，允许认证用户添加、更改和删除对象，只需在管理站点上注册模型即可 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[设计模型](https://docs.djangoproject.com/zh-hans/4.1/intro/overview/#design-your-model)">[1]</span></a></sup></p>
<h1 id="创建-model"><a href="#创建-model" class="headerlink" title="创建 model"></a>创建 model</h1><p>在 Project&#x2F;App 的 <code>models.py</code> 文件中创建 <code>model</code></p>
<figure class="highlight shell"><figcaption><span>models.py</span></figcaption><table><tr><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">公司部门</span></span><br><span class="line">class Department(models.Model):</span><br><span class="line">    name = models.CharField(max_length=24, unique=True, help_text=&quot;部门名称&quot;,verbose_name=&#x27;名称&#x27;)</span><br><span class="line">    shortName = models.CharField(max_length=8, unique=True, help_text=&quot;部门名称简称&quot;,verbose_name=&#x27;简称&#x27;)</span><br><span class="line">    manager = models.ForeignKey(&#x27;Emplyee&#x27;, on_delete=models.CASCADE, help_text=&quot;部门老大&quot;)</span><br><span class="line">    comment = models.CharField(max_length=256, blank=True, help_text=&quot;备注信息&quot;,verbose_name=&#x27;备注&#x27;)</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.shortName</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        # 管理后台显示的 model 名，最后面没有 &#x27;s&#x27;</span><br><span class="line">        verbose_name_plural = &quot;部门&quot;</span><br><span class="line">        </span><br><span class="line">        # 管理后台显示的 model 名，最后面有 &#x27;s&#x27;，显示为 &#x27;部门s&#x27;</span><br><span class="line">        verbose_name = &quot;部门&quot;</span><br><span class="line">        </span><br><span class="line">        # 数据库中生成的表名称 默认 app名称 + 下划线 + 类名</span><br><span class="line">        db_table = &quot;table_name&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="https://docs.djangoproject.com/zh-hans/4.1/ref/models/fields/">Django 模型字段参考</a></p>
<p>对修改后的 <code>model</code> 进行 <code>migrate</code>，以使在数据库中变更更改。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python manage.py makemigrations</span><br><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure>
<h1 id="model-注册到后台"><a href="#model-注册到后台" class="headerlink" title="model 注册到后台"></a>model 注册到后台</h1><p>在 Project&#x2F;App 的 <code>admin.py</code> 文件中注册 <code>model</code></p>
<figure class="highlight shell"><figcaption><span>admin.py</span></figcaption><table><tr><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">假如 app 为 servers，导入 models</span></span><br><span class="line">from servers import models</span><br><span class="line"></span><br><span class="line">admin.site.site_header = &quot;My Admin&quot;</span><br><span class="line">admin.site.site_title = &quot;My Admin&quot;</span><br><span class="line"></span><br><span class="line">@admin.register(models.Department)</span><br><span class="line">class DepartmentAdmin(admin.ModelAdmin):</span><br><span class="line">    list_display = (&#x27;id&#x27;,&#x27;name&#x27;,&#x27;shortName&#x27;,&#x27;manager&#x27;,&#x27;comment&#x27;)</span><br><span class="line">    list_display_links = (&#x27;id&#x27;,&#x27;name&#x27;,&#x27;shortName&#x27;,&#x27;manager&#x27;,&#x27;comment&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>更多有关 admin 配置方法，请参考 <a href="/202209021312/" title="Django admin 配置">Django admin 配置</a></p>
<span id="more"></span>

<h1 id="model-基本操作"><a href="#model-基本操作" class="headerlink" title="model 基本操作"></a>model 基本操作</h1><h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><p>假设 model 为 <code>Publish</code>，新增数据 <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[执行查询](https://docs.djangoproject.com/zh-hans/4.1/topics/db/queries/)">[2]</span></a></sup></p>
<h3 id="create-方式新增数据"><a href="#create-方式新增数据" class="headerlink" title="create 方式新增数据"></a>create 方式新增数据</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Publish.objects.create(&quot;name&quot;=&quot;人民出版社&quot;,city=&quot;北京&quot;)</span><br><span class="line">Publish.objects.create(**&#123;&quot;name&quot;:&quot;文艺出版社&quot;,&quot;city&quot;:&quot;上海&quot;&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="save-方式新增数据"><a href="#save-方式新增数据" class="headerlink" title="save 方式新增数据"></a>save 方式新增数据</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">book1=Book(title=&quot;python&quot;,price=&quot;88&quot;,publish_id=&quot;1&quot;,publication_date=&quot;2017-06-18&quot;)</span><br><span class="line">book1.save()</span><br></pre></td></tr></table></figure>
<p>为了避免重复创建数据表中已存在的条目，Django 还提供了 <code>get_or_create</code> 方法。它会返回查询到的或新建的模型对象实例，还会返回这个对象实例是否是刚刚创建的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj, created = Article.objects.get_or_create(title=<span class="string">&quot;My first article&quot;</span>, body=<span class="string">&quot;My first article body&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="update-or-create-方式更新或者添加数据"><a href="#update-or-create-方式更新或者添加数据" class="headerlink" title="update_or_create 方式更新或者添加数据"></a>update_or_create 方式更新或者添加数据</h3><p><code>update_or_create</code> 是使用给定的 <code>kwargs</code> 更新对象的一种方便方法，必要时创建一个新对象。<code>defaults</code> 是用来更新对象的 <code>(field, value)</code> 对的字典。<code>defaults</code> 中的值可以是可调用对象。</p>
<p>返回 <code>(object, created)</code> 的元组，其中 <code>object</code> 是创建或更新的对象，<code>created</code> 是一个布尔值，指定是否创建了一个新对象。 <sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[update_or_create](https://docs.djangoproject.com/zh-hans/4.1/ref/models/querysets/#update-or-create)">[3]</span></a></sup></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj, created = models.RawDomains.objects.update_or_create(<span class="built_in">id</span>=<span class="built_in">id</span>, domain=domain, defaults=d)</span><br></pre></td></tr></table></figure>
<p>以上示例中，先使用 <code>id=id, domain=domain</code> 的条件查询（筛选）数据，如果筛选出 1 条数据，则对此数据使用 <code>defaults</code> 中定义的对象进行更新，如果没有筛选出数据，则创建数据。</p>
<h3 id="存在-Foreignkey-的表新增数据"><a href="#存在-Foreignkey-的表新增数据" class="headerlink" title="存在 Foreignkey 的表新增数据"></a>存在 Foreignkey 的表新增数据</h3><h4 id="通过绑定对象的方式新增"><a href="#通过绑定对象的方式新增" class="headerlink" title="通过绑定对象的方式新增"></a>通过绑定对象的方式新增</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">获取出版社对象</span></span><br><span class="line">publish_obj=Publish.objects.get(id=4)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将出版社的对象绑定到书籍的记录中</span></span><br><span class="line">Book.objects.create(</span><br><span class="line">    title=&quot;python&quot;,</span><br><span class="line">    price=48.00,</span><br><span class="line">    publication_date=&quot;2017-07-12&quot;,</span><br><span class="line">    publish=publish_obj,</span><br><span class="line">)   </span><br></pre></td></tr></table></figure>

<h4 id="直接通过-Foreignkey-对应记录的-id-号新增数据"><a href="#直接通过-Foreignkey-对应记录的-id-号新增数据" class="headerlink" title="直接通过 Foreignkey 对应记录的 id 号新增数据"></a>直接通过 Foreignkey 对应记录的 id 号新增数据</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">直接把出版社的<span class="built_in">id</span>号插入到书籍的记录中</span></span><br><span class="line">Book.objects.create(</span><br><span class="line">    title=&quot;python&quot;,</span><br><span class="line">    price=48.00,</span><br><span class="line">    publish_id=2,</span><br><span class="line">    publication_date=&quot;2017-06-18&quot;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="ManyToManyField-的表新增数据"><a href="#ManyToManyField-的表新增数据" class="headerlink" title="ManyToManyField 的表新增数据"></a>ManyToManyField 的表新增数据</h3><p>为一本书添加多个作者</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">author1=Author.objects.get(id=1)              # 获取id号为1的作者对象</span><br><span class="line">author2=Author.objects.filter(name=&quot;a&quot;)       # 获取名字为&quot;tom&quot;的作者对象</span><br><span class="line">book1=Book.objects.get(id=2)                  # 获取id号为2的书籍对象</span><br><span class="line">book1.authors.add(author1,author2)            # 为书籍对象添加多个作者对象</span><br></pre></td></tr></table></figure>
<p>也可以使用以下方法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">book1.authors.add(*[author1,author2])             # 为书籍对象添加作者对象的列表</span><br><span class="line">book1.authors.remove(*[author1,author2])          # 删除指定书籍的所有作者</span><br></pre></td></tr></table></figure>

<p>为一个作者添加多本书</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">author_obj = Author.objects.filter(name=&quot;jerry&quot;)        # 获取名字为&quot;jerry&quot;的作者对象</span><br><span class="line">book_obj=Book.objects.filter(id__gt=3)                  # 获取id大于3的书籍对象集合</span><br><span class="line">author_obj.book_set.add(*book_obj)                      # 为作者对象添加书籍对象集合</span><br><span class="line">author_obj.book_set.remove(*book_obj)                   # 删除指定作者对象所有的书籍</span><br></pre></td></tr></table></figure>
<h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Book.objects.filter(id=1).delete()</span><br></pre></td></tr></table></figure>

<h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><h3 id="使用-save-方法将所有属性重新设定一遍-效率较低"><a href="#使用-save-方法将所有属性重新设定一遍-效率较低" class="headerlink" title="使用 save 方法将所有属性重新设定一遍,效率较低"></a>使用 save 方法将所有属性重新设定一遍,效率较低</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">author1=Author.objects.get(id=3)           # 获取id为3的作者对象</span><br><span class="line"></span><br><span class="line">author1.name=&quot;jobs&quot;                        # 修改作者对象的名字</span><br><span class="line"></span><br><span class="line">author1.save()                             # 把更改写入数据库</span><br></pre></td></tr></table></figure>

<h3 id="使用-update-方法直接设置对应的属性"><a href="#使用-update-方法直接设置对应的属性" class="headerlink" title="使用 update 方法直接设置对应的属性"></a>使用 update 方法直接设置对应的属性</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Publish.objects.filter(id=2).update(name=&quot;北京出版社&quot;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>update()</code> 是 <code>QuerySet</code> 对象的一个方法,<code>get</code> 返回的是一个 model 对象,其没有 <code>update</code> 方法</p>
</blockquote>
<h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><p>查询数据使用 <code>QuerySet</code> API。 <code>QuerySet</code> 是惰性执行的，创建 <code>Query Set</code> 不会访问数据库，只有在访问具体查询结果的时候才会访问数据库。</p>
<p>查询方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>方法说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td><code>filter(**kwargs)</code></td>
<td>包含了与所给筛选条件相匹配的对象，返回   <code>QuerySet</code>   ，相当于 SQL 中的 <code>WHERE</code></td>
<td></td>
</tr>
<tr>
<td><code>all() </code></td>
<td>查询所有结果     ，等同于 SQL 语句 <code>SELECT * FROM</code></td>
<td></td>
</tr>
<tr>
<td><code>get(**kwargs)</code></td>
<td>返回与所给筛选条件相匹配的对象,返回结果有且只有一个,如果符合筛选条件的对象超过一个或者没有都是报错</td>
<td></td>
</tr>
<tr>
<td><code>values(*field)</code></td>
<td>只取指定列 ，返回 <code>QuerySet</code>，此列表由字典 <code>&#123;&#39;列名&#39;： &#39;列值&#39;&#125;</code> 组成</td>
<td><code>models.AwsZoneInfo.objects.all().values(&#39;code&#39;)</code></td>
</tr>
<tr>
<td><code>exclude(**kwargs)</code></td>
<td>包含了与所给的筛选条件不匹配的对象</td>
<td></td>
</tr>
<tr>
<td><code>order by(*field) </code></td>
<td>对查询结果排序</td>
<td></td>
</tr>
<tr>
<td><code>reverse()  </code></td>
<td>对查询结果反向排序</td>
<td></td>
</tr>
<tr>
<td><code>distinct()  </code></td>
<td>从返回结果中剔除重复记录</td>
<td></td>
</tr>
<tr>
<td><code>values_list(*field)</code></td>
<td>与 <code>values()</code> 非常相似,返回一个元组序列,<code>values</code> 返回一个字典序列</td>
<td></td>
</tr>
<tr>
<td><code>count()</code></td>
<td>返回数据库中匹配的记录的数量</td>
<td></td>
</tr>
<tr>
<td><code>first() </code></td>
<td>返回数据库中匹配的对象的第一个对象</td>
<td></td>
</tr>
<tr>
<td><code>last()</code></td>
<td>返回数据库中匹配的对象的最后一个对象</td>
<td></td>
</tr>
<tr>
<td><code>exists() </code></td>
<td>判断一个对象集合中是否包含指定对象,包含返回 <code>True</code>,不包含返回 <code>False </code></td>
<td></td>
</tr>
<tr>
<td><code>exclude()</code></td>
<td>排除满足条件的对象</td>
<td></td>
</tr>
<tr>
<td><code>annotate()</code></td>
<td>使用聚合函数</td>
<td></td>
</tr>
<tr>
<td><code>dates() </code></td>
<td>根据日期获取查询集</td>
<td></td>
</tr>
<tr>
<td><code>datetimes()</code></td>
<td>根据时间获取查询集</td>
<td></td>
</tr>
<tr>
<td><code>none()  </code></td>
<td>创建空的查询集</td>
<td></td>
</tr>
<tr>
<td><code>union() </code></td>
<td>并集</td>
<td></td>
</tr>
<tr>
<td><code>intersection()</code></td>
<td>交集</td>
<td></td>
</tr>
<tr>
<td><code>difference() </code></td>
<td>差集</td>
<td></td>
</tr>
<tr>
<td><code>select_related()   </code></td>
<td>附带查询关联对象</td>
<td></td>
</tr>
<tr>
<td><code>prefetch_related()</code></td>
<td>预先查询</td>
<td></td>
</tr>
<tr>
<td><code>extra()  </code></td>
<td>附加 SQL 查询</td>
<td></td>
</tr>
<tr>
<td><code>defer() </code></td>
<td>不加载指定字段</td>
<td></td>
</tr>
<tr>
<td><code>only() </code></td>
<td>只加载指定的字段</td>
<td></td>
</tr>
<tr>
<td><code>using()</code></td>
<td>选择数据库</td>
<td></td>
</tr>
<tr>
<td><code>select_for_update()</code></td>
<td>锁住选择的对象，直到事务结束。</td>
<td></td>
</tr>
<tr>
<td><code>raw()</code></td>
<td>接收一个原始的 SQL 查询</td>
<td></td>
</tr>
</tbody></table>
<h3 id="values-field-和-values-list-field-使用示例"><a href="#values-field-和-values-list-field-使用示例" class="headerlink" title="values(*field) 和 values_list(*field) 使用示例"></a>values(*field) 和 values_list(*field) 使用示例</h3><p><code>values(*field)</code> 获取 QuerySet 中指定列的值，会返回一个由<strong>字典</strong> <code>&#123;&#39;列名1&#39;: &#39;列值1&#39;, &#39;列名2&#39;: &#39;列值2&#39;, ...&#125;</code> 组成的 QuerySet </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; models.AwsZoneInfo.objects.all().values(<span class="string">&#x27;code&#x27;</span>)</span></span><br><span class="line">&lt;QuerySet [&#123;&#x27;code&#x27;: &#x27;af-south-1&#x27;&#125;, &#123;&#x27;code&#x27;: &#x27;ap-east-1&#x27;&#125;, &#123;&#x27;code&#x27;: &#x27;ap-northeast-1&#x27;&#125;, &#123;&#x27;code&#x27;: &#x27;ap-south-1&#x27;&#125;, &#123;&#x27;code&#x27;: &#x27;ap-southeast-3&#x27;&#125;]&gt;</span><br><span class="line"></span><br><span class="line">models.AwsZoneInfo.objects.all().values(&#x27;code&#x27;,&#x27;name&#x27;)</span><br><span class="line">&lt;QuerySet [&#123;&#x27;code&#x27;: &#x27;ap-east-1&#x27;, &#x27;name&#x27;: &#x27;Asia Pacific (Hong Kong)&#x27;&#125;, &#123;&#x27;code&#x27;: &#x27;us-east-1&#x27;, &#x27;name&#x27;: &#x27;美国东部（弗吉尼亚北部）&#x27;]&gt;</span><br></pre></td></tr></table></figure>
<p><code>values_list(*field)</code> 获取 QuerySet 中指定列的值，会返回一个由<strong>元组</strong> <code>(&#39;列值1&#39;, &#39;列值2&#39;, ...)</code> 组成的 QuerySet</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; models.AwsZoneInfo.objects.all().values_list(<span class="string">&#x27;code&#x27;</span>,<span class="string">&#x27;name&#x27;</span>)</span></span><br><span class="line">&lt;QuerySet [(&#x27;us-east-2&#x27;, &#x27;美国东部（俄亥俄）&#x27;), (&#x27;ap-east-1&#x27;, &#x27;Asia Pacific (Hong Kong)&#x27;), (&#x27;us-east-1&#x27;, &#x27;美国东部（弗吉尼亚北部）&#x27;)]&gt;</span><br></pre></td></tr></table></figure>

<h1 id="model-类型使用说明"><a href="#model-类型使用说明" class="headerlink" title="model 类型使用说明"></a>model 类型使用说明</h1><h2 id="OneToOneField"><a href="#OneToOneField" class="headerlink" title="OneToOneField"></a>OneToOneField</h2><p>一对一表中，子表从母表中选出一条数据一一对应，母表中选出来一条就少一条，子表不可以再选择母表中已被选择的那条数据 <sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[一对一关联](https://docs.djangoproject.com/zh-hans/4.1/topics/db/examples/one_to_one/)">[4]</span></a></sup></p>
<h3 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h3><p>示例如下：</p>
<figure class="highlight python"><figcaption><span>models.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(models.Model):</span><br><span class="line">    username = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Profile</span>(models.Model):</span><br><span class="line">    user = models.OneToOneField(User, on_delete=models.CASCADE)</span><br><span class="line">    bio = models.TextField()</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<h4 id="User-实例中使用-Profile-实例的属性"><a href="#User-实例中使用-Profile-实例的属性" class="headerlink" title="User 实例中使用 Profile 实例的属性"></a>User 实例中使用 Profile 实例的属性</h4><p>假如需要在 User 对象中，调用和 User 实例关联的 Profile 对象的属性，可以通过以下方法实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">user = User.objects.get(<span class="built_in">id</span>=<span class="number">1</span>)</span><br><span class="line">bio = user.profile.bio</span><br></pre></td></tr></table></figure>
<p>需要注意的是，如果 <strong><code>user</code> 没有与之关联的 <code>Profile</code> 实例，那么  <code>user</code> 就没有 <code>profile</code> 属性</strong>，上述代码会报错：<code>models.User.profile.RelatedObjectDoesNotExist: User has no profile</code></p>
<p>可以通过以下方式处理异常 <sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[RelatedObjectDoesNotExist](https://docs.djangoproject.com/zh-hans/4.1/ref/models/fields/#onetoonefield)">[5]</span></a></sup></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">user = User.objects.get(<span class="built_in">id</span>=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    bio = user.profile.bio</span><br><span class="line"><span class="keyword">except</span> models.User.profile.RelatedObjectDoesNotExist:</span><br><span class="line">    bio = <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="可选择的字段"><a href="#可选择的字段" class="headerlink" title="可选择的字段"></a>可选择的字段</h2><p>要定义在给定选项中选择值的字段，可以通过在模型类中使用 <code>choices</code> 参数来配置可选字段。<code>choices</code> 参数需要传递一个元组的列表，其中每个元组表示一个可选择的选项。每个元组由 2 个值组成，第一个值是数据库中存储的值，第二个是在表单中显示的标签。</p>
<figure class="highlight python"><figcaption><span>models.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mymodel</span>(models.Model):</span><br><span class="line">    GENDER_CHOICES = (</span><br><span class="line">        (<span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;Male&#x27;</span>),</span><br><span class="line">        (<span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;Female&#x27;</span>)</span><br><span class="line">    )</span><br><span class="line">    name = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    gender = models.CharField(max_length=<span class="number">1</span>, choices=GENDER_CHOICES)</span><br></pre></td></tr></table></figure>

<h2 id="查询给定的-QuerySet-是否属于某个-model"><a href="#查询给定的-QuerySet-是否属于某个-model" class="headerlink" title="查询给定的 QuerySet 是否属于某个 model"></a>查询给定的 QuerySet 是否属于某个 model</h2><p>在 Django 中，可以使用以下方法来检查一个 <code>QuerySet</code> 是否是特定 model 的实例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>queryset.model == models.Mymodel</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>如果对象 <code>queryset</code> 中的所有对象都是 <code>Mymodel</code> 的实例，返回 <code>True</code>。如果 <code>queryset</code> 中有任何一个对象不是 <code>Mymodel</code> 的实例，返回 <code>False</code></p>
<h2 id="字符串格式的-QuerySet-转换为-QuerySet-对象"><a href="#字符串格式的-QuerySet-转换为-QuerySet-对象" class="headerlink" title="字符串格式的 QuerySet 转换为 QuerySet 对象"></a>字符串格式的 QuerySet 转换为 QuerySet 对象</h2><p>假如有以下字符串，内容和 QuerySet 内容一致，只是类型为字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>queryset_string</span><br><span class="line"><span class="string">&#x27;&lt;QuerySet [&lt;Domain: a11.com&gt;, &lt;Domain: a12.com&gt;, &lt;Domain: a13.com&gt;, &lt;Domain: a14.com&gt;]&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(queryset_string)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要将示例中的 <code>queryset_string</code> 类型从 <code>str</code> 转换为 <code>QuerySet</code> 对象，主要步骤如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.apps <span class="keyword">import</span> apps</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>model_name = <span class="string">&quot;Domain&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 model 类，app_label=&quot;your_app_label&quot; 换成自己的 Django 项目中的 app 名称</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>model = apps.get_model(app_label=<span class="string">&quot;your_app_label&quot;</span>, model_name=model_name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 queryset_string 转换为只包含主键的列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj_str_list = queryset_string.replace(<span class="string">&#x27;&lt;QuerySet&#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;&lt;DomainProjectInfo: &#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;[&#x27;</span>,<span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;]&#x27;</span>,<span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;&#x27;</span>).split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj_str_list</span><br><span class="line">[<span class="string">&#x27;a11.com&#x27;</span>, <span class="string">&#x27;a12.com&#x27;</span>, <span class="string">&#x27;a13.com&#x27;</span>, <span class="string">&#x27;a14.com&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据 obj_str_list 中的主键转换为 model 的对象组成的列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>queryset_list = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> obj_str <span class="keyword">in</span> obj_str_list:</span><br><span class="line"><span class="meta">... </span>    obj = model.objects.get(domain=obj_str)</span><br><span class="line"><span class="meta">... </span>    queryset_list.append(obj)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>queryset_list</span><br><span class="line">[&lt;DomainProjectInfo: a11.com&gt;, &lt;DomainProjectInfo: a12.com&gt;, &lt;DomainProjectInfo: <span class="number">613.</span>com&gt;, &lt;DomainProjectInfo: a14.com&gt;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(queryset_list)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 list 类型的 queryset_list 转换为 QuerySet 对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>queryset = model.objects.<span class="built_in">filter</span>(pk__in=[obj.pk <span class="keyword">for</span> obj <span class="keyword">in</span> queryset_list])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>queryset</span><br><span class="line">&lt;QuerySet [&lt;DomainProjectInfo: a11.com&gt;, &lt;DomainProjectInfo: a12.com&gt;, &lt;DomainProjectInfo: a13.com&gt;, &lt;DomainProjectInfo: a14.com&gt;]&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(queryset)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;django.db.models.query.QuerySet&#x27;</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="手动执行-migrate"><a href="#手动执行-migrate" class="headerlink" title="手动执行 migrate"></a>手动执行 migrate</h1><p>有时候使用 <code>python manage.py migrate</code> 执行数据库迁移会出错，可能需要重建数据库重新执行 migrate 操作，在不方便如此做的情况下，可以选择手动执行迁移操作。</p>
<ol>
<li><p>使用以下命令，根据想要迁移的文件生成实际在数据库中执行的 sql 语句。命令中 <code>0008_table_alter</code> 为要迁移的文件名（<strong>不用带完整路径(<code>myapp_name/migrations/</code>)</strong> 和文件名后缀(<code>.py</code>)），否则会报错：<code>CommandError: Cannot find a migration matching &#39;myapp_name/migrations/0008_table_alter.py&#39; from app &#39;myapp_name&#39;. Is it in INSTALLED_APPS?</code></p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python manage.py sqlmigrate myapp_name 0008_table_alter</span></span><br><span class="line">--</span><br><span class="line">-- Create model Domain</span><br><span class="line">--</span><br><span class="line">CREATE TABLE `myapp_name_domain` (`id` bigint AUTO_INCREMENT NOT NULL PRIMARY KEY, `name` varchar(10) NOT NULL UNIQUE);</span><br><span class="line">--</span><br><span class="line">-- Alter field owner on domainproject</span><br><span class="line">--</span><br><span class="line">--</span><br><span class="line">-- Add field usage to domainproject</span><br><span class="line">--</span><br><span class="line">ALTER TABLE `myapp_name_domainproject` ADD COLUMN `usage_id` bigint DEFAULT 1 NOT NULL , ADD CONSTRAINT `myapp_name_doma_usage_id_43803979_fk_domains_c` FOREIGN KEY (`usage_id`) REFERENCES `myapp_name_domainusage`(`id`);</span><br><span class="line">ALTER TABLE `myapp_name_domainproject` ALTER COLUMN `usage_id` DROP DEFAULT;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在数据库中执行打印出的 sql</p>
</li>
</ol>
<h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><h2 id="str-returned-non-string"><a href="#str-returned-non-string" class="headerlink" title="str returned non-string"></a><strong>str</strong> returned non-string</h2><p>后台添加对象失败，<a href="https://stackoverflow.com/questions/70827036/error-str-returned-non-string-type-modelname-in-django">原因说明</a></p>
<h2 id="remaining-elements-truncated"><a href="#remaining-elements-truncated" class="headerlink" title="remaining elements truncated"></a>remaining elements truncated</h2><p><code>django.db.models.query.QuerySet</code> 类型的对象，长度超过 20 时，20 个之后的内容会显示为 <code>remaining elements truncated</code>，如果值变为了字符串类型，最后一项默认变成了 <code>remaining elements truncated</code>。因此在 <code>django.db.models.query.QuerySet</code> 类型或类似类型的数据会转为 <code>str</code> 的场景下下，要将其处理成 <code>list</code> 类型 </p>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://docs.djangoproject.com/zh-hans/4.1/intro/overview/#design-your-model">设计模型</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://docs.djangoproject.com/zh-hans/4.1/topics/db/queries/">执行查询</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://docs.djangoproject.com/zh-hans/4.1/ref/models/querysets/#update-or-create">update_or_create</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://docs.djangoproject.com/zh-hans/4.1/topics/db/examples/one_to_one/">一对一关联</a><a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://docs.djangoproject.com/zh-hans/4.1/ref/models/fields/#onetoonefield">RelatedObjectDoesNotExist</a><a href="#fnref:5" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>django 接收 post 请求中的 json 数据</title>
    <url>/202209161740/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Python3.10</li>
<li>Django 4.0</li>
</ul>
<h3 id="接收-post-中的-json-数据"><a href="#接收-post-中的-json-数据" class="headerlink" title="接收 post 中的 json 数据"></a>接收 post 中的 json 数据</h3><p>示例通过 <code>curl</code> 命令模拟 post 请求，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -v -H &quot;Accept: application/json&quot; -H &quot;Content-type: application/json&quot; -X POST \</span><br><span class="line">      -d &#x27;&#123;&quot;id&quot; : &quot;yTP7PSsRxz53tJ56VVG&quot;, &quot;type&quot; : 5&#125;&#x27; 127.0.0.1:8000/csapi</span><br></pre></td></tr></table></figure>

<p>Django 处理程序示例：</p>
<figure class="highlight shell"><figcaption><span>views.py</span></figcaption><table><tr><td class="code"><pre><span class="line">from django.http import HttpResponse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def csapi(request):</span><br><span class="line">    post_body = request.body</span><br><span class="line">    print(f&#x27;****** POST body: &#123;post_body&#125;, type : &#123;type(post_body)&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">    # </span><br><span class="line">    data = eval(post_body)</span><br><span class="line"></span><br><span class="line">    print(f&#x27;****** data : &#123;data&#125; , type : &#123;type(data)&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">    return HttpResponse(&#x27;ok&#x27;)</span><br></pre></td></tr></table></figure>

<p>Console 输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">****** POST body: b&#x27;&#123;&quot;id&quot; : &quot;yTP7PSsRxz53tJ56VVG&quot;, &quot;type&quot; : 5&#125;&#x27;, type : &lt;class &#x27;bytes&#x27;&gt;</span><br><span class="line">****** data : &#123;&#x27;id&#x27;: &#x27;yTP7PSsRxz53tJ56VVG&#x27;, &#x27;type&#x27;: 5&#125; , type : &lt;class &#x27;dict&#x27;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上输出可以看到，<code>request.body</code> 中的类型为 <code>bytes</code></p>
<p>使用 <code>eval</code> 转换后类型变为 <code>dict</code></p>
<p>使用 <code>json.loads</code> 将 <code>request.body</code> 转换为 <code>dict</code> 时，可能会报以下错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">json.decoder.JSONDecodeError: Expecting property name enclosed in double quotes: line 1 column 2 (char 1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可能原因 <a href="https://www.jianshu.com/p/3a7dbd17e7b9">参考</a></p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django 模板语言</title>
    <url>/202303241517/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Python 3.11</li>
<li>Django 4.1</li>
</ul>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>在 Django 4.1 中，使用静态文件的方法与之前的版本相同。以下是使用静态文件的步骤：</p>
<ol>
<li><p>在 <code>settings.py</code> 中设置静态文件目录：</p>
 <figure class="highlight python"><figcaption><span>settings.py</span></figcaption><table><tr><td class="code"><pre><span class="line">STATIC_URL = <span class="string">&#x27;/static/&#x27;</span></span><br><span class="line">STATICFILES_DIRS = [</span><br><span class="line">    BASE_DIR / <span class="string">&quot;static&quot;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>STATIC_URL</code> 是静态文件 URL 的前缀。</li>
<li><code>STATICFILES_DIRS</code> 是一个列表，其中包含要在其中查找静态文件的目录。</li>
</ul>
</li>
<li><p>在 HTML 文件中使用静态文件</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% load static %&#125;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>My Static File Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&#123;% static &#x27;css/style.css&#x27; %&#125;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&#123;% static &#x27;images/logo.png&#x27; %&#125;&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;My logo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;&#123;% static &#x27;js/script.js&#x27; %&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> 在上面的示例中，我们使用了 Django 模板语言的 <code>&#123;% static %&#125;</code> 标记来引用静态文件。<code>&#123;% load static %&#125;</code> 指令必须在使用 <code>&#123;% static %&#125;</code> 标记之前加载，以确保 Django 能够正确解析它们。</p>
</li>
<li><p>运行 <code>collectstatic</code> 命令：<br>  当您准备部署您的 Django 应用程序时，您需要将静态文件收集到一个单独的目录中，以便可以轻松地在生产服务器上提供它们。您可以使用 Django 的 <code>collectstatic</code> 命令来完成此操作。在命令行中运行以下命令：</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python manage.py collectstatic</span><br></pre></td></tr></table></figure>

<p> Django 将在 <code>STATIC_ROOT</code> 目录中创建一个新的静态文件目录，并将您的静态文件从 <code>STATICFILES_DIRS</code> 中指定的目录复制到该目录中。您可以在 <code>settings.py</code> 文件中设置 <code>STATIC_ROOT</code> 目录的路径</p>
</li>
</ol>
<h1 id="DTL-语法"><a href="#DTL-语法" class="headerlink" title="DTL 语法"></a>DTL 语法</h1><h2 id="load-static"><a href="#load-static" class="headerlink" title="load static"></a>load static</h2><p><a href="#%E5%9C%A8-HTML-%E6%96%87%E4%BB%B6%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6">参考说明</a></p>
<h2 id="block-super"><a href="#block-super" class="headerlink" title="block.super"></a>block.super</h2><p>用来从父 block 中继承选项</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% load static %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block extrahead %&#125;</span><br><span class="line">&#123;&#123; block.super &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;&#123;% static &#x27;bootstrap/css/bootstrap.css&#x27; %&#125;&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;&#123;% static &#x27;bootstrap/css/base.css&#x27; %&#125;&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> /&gt;</span></span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>

<h2 id="url-反向解析"><a href="#url-反向解析" class="headerlink" title="url 反向解析"></a>url 反向解析</h2><p>在模板中不推荐使用 url 硬编码，建议使用 url 反向解析功能，在 <code>urls.py</code> 中定义 url 时，给 url 命名，在模板中 可以使用反向解析使用 url，避免使用 url 硬编码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">app_name = <span class="string">&#x27;polls&#x27;</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;&#x27;</span>, views.IndexView.as_view(), name=<span class="string">&#x27;index&#x27;</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>以上事例中，<code>name=&#39;index&#39;</code> 为 url 命名，在模板中通过以下方式使用 url 名称 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[反向命名空间 URLs](https://docs.djangoproject.com/zh-hans/4.1/topics/http/urls/#reversing-namespaced-urls)">[1]</span></a></sup></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;% url &#x27;polls:index&#x27; %&#125;&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://docs.djangoproject.com/zh-hans/4.1/topics/http/urls/#reversing-namespaced-urls">反向命名空间 URLs</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Django 常用配置</title>
    <url>/202301181649/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Python 3.10</li>
<li>Django 4.1</li>
</ul>
<h1 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h1><h2 id="创建项目及-app"><a href="#创建项目及-app" class="headerlink" title="创建项目及 app"></a>创建项目及 app</h2><p>开始使用 Django 时，需要初始化配置，执行以下命令生成初始化的工程环境 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[创建项目](https://docs.djangoproject.com/zh-hans/4.1/intro/tutorial01/#creating-a-project)">[1]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">django-admin startproject mysite</span><br></pre></td></tr></table></figure>
<p>创建 Project 成功后，会生成以 Project 命名的根目录(此处为 <code>mysite</code>)，根目录只是你项目的容器， 根目录名称对 Django 没有影响，你可以将它重命名为任何你喜欢的名称。以下为目录结构 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[创建项目](https://docs.djangoproject.com/zh-hans/4.1/intro/tutorial01/#creating-a-project)">[1]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysite/</span><br><span class="line">    manage.py</span><br><span class="line">    mysite/</span><br><span class="line">        __init__.py</span><br><span class="line">        settings.py</span><br><span class="line">        urls.py</span><br><span class="line">        asgi.py</span><br><span class="line">        wsgi.py</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>mysite/mysite/settings.py</code> 为项目配置文件，包括配置 app，数据库等。</li>
</ul>
<p>创建 App</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python manage.py startapp myapp</span><br></pre></td></tr></table></figure>
<p>创建 app 后，会在项目根目录下生成 app 命名的目录。创建 app 后，需要将 app 添加到项目配置文件 <code>settings.py</code> 中的 <code>INSTALLED_APPS</code></p>
<h2 id="项目配置文件-settings-py-常用配置说明"><a href="#项目配置文件-settings-py-常用配置说明" class="headerlink" title="项目配置文件 settings.py 常用配置说明"></a>项目配置文件 <code>settings.py</code> 常用配置说明</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ALLOWED_HOSTS = [&#x27;*&#x27;]</span><br></pre></td></tr></table></figure>
<p>访问控制，默认只允许从本地访问 Django Server，如果需要远程访问，需要配置远程主机地址，<code>*</code> 可以配置允许任一客户端访问。</p>
<h3 id="配置-mysql-数据库"><a href="#配置-mysql-数据库" class="headerlink" title="配置 mysql 数据库"></a>配置 mysql 数据库</h3><p>要为项目配置使用 Mysql 数据库，可以使用以下配置。</p>
<figure class="highlight shell"><figcaption><span>settings.py</span></figcaption><table><tr><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    &#x27;default&#x27;: &#123;</span><br><span class="line">        &#x27;ENGINE&#x27;: &#x27;django.db.backends.mysql&#x27;,</span><br><span class="line">        &#x27;NAME&#x27;: &quot;vb&quot;,</span><br><span class="line">        &#x27;USER&#x27;: &quot;root&quot;,</span><br><span class="line">        &quot;PASSWORD&quot;: &quot;dBVgcKGnn0&quot;,</span><br><span class="line">        &#x27;HOST&#x27;: &quot;127.0.0.1&quot;,</span><br><span class="line">        &quot;PORT&quot;: &#x27;3306&#x27;,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="配置语言为中文"><a href="#配置语言为中文" class="headerlink" title="配置语言为中文"></a>配置语言为中文</h3><figure class="highlight shell"><figcaption><span>settings.py</span></figcaption><table><tr><td class="code"><pre><span class="line">LANGUAGE_CODE = &#x27;zh-hans&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="配置时区"><a href="#配置时区" class="headerlink" title="配置时区"></a>配置时区</h3><figure class="highlight shell"><figcaption><span>settings.py</span></figcaption><table><tr><td class="code"><pre><span class="line">TIME_ZONE = &#x27;Asia/Shanghai&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Django-管理后台配置"><a href="#Django-管理后台配置" class="headerlink" title="Django 管理后台配置"></a>Django 管理后台配置</h2><ol>
<li>创建 project 后，要使用 Django 管理后台，需要首先初始化数据库并创建 superuser <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python manage.py makemigrations</span><br><span class="line">python manage.py migrate</span><br><span class="line">python manage.py createsuperuser</span><br></pre></td></tr></table></figure></li>
<li>为 admin 添加路由<br> 在工程目录中的 <code>urls.py</code> 文件中配置以下内容 <figure class="highlight shell"><figcaption><span>urls.py</span></figcaption><table><tr><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line">from django.urls import path</span><br><span class="line">from .views import index</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&#x27;admin/&#x27;, admin.site.urls),</span><br><span class="line">    path(&#x27;&#x27;, index),</span><br><span class="line">    # 项目根 url 既是后台</span><br><span class="line">    # path(&#x27;&#x27;, admin.site.urls),</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
如果要在访问项目 <code>/</code> 时，重定向到管理后台，可以在项目的 <code>views.py</code> 文件中添加以下内容，将 <code>/</code> 重定向到 <code>/admin/</code><figure class="highlight shell"><figcaption><span>views.py</span></figcaption><table><tr><td class="code"><pre><span class="line">from django.shortcuts import redirect</span><br><span class="line"></span><br><span class="line">def index(request):</span><br><span class="line">    return redirect(&#x27;admin/&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
访问项目 url，此时可以看到登陆后台页面。</li>
</ol>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://docs.djangoproject.com/zh-hans/4.1/intro/tutorial01/#creating-a-project">创建项目</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>docker daemon 常用配置</title>
    <url>/202211241005/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos 7</li>
<li>Docker 19.03.15</li>
</ul>
<h1 id="docker-配置容器日志-rotate"><a href="#docker-配置容器日志-rotate" class="headerlink" title="docker 配置容器日志 rotate"></a>docker 配置容器日志 rotate</h1><h2 id="docker-daemon-方式配置容器日志-rotate"><a href="#docker-daemon-方式配置容器日志-rotate" class="headerlink" title="docker daemon 方式配置容器日志 rotate"></a>docker daemon 方式配置容器日志 rotate</h2><p>编辑 docker daemon 配置文件 <code>/etc/docker/daemon.json</code> (若不存在则新建)，添加以下内容，用来配置 docker containers 的日志轮转</p>
<figure class="highlight shell"><figcaption><span>/etc/docker/daemon.json</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;log-driver&quot;: &quot;json-file&quot;,</span><br><span class="line">  &quot;log-opts&quot;: &#123;</span><br><span class="line">    &quot;max-size&quot;: &quot;100m&quot;,</span><br><span class="line">    &quot;max-file&quot;: &quot;3&quot;    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重启 docker 服务生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>
<p>根据以上配置，当容器日志大小达到 <code>100m</code>，即对其进行 rotate，并保留最多 3 个日志文件。 </p>
<h2 id="使用-OS-系统服务-logrotate-进行容器日志-rotate"><a href="#使用-OS-系统服务-logrotate-进行容器日志-rotate" class="headerlink" title="使用 OS 系统服务 logrotate 进行容器日志 rotate"></a>使用 OS 系统服务 logrotate 进行容器日志 rotate</h2><p>Linux 系统中有专门用来做日志 rotate 的 <a href="!--swig%EF%BF%BC3--">服务 <code>logrotate</code></a>，可直接使用此服务做 log rotate</p>
<p>配置针对 docker 的 <code>logrotate</code> 配置</p>
<figure class="highlight shell"><figcaption><span>/etc/logrotate.d/docker</span></figcaption><table><tr><td class="code"><pre><span class="line">/var/lib/docker/containers/*/*.log &#123;</span><br><span class="line">    daily</span><br><span class="line">    rotate 5</span><br><span class="line">    copytruncate</span><br><span class="line">    missingok</span><br><span class="line">    compress</span><br><span class="line">    delaycompress</span><br><span class="line">    maxsize 100M</span><br><span class="line">    minsize 1024k</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>copytruncate</code> 的方式做日志 totate 时，会先拷贝日志文件为 totate 日志文件，然后 <code>truncate</code> 日志，确保 totate 过程中，日志文件不变并一直保持打开状态。</p>
<span id="more"></span>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker 容器中安装常见工具</title>
    <url>/202209051507/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="常用工具安装"><a href="#常用工具安装" class="headerlink" title="常用工具安装"></a>常用工具安装</h1><p>查找 <code>netstat</code> 命令由哪个安装包提供</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum whatprovides /bin/netstat</span></span><br><span class="line">net-tools-2.0-0.25.20131004git.el7.x86_64 : Basic networking tools</span><br><span class="line">Repo        : base</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : /bin/netstat</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>安装 <code>net-tools</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y net-tools</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install -y net-tools</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>安装 <code>ping</code> 命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum whatprovides /bin/ping</span></span><br><span class="line">iputils-20160308-10.el7.x86_64 : Network monitoring tools including ping</span><br><span class="line">Repo        : base</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : /bin/ping</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">apt-cache search iputils</span></span><br><span class="line">iputils-arping - Tool to send ICMP echo requests to an ARP address</span><br><span class="line">iputils-clockdiff - Measure the time difference between networked computers</span><br><span class="line">iputils-ping - Tools to test the reachability of network hosts</span><br><span class="line">iputils-tracepath - Tools to trace the network path to a remote host</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install -y iputils-ping</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>安装 <code>ps</code> 命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install procps</span><br></pre></td></tr></table></figure>

<p>安装 <code>ip</code> 命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum whatprovides /usr/sbin/ip</span></span><br><span class="line">iproute-4.11.0-30.el7.x86_64 : Advanced IP routing and network device configuration tools</span><br><span class="line">Repo        : base</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : /usr/sbin/ip</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install iproute2</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker compose 命令</title>
    <url>/202208311004/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>对于 <code>Compose</code> 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。  </p>
<p>执行 <code>docker compose [COMMAND] --help</code>  可以查看具体某个命令的使用格式。  </p>
<p><code>docker compose</code> 命令的基本的使用格式是  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...]</span><br></pre></td></tr></table></figure>
<p>常用选项  </p>
<ul>
<li><code>-f, --file FILE</code>  指定使用的 Compose 模板文件，默认为 <code>docker-compose.yml</code>，可以多次指定。  </li>
<li><code>-p, --project-name NAME</code> 指定项目名称，默认将使用所在目录名称作为项目名。</li>
</ul>
<span id="more"></span>

<h3 id="build"><a href="#build" class="headerlink" title="build"></a>build</h3><p>格式为 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker compose build [options] [SERVICE...]</span><br></pre></td></tr></table></figure>
<p>构建（重新构建）项目中的服务容器。  </p>
<p>服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db。<br>可以随时在项目目录下运行 <code>docker compose build</code> 来重新构建服务。<br>常用选项包括：</p>
<ul>
<li><code>--no-cache</code>  构建镜像过程中不使用 cache（这将加长构建过程）。</li>
<li><code>--pull</code>  始终尝试通过 <code>pull</code> 来获取更新版本的镜像。</li>
<li><code>-q, --quiet</code>  不输出任何内容到 STDOUT</li>
</ul>
<h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker compose config</span><br></pre></td></tr></table></figure>
<p>验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因。</p>
<h3 id="up"><a href="#up" class="headerlink" title="up"></a>up</h3><p>格式为 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker compose up [options] [SERVICE...]</span><br></pre></td></tr></table></figure>
<p>该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。  </p>
<p>链接的服务都将会被自动启动，除非已经处于运行状态。</p>
<p>可以说，大部分时候都可以直接通过该命令来启动一个项目。</p>
<p>默认情况，<code>docker compose up</code> 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。</p>
<p>当通过 <code>Ctrl-C</code> 停止命令时，所有容器将会停止。</p>
<p>如果使用 <code>docker compose up -d</code>，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。</p>
<p>默认情况，如果服务容器已经存在，<code>docker compose up</code> 将会尝试停止容器，然后重新创建（保持使用 volumes-from 挂载的卷），以保证新启动的服务匹配 <code>docker-compose.yml</code> 文件的最新内容。如果用户不希望容器被停止并重新创建，可以使用 <code>docker compose up --no-recreate</code>。这样将只会启动处于停止状态的容器，而忽略已经运行的服务。如果用户只想重新部署某个服务，可以使用 <code>docker compose up --no-deps -d &lt;SERVICE_NAME&gt;</code> 来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。</p>
<p>常用选项说明：  </p>
<ul>
<li><code>-d, --detach</code> 在后台运行服务容器</li>
<li><code>--no-color</code> 不使用颜色来区分不同的服务的控制台输出</li>
<li><code>--no-deps</code> 不启动服务所链接的容器。</li>
<li><code>--force-recreate</code> 强制重新创建容器，不能与 <code>--no-recreate</code> 同时使用</li>
<li><code>--no-recreate</code> 如果容器已经存在了，则不重新创建，不能与 <code>--force-recreate</code> 同时使用。</li>
<li><code>--no-build</code> 不自动构建缺失的服务镜像</li>
<li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）时间。</li>
<li><code>--no-start</code> 创建服务但是不启动服务</li>
<li><code>--build</code>  启动容器之前，重新构建容器</li>
</ul>
<h3 id="down"><a href="#down" class="headerlink" title="down"></a>down</h3><p>此命令将会停止 <code>up</code> 命令所启动的容器，并移除网络</p>
<h3 id="start"><a href="#start" class="headerlink" title="start"></a>start</h3><p>启动已经存在的服务容器。</p>
<h3 id="pause"><a href="#pause" class="headerlink" title="pause"></a>pause</h3><p>暂停一个服务容器。</p>
<h3 id="unpause"><a href="#unpause" class="headerlink" title="unpause"></a>unpause</h3><p>恢复处于暂停状态中的服务。</p>
<h3 id="restart"><a href="#restart" class="headerlink" title="restart"></a>restart</h3><p>重启项目中的服务。</p>
<h3 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h3><p>停止已经处于运行状态的容器，但不删除它。通过 <code>docker compose start</code> 可以再次启动这些容器。</p>
<h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>列出项目中目前的所有容器。</p>
<h3 id="port"><a href="#port" class="headerlink" title="port"></a>port</h3><p>格式为 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker compose port [options] SERVICE PRIVATE_PORT</span><br></pre></td></tr></table></figure>
<p>打印某个容器端口所映射的公共端口  </p>
<p>常用选项  </p>
<ul>
<li><code>--protocol=proto</code> 指定端口协议，tcp（默认值）或者 udp。</li>
<li><code>--index=index</code> 如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1）</li>
</ul>
<h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><p>进入指定的容器。</p>
<h3 id="images"><a href="#images" class="headerlink" title="images"></a>images</h3><p>列出 Compose 文件中包含的镜像。</p>
<h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>格式为 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker compose kill [options] [SERVICE...]</span><br></pre></td></tr></table></figure>
<p>通过发送 SIGKILL 信号来强制停止服务容器。</p>
<p>支持通过 <code>-s</code> 参数来指定发送的信号，例如通过如下指令发送 SIGINT 信号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker compose kill -s SIGINT</span><br></pre></td></tr></table></figure>

<h3 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h3><p>格式为 </p>
<pre><code>docker compose logs [options] [SERVICE...]
</code></pre>
<p>查看服务容器的输出。默认情况下，<code>docker compose</code> 将对不同的服务输出使用不同的颜色来区分。可以通过 <code>--no-color</code> 来关闭颜色。<br>该命令在调试问题的时候十分有用。</p>
<h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>查看各个服务容器内运行的进程。</p>
<h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p>删除所有（停止状态的）服务容器。推荐先执行 <code>docker compose stop</code> 命令来停止容器。<br>选项：</p>
<ul>
<li><code>-f, --force</code> 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。</li>
<li><code>-v</code> 删除容器所挂载的数据卷。</li>
</ul>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://yeasy.gitbook.io/docker_practice/compose/commands">docker compose 命令说明</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker compose 简介</title>
    <url>/202208301738/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><code>Compose</code> 项目是 <code>Docker</code> 官方的开源项目，负责实现对 <code>Docker 容器集群</code> 的快速编排。</p>
<p><code>Compose</code> 定位是 <strong>「定义和运行多个 <code>Docker</code> 容器的应用（Defining and running multi-container Docker applications）」</strong>，其前身是开源项目 <code>Fig</code>。</p>
<p>使用一个 <a href="/202208050928/" title="Dockerfile">Dockerfile</a> 模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。  </p>
<p><code>Compose</code> 恰好满足了这样的需求。它允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件（<code>YAML</code> 格式）来定义一组相关联的应用容器为一个项目（<code>project</code>）。<br><code>Compose</code> 中有两个重要的概念：</p>
<ul>
<li><code>服务 (service)</code> ： 一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。  </li>
<li><code>项目 (project)</code> ： 由一组关联的应用容器组成的一个完整业务单元，在 <code>docker-compose.yml</code> 文件中定义。</li>
</ul>
<p><code>Compose</code> 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。<br><code>Compose</code> 项目由 <code>Python</code> 编写，实现上调用了 <code>Docker</code> 服务提供的 <code>API</code> 来对容器进行管理。因此，只要所操作的平台支持 <code>Docker API</code>，就可以在其上利用 <code>Compose</code> 来进行编排管理。</p>
<span id="more"></span>
<h3 id="Compose-v2"><a href="#Compose-v2" class="headerlink" title="Compose v2"></a>Compose v2</h3><p>目前 <code>Docker</code> 官方用 <code>GO 语言</code> 重写 了 <code>Docker Compose</code>，并将其作为了 <code>docker cli</code> 的子命令，称为 <code>Compose V2</code>。你可以参照官方文档安装，然后将熟悉的 <code>docker-compose</code> 命令替换为 <a href="/202208311004/" title="docker compose">docker compose</a>，即可使用 <code>Docker Compose</code>。</p>
<h3 id="Compose-模板文件"><a href="#Compose-模板文件" class="headerlink" title="Compose 模板文件"></a>Compose 模板文件</h3><p>模板文件是使用 Compose 的核心，里面大部分指令跟 <code>docker run</code> 相关参数的含义类似。  </p>
<p>默认的模板文件名称为 <code>docker-compose.yml</code>，格式为 YAML 格式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  webapp:</span><br><span class="line">    image: examples/web</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:80&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;/data&quot;</span><br></pre></td></tr></table></figure>

<p>每个服务都必须通过 <code>image</code> 指令指定镜像或 <code>build</code> 指令（需要 <a href="/202208050928/" title="Dockerfile">Dockerfile</a>）等来自动构建生成镜像。  </p>
<p>如果使用 <code>build</code> 指令，在 <code>Dockerfile</code> 中设置的选项(例如：<code>CMD</code>, <code>EXPOSE</code>, <code>VOLUME</code>, <code>ENV</code> 等) 将会自动被获取，无需在 <code>docker-compose.yml</code> 中重复设置。</p>
<p>下面分别介绍各个指令的用法。</p>
<h3 id="docker-compose-yml-中的常用指令"><a href="#docker-compose-yml-中的常用指令" class="headerlink" title="docker-compose.yml 中的常用指令"></a>docker-compose.yml 中的常用指令</h3><h4 id="build"><a href="#build" class="headerlink" title="build"></a>build</h4><p>指定 <code>Dockerfile</code> 所在文件夹的路径（可以是绝对路径，或者相对 <code>docker-compose.yml</code> 文件的路径）。 Compose 将会利用它自动构建这个镜像，然后使用这个镜像。  </p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  webapp:</span><br><span class="line">    build: ./dir</span><br></pre></td></tr></table></figure>
<p>也可以使用 <code>context</code> 指令指定 <code>Dockerfile</code> 所在文件夹的路径。<br>使用 <code>dockerfile</code> 指令指定 <code>Dockerfile</code> 文件名。<br>使用 <code>arg</code> 指令指定构建镜像时的变量。  </p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  webapp:</span><br><span class="line">    build:</span><br><span class="line">      context: ./dir</span><br><span class="line">      dockerfile: Dockerfile-alternate</span><br><span class="line">      args:</span><br><span class="line">        buildno: 1</span><br></pre></td></tr></table></figure>

<h4 id="image"><a href="#image" class="headerlink" title="image"></a>image</h4><p>指定为镜像名称或镜像 ID。如果镜像在本地不存在，Compose 将会尝试拉取这个镜像。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">image: ubuntu</span><br><span class="line">image: orchardup/postgresql</span><br><span class="line">image: a4bc65fd</span><br></pre></td></tr></table></figure>

<h4 id="command"><a href="#command" class="headerlink" title="command"></a>command</h4><p>覆盖容器启动后默认执行的命令  </p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">command: echo &quot;hello world&quot;</span><br></pre></td></tr></table></figure>

<h4 id="entrypoint"><a href="#entrypoint" class="headerlink" title="entrypoint"></a>entrypoint</h4><p>指定服务容器启动后执行的入口文件。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">entrypoint: /code/entrypoint.sh</span><br></pre></td></tr></table></figure>

<h4 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a>container_name</h4><p>指定容器名称。默认将会使用 项目名称_服务名称_序号 这样的格式。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">container_name: docker-web-container</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。</strong></p>
</blockquote>
<h4 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a>depends_on</h4><p>解决容器的依赖、启动先后的问题。以下例子中会先启动 redis db 再启动 web  </p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">      - redis</span><br><span class="line"></span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line"></span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：web 服务不会等待 redis db 「完全启动」之后才启动。</p>
</blockquote>
<h4 id="dns"><a href="#dns" class="headerlink" title="dns"></a>dns</h4><p>自定义 DNS 服务器。可以是一个值，也可以是一个列表。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">dns: 8.8.8.8</span><br><span class="line"></span><br><span class="line">dns:</span><br><span class="line">  - 8.8.8.8</span><br><span class="line">  - 114.114.114.114</span><br></pre></td></tr></table></figure>

<h4 id="dns-search"><a href="#dns-search" class="headerlink" title="dns_search"></a>dns_search</h4><p>配置 DNS 搜索域。可以是一个值，也可以是一个列表。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">dns_search: example.com</span><br><span class="line"></span><br><span class="line">dns_search:</span><br><span class="line">  - domain1.example.com</span><br><span class="line">  - domain2.example.com</span><br></pre></td></tr></table></figure>

<h4 id="extra-hosts"><a href="#extra-hosts" class="headerlink" title="extra_hosts"></a>extra_hosts</h4><p>类似 Docker 中的 <code>--add-host</code> 参数，指定额外的 host 名称映射信息。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">extra_hosts:</span><br><span class="line"> - &quot;googledns:8.8.8.8&quot;</span><br><span class="line"> - &quot;dockerhub:52.1.157.61&quot;</span><br></pre></td></tr></table></figure>
<p>会在启动后的服务容器中 <code>/etc/hosts</code> 文件中添加如下两条条目</p>
<figure class="highlight shell"><figcaption><span>/etc/hosts</span></figcaption><table><tr><td class="code"><pre><span class="line">8.8.8.8 googledns</span><br><span class="line">52.1.157.61 dockerhub</span><br></pre></td></tr></table></figure>

<h4 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h4><p>设置环境变量。可以使用数组或字典两种格式  </p>
<p>只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。  </p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">environment:</span><br><span class="line">  RACK_ENV: development</span><br><span class="line">  SESSION_SECRET:</span><br><span class="line"></span><br><span class="line">environment:</span><br><span class="line">  - RACK_ENV=development</span><br><span class="line">  - SESSION_SECRET</span><br></pre></td></tr></table></figure>

<p>如果变量名称或者值中用到 <code>true</code>|<code>false</code>，<code>yes</code>|<code>no</code> 等表达 布尔 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF</span><br></pre></td></tr></table></figure>

<h4 id="env-file"><a href="#env-file" class="headerlink" title="env_file"></a>env_file</h4><p>从文件中获取环境变量，可以为单独的文件路径或列表。  </p>
<p>如果通过 <code>docker compose -f FILE</code> 方式来指定 Compose 模板文件，则 <code>env_file</code> 中变量的路径会基于模板文件路径。<br>如果有变量名称与 <a href="#environment"><code>environment</code></a> 指令冲突，则按照惯例，以后者为准。  </p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">env_file: .env</span><br><span class="line"></span><br><span class="line">env_file:</span><br><span class="line">  - ./common.env</span><br><span class="line">  - ./apps/web.env</span><br><span class="line">  - /opt/secrets.env</span><br></pre></td></tr></table></figure>
<p>环境变量文件中每一行必须符合格式，支持 # 开头的注释行。</p>
<figure class="highlight shell"><figcaption><span>.env</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">common.env: Set development environment</span></span><br><span class="line">PROG_ENV=development</span><br></pre></td></tr></table></figure>

<h4 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h4><p>暴露端口，但不映射到宿主机，只被连接的服务访问。<br>仅可以指定内部端口为参数</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">expose:</span><br><span class="line"> - &quot;3000&quot;</span><br><span class="line"> - &quot;8000&quot;</span><br></pre></td></tr></table></figure>

<h4 id="healthcheck"><a href="#healthcheck" class="headerlink" title="healthcheck"></a>healthcheck</h4><p>通过命令检查容器是否健康运行</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">healthcheck:</span><br><span class="line">  test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost&quot;]</span><br><span class="line">  interval: 1m30s</span><br><span class="line">  timeout: 10s</span><br><span class="line">  retries: 3</span><br></pre></td></tr></table></figure>

<h4 id="labels"><a href="#labels" class="headerlink" title="labels"></a>labels</h4><p>为容器添加 Docker 元数据（metadata）信息。例如可以为容器添加辅助说明信息。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">labels:</span><br><span class="line">  com.startupteam.description: &quot;webapp for a startup team&quot;</span><br><span class="line">  com.startupteam.department: &quot;devops department&quot;</span><br><span class="line">  com.startupteam.release: &quot;rc3 for v1.0&quot;</span><br></pre></td></tr></table></figure>

<h4 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h4><p>配置日志选项。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">logging:</span><br><span class="line">  driver: syslog</span><br><span class="line">  options:</span><br><span class="line">    syslog-address: &quot;tcp://192.168.0.42:123&quot;</span><br></pre></td></tr></table></figure>
<p>目前支持三种日志驱动类型。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">driver: &quot;json-file&quot;</span><br><span class="line">driver: &quot;syslog&quot;</span><br><span class="line">driver: &quot;none&quot;</span><br></pre></td></tr></table></figure>
<p>options 配置日志驱动的相关参数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">options:</span><br><span class="line">  max-size: &quot;200k&quot;</span><br><span class="line">  max-file: &quot;10&quot;</span><br></pre></td></tr></table></figure>

<h4 id="networks"><a href="#networks" class="headerlink" title="networks"></a>networks</h4><p>配置容器连接的网络。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  some-service:</span><br><span class="line">    networks:</span><br><span class="line">     - some-network</span><br><span class="line">     - other-network</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  some-network:</span><br><span class="line">  other-network:</span><br></pre></td></tr></table></figure>

<h4 id="ports"><a href="#ports" class="headerlink" title="ports"></a>ports</h4><p>暴露端口信息。<br>使用 <code>宿主端口：容器端口 (HOST:CONTAINER)</code> 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">ports:</span><br><span class="line"> - &quot;3000&quot;</span><br><span class="line"> - &quot;8000:8000&quot;</span><br><span class="line"> - &quot;49100:22&quot;</span><br><span class="line"> - &quot;127.0.0.1:8001:8001&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当使用 <code>HOST:CONTAINER</code> 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 YAML 会自动解析 <code>xx:yy</code> 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。</p>
</blockquote>
<h4 id="sysctls"><a href="#sysctls" class="headerlink" title="sysctls"></a>sysctls</h4><p>配置容器内核参数。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">sysctls:</span><br><span class="line">  net.core.somaxconn: 1024</span><br><span class="line">  net.ipv4.tcp_syncookies: 0</span><br><span class="line"></span><br><span class="line">sysctls:</span><br><span class="line">  - net.core.somaxconn=1024</span><br><span class="line">  - net.ipv4.tcp_syncookies=0</span><br></pre></td></tr></table></figure>

<h4 id="ulimits"><a href="#ulimits" class="headerlink" title="ulimits"></a>ulimits</h4><p>指定容器的 ulimits 限制值。<br>例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">ulimits:</span><br><span class="line">  nproc: 65535</span><br><span class="line">  nofile:</span><br><span class="line">    soft: 20000</span><br><span class="line">    hard: 40000</span><br></pre></td></tr></table></figure>

<h4 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a>volumes</h4><p>数据卷所挂载路径设置。可以设置为宿主机路径 (<code>HOST:CONTAINER</code>) 或者数据卷名称( <code>VOLUME:CONTAINER</code> )，并且可以设置访问模式 （ <code>HOST:CONTAINER:ro</code> ）。<br>该指令中路径支持相对路径。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">volumes:</span><br><span class="line"> - /var/lib/mysql</span><br><span class="line"> - cache/:/tmp/cache</span><br><span class="line"> - ~/configs:/etc/configs/:ro</span><br></pre></td></tr></table></figure>
<p>如果路径为数据卷名称，必须在文件中配置数据卷。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  my_src:</span><br><span class="line">    image: mysql:8.0</span><br><span class="line">    volumes:</span><br><span class="line">      - mysql_data:/var/lib/mysql</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  mysql_data:  </span><br></pre></td></tr></table></figure>

<h4 id="user"><a href="#user" class="headerlink" title="user"></a>user</h4><p>指定容器中运行应用的用户名。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">user: nginx</span><br></pre></td></tr></table></figure>
<h4 id="hostname"><a href="#hostname" class="headerlink" title="hostname"></a>hostname</h4><p>指定容器中主机名</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">hostname: test</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="working-dir"><a href="#working-dir" class="headerlink" title="working_dir"></a>working_dir</h4><p>指定容器中工作目录。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">working_dir: /code</span><br></pre></td></tr></table></figure>

<h4 id="restart"><a href="#restart" class="headerlink" title="restart"></a>restart</h4><p>指定容器退出后的重启策略为始终重启。该命令对保持服务始终运行十分有效，在生产环境中推荐配置为 <code>always</code> 或者 <code>unless-stopped</code>。  </p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">restart: always</span><br></pre></td></tr></table></figure>

<h4 id="read-only"><a href="#read-only" class="headerlink" title="read_only"></a>read_only</h4><p>以只读模式挂载容器的 root 文件系统，意味着不能对容器内容进行修改。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">read_only: true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="读取变量"><a href="#读取变量" class="headerlink" title="读取变量"></a>读取变量</h3><p>Compose 模板文件支持动态读取主机的系统环境变量和当前目录下的 <code>.env</code> 文件中的变量。  </p>
<p>例如，下面的 Compose 文件将从运行它的环境中读取变量 ${MONGO_VERSION} 的值，并写入执行的指令中。 </p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">db:</span><br><span class="line">  image: &quot;mongo:$&#123;MONGO_VERSION&#125;&quot;</span><br></pre></td></tr></table></figure>

<p>如果执行 <code>MONGO_VERSION=3.2 ; docker compose up</code> 则会启动一个 <code>mongo:3.2</code> 镜像的容器；<br>如果执行 <code>MONGO_VERSION=2.8 ; docker compose up</code> 则会启动一个 <code>mongo:2.8</code> 镜像的容器  </p>
<p>若当前目录存在 <code>.env</code> 文件，执行 <code>docker compose</code> 命令时将从该文件中读取变量。  </p>
<p>在当前目录新建 <code>.env</code> 文件并写入以下内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 支持 # 号注释</span><br><span class="line">MONGO_VERSION=3.6</span><br></pre></td></tr></table></figure>
<p>执行 <code>docker compose up</code> 则会启动一个 <code>mongo:3.6</code> 镜像的容器。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://docs.docker.com/compose/">Compose V2 beta</a><br><a href="https://yeasy.gitbook.io/docker_practice/compose/v2">Docker 从入门到实践</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker compose 配置 django mysql 站点</title>
    <url>/202209051137/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文主要记录使用 <code>docker compose</code> 配置 Django + Mysql 的 web 站点的过程。</p>
<h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Centos7</li>
<li>Docker version 20.10.17</li>
</ul>
<h3 id="目录结构及说明"><a href="#目录结构及说明" class="headerlink" title="目录结构及说明"></a>目录结构及说明</h3><p>项目目录结构及简要说明如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── compose</span><br><span class="line">│   └── mysql</span><br><span class="line">│       └── my.cnf</span><br><span class="line">├── django_project</span><br><span class="line">│   ├── db.sqlite3</span><br><span class="line">│   ├── django_app</span><br><span class="line">│   │   ├── admin.py</span><br><span class="line">│   │   ├── apps.py</span><br><span class="line">│   │   ├── __init__.py</span><br><span class="line">│   │   ├── migrations</span><br><span class="line">│   │   ├── models.py</span><br><span class="line">│   │   ├── tests.py</span><br><span class="line">│   │   └── views.py</span><br><span class="line">│   ├── django_project</span><br><span class="line">│   │   ├── asgi.py</span><br><span class="line">│   │   ├── __init__.py</span><br><span class="line">│   │   ├── __pycache__</span><br><span class="line">│   │   ├── settings.py</span><br><span class="line">│   │   ├── urls.py</span><br><span class="line">│   │   └── wsgi.py</span><br><span class="line">│   ├── Dockerfile</span><br><span class="line">│   ├── manage.py</span><br><span class="line">│   └── requirements.txt</span><br><span class="line">├── docker-compose.yml</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><code>compose</code> : 存放应用配置文件，如 mysql 配置文件 <code>compose/mysql/my.cnf</code></li>
<li><code>django_project</code> : Django project 项目目录， <code>django-admin startproject django_project</code> 生成</li>
<li><code>django_project/django_app</code> : Django project 项目下的 app 目录，<code>django-admin startapp django_app</code> 生成</li>
<li><code>docker-compose.yml</code> : 项目的 compose 文件</li>
</ul>
<span id="more"></span>

<h3 id="编写-django-运行镜像的-Dockerfile"><a href="#编写-django-运行镜像的-Dockerfile" class="headerlink" title="编写 django 运行镜像的 Dockerfile"></a>编写 django 运行镜像的 Dockerfile</h3><p>编写构建 django 镜像的 Dockerfile，文件位置 <code>django_project/Dockerfile</code></p>
<figure class="highlight shell"><figcaption><span>django_project/Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">FROM python:3.10</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将上下文环境中(django_project/)的 requirements.txt 拷贝到镜像的 /code 目录</span></span><br><span class="line">COPY requirements.txt /code/</span><br><span class="line"></span><br><span class="line">WORKDIR /code/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 python 项目依赖</span></span><br><span class="line">RUN pip install -r requirements.txt &amp;&amp; rm -rf requirements.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解决 django 无法加载 MySQLdb 模块的问题</span></span><br><span class="line">RUN echo &quot;import pymysql&quot; &gt; /usr/local/lib/python3.10/site-packages/django/db/backends/mysql/__init__.py &amp;&amp; \</span><br><span class="line">    echo &quot;pymysql.install_as_MySQLdb()&quot; &gt;&gt; /usr/local/lib/python3.10/site-packages/django/db/backends/mysql/__init__.py</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装常用工具，方便容器启动后的调试</span></span><br><span class="line">RUN apt-get update &amp;&amp; apt install -y netcat &amp;&amp; apt install -y vim &amp;&amp; \</span><br><span class="line">    apt-get install -y iputils-ping &amp;&amp; \</span><br><span class="line">    apt-get install -y net-tools</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">健康检查，环境变量 <span class="variable">$&#123;DJANGO_SERVER_PORT&#125;</span> 来自 docker-compose.yml 文件</span></span><br><span class="line">HEALTHCHECK CMD curl -fs http://localhost:$&#123;DJANGO_SERVER_PORT&#125;/ || exit 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>构建镜像时，只将构建镜像所需的文件（<code>requirements.txt</code>）拷贝进镜像，使用完成后删除，容器运行时需要的代码文件，通过 <code>docker-compose.yml</code> 中的 <code>volumes</code> 命令进行挂载，这样更新代码时，只需要在宿主机上面更新代码，不用再对镜像进行变更，只有需要更新运行环境时才需要更新镜像  </p>
<p>django 镜像构建文件的 <code>Dockerfile</code> 中先不写 <code>CMD</code> 或者 <code>ENTRYPOINT</code> 启动 web 服务器，因为数据库还没启动，配置 <code>CMD</code> 启动 django 服务会报错（无法连接数据库）</p>
<p>修改 django 工程配置文件 <code>django_project/django_project/settings.py</code>，提前配置好 mysql 配置：</p>
<figure class="highlight shell"><figcaption><span>django_project/django_project/settings.py</span></figcaption><table><tr><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    &#x27;default&#x27;: &#123;</span><br><span class="line">        &#x27;ENGINE&#x27;: &#x27;django.db.backends.mysql&#x27;,</span><br><span class="line">        # 此处 &#x27;HOST&#x27; 配置的主机地址，要和 docker-compose.yml 中配置的 mysql 服务名称一致</span><br><span class="line">        &#x27;HOST&#x27;: &quot;db&quot;,</span><br><span class="line">        &#x27;NAME&#x27;: &quot;ops&quot;,</span><br><span class="line">        &#x27;USER&#x27;: &quot;root&quot;,</span><br><span class="line">        &quot;PASSWORD&quot;: &quot;123456&quot;,</span><br><span class="line">        &quot;PORT&quot;: &#x27;3306&#x27;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编写项目的-docker-compose-yml"><a href="#编写项目的-docker-compose-yml" class="headerlink" title="编写项目的 docker-compose.yml"></a>编写项目的 docker-compose.yml</h3><p>项目的 <code>docker-compose.yml</code> 文件内容及说明如下</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  mysql_data_vol:   # mysql datadir 需要挂载的数据卷</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  django_network:    # 本项目使用的 network ，方便项目中的服务容器之间互相通信，直接使用服务名</span><br><span class="line">    </span><br><span class="line">services:</span><br><span class="line">  db:   #  mysql 服务名</span><br><span class="line">    image: mysql:5.7</span><br><span class="line">    env_file:</span><br><span class="line">      - .env   # 服务要加载的环境变量文件，路径为相对于 docker-compose.yml 的路径</span><br><span class="line">    networks:</span><br><span class="line">      - django_network</span><br><span class="line">    volumes:</span><br><span class="line">      - mysql_data_vol:/var/lib/mysql:rw</span><br><span class="line">      - ./compose/mysql/my.cnf:/etc/my.cnf</span><br><span class="line"></span><br><span class="line">    ports:</span><br><span class="line">        - &quot;3307:3306&quot;</span><br><span class="line">    restart: always</span><br><span class="line"></span><br><span class="line">  django_server:</span><br><span class="line">    build: ./django_project/      # 使用 ./django_project/Dockerfile 构建镜像</span><br><span class="line">    env_file:</span><br><span class="line">      - .env  # 加载环境变量，其中的变量可以在 docker-compose.yml 和 Dockerfile 中使用</span><br><span class="line">      </span><br><span class="line">    volumes:</span><br><span class="line">      - ./django_project/：/code/</span><br><span class="line">    # command ： 容器要运行的命令</span><br><span class="line">    command: python manage.py runserver 0.0.0.0:$&#123;DJANGO_SERVER_PORT&#125;</span><br><span class="line">    networks:</span><br><span class="line">      - django_network</span><br><span class="line">    ports:</span><br><span class="line">      - &#x27;$&#123;DJANGO_SERVER_PORT&#125;:$&#123;DJANGO_SERVER_PORT&#125;&#x27;</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">    restart: always</span><br></pre></td></tr></table></figure>

<p>其中使用的 <code>.env</code> 文件内容如下：</p>
<figure class="highlight shell"><figcaption><span>.env</span></figcaption><table><tr><td class="code"><pre><span class="line">MYSQL_ROOT_PASSWORD=123456</span><br><span class="line"></span><br><span class="line">DJANGO_SERVER_PORT=8081</span><br></pre></td></tr></table></figure>

<h3 id="启动-docker-compose-项目"><a href="#启动-docker-compose-项目" class="headerlink" title="启动 docker compose 项目"></a>启动 docker compose 项目</h3><p>使用 <code>docker compose build</code> 之前，可以先检查一下配置，确保配置无误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker compose config</span></span><br><span class="line">name: dockerproject</span><br><span class="line">services:</span><br><span class="line">  db:</span><br><span class="line">    environment:</span><br><span class="line">      DJANGO_SERVER_PORT: &quot;8081&quot;</span><br><span class="line">      MYSQL_ROOT_PASSWORD: 123456</span><br><span class="line">    image: mysql:5.7</span><br><span class="line">    networks:</span><br><span class="line">      django_network: null</span><br><span class="line">    ports:</span><br><span class="line">    - mode: ingress</span><br><span class="line">      target: 3306</span><br><span class="line">      published: &quot;3307&quot;</span><br><span class="line">      protocol: tcp</span><br><span class="line">    restart: always</span><br><span class="line">    volumes:</span><br><span class="line">    - type: volume</span><br><span class="line">      source: mysql_data_vol</span><br><span class="line">      target: /var/lib/mysql</span><br><span class="line">      volume: &#123;&#125;</span><br><span class="line">    - type: bind</span><br><span class="line">      source: /root/dockerProject/compose/mysql/my.cnf</span><br><span class="line">      target: /etc/my.cnf</span><br><span class="line">      bind:</span><br><span class="line">        create_host_path: true</span><br><span class="line">  django_server:</span><br><span class="line">    build:</span><br><span class="line">      context: /root/dockerProject/django_project</span><br><span class="line">      dockerfile: Dockerfile</span><br><span class="line">    command:</span><br><span class="line">    - python</span><br><span class="line">    - manage.py</span><br><span class="line">    - runserver</span><br><span class="line">    - 0.0.0.0:8081</span><br><span class="line">    depends_on:</span><br><span class="line">      db:</span><br><span class="line">        condition: service_started</span><br><span class="line">    environment:</span><br><span class="line">      DJANGO_SERVER_PORT: &quot;8081&quot;</span><br><span class="line">      MYSQL_ROOT_PASSWORD: 123456</span><br><span class="line">    networks:</span><br><span class="line">      django_network: null</span><br><span class="line">    ports:</span><br><span class="line">    - mode: ingress</span><br><span class="line">      target: 8081</span><br><span class="line">      published: &quot;8081&quot;</span><br><span class="line">      protocol: tcp</span><br><span class="line">    restart: always</span><br><span class="line">networks:</span><br><span class="line">  django_network:</span><br><span class="line">    name: dockerproject_django_network</span><br><span class="line">volumes:</span><br><span class="line">  mysql_data_vol:</span><br><span class="line">    name: dockerproject_mysql_data_vol</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>配置无误，<code>docker compose config</code> 命令会输出配置，有错误会显示错误，<a href="/202208311004/" title="docker compose 其他常用命令参考">docker compose 其他常用命令参考</a></p>
<p>使用 <code>docker compose build</code> 命令构建镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker compose build</span></span><br><span class="line">[+] Building 0.1s (11/11) FINISHED                                                                                   </span><br><span class="line"> =&gt; [internal] load build definition from Dockerfile                                                            0.0s</span><br><span class="line"> =&gt; =&gt; transferring dockerfile: 32B                                                                             0.0s</span><br><span class="line"> =&gt; [internal] load .dockerignore                                                                               0.0s</span><br><span class="line"> =&gt; =&gt; transferring context: 2B                                                                                 0.0s</span><br><span class="line"> =&gt; [internal] load metadata for docker.io/library/python:3.10                                                  0.0s</span><br><span class="line"> =&gt; [internal] load build context                                                                               0.0s</span><br><span class="line"> =&gt; =&gt; transferring context: 982B                                                                               0.0s</span><br><span class="line"> =&gt; [1/6] FROM docker.io/library/python:3.10                                                                    0.0s</span><br><span class="line"> =&gt; CACHED [2/6] COPY . /code                                                                                   0.0s</span><br><span class="line"> =&gt; CACHED [3/6] WORKDIR /code                                                                                  0.0s</span><br><span class="line"> =&gt; CACHED [4/6] RUN pip install -r requirements.txt                                                            0.0s</span><br><span class="line"> =&gt; CACHED [5/6] RUN echo &quot;import pymysql&quot; &gt; /usr/local/lib/python3.10/site-packages/django/db/backends/mysql/  0.0s</span><br><span class="line"> =&gt; CACHED [6/6] RUN apt-get update &amp;&amp; apt install -y netcat &amp;&amp; apt install -y vim                              0.0s</span><br><span class="line"> =&gt; exporting to image                                                                                          0.0s</span><br><span class="line"> =&gt; =&gt; exporting layers                                                                                         0.0s</span><br><span class="line"> =&gt; =&gt; writing image sha256:9da868de3de9538931f9d60a7fd40d6197c332f4aadc03c8b8ca8446df7cee23                    0.0s</span><br><span class="line"> =&gt; =&gt; naming to docker.io/library/dockerproject_django_server                                                  0.0s</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也可以直接使用 <code>docker compose up</code>（会先构建镜像，然后启动项目中的所有服务）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker compose up</span></span><br><span class="line">[+] Running 3/2</span><br><span class="line"> ⠿ Network dockerproject_django_network     Created                                                             0.1s</span><br><span class="line"> ⠿ Container dockerproject-db-1             Created                                                             0.0s</span><br><span class="line"> ⠿ Container dockerproject-django_server-1  Created                                                             0.0s</span><br><span class="line">Attaching to dockerproject-db-1, dockerproject-django_server-1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看 compose 项目的状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker compose <span class="built_in">ls</span></span></span><br><span class="line">NAME                STATUS              CONFIG FILES</span><br><span class="line">dockerproject       running(2)          /root/dockerProject/docker-compose.yml</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看 compose 项目中的容器情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker compose ps</span></span><br><span class="line">NAME                            COMMAND                  SERVICE             STATUS              PORTS</span><br><span class="line">dockerproject-db-1              &quot;docker-entrypoint.s…&quot;   db                  running             0.0.0.0:3307-&gt;3306/tcp, :::3307-&gt;3306/tcp</span><br><span class="line">dockerproject-django_server-1   &quot;python manage.py ru…&quot;   django_server       running (healthy)   0.0.0.0:8081-&gt;8081/tcp, :::8081-&gt;8081/tcp</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看 compose 项目中的镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker compose images</span></span><br><span class="line">Container                       Repository                    Tag                 Image Id            Size</span><br><span class="line">dockerproject-db-1              mysql                         5.7                 daff57b7d2d1        430MB</span><br><span class="line">dockerproject-django_server-1   dockerproject_django_server   latest              9da868de3de9        1.02GB</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://csms.tech/categories/Docker/">docker compose 说明</a><br><a href="https://csms.tech/202208311004/">docker compose 常用命令</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>compose</tag>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 私有镜像仓库 Harbor 安装及使用</title>
    <url>/202210191515/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h2><ul>
<li>Centos 7</li>
<li>docker-ce-19.03.15</li>
<li>harbor v2.6.1</li>
</ul>
<h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><p><a href="https://goharbor.io/docs/2.6.0/install-config/">官网安装参考链接</a></p>
<h3 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://github.com/goharbor/harbor/releases/download/v2.6.1/harbor-offline-installer-v2.6.1.tgz</span><br><span class="line">tar -xf harbor-offline-installer-v2.6.1.tgz</span><br><span class="line">cd harbor</span><br></pre></td></tr></table></figure>

<h3 id="准备证书"><a href="#准备证书" class="headerlink" title="准备证书"></a>准备证书</h3><p>将申请好的证书上传到服务器，将 <code>harbor.crt</code> 转换为 <code>harbor.cert</code>  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl x509 -inform PEM -in harbor.crt -out harbor.cert </span><br></pre></td></tr></table></figure>

<p>将转换好的证书和私钥拷贝到 Docker 的证书目录 <code>/etc/docker/certs.d/yourdomain.com/</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp yourdomain.com.cert /etc/docker/certs.d/yourdomain.com/</span><br><span class="line">cp yourdomain.com.key /etc/docker/certs.d/yourdomain.com/</span><br><span class="line">cp ca.crt /etc/docker/certs.d/yourdomain.com/</span><br></pre></td></tr></table></figure>

<p>重启 Docker</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<h3 id="配置-Harbor-安装配置文件"><a href="#配置-Harbor-安装配置文件" class="headerlink" title="配置 Harbor 安装配置文件"></a>配置 Harbor 安装配置文件</h3><p>执行 <code>install.sh</code> 命令安装 Harbor 时，会使用配置文件 <code>harbor.yml</code>（需要拷贝安装包中的 <code>harbor.yml.tmpl</code> 为 <code>harbor.yml</code>）。</p>
<p>修改配置中的 <code>hostname</code> 选项，配置访问 Harbor 的域名。<strong>此为必须修改的参数</strong>。</p>
<p>修改配置中的 <code>https.certificate</code> 和 <code>https.private_key</code>，配置证书（<code>harbor.crt</code>）和私钥的路径，<strong>使用 HTTPS 时必须配置</strong>。</p>
<p>修改配置中的 <code>data_volume</code>，指定持久化数据卷的路径。默认为 <code>data_volume: /data</code></p>
<span id="more"></span>
<h3 id="执行安装脚本"><a href="#执行安装脚本" class="headerlink" title="执行安装脚本"></a>执行安装脚本</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ./install.sh</span><br></pre></td></tr></table></figure>

<p>安装成功后，使用浏览器登陆 WEB，初始密码为部署配置文件中配置，默认为 <code>Harbor12345</code></p>
<figure class="highlight shell"><figcaption><span>harbor.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">harbor_admin_password: Harbor12345</span><br></pre></td></tr></table></figure>

<p>执行安装脚本部署完成后，会生产 <code>docker-compose.yml</code> 文件，此文件为 Docker 编排 Harbor 的配置文件。使用 <code>docker</code> 重启 Harbor 命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker compose restart</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<a href="/202208311004/" title="更多 docker compose 命令说明">更多 docker compose 命令说明</a>

<h2 id="常用操作说明"><a href="#常用操作说明" class="headerlink" title="常用操作说明"></a>常用操作说明</h2><p>根据安装脚本生成的 <code>docker-compose.yml</code> ，可以看到各个服务的配置</p>
<ul>
<li>日志路径： <code>/var/log/harbor/</code>。各个服务的日志输出到了宿主机的目录 ： <code>/var/log/harbor/</code></li>
<li><code>registry</code> 服务使用本地存储时，默认路径为 ： <code>/data/registry</code></li>
<li><code>postgresql</code> 数据库目录 ： <code>/data/database</code></li>
</ul>
<h3 id="使用-docker-登陆并-push-镜像"><a href="#使用-docker-登陆并-push-镜像" class="headerlink" title="使用 docker 登陆并 push 镜像"></a>使用 docker 登陆并 push 镜像</h3><p>登陆 Harbor</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker login harbor.xxx.com</span></span><br><span class="line">sername: admin</span><br><span class="line">Password: </span><br><span class="line">WARNING! Your password will be stored unencrypted in /root/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</span><br><span class="line"></span><br><span class="line">Login Succeeded</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>push</code> 镜像步骤</p>
<ol>
<li>为要推送的镜像打上标签，其中 <code>common</code> 为项目名称 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker tag netshoot:my harbor.xxx.com/common/netshoot:my</span><br></pre></td></tr></table></figure></li>
<li><code>push</code> 镜像 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker push harbor.8be939d.com/common/netshoot:my</span><br></pre></td></tr></table></figure></li>
<li>Harbor potal 中检查推送是否成功<br> <img src="https://i.csms.tech/img_64.png"></li>
</ol>
<h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p>除了系统管理员 <code>admin</code>（拥有最大权限），Harbor 用户分还有以下几种角色<br><img src="https://i.csms.tech/img_72.png"></p>
<ul>
<li><p><code>Project Admin</code></p>
<p>  当系统管理员（<code>admin</code>）给某个用户 <code>项目管理员</code> 的角色后，该用户即可以 <code>项目管理员</code> 的身份管理该项目，其它未分配的项目无权限，<code>项目管理员</code> 有 <strong>镜像上传&#x2F;拉取</strong>、<strong>添加&#x2F;删除成员</strong>、<strong>Helm Chart 上传&#x2F;下载</strong>、<strong>配置管理</strong> 等权限。该角色在实际的业务场景通常是分配给某个项目的负责人。</p>
</li>
<li><p><code>Maintainer</code></p>
<p>  <code>维护者</code> 拥有超越<code>开发者</code> 的权限，包括 <strong>扫描镜像</strong>、<strong>查看复制任务</strong> 以及 <strong>删除镜像</strong> 和 <strong>Helm Chart上传&#x2F;下载、删除</strong> 的能力。</p>
</li>
<li><p><code>Developer</code></p>
<p>  <code>开发者</code> 拥有项目的读写权限，即 <strong>上传镜像</strong> 到该项目和从该项目 <strong>拉取镜像</strong>、<strong>上传&#x2F;下载HelmChart</strong>、<strong>查看日志</strong>，其它权限没有。</p>
</li>
<li><p><code>Guest</code></p>
<p>  <code>访客</code> 对指定项目具有 <strong>只读权限</strong>。他们可以 <strong>拉取</strong> 和重新标记图像，但 <strong>不能推送</strong>，也可以登录Harbor UI界面。</p>
</li>
<li><p><code>Limited Guest</code></p>
<p>  <code>受限访客</code> 没有项目的完全读取权限。他们可以拉取图像但不能推送，而且他们看不到日志或项目的其他成员。例如，您可以为来自不同组织的共享项目访问权限的用户创建受限访客。</p>
<p>  受限访客也可以登录 Harbor，但是只具有镜像拉取权限，无法查看日志等权限。</p>
</li>
</ul>
<h4 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h4><p>要为指定项目分配用户，必须先创建用户。只有 <code>admin</code> 用户才能创建用户。</p>
<p>要创建用户，在 <code>Administration</code> -&gt; <code>Users</code> -&gt; <code>+ NEW USER</code> 添加新用户。<br><img src="https://i.csms.tech/img_73.png"></p>
<h4 id="分配用户"><a href="#分配用户" class="headerlink" title="分配用户"></a>分配用户</h4><p><code>admin</code> 或具有 <code>Project Admin</code> 权限的用户可以在指定的项目中，为项目添加成员</p>
<p>要为项目添加成员，进入指定项目，在 <code>Members</code> -&gt; <code>+ USER</code> ，为项目分配成员<br><img src="https://i.csms.tech/img_74.png"></p>
<h2 id="配置复制"><a href="#配置复制" class="headerlink" title="配置复制"></a>配置复制</h2><p>此种复制不会复制用户信息。镜像复制到目标后，会自动更改镜像地址到目标镜像地址，可以直接使用镜像。</p>
<h3 id="配置复制到-Harbor"><a href="#配置复制到-Harbor" class="headerlink" title="配置复制到 Harbor"></a>配置复制到 Harbor</h3><p>为了对 Harbor 提供备份，可以配置复制到目标 Harbor 作为备份。</p>
<h4 id="在源-Harbor-配置-replication-endpoints"><a href="#在源-Harbor-配置-replication-endpoints" class="headerlink" title="在源 Harbor 配置 replication endpoints"></a>在源 Harbor 配置 replication endpoints</h4><p>在 <code>Administration</code> -&gt; <code>Registies</code> -&gt; <code>+ NEW ENDPOINT</code> 中，添加 <code>Endpoint</code>，除了 Harbor，还支持以下 <code>Provider</code> <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Creating Replication Endpoints](https://goharbor.io/docs/2.6.0/administration/configuring-replication/create-replication-endpoints/)">[1]</span></a></sup></p>
<ul>
<li>Docker Hub</li>
<li>Docker registry</li>
<li>AWS Elastic Container Registry</li>
<li>Azure Container Registry</li>
<li>Ali Cloud Container Registry</li>
<li>Google Container Registry</li>
<li>Huawei SWR</li>
<li>Artifact Hub</li>
<li>Gitlab</li>
<li>Quay</li>
<li>Jfrog Artifactory</li>
</ul>
<p>此处  <code>Provider</code> 选择 Harbor<br><img src="https://i.csms.tech/img_75.png"></p>
<h4 id="创建复制规则"><a href="#创建复制规则" class="headerlink" title="创建复制规则"></a>创建复制规则</h4><p>在 <code>Administration</code> -&gt; <code>Replications</code> -&gt; <code>+ NEW REPLICATION RULE</code></p>
<p>根据提示输入自定义选项</p>
<ul>
<li>如果目标 Harbor 只是用来备用或用来作为镜像下载的仓库，可以配置复制时覆盖目标中同名的镜像</li>
</ul>
<h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><h3 id="Harbar-主要的数据组成"><a href="#Harbar-主要的数据组成" class="headerlink" title="Harbar 主要的数据组成"></a>Harbar 主要的数据组成</h3><p>Harbor 安装过程中，主要依赖执行安装脚本 <a href="#%E9%85%8D%E7%BD%AE-Harbor-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">需要的配置文件 <code>harbor.yml</code></a>，安装脚本执行后，会生成 <code>docker-compose.yml</code> 文件，同时会生成其他一些临时文件，这些临时文件在 Harbor 容器启动时需要挂载到容器，这些数据通常在 Harbor 安装目录的 <code>common</code> 目录下。虽然临时数据对服务的顺利运行至关重要，但是安装程序每次都会读取 Harbor 配置文件重新生成一份临时数据，所以此处仅需备份配置文件即可</p>
<p>Harbor 容器使用的持久化数据默认保存在宿主机目录 <code>/data</code>，具体目录由安装配置文件 <code>harbor.yml</code> 配置</p>
<figure class="highlight shell"><figcaption><span>harbor.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">The default data volume</span></span><br><span class="line">data_volume: /data</span><br></pre></td></tr></table></figure>
<p><code>/data</code> 目录包含的文件夹和相应的作用如下:</p>
<ul>
<li><code>ca_download</code> - 存放用户访问Harbor时所需的 CA 证书。</li>
<li><code>database</code> - 存放数据库的目录，Harbor、Clair 和 Notary 数据库的数据都在此目录下。</li>
<li><code>job_logs</code> - 存放 JobService 的日志信息。</li>
<li><code>redis</code> - 存放 Redis 数据。</li>
<li><code>registry</code> - 存放 OCI Artifacts 数据（对于大部分用户来说是镜像数据）。</li>
<li><code>secret</code> - 存放 Harbor 内部组件通信所需的加密信息。</li>
</ul>
<p>Harbor 容器运行日志保存宿主机在 <code>/var/log/harbor</code></p>
<h3 id="备份数据"><a href="#备份数据" class="headerlink" title="备份数据"></a>备份数据</h3><ol>
<li>创建备份目录 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /HarborBackup</span><br></pre></td></tr></table></figure></li>
<li>备份 Harbor 安装目录， <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp -p -r ./harbor/ /HarborBackup/harbor</span><br></pre></td></tr></table></figure></li>
<li>备份 Harbor 持久化数据<br> 若不确定持久化数据卷的路径，可以查看安装配置文件<code>harbor.yml</code> 中的 <code>data_volume</code> 配置，默认为 <code>data_volume: /data</code> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp -p -r /data/ /HarborBackup/data</span><br></pre></td></tr></table></figure></li>
</ol>
<p>在需要恢复时，反向拷贝数据即可。需要注意，文件权限需要保持和备份之前的信息一致。</p>
<h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><h3 id="http-server-gave-HTTP-response-to-HTTPS-client"><a href="#http-server-gave-HTTP-response-to-HTTPS-client" class="headerlink" title="http: server gave HTTP response to HTTPS client"></a>http: server gave HTTP response to HTTPS client</h3><p><strong>错误原因</strong></p>
<p>docker client 和 docker registry 交互默认使用的是 HTTPS，如果镜像仓库使用的是 HTTP 服务，则与私有镜像交互时出现以上错误。</p>
<p><strong>解决方法</strong></p>
<p>修改或创建文件 <code>/etc/docker/daemon.json</code>，添加以下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123; &quot;insecure-registries&quot;:[&quot;54.236.67.117:5000&quot;] &#125;</span><br></pre></td></tr></table></figure>
<p>重启 docker</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://github.com/goharbor/harbor">官网说明</a></p>
<h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://goharbor.io/docs/2.6.0/administration/configuring-replication/create-replication-endpoints/">Creating Replication Endpoints</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://goharbor.io/docs/2.6.0/administration/configuring-replication/create-replication-rules/">Creating a Replication Rule</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Harbor</tag>
      </tags>
  </entry>
  <entry>
    <title>docker 安装及常用命令介绍</title>
    <url>/202208041317/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos 7.9.2009</li>
<li>docker-ce-19.03.15</li>
<li>docker-20.10.9</li>
</ul>
<h1 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h1><h2 id="docker-yum-安装"><a href="#docker-yum-安装" class="headerlink" title="docker yum 安装"></a>docker yum 安装</h2><p>安装 yum 源，<a href="https://docs.docker.com/engine/install/centos/">docker官方 centos 安装文档</a>  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils</span><br><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<p>安装 <code>docker</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure>

<h2 id="docker-离线安装"><a href="#docker-离线安装" class="headerlink" title="docker 离线安装"></a>docker 离线安装</h2><p><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a>下载rpm安装包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-ce-19.03.15-3.el7.x86_64.rpm</span><br><span class="line">wget https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-ce-cli-19.03.15-3.el7.x86_64.rpm</span><br><span class="line">wget https://download.docker.com/linux/centos/7/x86_64/stable/Packages/containerd.io-1.4.13-3.1.el7.x86_64.rpm</span><br><span class="line">wget https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-compose-plugin-2.3.3-3.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>
<p>安装 docker</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum localinstall -y containerd.io-1.4.13-3.1.el7.x86_64.rpm \</span><br><span class="line">                    docker-ce-cli-19.03.15-3.el7.x86_64.rpm \</span><br><span class="line">                    docker-ce-19.03.15-3.el7.x86_64.rpm \</span><br><span class="line">                    docker-compose-plugin-2.3.3-3.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>

<p>以上 2 条命令可以使用以下 1 条命令完成</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum localinstall -y https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-ce-19.03.15-3.el7.x86_64.rpm \</span><br><span class="line">                    https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-ce-cli-19.03.15-3.el7.x86_64.rpm \</span><br><span class="line">                    https://download.docker.com/linux/centos/7/x86_64/stable/Packages/containerd.io-1.4.13-3.1.el7.x86_64.rpm \</span><br><span class="line">                    https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-compose-plugin-2.3.3-3.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>

<p>启动docker</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable docker --now</span><br></pre></td></tr></table></figure>

<span id="more"></span>
<h2 id="docker-ce-19-03-15-升级到-docker-ce-20-10-9"><a href="#docker-ce-19-03-15-升级到-docker-ce-20-10-9" class="headerlink" title="docker-ce-19.03.15 升级到 docker-ce-20.10.9"></a>docker-ce-19.03.15 升级到 docker-ce-20.10.9</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum update https://download.docker.com/linux/centos/7/x86_64/stable/Packages/containerd.io-1.6.9-3.1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">yum install https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-scan-plugin-0.9.0-3.el7.x86_64.rpm \</span><br><span class="line">            https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-ce-rootless-extras-20.10.9-3.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">yum update https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-ce-cli-20.10.9-3.el7.x86_64.rpm \</span><br><span class="line">           https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-ce-20.10.9-3.el7.x86_64.rpm \</span><br><span class="line">           https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-compose-plugin-2.6.0-3.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>

<h2 id="安装-docker-20-10-9"><a href="#安装-docker-20-10-9" class="headerlink" title="安装 docker-20.10.9"></a>安装 docker-20.10.9</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y https://download.docker.com/linux/centos/7/x86_64/stable/Packages/containerd.io-1.6.9-3.1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">yum install -y https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-ce-cli-20.10.9-3.el7.x86_64.rpm \</span><br><span class="line">               https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-scan-plugin-0.9.0-3.el7.x86_64.rpm</span><br><span class="line">              </span><br><span class="line">              </span><br><span class="line">yum install -y  https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-ce-rootless-extras-20.10.9-3.el7.x86_64.rpm \</span><br><span class="line">                https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-ce-20.10.9-3.el7.x86_64.rpm \</span><br><span class="line">                https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-ce-rootless-extras-20.10.9-3.el7.x86_64.rpm \</span><br><span class="line">                https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-compose-plugin-2.6.0-3.el7.x86_64.rpm</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="docker-常用命令"><a href="#docker-常用命令" class="headerlink" title="docker 常用命令"></a>docker 常用命令</h1><h2 id="docker-镜像管理命令"><a href="#docker-镜像管理命令" class="headerlink" title="docker 镜像管理命令"></a>docker 镜像管理命令</h2><h3 id="获取（下载）镜像"><a href="#获取（下载）镜像" class="headerlink" title="获取（下载）镜像"></a>获取（下载）镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span><br><span class="line">docker pull centos:centos7.9.2009</span><br></pre></td></tr></table></figure>
<blockquote>
<p>未指定地址，默认是从 <a href="https://hub.docker.com/search?q=&type=image">Docker Hub</a> 上面获取镜像，<a href="https://yeasy.gitbook.io/docker_practice/image/pull">参考说明</a><br>标签信息可从 <a href="https://hub.docker.com/search?q=&type=image">Docker Hub</a> 上面查看</p>
</blockquote>
<h3 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h3><p><a href="#%E8%8E%B7%E5%8F%96%EF%BC%88%E4%B8%8B%E8%BD%BD%EF%BC%89%E9%95%9C%E5%83%8F">获取（下载）镜像</a>后，运行镜像并运行镜像中的<code>bash</code>命令进入对应容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it --rm centos:centos7.9.2009 bash</span><br><span class="line">cat /etc/os-release</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>

<p>进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。例如执行 <code>cat /etc/os-release</code>。容器中执行<code>exit</code>命令可以退出容器</p>
<p><img src="https://i.csms.tech/img_35.png"></p>
<p><code>docker run</code> 命令常用选项说明</p>
<style>
table th:nth-of-type(1){
width: 10%;
}
table th:nth-of-type(2){
width: 70%
;
}
table th:nth-of-type(3){
width: 20%;
}

</style>

<table>
<thead>
<tr>
<th align="left">选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-i</code></td>
<td>启用交互式操作</td>
<td></td>
</tr>
<tr>
<td align="left"><code>-t</code></td>
<td>开启终端（输入输出）</td>
<td></td>
</tr>
<tr>
<td align="left"><code>--rm</code></td>
<td>容器退出(<code>exit</code>)后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。</td>
<td></td>
</tr>
<tr>
<td align="left"><code>--name</code></td>
<td>给启动的容器命名</td>
<td><code>docker run -d --name &quot;centos7&quot; centos:centos7.9.2009 bash</code></td>
</tr>
<tr>
<td align="left"><code>-d</code></td>
<td>后台运行，启动后返回容器id，并进入后台运行，容器的输出可使用 <code>docker logs CONTAINER</code> 或 <code>docker container logs CONTAINER</code> 查看</td>
<td></td>
</tr>
<tr>
<td align="left"><code>--entrypoint</code></td>
<td>覆盖（替换）镜像中<a href="https://csms.tech/202208050928/#ENTRYPOINT-容器启动程序指令">默认的<code>ENTRYPOINT</code></a></td>
<td></td>
</tr>
</tbody></table>
<h3 id="列出已下载的镜像"><a href="#列出已下载的镜像" class="headerlink" title="列出已下载的镜像"></a>列出已下载的镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker image <span class="built_in">ls</span></span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE  </span><br><span class="line">centos              centos7.9.2009      eeb6ee3f44bd        10 months ago       204MB</span><br></pre></td></tr></table></figure>



<p>列表包含了 <code>仓库名</code>、<code>标签</code>、<code>镜像 ID</code>、<code>创建时间</code> 以及 <code>所占用的空间</code>。  </p>
<blockquote>
<p><code>IMAGE ID</code> 是镜像的唯一标识，同一个镜像可以有多个标签</p>
</blockquote>
<h3 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker image rm centos:centos7.9.2009</span><br><span class="line"></span><br><span class="line">docker image rm eeb6ee3f44bd</span><br></pre></td></tr></table></figure>

<p>可以用镜像名(<code>&lt;仓库名&gt;:&lt;标签&gt;</code>) ，<code>镜像 ID</code> 删除镜像</p>
<p>也可以使用 <code>镜像摘要</code> 删除镜像<br>查看 <code>镜像摘要</code>  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker image <span class="built_in">ls</span> --digests</span></span><br><span class="line">REPOSITORY          TAG                 DIGEST                      IMAGE ID            CREATED             SIZE</span><br><span class="line">centos              centos7.9.2009      sha256:c73f515d06b0fa0...   eeb6ee3f44bd        10 months ago       204MB</span><br></pre></td></tr></table></figure>


<p>使用 <code>镜像摘要</code> 删除镜像<br>命令格式 <code>docker image rm REPOSITORY@DIGEST</code>  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker image <span class="built_in">rm</span> centos@sha256:c73f515d06b0fa0...</span></span><br><span class="line">Untagged: centos@sha256:c73f515d06b0fa07bb18d8202035e739a494ce760aa73129f60f4bf2bd22b407</span><br></pre></td></tr></table></figure>


<p>删除行为分为两类，一类是 <code>Untagged</code>，另一类是 <code>Deleted</code>。<br>因为一个镜像可以对应多个标签，当我们使用上面命令删除镜像的时候，实际上是在要求删除某个标签的镜像。<br>所以首先需要做的是将满足我们要求的所有镜像标签都取消，这就是我们看到的 <code>Untagged</code> 的信息 ,因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么 <code>Delete</code> 行为就不会发生。<br>所以并非所有的 <code>docker image rm</code> 都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。<br>当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。  </p>
<h3 id="镜像导出和导入"><a href="#镜像导出和导入" class="headerlink" title="镜像导出和导入"></a>镜像导出和导入</h3><h4 id="通过镜像来导出导入"><a href="#通过镜像来导出导入" class="headerlink" title="通过镜像来导出导入"></a>通过镜像来导出导入</h4><p>使用命令 <code>docker save</code> 和 <code>docker load</code> 可以根据镜像 ID 将镜像导出到文件，并在另一个 docker 节点导入。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker image <span class="built_in">ls</span></span></span><br><span class="line">REPOSITORY                   TAG              IMAGE ID       CREATED         SIZE</span><br><span class="line">centos7                      my               f40e4ec9c0c7   3 weeks ago     485MB</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker save f40e4ec9c0c7 &gt; centos7_my.tar</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker load &lt; centos7_my.tar</span></span><br></pre></td></tr></table></figure>

<h3 id="容器制作成镜像"><a href="#容器制作成镜像" class="headerlink" title="容器制作成镜像"></a>容器制作成镜像</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">docker commit -m <span class="string">&quot;describe info&quot;</span> -p CONTAINER [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-m</code></td>
<td>描述信息</td>
<td></td>
</tr>
<tr>
<td align="left"><code>-p</code></td>
<td>打包镜像时暂停容器</td>
<td></td>
</tr>
<tr>
<td align="left"><code>a</code></td>
<td>提交的镜像作者</td>
<td></td>
</tr>
</tbody></table>
<h2 id="doker-容器管理命令"><a href="#doker-容器管理命令" class="headerlink" title="doker 容器管理命令"></a>doker 容器管理命令</h2><h3 id="启动已终止的容器"><a href="#启动已终止的容器" class="headerlink" title="启动已终止的容器"></a>启动已终止的容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker container start CONTAINER</span><br><span class="line">docker container restart CONTAINER</span><br><span class="line">docker start CONTAINER</span><br></pre></td></tr></table></figure>

<h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker attach CONTAINER</span><br><span class="line">docker exec -it CONTAINER bash</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>docker attach</code> 进入容器，如果再从这个 <code>stdin</code> 中 <code>exit</code>，会导致容器的停止<br><code>docker exec</code> 进入容器，如果再从这个 <code>stdin</code> 中 <code>exit</code>，不会导致容器的停止，推荐进入容器使用 <code>docker exec -it CONTAINER bash</code>  </p>
</blockquote>
<h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker container rm CONTAINER</span><br></pre></td></tr></table></figure>

<p><code>docker container rm</code> 可以删除已终止的容器，要强制删除运行中的容器，可以使用选项 <code>-f</code>，Docker 会发送 SIGKILL 信号给容器。  </p>
<p>用 <code>docker container ls -a</code> 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker container prune</span><br></pre></td></tr></table></figure>

<h2 id="docker-数据管理命令"><a href="#docker-数据管理命令" class="headerlink" title="docker 数据管理命令"></a>docker 数据管理命令</h2><h3 id="容器数据卷管理命令"><a href="#容器数据卷管理命令" class="headerlink" title="容器数据卷管理命令"></a>容器数据卷管理命令</h3><p><code>数据卷</code> 的使用，类似于 Linux 下对目录或文件进行 <code>mount</code> ，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。</p>
<p>创建数据卷</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker volume create DOCKERVOLUME</span><br></pre></td></tr></table></figure>

<p>查看数据卷信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker volume <span class="built_in">ls</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker volume inspect DOCKERVOLUME</span></span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;CreatedAt&quot;: &quot;2022-08-10T15:03:13+08:00&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/DOCKERVOLUME/_data&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;DOCKERVOLUME&quot;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>删除不在使用的数据卷</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker volume rm DOCKERVOLUME</span><br></pre></td></tr></table></figure>

<p>挂载使用数据卷</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -it -v DOCKERVOLUME:/data/ --name centos7 centos:centos7</span><br><span class="line">docker run -d -it --mount source=DOCKERVOLUME,target=/data, --name centos7 centos:centos7</span><br></pre></td></tr></table></figure>

<h3 id="挂载宿主机目录-文件"><a href="#挂载宿主机目录-文件" class="headerlink" title="挂载宿主机目录(文件)"></a>挂载宿主机目录(文件)</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -it -v /data/:/data/ --name centos7 centos:centos7</span><br><span class="line">docker run -d -it --mount type=bind,source=/data/,target=/data --name centos7 centos:centos7</span><br></pre></td></tr></table></figure>

<p>本地目录的路径必须是绝对路径，以前使用 <code>-v</code> 参数时如果本地目录不存在 <code>Docker</code> 会自动为你创建一个文件夹，现在使用 <code>--mount</code> 参数时如果本地目录不存在，<code>Docker</code> 会报错。  </p>
<p>挂载权限默认为 <code>rw</code> ，可以通过增加 <code>readonly</code> 指定为 只读</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -it -v /data/:/data/:ro --name centos7 centos:centos7</span><br><span class="line">docker run -d -it --mount type=bind,source=/data/,target=/data,readonly --name centos7 centos:centos7</span><br></pre></td></tr></table></figure>

<blockquote>
<p>挂载本地宿主机目录(文件)，使用选项 <code>--mount</code> 时，需要指定 <code>type=bind</code>, 否则 docker 会将源目录当做 <code>数据卷</code> 处理，可能报以下错误：<br><code>docker: Error response from daemon: create /data/: &quot;/data/&quot; includes invalid characters for a local volume name, only &quot;[a-zA-Z0-9][a-zA-Z0-9_.-]&quot; are allowed. If you intended to pass a host directory, use absolute path.</code></p>
</blockquote>
<h2 id="docker-网络管理命令"><a href="#docker-网络管理命令" class="headerlink" title="docker 网络管理命令"></a>docker 网络管理命令</h2><p>使用 <code>docker run</code> 命令的 <code>-P</code> 选项，<code>Docker</code> 会随机映射一个宿主机端口到内部容器开放的网络端口(<code>Dockerfile</code> 中 <code>EXPOSE</code> 的端口)。  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d -P nginx:alpine</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker container <span class="built_in">ls</span> -l</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                   NAMES</span><br><span class="line">fae320d08268        nginx:alpine        &quot;/docker-entrypoint.…&quot;   24 seconds ago      Up 20 seconds       0.0.0.0:32768-&gt;80/tcp   bold_mcnulty</span><br></pre></td></tr></table></figure>

<p>使用 <code>docker run</code> 命令的 <code>-p</code> 选项，则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有</p>
<ul>
<li><code>hostPort:containerPort</code>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 80:80 nginx:alpine</span><br></pre></td></tr></table></figure>
这样会绑定到宿主机所有接口上的所有 ip 地址</li>
<li><code>ip:hostPort:containerPort</code>    <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 127.0.0.1:80:80 nginx:alpine</span><br></pre></td></tr></table></figure>
此种格式可以指定映射宿主机的一个特定地址（IP），比如 <code>localhost</code> 地址 <code>127.0.0.1</code></li>
<li><code>ip::containerPort</code>    <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 127.0.0.1::80 nginx:alpine</span><br></pre></td></tr></table></figure>
使用 <code>ip::containerPort</code> 会绑定宿主机指定 ip 的任意端口到容器的指定端口，本地宿主机会自动分配一个随机端口。</li>
</ul>
<p><code>-p</code> 选项可以多次使用来绑定多个端口  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">    -p 80:80 \</span><br><span class="line">    -p 443:443 \</span><br><span class="line">    nginx:alpine</span><br></pre></td></tr></table></figure>

<p>还可以使用 <code>udp</code> 标记来指定 <code>udp</code> 端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 127.0.0.1:80:80/udp nginx:alpine</span><br></pre></td></tr></table></figure>

<p>查看容器映射的端口信息可以使用以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker port c8a91c8fafba</span></span><br><span class="line">80/tcp -&gt; 0.0.0.0:81</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker port c8a91c8fafba 80</span></span><br><span class="line">0.0.0.0:81</span><br></pre></td></tr></table></figure>


<h2 id="docker-资源状态命令"><a href="#docker-资源状态命令" class="headerlink" title="docker 资源状态命令"></a>docker 资源状态命令</h2><h3 id="查看-docker-各项功能占用的系统磁盘大小"><a href="#查看-docker-各项功能占用的系统磁盘大小" class="headerlink" title="查看 docker 各项功能占用的系统磁盘大小"></a>查看 docker 各项功能占用的系统磁盘大小</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker system <span class="built_in">df</span></span></span><br><span class="line">TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE</span><br><span class="line">Images              1                   0                   203.9MB             203.9MB (100%)</span><br><span class="line">Containers          0                   0                   0B                  0B</span><br><span class="line">Local Volumes       0                   0                   0B                  0B</span><br><span class="line">Build Cache         0                   0                   0B                  0B</span><br></pre></td></tr></table></figure>

<p>结果中包含了 <code>镜像</code>、<code>容器</code>、<code>数据卷</code> 所占用的空间</p>
<h3 id="清除-docker-中所有未使用的资源"><a href="#清除-docker-中所有未使用的资源" class="headerlink" title="清除 docker 中所有未使用的资源"></a>清除 docker 中所有未使用的资源</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker system prune</span></span><br><span class="line">WARNING! This will remove:</span><br><span class="line">  - all stopped containers</span><br><span class="line">  - all networks not used by at least one container</span><br><span class="line">  - all dangling images</span><br><span class="line">  - all dangling build cache</span><br><span class="line"></span><br><span class="line">Are you sure you want to continue? [y/N] y</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="查看-docker-容器中启动的脚本参数和完整的命令"><a href="#查看-docker-容器中启动的脚本参数和完整的命令" class="headerlink" title="查看 docker 容器中启动的脚本参数和完整的命令"></a>查看 docker 容器中启动的脚本参数和完整的命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps -a --no-trunc</span><br></pre></td></tr></table></figure>

<h1 id="其他相关功能"><a href="#其他相关功能" class="headerlink" title="其他相关功能"></a>其他相关功能</h1><h2 id="获得容器运行时的命令"><a href="#获得容器运行时的命令" class="headerlink" title="获得容器运行时的命令"></a>获得容器运行时的命令</h2><p>运行容器最好使用 compose ，不然时间长了，不记得创建&#x2F;运行容器时的命令，需要重新找回创建&#x2F;运行容器时的命令</p>
<h3 id="runlike"><a href="#runlike" class="headerlink" title="runlike"></a>runlike</h3><p>若需要方便的查看容器 <code>run</code> 或 <code>create</code> 时使用的命令，可以使用 <code>runlike</code> 命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip3 install runlike</span><br><span class="line"></span><br><span class="line">runlike -p aa245f973a1c</span><br></pre></td></tr></table></figure>
<h3 id="get-command-4-run-container"><a href="#get-command-4-run-container" class="headerlink" title="get_command_4_run_container"></a>get_command_4_run_container</h3><p><code>get_command_4_run_container</code> 类似 <code>runlike</code> 命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull cucker/get_command_4_run_container</span><br><span class="line"></span><br><span class="line">docker run --rm -v /var/run/docker.sock:/var/run/docker.sock cucker/get_command_4_run_container [容器名称]/[容器ID]</span><br></pre></td></tr></table></figure>

<h2 id="修改运行中的容器的配置"><a href="#修改运行中的容器的配置" class="headerlink" title="修改运行中的容器的配置"></a>修改运行中的容器的配置</h2><p>容器已经运行后，若需要在不删除容器的情况下修改配置，可以修改容器的配置文件，默认路径在 <code>/var/lib/docker/containers/$&#123;CONTAINERID&#125;/hostconfig.json</code>，其内容为 json 格式，可以使用专门能解析 json 格式的工具打开，进行相应的修改。</p>
<p>修改之前要先停止 docker 服务，再修改，修改后在启动 docker 服务，否则无法更改成功。</p>
<h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><h2 id="docker-启动容器时报错"><a href="#docker-启动容器时报错" class="headerlink" title="docker 启动容器时报错"></a>docker 启动容器时报错</h2><p>docker 报以下错误</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker: Error response from daemon: OCI runtime create failed: unable to retrieve OCI runtime error (open /run/containerd/io.containerd.runtime.v1.linux/moby/f3cc24022c80fa1e12fcf91f31421ac7f1244abd03af1403edeeb01aceffb3fe/log.json: no such file or directory): runc did not terminate successfully: exit status 127: runc: symbol lookup error: runc: undefined symbol: seccomp_notify_respond</span><br><span class="line">: unknown.</span><br></pre></td></tr></table></figure>
<p>此错误由底层的 <code>runc</code> 返回，直接执行 <code>runc</code> 命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ runc</span><br><span class="line">runc: symbol lookup error: runc: undefined symbol: seccomp_notify_respond</span><br></pre></td></tr></table></figure>
<p><strong>原因</strong>： <code>runc</code> 缺乏依赖 <code>libseccomp</code>，centos7 中 yum 默认的版本是 2.3 的，版本不满足最新 <code>containerd</code> 的需求，需要下载 2.4 以上的 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Containerd 提示runc: symbol lookup error: runc: undefined symbol: seccomp_notify_respond](https://i4t.com/5434.html)">[1]</span></a></sup> </p>
<p>卸载旧版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rpm -qa | grep libseccomp</span></span><br><span class="line">libseccomp-2.3.1-4.el7.x86_64</span><br><span class="line">libseccomp-devel-2.3.1-4.el7.x86_64</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rpm -e libseccomp-2.3.1-4.el7.x86_64 libseccomp-devel-2.3.1-4.el7.x86_64 --nodeps</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget http://rpmfind.net/linux/centos/8-stream/BaseOS/x86_64/os/Packages/libseccomp-2.5.1-1.el8.x86_64.rpm</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rpm -ivh libseccomp-2.5.1-1.el8.x86_64.rpm</span></span><br><span class="line">warning: libseccomp-2.5.1-1.el8.x86_64.rpm: Header V3 RSA/SHA256 Signature, key ID 8483c65d: NOKEY</span><br><span class="line">Preparing...                          ################################# [100%]</span><br><span class="line">Updating / installing...</span><br><span class="line">   1:libseccomp-2.5.1-1.el8           ################################# [100%]</span><br><span class="line">   </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rpm -qa | grep libseccomp</span></span><br><span class="line">libseccomp-2.5.1-1.el8.x86_64 </span><br></pre></td></tr></table></figure>

<p>再次执行 <code>runc</code>，正常</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">runc</span></span><br><span class="line">NAME:</span><br><span class="line">   runc - Open Container Initiative runtime</span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://docs.docker.com/engine/install/centos/">docker官方 centos 安装文档</a>  </p>
<p><a href="https://download.docker.com/linux/centos/">docker 官方 centos 版本下载地址</a></p>
<p><a href="https://mirrors.aliyun.com/docker-ce/linux/centos/7/x86_64/stable/Packages/">docker centos版本 阿里云下载地址</a>  </p>
<p><a href="https://yeasy.gitbook.io/docker_practice/introduction/what">什么是 Docker</a>  </p>
<p><a href="https://yeasy.gitbook.io/docker_practice/introduction/why">为什么要用 Docker</a></p>
<p><a href="https://yeasy.gitbook.io/docker_practice/">docker 从入门到实践</a></p>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://i4t.com/5434.html">Containerd 提示runc: symbol lookup error: runc: undefined symbol: seccomp_notify_respond</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 docker 运行 jenkins 的安装配置及使用</title>
    <url>/202210121455/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="版本信息"><a href="#版本信息" class="headerlink" title="版本信息"></a>版本信息</h1><ul>
<li>Centos-7 3.10.0-1160</li>
<li>Docker Engine 19.03.15</li>
<li>jenkinsci&#x2F;blueocean Jenkins 2.346.3</li>
</ul>
<h1 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h1><h2 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h2><p><a href="https://hub.docker.com/">官方镜像仓库</a> 中搜索 <code>jenkinsci/blueocean</code>，下载最新镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull jenkinsci/blueocean</span><br></pre></td></tr></table></figure>


<h2 id="启动-jenkins-容器"><a href="#启动-jenkins-容器" class="headerlink" title="启动 jenkins 容器"></a>启动 jenkins 容器</h2><p>创建数据目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /data/JenkinsData_blueocean</span><br><span class="line">chmod 777 /data/JenkinsData_blueocean</span><br></pre></td></tr></table></figure>
<p>启动 jenkins 容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8080:8080 --name jenkins \</span><br><span class="line">          -v /var/run/docker.sock:/var/run/docker.sock  \</span><br><span class="line">          -v /data/JenkinsData_blueocean/:/var/jenkins_home/ \</span><br><span class="line">          -u root \</span><br><span class="line">          jenkinsci/blueocean</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-v /var/run/docker.sock:/var/run/docker.sock</code> - 在需要使用 Jenkins 构建 Docker 镜像时，Jenkins 容器中的 docker 客户端需要连接到宿主机的 Docker server</li>
<li><code>-v /data/JenkinsData_blueocean/:/var/jenkins_home/</code> - 数据持久化到宿主机目录</li>
<li><code>-u root</code> - 容器中使用 <code>root</code> 用户运行，要使用 Jenkins 构建 Docker 镜像时，默认的 <code>jenkins</code> 用户无权限访问 <code>/var/run/docker.sock</code></li>
</ul>
<span id="more"></span>
<h2 id="防火墙开放端口"><a href="#防火墙开放端口" class="headerlink" title="防火墙开放端口"></a>防火墙开放端口</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -I INPUT 7 -p tcp -m multiport --dports 8080 -j ACCEPT -m comment --comment &quot;Jenkins&quot;</span><br></pre></td></tr></table></figure>

<h2 id="查看初始密码"><a href="#查看初始密码" class="headerlink" title="查看初始密码"></a>查看初始密码</h2><p>初始密码会打印在日志里面</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker logs jenkins</span></span><br><span class="line">...</span><br><span class="line">*************************************************************</span><br><span class="line">*************************************************************</span><br><span class="line">*************************************************************</span><br><span class="line"></span><br><span class="line">Jenkins initial setup is required. An admin user has been created and a password generated.</span><br><span class="line">Please use the following password to proceed to installation:</span><br><span class="line"></span><br><span class="line">acafa239f38043e6a54a0fde448</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用日志中显示的密码登陆 web。</p>
<h1 id="Jenkins-pipeline-script-语法"><a href="#Jenkins-pipeline-script-语法" class="headerlink" title="Jenkins pipeline script 语法"></a>Jenkins pipeline script 语法</h1><p><code>Jenkins pipeline script</code> 基本格式如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&#x27;Build&#x27;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh &#x27;echo &quot;Hello World&quot;&#x27;</span><br><span class="line">                sh &#x27;&#x27;&#x27;</span><br><span class="line">                    echo &quot;Multiline shell steps works too&quot;</span><br><span class="line">                    ls -lah</span><br><span class="line">                &#x27;&#x27;&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage() &#123;</span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    post &#123;</span><br><span class="line">        always &#123;</span><br><span class="line">            echo &#x27;This will always run&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        success &#123;</span><br><span class="line">            echo &#x27;This will run only if successful&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        failure &#123;</span><br><span class="line">            echo &#x27;This will run only if failed&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        unstable &#123;</span><br><span class="line">            echo &#x27;This will run only if the run was marked as unstable&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        changed &#123;</span><br><span class="line">            echo &#x27;This will run only if the state of the Pipeline has changed&#x27;</span><br><span class="line">            echo &#x27;For example, if the Pipeline was previously failing but is now successful&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="agent-命令"><a href="#agent-命令" class="headerlink" title="agent 命令"></a>agent 命令</h2><p><code>agent</code> 指令告诉 Jenkins 在哪里以及如何执行 <code>Pipeline</code> 或者<code> Pipeline</code> 子集。 所有的 <code>Pipeline</code> 都需要 <code>agent</code> 指令。 <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[定义执行环境](https://www.jenkins.io/zh/doc/pipeline/tour/agents/#%E5%AE%9A%E4%B9%89%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83)">[2]</span></a></sup></p>
<p>下面的 <code>pipeline</code> 使用 <code>docker</code> 做为执行环境，并指定 <code>docker</code> 镜像，当执行 Pipelin e时，Jenkins 将会自动运行指定的容器，并执行 Pipeline 中已经定义好的步骤 <code>steps</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent &#123;</span><br><span class="line">        docker &#123; image &#x27;node:7-alpine&#x27; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&#x27;Test&#x27;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh &#x27;node --version&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>agent any</code> 指令指示 Jenkins 为整个流水线分配一个执行器 (在 Jenkins 环境中的任何可用代理&#x2F;节点上)和工作区</p>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>环境变量（<code>environment</code>）可以设置为全局的，也可以是阶段（<code>stage</code>）级别的，阶段（<code>stage</code>）级别的环境变量只能在定义变量的阶段（<code>stage</code>）使用 <sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[使用环境变量](https://www.jenkins.io/zh/doc/pipeline/tour/environment/#%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F)">[3]</span></a></sup></p>
<p>Jenkins 流水线通过全局变量 <code>env</code> 提供全局环境变量，它在 <code>Jenkinsfile</code> 文件的任何地方都可以使用。Jenkins 流水线中可访问的完整的环境变量列表记录在 <code>$&#123;YOUR_JENKINS_URL&#125;/pipeline-syntax/globals#env</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Jenkinsfile (Declarative Pipeline)</span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    environment &#123; </span><br><span class="line">        CC = &#x27;clang&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&#x27;Example&#x27;) &#123;</span><br><span class="line">            environment &#123; </span><br><span class="line">                DEBUG_FLAGS = &#x27;-g&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh &#x27;printenv&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你使用 <code>Build with Parameters</code> 选项将流水线配置为接受参数，这些参数将作为 <code>params</code> 变量的成员被访问。 <sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[处理参数](https://www.jenkins.io/zh/doc/book/pipeline/jenkinsfile/#%E5%A4%84%E7%90%86%E5%8F%82%E6%95%B0)">[5]</span></a></sup></p>
<p>假设在 Jenkinsfile 中配置了名为 <code>Greeting</code> 的字符串参数，它可以通过 <code>$&#123;params.Greeting&#125;</code> 访问该参数</p>
<p>**引用环境变量时，如果使用引号，需要使用 <code>&quot;</code>（双引号），不能使用 <code>&#39;</code>（单引号） **</p>
<h2 id="post-命令"><a href="#post-命令" class="headerlink" title="post 命令"></a>post 命令</h2><p>因为 <code>post</code> 部分保证在 <code>Pipeline</code> 结束的时候运行， 所以我们可以添加通知或者其他的步骤去完成清理、通知或者其他的 <code>Pipeline</code> 结束任务。 <sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[清理和通知](https://www.jenkins.io/zh/doc/pipeline/tour/post/#%E6%B8%85%E7%90%86%E5%92%8C%E9%80%9A%E7%9F%A5)">[4]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&#x27;No-op&#x27;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh &#x27;ls&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    post &#123;</span><br><span class="line">        always &#123;</span><br><span class="line">            echo &#x27;One way or another, I have finished&#x27;</span><br><span class="line">            deleteDir() /* clean up our workspace */</span><br><span class="line">        &#125;</span><br><span class="line">        success &#123;</span><br><span class="line">            echo &#x27;I succeeeded!&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        unstable &#123;</span><br><span class="line">            echo &#x27;I am unstable :/&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        failure &#123;</span><br><span class="line">            echo &#x27;I failed :(&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        changed &#123;</span><br><span class="line">            echo &#x27;Things were different before...&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h1><h2 id="凭证使用方法"><a href="#凭证使用方法" class="headerlink" title="凭证使用方法"></a>凭证使用方法</h2><h3 id="Usernames-and-passwords"><a href="#Usernames-and-passwords" class="headerlink" title="Usernames and passwords"></a>Usernames and passwords</h3><p>在 <code>Manage Jenkins</code> -&gt; <code>Manage Credentials</code> 中添加 <code>kind</code> 为 <code>Username with password</code> 的凭据。</p>
<p>在 Pipeline 中配置环境变量，使用方法 <code>credentials()</code> 调用已配置的凭据，需要的参数为 credentials 的 ID 信息<br><img src="https://i.csms.tech/img_70.png"></p>
<figure class="highlight shell"><figcaption><span>Jenkinsfile</span></figcaption><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">	</span><br><span class="line">	environment &#123;</span><br><span class="line">		harbor_credentials = credentials(&#x27;harbor.my.com&#x27;)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	stages &#123;</span><br><span class="line">        </span><br><span class="line">		stage(&#x27;login harbor&#x27;) &#123;</span><br><span class="line">		    steps &#123;</span><br><span class="line">				</span><br><span class="line">				sh &#x27;docker login -u $&#123;harbor_credentials_USR&#125; -p $&#123;harbor_credentials_PSW&#125; $&#123;DOCKER_REGISTRY&#125;&#x27;</span><br><span class="line">	</span><br><span class="line">			&#125;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>stages</code> 中可以通过 <code>$&#123;harbor_credentials_USR&#125;</code>，<code>$&#123;harbor_credentials_PSW&#125;</code> 分别调用 <code>username</code> 和 <code>password</code> <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[凭证使用方法](https://www.jenkins.io/doc/book/pipeline/jenkinsfile/#handling-credentials)">[1]</span></a></sup></p>
<h2 id="environment-中变量的值为其他命令的输出"><a href="#environment-中变量的值为其他命令的输出" class="headerlink" title="environment 中变量的值为其他命令的输出"></a>environment 中变量的值为其他命令的输出</h2><p>在 <code>environment</code> 中需要定义变量，变量的值为其他命令的输出，等同于 <code>shell</code> 中的如下定义</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">DATE=`date +%Y%m%d%H%M`</span><br></pre></td></tr></table></figure>
<p>在 Jenkins 的 <code>environment</code> 中需要使用以下方式</p>
<figure class="highlight shell"><figcaption><span>Jenkinsfile</span></figcaption><table><tr><td class="code"><pre><span class="line">environment &#123;</span><br><span class="line">	</span><br><span class="line">	DATE=&quot;$&#123;sh(script: &#x27;date +%Y%m%d%H%M&#x27;, returnStdout:true)&#125;&quot;.trim()</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>.trim()</code> 去除变量最后的换行。</p>
<h2 id="配置文件管理插件-Config-File-Provider"><a href="#配置文件管理插件-Config-File-Provider" class="headerlink" title="配置文件管理插件 Config File Provider"></a>配置文件管理插件 Config File Provider</h2><p>多个配置中如果有公共的配置，可以将其进行统一管理，使用 <code>Config File Provider</code> 插件，安装后管理页面（<code>Manage Jenkins</code>）会多出 <code>Managed files</code> 菜单项，进入后 <code>Add a new Config</code> 可以添加配置，同时指定 <code>id</code> 和 <code>Name</code>。<br><img src="https://i.csms.tech/img_84.png"></p>
<p>示例内容，格式为 <code>yaml</code>，调用用时可以使用 <code>readYaml  file:&quot;$&#123;CONFIG_FILE&#125;&quot;</code> 读取内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">system:</span><br><span class="line">  docker_harbor_url: https://harbor.my.com</span><br><span class="line">  docker_hub_cre_id: habor</span><br><span class="line">project:</span><br><span class="line">  - name: app-0</span><br><span class="line">    git_url: http://gitlab.my.com/app1/app.git</span><br><span class="line">    git_cre_id: git</span><br><span class="line">  - name: app-1</span><br><span class="line">    git_url: http://gitlab.my.com/app2/app.git</span><br><span class="line">    git_cre_id: git</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>调用方式 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">configFileProvider(</span><br><span class="line">        [configFile(fileId: &#x27;config-yaml&#x27;, variable: &#x27;CONFIG_FILE&#x27;)]) &#123;</span><br><span class="line">        jenkins_props = readYaml  file:&quot;$&#123;CONFIG_FILE&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    echo jenkins_props.project[0].name   / 输出内容： app-0 /</span><br><span class="line">    echo jenkins_props.project[1].git_url  / 输出内容： http://gitlab.my.com/app2/app.git /</span><br></pre></td></tr></table></figure>

<ul>
<li><code>fileId</code> - 为创建配置时的 <code>id</code></li>
<li><code>variable</code> - 将配置文件内容临时存储于指定的文件名中</li>
<li><code>targetLocation</code> - 将配置文件拷贝到 <code>$&#123;WORKSPACE&#125;/$&#123;targetLocation&#125;</code></li>
</ul>
<h2 id="脚本式-Pipeline-语法中执行-shell-命令"><a href="#脚本式-Pipeline-语法中执行-shell-命令" class="headerlink" title="脚本式 Pipeline 语法中执行 shell 命令"></a>脚本式 Pipeline 语法中执行 shell 命令</h2><p>在脚本式 Pipeline 语法中，需要执行 shell 命令及获取命令输出时，可以通过 <code>sh</code> 指令执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git_commit = sh(returnStdout: true, script: &quot;git rev-parse HEAD&quot;).trim()</span><br><span class="line">echo git_commit</span><br></pre></td></tr></table></figure>

<h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><h2 id="find-x2F-usr-x2F-share-x2F-jenkins-x2F-ref-No-such-file-or-directory"><a href="#find-x2F-usr-x2F-share-x2F-jenkins-x2F-ref-No-such-file-or-directory" class="headerlink" title="find: &#x2F;usr&#x2F;share&#x2F;jenkins&#x2F;ref: No such file or directory"></a>find: &#x2F;usr&#x2F;share&#x2F;jenkins&#x2F;ref: No such file or directory</h2><p>使用 Docker 运行 Jenkins，启动 Jenkins 容器时报错： <code>find: /usr/share/jenkins/ref: No such file or directory</code>，Jenkins 容器无法启动。</p>
<p><strong>可能原因及解决办法</strong></p>
<p>可能是因为不小心删除了某些文件导致，删除本地镜像，重新拉取镜像，启动正常。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://hub.docker.com/r/jenkinsci/blueocean">使用Docker安装Jenkins</a></p>
<h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.jenkins.io/doc/book/pipeline/jenkinsfile/#handling-credentials">凭证使用方法</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.jenkins.io/zh/doc/pipeline/tour/agents/#%E5%AE%9A%E4%B9%89%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83">定义执行环境</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.jenkins.io/zh/doc/pipeline/tour/environment/#%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">使用环境变量</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.jenkins.io/zh/doc/pipeline/tour/post/#%E6%B8%85%E7%90%86%E5%92%8C%E9%80%9A%E7%9F%A5">清理和通知</a><a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.jenkins.io/zh/doc/book/pipeline/jenkinsfile/#%E5%A4%84%E7%90%86%E5%8F%82%E6%95%B0">处理参数</a><a href="#fnref:5" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>docker 网络</title>
    <url>/202208301536/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos 7.9.2009</li>
<li>docker-ce-19.03.15</li>
</ul>
<h1 id="Docker-网络模式"><a href="#Docker-网络模式" class="headerlink" title="Docker 网络模式"></a>Docker 网络模式</h1><h2 id="Bridge-模式"><a href="#Bridge-模式" class="headerlink" title="Bridge 模式"></a>Bridge 模式</h2><p>bridge 模式是 docker 的默认网络模式，不使用 <code>--network</code> 参数，就是 bridge 模式。</p>
<p>当 Docker 进程启动时，会在主机上创建一个名为 docker0 的虚拟网桥，默认主机上启动的 Docker 容器会连接到这个虚拟网桥上。</p>
<p>容器启动时，docker 会从 docker0 网桥的子网中分配一个 IP 地址给容器中的网卡。大体流程为在主机上创建一个 <a href="/202304251611/" title="&#96;veth pair&#96;">&#96;veth pair&#96;</a>，Docker 将 <code>veth pair</code> 的一端放在容器中，命名为 <code>eth0</code> 并配置 IP，网关，路由等信息，将 <code>veth pair</code> 的另一端加入 docker0 网桥。</p>
<p><strong>通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。</strong></p>
<h2 id="Host-模式"><a href="#Host-模式" class="headerlink" title="Host 模式"></a>Host 模式</h2><p><strong>如果启动容器的时候使用 host 模式，那么这个容器将不会获得一个独立的 Network Namespace，而是和宿主机一样在 Root Network Namespace，容器中看到的网络方面的信息和宿主机一样，容器使用的网络资源在整个 Root Network Namespace 不能出现冲突</strong>。容器将不会虚拟出自己的网卡，配置自己的 IP 等，而是使用宿主机的 IP 和端口，主机名也是使用宿主机的。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。</p>
<p><strong>host 模式下的容器可以看到宿主机上的所有网卡信息，可以直接使用宿主机 IP 或主机名与外界通信，无需额外的 NAT，也无需通过 Linux bridge 进行转发或者数据包的封装，可以访问主机上的其他任一容器</strong>。</p>
<p>使用如下命令参数启动 host 网络模式的容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --network host --name test1 -p 80:80 -d -it centos:centos7.9.2009</span><br></pre></td></tr></table></figure>
<p>host 模式的容器，没有自己的 network namespace，在 root network namespace 中。进入测试容器 <code>test1</code>，查看网卡、 IP 信息及端口、主机名信息，会看到和宿主机一样的信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip <span class="built_in">link</span></span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 00:0c:29:e7:c0:27 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN mode DEFAULT group default </span><br><span class="line">    link/ether 02:42:f2:1b:dc:ea brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip add</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    link/ether 00:0c:29:e7:c0:27 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.142.10/24 brd 192.168.142.255 scope global noprefixroute ens33</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::20c:29ff:fee7:c027/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default </span><br><span class="line">    link/ether 02:42:f2:1b:dc:ea brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0</span><br><span class="line">       valid_lft forever preferred_lft forever    </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">[root@test1 /]<span class="comment"># netstat -anutp</span></span></span><br><span class="line">Active Internet connections (servers and established)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      -                   </span><br><span class="line">tcp        0      0 0.0.0.0:81              0.0.0.0:*               LISTEN      124/nginx: master p </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      -                   </span><br><span class="line">tcp        0     36 192.168.142.10:22       192.168.142.1:61396     ESTABLISHED -                   </span><br><span class="line">tcp6       0      0 :::80                   :::*                    LISTEN      -                   </span><br><span class="line">tcp6       0      0 :::81                   :::*                    LISTEN      124/nginx: master p </span><br><span class="line">tcp6       0      0 :::22                   :::*                    LISTEN      -          </span><br></pre></td></tr></table></figure>

<p>host 模式的缺点</p>
<ul>
<li>容器没有自己的 network namespace ，网络和宿主机或其他使用 host 模式的容器未隔离，容易出现资源冲突，比如同一个宿主机上，使用 host 模式的容器中启动的端口不能相同。</li>
</ul>
<h2 id="None-模式"><a href="#None-模式" class="headerlink" title="None 模式"></a>None 模式</h2><p>使用 none 模式，Docker 容器拥有自己的 Network Namespace，但是，系统并不为 Docker 容器进行任何网络配置。也就是说，这个 Docker 容器没有网卡（lo 回环网卡除外）、IP、路由等信息。需要我们自己为 Docker 容器添加网卡、配置 IP 等。</p>
<p>参考以下命令创建 <code>none</code> 模式的容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --network none --name test-none -p 82:80 -d -it centos7:my</span><br></pre></td></tr></table></figure>
<p>容器创建后，进入容器中，查看网卡和 IP 等信息，容器中默认只存在 <code>lo</code> 网卡，不存在其他网卡</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip add</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">       </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip <span class="built_in">link</span></span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00       </span><br></pre></td></tr></table></figure>
<p>以下操作演示手动为容器配置网络</p>
<ol>
<li><p>创建 <code>veth pair</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip link add veth0 type veth peer name veth0_p</span><br></pre></td></tr></table></figure></li>
<li><p>将 <code>veth pair</code> 的一端 <code>veth0</code> 放入 docker 默认的网桥 <code>docker0</code>，另一端 <code>veth0_p</code> 放入容器中</p>
<p>首先使用命令 <code>docker inspect test-none | grep &quot;Pid&quot;</code> 找到容器对应的 PID，此处为 84040，根据此 PID 将 veth 的一端放入容器的 network namespace 中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip link set dev veth0 master docker0</span><br><span class="line"></span><br><span class="line">ip link set dev veth0 up</span><br><span class="line"></span><br><span class="line">ip link set veth0_p netns 84040</span><br></pre></td></tr></table></figure>
<p>在宿主机上面检查 <code>veth0</code>，确定其已经加入网桥 <code>docker0</code>，并且 <code>veth0_p</code> 已不在 root network namespace 中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip <span class="built_in">link</span></span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 00:0c:29:e7:c0:27 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN mode DEFAULT group default </span><br><span class="line">    link/ether 02:42:f2:1b:dc:ea brd ff:ff:ff:ff:ff:ff</span><br><span class="line">12: veth0@if11: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue master docker0 state LOWERLAYERDOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 16:7f:98:d8:9d:dc brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br></pre></td></tr></table></figure>
<p>重新进入容器，检查网卡信息，可以看到容器中已经有了网卡 <code>veth0_p</code>，状态为 <code>DOWN</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip -d <span class="built_in">link</span></span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 promiscuity 0 addrgenmode eui64 numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535 </span><br><span class="line">11: veth0_p@if12: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether be:f1:94:9f:b8:c9 brd ff:ff:ff:ff:ff:ff link-netnsid 0 promiscuity 0 </span><br><span class="line">    veth addrgenmode eui64 numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535</span><br></pre></td></tr></table></figure>
</li>
<li><p>为容器中的网卡配置 IP 及网关等信息</p>
<p>为了能在宿主机对容器的 network namespace 进行操作，首先需要将容器的 network namespace 暴露出来，之后可以在宿主机通过 network namespace 名称(此处为 84040，可以自定义)操作 network namespace 。<a href="/202304031317/" title="Linux network namespace 参考">Linux network namespace 参考</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ln</span> -s /proc/84040/ns/net /var/run/netns/84040</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip netns <span class="built_in">ls</span></span></span><br><span class="line">84040 (id: 0)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过 network namespace 名称(此处为 84040)配置容器中网卡的 IP 地址信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip netns exec 84040 ip link set dev veth0_p name eth0</span><br><span class="line">ip netns exec 84040 ip link set dev eth0 up</span><br><span class="line"></span><br><span class="line">ip netns exec 84040 ip add add 172.17.0.10/16 dev eth0</span><br><span class="line"></span><br><span class="line">ip netns exec 84040 ip route add default via 172.17.0.1</span><br></pre></td></tr></table></figure>
<p>进入容器检查网络信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip add</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">15: eth0@if16: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000</span><br><span class="line">    link/ether 7e:36:b3:20:a1:8c brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.17.0.10/16 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">       </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip route show</span></span><br><span class="line">default via 172.17.0.1 dev eth0 </span><br><span class="line">172.17.0.0/16 dev eth0 proto kernel scope link src 172.17.0.10       </span><br></pre></td></tr></table></figure>

<p>进入容器测试网络连接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ping 8.8.8.8</span></span><br><span class="line">PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data.</span><br><span class="line">64 bytes from 8.8.8.8: icmp_seq=1 ttl=127 time=37.4 ms</span><br><span class="line">64 bytes from 8.8.8.8: icmp_seq=2 ttl=127 time=37.0 ms</span><br><span class="line">^C</span><br><span class="line">--- 8.8.8.8 ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 1000ms</span><br><span class="line">rtt min/avg/max/mdev = 37.047/37.234/37.422/0.269 ms</span><br></pre></td></tr></table></figure></li>
</ol>
<span id="more"></span>

<h2 id="Container-模式"><a href="#Container-模式" class="headerlink" title="Container 模式"></a>Container 模式</h2><p>在创建容器时通过参数 <code>--network container:已运行的容器名称|ID</code> 指定，处于这个模式下的 Docker 容器会共享一个网络栈，这样两个容器之间可以使用 localhost 高效快速通信。<br>Container 网络模式即新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围、主机名等。同样两个容器除了网络方面相同之外，其他的如文件系统、进程列表等还是隔离的。</p>
<blockquote>
<p>Kubernetes 的 POD 网络采用的就是 Docker 的 container 模式网络。</p>
</blockquote>
<h2 id="Macvlan-模式"><a href="#Macvlan-模式" class="headerlink" title="Macvlan 模式"></a>Macvlan 模式</h2><a href="/202304251611/" title="linux macvlan 网卡虚拟化技术">linux macvlan 网卡虚拟化技术</a>

<h2 id="ipvlan-模式"><a href="#ipvlan-模式" class="headerlink" title="ipvlan  模式"></a>ipvlan  模式</h2><p><a href="https://blog.gazer.win/essay/connect-container-networks-to-physical-networks.html">IPVLAN&#x2F;MACVLAN 实现 Docker 和物理局域网络真正互联互通</a></p>
<h1 id="容器网络组网类型"><a href="#容器网络组网类型" class="headerlink" title="容器网络组网类型"></a>容器网络组网类型</h1><p>常见的非主机网络（host network）的容器组网类型有 L2 overlay、L3 overlay、L2 underlay、L3 underlay。</p>
<h2 id="overlay-网络"><a href="#overlay-网络" class="headerlink" title="overlay 网络"></a>overlay 网络</h2><p>overlay 网络，也称为隧道网络或覆盖网络。</p>
<p>overlay 网络是在传统网络（数据链路层、网络层）上虚拟出一个虚拟网络，承载虚拟网络的底层传统网络不再需要进行任何适配和变更。在容器的世界了，底层物理网络只需要承载主机的网络通信，虚拟网络只承载容器网络通信。</p>
<p>overlay 网络的任何协议都要求发送方对报文进行封装（在虚拟网络报文的头部添加底层物理网络的地址信息，以将报文传输到容器所在的节点），接收方对报文进行解封装，使用 UDP 进行封装时，性能损失在 50% 以上，使用 VXLAN 也会有 20%-30% 的损耗。</p>
<p>overlay 网络最大的优点是<strong>适用于几乎所有的网络基础架构，唯一要求是主机 IP 互通</strong>，问题是随着规模的增长，复杂度会随之增加，封包和解封包性能损坏较大且难于定位问题。</p>
<h3 id="L2-overlay"><a href="#L2-overlay" class="headerlink" title="L2 overlay"></a>L2 overlay</h3><p>传统的 L2 网络，通信双方在同一个逻辑网段内，如 172.17.1.10&#x2F;16 和 172.17.2.10&#x2F;16</p>
<p>L2 overlay 是构建在底层物理网络之上的 L2 网络，相较于传统的 L2 网络，L2 overlay 是个 <code>大二层</code>（可以跨越多个数据中心，即可以跨 L3 underlay 进行 L2 通信）。</p>
<p>VXLAN 就是 L2 overlay 网络的典型实现，其通过在 UDP 包中封装原始的 L2 报文，实现了容器的跨主机通信。</p>
<p>L2 overlay 网络的容器可以在任意的宿主机间迁移而不改变其 IP 地址，这种特性使得构建在大二层 overlay 网络上的容器在动态迁移时具有很高的灵活性。</p>
<h3 id="L3-overlay"><a href="#L3-overlay" class="headerlink" title="L3 overlay"></a>L3 overlay</h3><p>L2 overlay 类似于 L2 overlay，但会在节点上增加个网关，每个节点上的容器都在同一个子网内，可以直接进行二层通信。跨接点间的通信只能通过 L3，都会经过网关转发，性能相比于 L2 overlay 弱。优点是跨节点通信的容器可以在不同的网段。</p>
<p>flannel 的 UDP 模式采用的就是 L3 overlay 模式。</p>
<h2 id="underlay-网络"><a href="#underlay-网络" class="headerlink" title="underlay 网络"></a>underlay 网络</h2><p>underlay 网络通常指底层网络，即传统的网络组网，主要要来区别于 overlay 网络。</p>
<h3 id="L2-underlay"><a href="#L2-underlay" class="headerlink" title="L2 underlay"></a>L2 underlay</h3><p>指传统的二层网络。 ipvlan 的 L2 模式属于 L2 underlay 类型的网络</p>
<h3 id="L3-underlay"><a href="#L3-underlay" class="headerlink" title="L3 underlay"></a>L3 underlay</h3><p>指传统的三层网络。</p>
<p>ipvlan 的 L3 模式、flannel 的 host-gw 模式和 Calico 的 BGP 组网都是 L3 underlay 类型的网络</p>
<h1 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h1><p>为了使容器互联，新版本建议将容器加入自定义的<code> Docker 网络</code> 来连接多个容器，而不是使用 <code>--link</code> 参数。</p>
<p>从 Docker 1.10 版本开始，docker daemon 实现了一个内嵌的 DNS server，使容器可以直接通过容器名称通信。方法很简单，只要在创建容器时使用 <code>--name</code> 为容器命名即可。但是使用 Docker DNS 有个限制：只能在 user-defined 网络中使用。也就是说，默认的 bridge 网络是无法使用 DNS 的，所以我们就需要自定义网络。</p>
<p>先创建一个新的 <code>Docker 网络</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker network create -d bridge my-net</span><br></pre></td></tr></table></figure>
<p><code>-d</code> 参数指定 Docker 网络类型，可选 <code>bridge</code> <code>overlay</code>  </p>
<p>查看 <code>Docker network</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker network <span class="built_in">ls</span></span></span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">1c751b3a52b9   bridge    bridge    local</span><br><span class="line">f8d9861e5797   host      host      local</span><br><span class="line">2e19366fb323   my-net    bridge    local</span><br><span class="line">4c188c59ff20   none      null      local</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>新建容器并连接到刚刚新建的 <code>Docker network</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -it --name c1 --network my-net centos</span><br><span class="line">docker run -d -it --name c2 --network my-net centos</span><br></pre></td></tr></table></figure>
<p>以上命令运行了 2 个 <code>centos</code> 最新版本的容器，并连接到了刚刚创建的网络： <code>--network my-net </code><br>登录到容器 <code>c1</code>的终端，并 <code>ping</code> 容器 <code>c2</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">exec</span> -it c1 bash</span></span><br><span class="line">[root@e520d1c8e30b /]# ping c2</span><br><span class="line">PING c2 (172.18.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from c2.my-net (172.18.0.3): icmp_seq=1 ttl=64 time=0.115 ms</span><br><span class="line">64 bytes from c2.my-net (172.18.0.3): icmp_seq=2 ttl=64 time=0.071 ms</span><br><span class="line">^C</span><br><span class="line">--- c2 ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 1000ms</span><br><span class="line">rtt min/avg/max/mdev = 0.071/0.093/0.115/0.022 ms</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，容器 <code>c1</code> 可以直接使用容器名 <code>c2</code>，来识别容器 <code>c2</code>，同理，容器 <code>c2</code> 也可以使用同样的方式识别到容器 <code>c1</code>，连接到同一个 <code>Docker network</code> 的容器 <code>c1</code>, <code>c2</code> 可以互相连接<br>使用以下命令，可以查看 <code>Docker network</code> 的详细信息，包括 ip 网段，ip 分配信息等</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker network inspect my-net</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;my-net&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;2e19366fb32312235a3571192d1a19e6ebb7adc3e6e25c1f5e6007e8c3315f08&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2022-08-30T15:44:54.241420767+08:00&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;172.18.0.0/16&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.18.0.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;4b6b1159073d3b70312f2b7e5da8c4a36133a6c00c4746fe2c58d37e81a86b12&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;c2&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;0cbe15ff760040d20cd10a04ffed5f4398e1c3c2b597a86461758606ebdc919d&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:12:00:03&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.18.0.3/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;e520d1c8e30bf97ece44fae53840d13e801648ca02899a17416a75563d3a64f6&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;c1&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;214c7596e2610208402cfa55a225fa67c0dd02d4b585c62b43a9a6c42f360147&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:12:00:02&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.18.0.2/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果容器启动时使用了自定义的 <code>Docker network</code>，并且启动过程中挂载了宿主机的 <code>/etc/resolv.conf</code>，则容器启动后无法再使用容器名和其他容器互联，比如使用以下命令启动容器 <code>c3</code>，<code>c3</code> 无法使用容器名和 <code>c1</code>,<code>c2</code> 互联，但是<code>c1</code>,<code>c2</code> 可以使用容器名 <code>c3</code> 连接到容器 <code>c3</code>  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -ti --network my-net -v /etc/resolv.conf:/etc/resolv.conf --name c3 centos</span><br></pre></td></tr></table></figure>
<p>以上示例中，如果登录 <code>c1</code> 终端后，修改 <code>/etc/resolv.conf</code> 文件，再次使用 <code>c2</code> ，会无法连接 <code>c2</code> 容器  </p>
</blockquote>
<p>如果容器启动时，需要为容器指定域名 ip 映射关系，可以使用选项 <code>--add-host host:ip</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --network my-net --add-host db:172.18.0.3 --name c3 centos</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>容器运行过程中，可以直接修改容器内的 <code>/etc/hosts</code> 文件</p>
<h1 id="Docker-网络相关问题"><a href="#Docker-网络相关问题" class="headerlink" title="Docker 网络相关问题"></a>Docker 网络相关问题</h1><h2 id="定位-Docker-容器中的网卡和宿主机上面的-veth-的-pair-关系"><a href="#定位-Docker-容器中的网卡和宿主机上面的-veth-的-pair-关系" class="headerlink" title="定位 Docker 容器中的网卡和宿主机上面的 veth 的 pair 关系"></a>定位 Docker 容器中的网卡和宿主机上面的 veth 的 pair 关系</h2><p>在经典容器组网中，主要是使用 <a href="!--swig%EF%BF%BC28--"><code>veth</code></a> + <code>bridge</code> 的模式，容器中的 <code>eth0</code> 实际上和宿主机上面的某个 <code>veth</code> 是成对（pair）关系，要查看容器中的网卡和宿主机上面的 <code>veth</code> 网卡的成对关系，可以参考以下方法</p>
<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法 1"></a>方法 1</h3><ol>
<li>在目标容器中查看 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat /sys/class/net/eth0/iflink </span><br><span class="line">60</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>在宿主机上遍历 <code>/sys/class/net/</code> 下面的全部目录，查看子目录中的 <code>ifindex</code> 文件的内容，找出和容器中 <code>/sys/class/net/eth0/iflink</code> 的值一样的 <code>veth</code> 的名称，这样就找到了容器和主机的 <code>veth pair</code> 的关系 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat /sys/class/net/vethc41ba34/ifindex </span><br><span class="line">60</span><br></pre></td></tr></table></figure>
 本示例中，宿主机上的 <code>vethc41ba34</code> 和容器中的网卡是 <code>veth pair</code></li>
</ol>
<h3 id="方法-2"><a href="#方法-2" class="headerlink" title="方法 2"></a>方法 2</h3><ol>
<li>目标容器中查看<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip <span class="built_in">link</span> show eth0</span></span><br><span class="line">59: eth0@if60: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default </span><br><span class="line"> link/ether 02:42:ac:16:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br></pre></td></tr></table></figure>
从上面的命令可以看到 <code>59: eth0@if60</code>，其中 <code>59</code> 是 <code>eth0</code> 接口的 index，<code>60</code> 是和它成对的 <code>veth</code> 的 index。</li>
<li>在 host 上面执行下面的命令，可以看到对应 <code>60</code> 的 <code>veth</code> 网卡是哪一个<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip link show | grep 60</span><br><span class="line">60: vethc41ba34@if59: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master br-9d2a9fc0ff85 state UP mode DEFAULT group default </span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="方法-3"><a href="#方法-3" class="headerlink" title="方法 3"></a>方法 3</h3><p>通过 <code>ethtool -S</code> 命令列出 <code>veth pair</code> 对端的网卡 index</p>
<ol>
<li>目标容器中执行<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ethtool -S eth0</span></span><br><span class="line">NIC statistics:</span><br><span class="line">  peer_ifindex: 60</span><br></pre></td></tr></table></figure></li>
<li>在宿主机上面查找 index 为 60 的 <code>veth</code> 网卡是哪一个<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip link show | grep 60</span><br><span class="line">60: vethc41ba34@if59: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master br-9d2a9fc0ff85 state UP mode DEFAULT group default </span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 部署 OpenLDAP + phpLDAPadmin 教程</title>
    <url>/202210131557/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h2><ul>
<li>Centos7 3.10.0-1160.76.1</li>
<li>Docker Engine - Community 19.03.15</li>
</ul>
<h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><h3 id="创建自定义网络"><a href="#创建自定义网络" class="headerlink" title="创建自定义网络"></a>创建自定义网络</h3><p>为了使容器互联，新版本建议将容器加入自定义的 Docker 网络 来连接多个容器，而不是使用 <code>--link</code> 参数。</p>
<p>从 Docker 1.10 版本开始，<code>docker daemon</code> 实现了一个内嵌的 DNS server，使容器可以直接通过容器名称通信。方法很简单，只要在创建容器时使用 <code>--name</code> 为容器命名即可。但是使用 Docker DNS 有个限制：只能在 <code>user-defined</code> 网络中使用。也就是说，默认的 bridge 网络是无法使用 DNS 的，所以我们就需要自定义网络。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker network create -d bridge docker-network-for-openldap</span><br></pre></td></tr></table></figure>
<p>之后为 LDAP 创建的相关容器，都连接到此网络。</p>
<h3 id="启动-openldap-容器"><a href="#启动-openldap-容器" class="headerlink" title="启动 openldap 容器"></a>启动 openldap 容器</h3><p>为 openldap 容器创建本地持久化数据目录，容器启动时将此目录以数据卷的形式挂载使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /data/OpenLDAPData</span><br></pre></td></tr></table></figure>
<p>启动容器，挂载数据卷，使用自定义网络</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 389:389 -p 636:636 \</span><br><span class="line">           -v /data/OpenLDAPData:/usr/local/ldap \</span><br><span class="line">           --name openldap \</span><br><span class="line">           --network docker-network-for-openldap  \</span><br><span class="line">           osixia/openldap:1.3.0</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>ldap 默认配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dn     dc=example,dc=org</span><br><span class="line">admin    cn=admin,dc=example,dc=org</span><br><span class="line">password  admin</span><br></pre></td></tr></table></figure>

<p>进入容器验证</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">exec</span> -it openldap bash</span></span><br><span class="line">root@2f49810360ce:/# ldapsearch -x -H ldap://localhost:389 -b dc=example,dc=org -D &quot;cn=admin,dc=example,dc=org&quot; -w admin</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">extended LDIF</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># LDAPv3</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">base &lt;dc=example,dc=org&gt; with scope subtree</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">filter: (objectclass=*)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">requesting: ALL</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"></span><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">example.org</span></span><br><span class="line">dn: dc=example,dc=org</span><br><span class="line">objectClass: top</span><br><span class="line">objectClass: dcObject</span><br><span class="line">objectClass: organization</span><br><span class="line">o: Example Inc.</span><br><span class="line">dc: example</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">admin, example.org</span></span><br><span class="line">dn: cn=admin,dc=example,dc=org</span><br><span class="line">objectClass: simpleSecurityObject</span><br><span class="line">objectClass: organizationalRole</span><br><span class="line">cn: admin</span><br><span class="line">description: LDAP administrator</span><br><span class="line">userPassword:: e1NTSEF9NENMcFBvNEQrUlhhcFUxdDRVT1FSUm5SdU0zQnNEdnk=</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">search result</span></span><br><span class="line">search: 2</span><br><span class="line">result: 0 Success</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">numResponses: 3</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">numEntries: 2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="启动-phpLDAPadmin"><a href="#启动-phpLDAPadmin" class="headerlink" title="启动 phpLDAPadmin"></a>启动 phpLDAPadmin</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -dit -p 8081:80 --name phpLDAPadmin --network docker-network-for-openldap \</span><br><span class="line">            --env PHPLDAPADMIN_HTTPS=false \</span><br><span class="line">            --env PHPLDAPADMIN_LDAP_HOSTS=openldap \</span><br><span class="line">            --restart always \</span><br><span class="line">            osixia/phpldapadmin</span><br></pre></td></tr></table></figure>

<p>浏览器访问相应链接，可登录到 WEB 页面。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://m.studyofnet.com/news/5359.html">Docker搭建OpenLDAP+phpLDAPadmin统一用户认证的方法</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>OpenLDAP</tag>
        <tag>phpLDAPadmin</tag>
      </tags>
  </entry>
  <entry>
    <title>docker 运行 mysql</title>
    <url>/202301181604/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Docker 19.03.15</li>
<li>Mysql 5.7</li>
</ul>
<h1 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h1><h2 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull mysql:5.7.31</span><br></pre></td></tr></table></figure>

<h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><p>启动容器前先在本地创建 Mysql 数据目录以用来持久化 Mysql 数据，如果需要配置文件，可以在本地创建好配置文件挂载到容器的 <code>/etc/mysql/my.cnf</code>，无需配置文件的话，则只需要将持久化的本地数据目录挂载到容器默认的数据目录 <code>/var/lib/mysql</code>，本示例中 Mysql 本地持久化数据目录为 <code>/opt/docker_mysql_home/data/</code>。使用以下命令启动容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --name mysql -v /opt/docker_mysql_home/data/:/var/lib/mysql/ -p 3306:3306 \</span><br><span class="line">              -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7.31</span><br></pre></td></tr></table></figure>
<p><code>-e MYSQL_ROOT_PASSWORD=123456</code>  通过环境变量配置 Mysql 初始化后的密码</p>
<p>容器启动后，通过以下命令连接数据库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -h 127.0.0.1 -uroot -p</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch 安装使用</title>
    <url>/202303301601/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos7 3.10.0-1062.9.1.el7</li>
<li>OpenJDK Runtime Environment (build 1.8.0_362-b08)</li>
<li>elasticsearch 6.8.23</li>
</ul>
<h2 id="elasticsearch-下载"><a href="#elasticsearch-下载" class="headerlink" title="elasticsearch 下载"></a>elasticsearch 下载</h2><p><a href="https://www.elastic.co/downloads/past-releases/elasticsearch-6-8-23">elasticsearch 下载页面</a></p>
<h2 id="安装-Java"><a href="#安装-Java" class="headerlink" title="安装 Java"></a>安装 Java</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y java-1.8.0-openjdk</span><br></pre></td></tr></table></figure>

<h2 id="安装-elasticsearch-6-8-23"><a href="#安装-elasticsearch-6-8-23" class="headerlink" title="安装 elasticsearch-6.8.23"></a>安装 elasticsearch-6.8.23</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum localinstall -y elasticsearch-6.8.23.rpm</span><br></pre></td></tr></table></figure>


<p>配置服务开机启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable elasticsearch</span><br></pre></td></tr></table></figure>

<h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><h3 id="Caused-by-java-io-IOException-failed-to-read-id-2-file-x2F-var-x2F-lib-x2F-elasticsearch-x2F-nodes-x2F-0-x2F-state-x2F-node-2-st"><a href="#Caused-by-java-io-IOException-failed-to-read-id-2-file-x2F-var-x2F-lib-x2F-elasticsearch-x2F-nodes-x2F-0-x2F-state-x2F-node-2-st" class="headerlink" title="Caused by: java.io.IOException: failed to read [id:2, file:&#x2F;var&#x2F;lib&#x2F;elasticsearch&#x2F;nodes&#x2F;0&#x2F;_state&#x2F;node-2.st]"></a>Caused by: java.io.IOException: failed to read [id:2, file:&#x2F;var&#x2F;lib&#x2F;elasticsearch&#x2F;nodes&#x2F;0&#x2F;_state&#x2F;node-2.st]</h3><p>启动报错，手动执行启动程序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su - elasticsearch -c /usr/share/elasticsearch/bin/elasticsearch</span><br></pre></td></tr></table></figure>
<p>启动报错：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[2023-03-30T16:20:28,458][WARN ][o.e.b.ElasticsearchUncaughtExceptionHandler] [node-1] uncaught exception in thread [main]</span><br><span class="line">org.elasticsearch.bootstrap.StartupException: ElasticsearchException[java.io.IOException: failed to read [id:2, file:/var/lib/elasticsearch/nodes/0/_state/node-2.st]]; nested: IOException[failed to read [id:2, file:/var/lib/elasticsearch/nodes/0/_state/node-2.st]]; nested: XContentParseException[[-1:36] [node_meta_data] unknown field [node_version], parser not found];</span><br><span class="line">	at org.elasticsearch.bootstrap.Elasticsearch.init(Elasticsearch.java:163) ~[elasticsearch-6.8.23.jar:6.8.23]</span><br><span class="line">	at org.elasticsearch.bootstrap.Elasticsearch.execute(Elasticsearch.java:150) ~[elasticsearch-6.8.23.jar:6.8.23]</span><br><span class="line">	at org.elasticsearch.cli.EnvironmentAwareCommand.execute(EnvironmentAwareCommand.java:86) ~[elasticsearch-6.8.23.jar:6.8.23]</span><br><span class="line">	at org.elasticsearch.cli.Command.mainWithoutErrorHandling(Command.java:124) ~[elasticsearch-cli-6.8.23.jar:6.8.23]</span><br><span class="line">	at org.elasticsearch.cli.Command.main(Command.java:90) ~[elasticsearch-cli-6.8.23.jar:6.8.23]</span><br><span class="line">	at org.elasticsearch.bootstrap.Elasticsearch.main(Elasticsearch.java:116) ~[elasticsearch-6.8.23.jar:6.8.23]</span><br><span class="line">	at org.elasticsearch.bootstrap.Elasticsearch.main(Elasticsearch.java:93) ~[elasticsearch-6.8.23.jar:6.8.23]</span><br><span class="line">Caused by: org.elasticsearch.ElasticsearchException: java.io.IOException: failed to read [id:2, file:/var/lib/elasticsearch/nodes/0/_state/node-2.st]</span><br></pre></td></tr></table></figure>

<p><strong>问题原因</strong></p>
<p>系统安装过其他版本的 elasticsearch，卸载后重新安装，报这个错误，可能是因为版本之间的数据不兼容，重新卸载 elasticsearch，并删除以下数据，重新安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum remove elasticsearch</span><br><span class="line"></span><br><span class="line">rm -rf /etc/elasticsearch/</span><br><span class="line">rm -rf /var/lib/elasticsearch/</span><br><span class="line">rm -rf /usr/share/elasticsearch</span><br><span class="line"></span><br><span class="line">yum install -y elasticsearch-6.8.23.rpm</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux fail2ban 详解</title>
    <url>/202208171501/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Centos 7</li>
<li>iptables</li>
</ul>
<p><a href="https://www.fail2ban.org/wiki/index.php/Main_Page">Fail2ban</a> 是 Linux 上的一个著名的入侵保护的开源框架。它通过监视相应服务的日志记录文件，匹配日志记录中的错误信息（正则式匹配），然后与系统的 <code>iptables</code> 联动执行相应的屏蔽动作（一般情况下是调用防火墙屏蔽），比如：当有人在试探你的 <code>HTTP</code>、<code>SSH</code>、<code>SMTP</code>、<code>FTP</code> 密码，只要达到你预设的次数，<code>Fail2ban</code> 就会调用防火墙屏蔽这个 IP，并且可以发送 e-mail 通知系统管理员。</p>
<p>由于 <code>Fail2ban</code> 需要与系统的 <code>iptables</code>、<code>firewalld</code> 等联动来达到封禁 IP 的目的， <code>iptables</code> 使用与 <code>firewalld</code> 有少许不同。  </p>
<p>本文以 <code>iptables</code> 为例</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install epel-release</span><br><span class="line">yum install -y fail2ban</span><br><span class="line">systemctl enable fail2ban</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 Fail2ban 的状态</span></span><br><span class="line">fail2ban-client status   </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 Fai2ban 的版本</span></span><br><span class="line">fail2ban-client version   </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查 Fail2ban 是否正常运行（正常将显示 pong）</span></span><br><span class="line">fail2ban-client ping     </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动 Fail2ban</span></span><br><span class="line">systemctl start fail2ban   </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止 Fail2ban</span>  </span><br><span class="line">systemctl stop fail2ban  </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启 Fail2ban</span>  </span><br><span class="line">systemctl restart fail2ban</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打开 Fail2ban 的日志监控</span>     </span><br><span class="line">tail -f /var/log/fail2ban.log  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="主要文件说明"><a href="#主要文件说明" class="headerlink" title="主要文件说明"></a>主要文件说明</h3><table>
<thead>
<tr>
<th>文件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;etc&#x2F;fail2ban&#x2F;jail.d&#x2F;</td>
<td>配置文件夹。用于定义错误次数、封禁时长、封禁动作等</td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;fail2ban&#x2F;filter.d&#x2F;</td>
<td>条件文件夹。内含默认文件，用于定义日志文件内容的过滤规则</td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;fail2ban&#x2F;action.d</td>
<td>动作文件夹。内含默认文件，用于 iptables 以及 mail 等动作配置</td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;fail2ban&#x2F;fail2ban.conf<br/>&#x2F;etc&#x2F;fail2ban&#x2F;jail.conf</td>
<td><code>*.conf</code> 是主要（默认）配置文件，<strong>不要直接更改 <code>.conf</code> 文件</strong> ，升级后会被覆盖<br/>应该手动创建 <code>fail2ban.local</code> ,<code>jail.local</code>(或者分离 <code>.conf</code> 文件到 <code>jail.d/</code> 目录)</td>
</tr>
</tbody></table>
<h3 id="fail2ban-配置文件说明"><a href="#fail2ban-配置文件说明" class="headerlink" title="fail2ban 配置文件说明"></a>fail2ban 配置文件说明</h3><p><code>/etc/fail2ban/fail2ban.conf</code> 是主配置文件，定义了 <code>fai2ban</code> 默认的日志级别、日志位置及 sock 文件位置。<strong>不要更改此文件</strong>，要更改默认配置，可以复制 <code>fail2ban.conf</code> 成 <code>/etc/fail2ban/fail2ban.local</code> ，更改此 <code>local</code> 文件</p>
<figure class="highlight shell"><figcaption><span>/etc/fail2ban/fail2ban.local</span></figcaption><table><tr><td class="code"><pre><span class="line">[DEFAULT]</span><br><span class="line"></span><br><span class="line">loglevel = INFO</span><br><span class="line"></span><br><span class="line">logtarget = /var/log/fail2ban.log</span><br><span class="line"></span><br><span class="line">syslogsocket = auto</span><br><span class="line"></span><br><span class="line">socket = /var/run/fail2ban/fail2ban.sock</span><br><span class="line"></span><br><span class="line">pidfile = /var/run/fail2ban/fail2ban.pid</span><br><span class="line"></span><br><span class="line">dbfile = /var/lib/fail2ban/fail2ban.sqlite3</span><br><span class="line"></span><br><span class="line">dbpurgeage = 1d</span><br><span class="line"></span><br><span class="line">dbmaxmatches = 10</span><br><span class="line"></span><br><span class="line">[Definition]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Thread]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="jail-配置文件说明"><a href="#jail-配置文件说明" class="headerlink" title="jail 配置文件说明"></a>jail 配置文件说明</h3><p><code>/etc/fail2ban/jail.conf</code> 主要设置启用 <code>ban</code> 动作的服务及动作阀值。<strong>不要更改此文件</strong>，要更改此处的默认配置，可以复制 <code>jail.conf</code> 到 <code>/etc/fail2ban/jail.local</code>，更改此文件中的默认配置</p>
<figure class="highlight shell"><figcaption><span>/etc/fail2ban/jail.local</span></figcaption><table><tr><td class="code"><pre><span class="line">[DEFAULT]</span><br><span class="line">ignorecommand =</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">屏蔽时间，默认单位：秒</span></span><br><span class="line">bantime  = 10m</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这个时间段内超过 maxretry 定义的次数会被 ban 掉</span></span><br><span class="line">findtime  = 10m</span><br><span class="line">maxretry = 5</span><br><span class="line"></span><br><span class="line">maxmatches = %(maxretry)s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">日志修改检测机制(gamin、polling和auto这三种)</span></span><br><span class="line">backend = auto</span><br><span class="line"></span><br><span class="line">usedns = warn</span><br><span class="line">logencoding = auto</span><br><span class="line">enabled = false</span><br><span class="line">mode = normal</span><br><span class="line">filter = %(__name__)s[mode=%(mode)s]</span><br><span class="line">destemail = root@localhost</span><br><span class="line">sender = root@&lt;fq-hostname&gt;</span><br><span class="line">mta = sendmail</span><br><span class="line">protocol = tcp</span><br><span class="line">chain = &lt;known/chain&gt;</span><br><span class="line">port = 0:65535</span><br><span class="line">fail2ban_agent = Fail2Ban/%(fail2ban_version)s</span><br><span class="line">banaction = iptables-multiport</span><br><span class="line">banaction_allports = iptables-allports</span><br><span class="line">action_ = %(banaction)s[port=&quot;%(port)s&quot;, protocol=&quot;%(protocol)s&quot;, chain=&quot;%(chain)s&quot;]</span><br><span class="line">action_mw = %(action_)s</span><br><span class="line">            %(mta)s-whois[sender=&quot;%(sender)s&quot;, dest=&quot;%(destemail)s&quot;, protocol=&quot;%(protocol)s&quot;, chain=&quot;%(chain)s&quot;]</span><br><span class="line">action_mwl = %(action_)s</span><br><span class="line">             %(mta)s-whois-lines[sender=&quot;%(sender)s&quot;, dest=&quot;%(destemail)s&quot;, logpath=&quot;%(logpath)s&quot;, chain=&quot;%(chain)s&quot;]</span><br><span class="line">action_xarf = %(action_)s</span><br><span class="line">             xarf-login-attack[service=%(__name__)s, sender=&quot;%(sender)s&quot;, logpath=&quot;%(logpath)s&quot;, port=&quot;%(port)s&quot;]</span><br><span class="line">action_cf_mwl = cloudflare[cfuser=&quot;%(cfemail)s&quot;, cftoken=&quot;%(cfapikey)s&quot;]</span><br><span class="line">                %(mta)s-whois-lines[sender=&quot;%(sender)s&quot;, dest=&quot;%(destemail)s&quot;, logpath=&quot;%(logpath)s&quot;, chain=&quot;%(chain)s&quot;]</span><br><span class="line">action_blocklist_de  = blocklist_de[email=&quot;%(sender)s&quot;, service=&quot;%(__name__)s&quot;, apikey=&quot;%(blocklist_de_apikey)s&quot;, agent=&quot;%(fail2ban_agent)s&quot;]</span><br><span class="line">action_badips = badips.py[category=&quot;%(__name__)s&quot;, banaction=&quot;%(banaction)s&quot;, agent=&quot;%(fail2ban_agent)s&quot;]</span><br><span class="line">action_badips_report = badips[category=&quot;%(__name__)s&quot;, agent=&quot;%(fail2ban_agent)s&quot;]</span><br><span class="line">action_abuseipdb = abuseipdb</span><br><span class="line">action = %(action_)s</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中 <code>[DEFAULT]</code> 块定义了默认的配置，具体的服务配置中 (如 <code>/etc/fail2ban/jail.d/ssh.local</code>)，可以覆盖默认值。 </p>
<p>针对具体服务配置防护，以 <code>sshd</code> 为例，手动创建配置 <code>/etc/fail2ban/jail.d/sshd.local</code></p>
<figure class="highlight shell"><figcaption><span>/etc/fail2ban/jail.d/sshd.local</span></figcaption><table><tr><td class="code"><pre><span class="line">[sshd]</span><br><span class="line">enabled = true</span><br><span class="line">port = 22</span><br><span class="line">filter = sshd</span><br><span class="line">action = iptables[name=SSH, port=ssh, protocol=tcp]</span><br><span class="line">logpath = /var/log/secure</span><br><span class="line">maxretry = 3</span><br><span class="line">bantime = 43200</span><br><span class="line">findtime = 3600</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>[sshd]</code> : 名称，可以随便填写</li>
<li><code>enabled =true</code> ： 启用此配置</li>
<li><code>port = 22</code> : 服务端口</li>
<li><code>filter = sshd</code> : 应用的 <code>filter</code> 名称，对应的 <a href="#filter-%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E"><code>filter</code> 配置</a> 位于 <code>/etc/fail2ban/filter.d/sshd.conf</code></li>
<li><code>action = iptables[name=SSH, port=ssh, protocol=tcp]</code> : 执行的动作，对应 <code>/etc/fail2ban/action.d/iptables.conf</code> ，并传入 <code>name=SSH, port=ssh, protocol=tcp</code>，此处传入的端口 <code>ssh</code> 默认为 22 ，如果端口不为 22 ，需要更改为对应端口，传入的 <code>name</code> 会在定义防火墙链时被当做链名的一部分</li>
<li><code>logpath = /var/log/secure</code> : 要过滤的日志记录文件路径</li>
<li><code>maxretry = 3</code> ： 执行封禁动作前允许的错误记录数</li>
<li><code>bantime = 43200</code> ： 执行封禁的时长（秒）</li>
<li><code>findtime = 3600</code> ：此时长（秒）内达到 <code>maxretry</code> 次就执行封禁动作</li>
</ul>
<p>配置好之后，重启 <code>fail2ban</code> 使配置生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart fail2ban</span><br></pre></td></tr></table></figure>
<p>或者执行以下命令，在不重启 <code>fail2ban</code> 的情况下重新分析并加载配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fail2ban-client reload</span><br></pre></td></tr></table></figure>

<p>执行以下命令查看 <code>fail2ban</code> 的状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">fail2ban-client status</span></span><br><span class="line">Status</span><br><span class="line">|- Number of jail:	1</span><br><span class="line">`- Jail list:	sshd</span><br></pre></td></tr></table></figure>
<p>可以看到当前只启动了 <code>sshd</code> 这一个 <code>jail</code></p>
<p>执行以下命令查看 <code>sshd</code> 的防护情况，可以看到目前有哪些 ip 被封锁，以及过去总共多少 ip 被封锁</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">fail2ban-client status sshd</span></span><br><span class="line">Status for the jail: sshd</span><br><span class="line">|- Filter</span><br><span class="line">|  |- Currently failed:	0</span><br><span class="line">|  |- Total failed:	0</span><br><span class="line">|  `- Journal matches:	_SYSTEMD_UNIT=sshd.service + _COMM=sshd</span><br><span class="line">`- Actions</span><br><span class="line">   |- Currently banned:	1</span><br><span class="line">   |- Total banned:	1</span><br><span class="line">   `- Banned IP list:	54.193.188.141</span><br></pre></td></tr></table></figure>

<h3 id="filter-配置说明"><a href="#filter-配置说明" class="headerlink" title="filter 配置说明"></a>filter 配置说明</h3><p><code>fail2ban</code> 使用的各个 <code>filter</code> 位于 <code>/etc/fail2ban/filter.d/</code> 下。其中主要配置了日志的过滤规则  </p>
<p>以创建防护 <code>VNC</code> 的 <code>filter</code> 来说明。<code>VNC</code> 的日志中，如果有恶意登录，经常会出现以下日志记录：</p>
<figure class="highlight shell"><figcaption><span>/home/USER1/.vnc/USER1\:1.log</span></figcaption><table><tr><td class="code"><pre><span class="line">Sat Aug 20 10:35:27 2022</span><br><span class="line"> Connections: blacklisted: 185.170.144.226</span><br><span class="line"> Connections: blacklisted: 185.170.144.226</span><br><span class="line"></span><br><span class="line">Sat Aug 20 10:35:28 2022</span><br><span class="line"> Connections: blacklisted: 185.170.144.226</span><br><span class="line"> Connections: blacklisted: 185.170.144.226</span><br><span class="line"></span><br><span class="line">Sat Aug 20 10:35:29 2022</span><br><span class="line"> Connections: blacklisted: 185.170.144.226</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>filter</code> 的匹配规则里面，<strong>行的开头一定要先匹配到时间</strong>，时间格式可以试试系统可以识别的格式，如果开头不能匹配到时间，规则会匹配失败，因此，如果日志开头不是时间格式，需要修改日志格式，本例中，处理 <code>vnc</code> 日志时，会先在行首添加时间    </p>
</blockquote>
<p>可以根据此日志记录，创建针对 <code>VNC</code> 服务的日志过滤规则，手动创建文件 <code>/etc/fail2ban/filter.d/vnc.local</code></p>
<figure class="highlight shell"><figcaption><span>/etc/fail2ban/filter.d/vnc.local</span></figcaption><table><tr><td class="code"><pre><span class="line">[Definition]</span><br><span class="line">failregex = .*Connections: blacklisted: &lt;HOST&gt;</span><br><span class="line">ignoreregex =</span><br></pre></td></tr></table></figure>

<p>创建好配置文件，使配置生效前，一定要对 <code>filter</code> 配置文件的有效性进行测试，<code>fail2ban</code> 提供了命令 <code>fail2ban-regex</code> 用来测试 <code>filter</code> 的正则表达式，使用方法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">fail2ban-regex /home/USER1/.vnc/USER1\:1.<span class="built_in">log</span> vnc</span></span><br><span class="line"></span><br><span class="line">Running tests</span><br><span class="line">=============</span><br><span class="line"></span><br><span class="line">Use   failregex filter file : vnc, basedir: /etc/fail2ban</span><br><span class="line">Use         log file : /home/USER1/.vnc/USER1\:1.log</span><br><span class="line">Use         encoding : UTF-8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Results</span><br><span class="line">=======</span><br><span class="line"></span><br><span class="line">Failregex: 171210 total</span><br><span class="line">|-  #) [# of hits] regular expression</span><br><span class="line">|   1) [171210] .*Connections: blacklisted: &lt;HOST&gt;</span><br><span class="line">`-</span><br><span class="line"></span><br><span class="line">Ignoreregex: 0 total</span><br><span class="line"></span><br><span class="line">Date template hits:</span><br><span class="line">|- [# of hits] date format</span><br><span class="line">|  [377319] &#123;^LN-BEG&#125;(?:DAY )?MON Day %k:Minute:Second(?:\.Microseconds)?(?: ExYear)?</span><br><span class="line">`-</span><br><span class="line"></span><br><span class="line">Lines: 377319 lines, 0 ignored, 171210 matched, 206109 missed</span><br><span class="line">[processed in 23.67 sec]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以上命令使用规则 <code>vnc</code>，匹配日志文件 <code>/home/USER1/.vnc/USER1\:1.log</code>，结果中显示：<code>Lines: 377319 lines, 0 ignored, 171210 matched, 206109 missed</code>，可以说明匹配到了需要的内容  </p>
<p>也可以通过以下命令，验证具体的正则表达式是否能匹配到指定的日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">fail2ban-regex <span class="string">&#x27; Connections: blacklisted: 185.170.144.226&#x27;</span> <span class="string">&#x27;.*Connections: blacklisted: &lt;HOST&gt;&#x27;</span></span></span><br><span class="line"></span><br><span class="line">Running tests</span><br><span class="line">=============</span><br><span class="line"></span><br><span class="line">Use   failregex line : .*Connections: blacklisted: &lt;HOST&gt;</span><br><span class="line">Use      single line :  Connections: blacklisted: 185.170.144.226</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Results</span><br><span class="line">=======</span><br><span class="line"></span><br><span class="line">Failregex: 1 total</span><br><span class="line">|-  #) [# of hits] regular expression</span><br><span class="line">|   1) [1] .*Connections: blacklisted: &lt;HOST&gt;</span><br><span class="line">`-</span><br><span class="line"></span><br><span class="line">Ignoreregex: 0 total</span><br><span class="line"></span><br><span class="line">Date template hits:</span><br><span class="line"></span><br><span class="line">Lines: 1 lines, 0 ignored, 1 matched, 0 missed</span><br><span class="line">[processed in 0.03 sec]</span><br></pre></td></tr></table></figure>
<p>以上结果显示 <code>Lines: 1 lines, 0 ignored, 1 matched, 0 missed</code> , 说明日志被正则表达式匹配到了  </p>
<blockquote>
<p>以上命令中，隐含了日志开始匹配到了时间格式</p>
</blockquote>
<p>创建 <code>ban</code> 配置，手动创建配置文件 <code>/etc/fail2ban/jail.d/vnc.local</code>  </p>
<figure class="highlight shell"><figcaption><span>/etc/fail2ban/jail.d/vnc.local</span></figcaption><table><tr><td class="code"><pre><span class="line">[vnc]</span><br><span class="line">enabled = true</span><br><span class="line">port = 5901</span><br><span class="line">filter = vnc</span><br><span class="line">action = iptables[name=VNC, port=5901, protocol=tcp]</span><br><span class="line">logpath = /home/cosmos/.vnc/cosmos:1.log</span><br><span class="line">maxretry = 3</span><br><span class="line">bantime = 43200</span><br><span class="line">findtime = 3600</span><br></pre></td></tr></table></figure>

<p>配置更改完后，重启 <code>fail2ban</code> 使配置生效  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart fail2ban</span><br></pre></td></tr></table></figure>
<p>重启后，使用以下命令查看 <code>fail2ban</code> 状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">fail2ban-client status</span></span><br><span class="line">Status</span><br><span class="line">|- Number of jail:	2</span><br><span class="line">`- Jail list:	sshd, vnc</span><br></pre></td></tr></table></figure>
<p>如果输出显示 : <code>ERROR   Failed to access socket path: /var/run/fail2ban/fail2ban.sock. Is fail2ban running? </code>，说明 <code>fail2ban</code> 启动失败，可能是配置文件存在问题，比如 <code>fail2ban</code> 服务状态如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl status fail2ban -l</span></span><br><span class="line"> fail2ban.service - Fail2Ban Service</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/fail2ban.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: failed (Result: exit-code) since Sat 2022-08-20 13:33:48 CST; 24s ago</span><br><span class="line">     Docs: man:fail2ban(1)</span><br><span class="line">  Process: 2520 ExecStop=/usr/bin/fail2ban-client stop (code=exited, status=0/SUCCESS)</span><br><span class="line">  Process: 2536 ExecStart=/usr/bin/fail2ban-server -xf start (code=exited, status=255)</span><br><span class="line">  Process: 2533 ExecStartPre=/bin/mkdir -p /run/fail2ban (code=exited, status=0/SUCCESS)</span><br><span class="line"> Main PID: 2536 (code=exited, status=255)</span><br><span class="line"></span><br><span class="line">Aug 20 13:33:47 myserver-cn systemd[1]: Starting Fail2Ban Service...</span><br><span class="line">Aug 20 13:33:47 myserver-cn systemd[1]: Started Fail2Ban Service.</span><br><span class="line">Aug 20 13:33:48 myserver-cn fail2ban-server[2536]: 2022-08-20 13:33:48,058 fail2ban                </span><br><span class="line">    [2536]: ERROR   Failed during configuration: Have not found any log file for vnc jail</span><br><span class="line">Aug 20 13:33:48 myserver-cn fail2ban-server[2536]: 2022-08-20 13:33:48,060 fail2ban               </span><br><span class="line">    [2536]: ERROR   Async configuration of server failed</span><br><span class="line">Aug 20 13:33:48 myserver-cn systemd[1]: fail2ban.service: main process exited, code=exited, status=255/n/a</span><br><span class="line">Aug 20 13:33:48 myserver-cn systemd[1]: Unit fail2ban.service entered failed state.</span><br><span class="line">Aug 20 13:33:48 myserver-cn systemd[1]: fail2ban.service failed.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出中显示 <code>Failed during configuration: Have not found any log file for vnc jail</code>，说明 <code>jail.d/vnc.local</code> 中配置的日志路径或者是权限有问题，需要检查此处配置。  </p>
<blockquote>
<p>此处报错是因为 <code>jail.d/vnc.local</code> 中配置的日志路径如下： </p>
<figure class="highlight shell"><figcaption><span>jail.d/vnc.local</span></figcaption><table><tr><td class="code"><pre><span class="line">logpath = /home/cosmos/.vnc/cosmos\:1.log</span><br></pre></td></tr></table></figure>
<p>配置文件中不需要对 <code>:</code> 进行转义。</p>
</blockquote>
<p>配置无误，重启服务生效后，可以检查 <code>vnc</code> 对应的 <code>ban</code> 的状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">fail2ban-client status vnc</span></span><br><span class="line">Status for the jail: vnc</span><br><span class="line">|- Filter</span><br><span class="line">|  |- Currently failed:	22</span><br><span class="line">|  |- Total failed:	52632</span><br><span class="line">|  `- File list:	/home/cosmos/.vnc/cosmos:1.log.bak</span><br><span class="line">`- Actions</span><br><span class="line">   |- Currently banned:	18</span><br><span class="line">   |- Total banned:	18</span><br><span class="line">   `- Banned IP list:	212.80.219.226 212.80.219.175 175.211.155.52 ...</span><br></pre></td></tr></table></figure>
<p>查看防火墙状态，可以看到被封的 ip ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -L -v -n</span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_42.png"></p>
<p>如果被封禁的 ip 中有被误伤的，需要解禁，使用以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fail2ban-client set vnc  unbanip 45.33.65.249</span><br></pre></td></tr></table></figure>
<p>命令中的 <code>vnc</code> 指 <code>ban</code> 配置文件 <code>/etc/fail2ban/jail.d/vnc.local</code> 中的 <code>[vnc]</code> <a href="#jail-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E">名称</a></p>
<h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p><a href="https://www.fail2ban.org/wiki/index.php/Main_Page">fail2ban 官网</a><br><a href="https://www.fail2ban.org/wiki/index.php/MANUAL_0_8#Filters">fail2ban 配置官网说明</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>fail2ban</tag>
      </tags>
  </entry>
  <entry>
    <title>firewalld 使用</title>
    <url>/202302220932/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos7 3.10.0-1160</li>
</ul>
<p><code>firewalld</code> 是 <code>iptables</code> 的一个封装，可以让你更容易地管理 <code>iptables</code> 规则， 它并不是 <code>iptables</code> 的替代品。虽然 <code>iptables</code> 命令仍可用于 <code>firewalld</code> ，但建议使用 <code>firewalld</code> 时仅使用 <code>firewalld</code> 命令。 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[FirewallD入门手册](https://www.linuxprobe.com/centos-firewalld.html)">[1]</span></a></sup></p>
<p><code>firewalld</code> 是 <code>iptables</code> 的前端控制器，用于实现持久的网络流量规则。它提供命令行和图形界面，在大多数 Linux 发行版的仓库中都有。与直接控制 <code>iptables</code> 相比，使用 <code>firewalld</code> 有两个主要区别：</p>
<ul>
<li><code>firewalld</code> 使用区域和服务而不是链式规则。</li>
<li>它动态管理规则集，允许更新规则而不破坏现有会话和连接。</li>
</ul>
<h1 id="firewalld-配置说明"><a href="#firewalld-配置说明" class="headerlink" title="firewalld 配置说明"></a>firewalld 配置说明</h1><h2 id="配置文件目录"><a href="#配置文件目录" class="headerlink" title="配置文件目录"></a>配置文件目录</h2><p>配置文件位于两个目录中：</p>
<ul>
<li><code>/usr/lib/firewalld/</code> 下保存默认配置，如默认区域和公用服务。避免修改它们，因为每次 <code>firewall</code> 软件包更新时都会覆盖这些文件。</li>
<li><code>/etc/firewalld</code> 下保存系统配置文件。 这些文件将覆盖默认配置。</li>
</ul>
<h2 id="配置集说明"><a href="#配置集说明" class="headerlink" title="配置集说明"></a>配置集说明</h2><p><code>firewalld</code> 使用两个配置集： <code>运行时</code> 和 <code>持久</code></p>
<p>在系统重新启动或重新启动 <code>firewalld</code> 服务时，不会保留 <code>运行时</code> 的配置更改，而对 <code>持久</code> 配置集的更改不会应用于正在运行的系统。</p>
<p>默认情况下，<code>firewall-cmd</code> 命令适用于 <code>运行时</code> 配置，但使用 <code>--permanent</code> 选项将保存配置到  <code>持久</code> 配置中。</p>
<p>要添加和激活持久性规则，你可以使用以下两种方法之一：</p>
<ol>
<li>将规则同时添加到持久规则集和运行时规则集中<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo firewall-cmd --zone=public --add-service=http --permanent</span><br><span class="line">sudo firewall-cmd --zone=public --add-service=http</span><br></pre></td></tr></table></figure></li>
<li>将规则添加到持久规则集中并重新加载 <code>firewalld</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo firewall-cmd --zone=public --add-service=http --permanent</span><br><span class="line">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure>
<code>--reload</code> 选项会删除所有 <code>运行时</code> 配置并应用 <code>持久</code> 配置。因为 <code>firewalld</code> 动态管理规则集，所以它不会破坏现有的连接和会话。<span id="more"></span></li>
</ol>
<h2 id="区域说明"><a href="#区域说明" class="headerlink" title="区域说明"></a>区域说明</h2><p><code>区域</code> 是针对给定位置或场景（例如家庭、公共、受信任等）可能具有的各种信任级别的预构建规则集。不同的区域允许不同的网络服务和入站流量类型，而拒绝其他任何流量。 首次启用 <code>firewalld</code> 后，<code>public</code> 将是默认区域。</p>
<p>区域也可以用于不同的网络接口。例如，要分离内部网络和互联网的接口，你可以在 <code>internal</code> 区域上允许 DHCP，但在 <code>external</code> 区域仅允许 HTTP 和 SSH。未明确设置为特定区域的任何接口将添加到默认区域。</p>
<h3 id="查看默认区域"><a href="#查看默认区域" class="headerlink" title="查看默认区域"></a>查看默认区域</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">firewall-cmd --get-default-zone</span></span><br><span class="line">public</span><br></pre></td></tr></table></figure>
<h3 id="修改默认区域"><a href="#修改默认区域" class="headerlink" title="修改默认区域"></a>修改默认区域</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --set-default-zone=internal</span><br></pre></td></tr></table></figure>
<h3 id="查看激活的区域及网络接口使用的区域"><a href="#查看激活的区域及网络接口使用的区域" class="headerlink" title="查看激活的区域及网络接口使用的区域"></a>查看激活的区域及网络接口使用的区域</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">firewall-cmd --get-active-zones</span></span><br><span class="line">public</span><br><span class="line">  interfaces: eth0</span><br></pre></td></tr></table></figure>
<h3 id="查看指定区域的所有规则集-默认查看-运行时"><a href="#查看指定区域的所有规则集-默认查看-运行时" class="headerlink" title="查看指定区域的所有规则集(默认查看 运行时)"></a>查看指定区域的所有规则集(默认查看 <code>运行时</code>)</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">firewall-cmd --zone=public --list-all</span></span><br><span class="line">public (active)</span><br><span class="line">  target: default</span><br><span class="line">  icmp-block-inversion: no</span><br><span class="line">  interfaces: eth0</span><br><span class="line">  sources: </span><br><span class="line">  services: dhcpv6-client ssh</span><br><span class="line">  ports: 20/tcp 21/tcp 22/tcp 80/tcp 443/tcp 32210/tcp 39000-40000/tcp</span><br><span class="line">  protocols: </span><br><span class="line">  masquerade: no</span><br><span class="line">  forward-ports: </span><br><span class="line">  source-ports: </span><br><span class="line">  icmp-blocks: </span><br><span class="line">  rich rules:</span><br></pre></td></tr></table></figure>
<h3 id="查看指定区域-持久-配置集的所有规则"><a href="#查看指定区域-持久-配置集的所有规则" class="headerlink" title="查看指定区域 持久 配置集的所有规则"></a>查看指定区域 <code>持久</code> 配置集的所有规则</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">firewall-cmd --zone=public --list-all --permanent</span></span><br><span class="line">public</span><br><span class="line">  target: default</span><br><span class="line">  icmp-block-inversion: no</span><br><span class="line">  interfaces: </span><br><span class="line">  sources: </span><br><span class="line">  services: dhcpv6-client ssh</span><br><span class="line">  ports: 20/tcp 21/tcp 22/tcp 80/tcp 443/tcp 32210/tcp 39000-40000/tcp</span><br><span class="line">  protocols: </span><br><span class="line">  masquerade: no</span><br><span class="line">  forward-ports: </span><br><span class="line">  source-ports: </span><br><span class="line">  icmp-blocks: </span><br><span class="line">  rich rules: </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="查看所有区域的配置"><a href="#查看所有区域的配置" class="headerlink" title="查看所有区域的配置"></a>查看所有区域的配置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">firewall-cmd --list-all-zones</span></span><br><span class="line">block</span><br><span class="line">  target: %%REJECT%%</span><br><span class="line">  icmp-block-inversion: no</span><br><span class="line">  interfaces: </span><br><span class="line">  sources: </span><br><span class="line">  services: </span><br><span class="line">  ports: </span><br><span class="line">  protocols: </span><br><span class="line">  masquerade: no</span><br><span class="line">  forward-ports: </span><br><span class="line">  source-ports: </span><br><span class="line">  icmp-blocks: </span><br><span class="line">  rich rules: </span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">dmz</span><br><span class="line">  target: default</span><br><span class="line">  icmp-block-inversion: no</span><br><span class="line">  interfaces: </span><br><span class="line">  sources: </span><br><span class="line">  services: ssh</span><br><span class="line">  ports: </span><br><span class="line">  protocols: </span><br><span class="line">  masquerade: no</span><br><span class="line">  forward-ports: </span><br><span class="line">  source-ports: </span><br><span class="line">  icmp-blocks: </span><br><span class="line">  rich rules: </span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">drop</span><br><span class="line">  target: DROP</span><br><span class="line">  icmp-block-inversion: no</span><br><span class="line">  interfaces: </span><br><span class="line">  sources: </span><br><span class="line">  services: </span><br><span class="line">  ports: </span><br><span class="line">  protocols: </span><br><span class="line">  masquerade: no</span><br><span class="line">  forward-ports: </span><br><span class="line">  source-ports: </span><br><span class="line">  icmp-blocks: </span><br><span class="line">  rich rules: </span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">external</span><br><span class="line">  target: default</span><br><span class="line">  icmp-block-inversion: no</span><br><span class="line">  interfaces: </span><br><span class="line">  sources: </span><br><span class="line">  services: ssh</span><br><span class="line">  ports: </span><br><span class="line">  protocols: </span><br><span class="line">  masquerade: yes</span><br><span class="line">  forward-ports: </span><br><span class="line">  source-ports: </span><br><span class="line">  icmp-blocks: </span><br><span class="line">  rich rules: </span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">home</span><br><span class="line">  target: default</span><br><span class="line">  icmp-block-inversion: no</span><br><span class="line">  interfaces: </span><br><span class="line">  sources: </span><br><span class="line">  services: dhcpv6-client mdns samba-client ssh</span><br><span class="line">  ports: </span><br><span class="line">  protocols: </span><br><span class="line">  masquerade: no</span><br><span class="line">  forward-ports: </span><br><span class="line">  source-ports: </span><br><span class="line">  icmp-blocks: </span><br><span class="line">  rich rules: </span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">internal</span><br><span class="line">  target: default</span><br><span class="line">  icmp-block-inversion: no</span><br><span class="line">  interfaces: </span><br><span class="line">  sources: </span><br><span class="line">  services: dhcpv6-client mdns samba-client ssh</span><br><span class="line">  ports: </span><br><span class="line">  protocols: </span><br><span class="line">  masquerade: no</span><br><span class="line">  forward-ports: </span><br><span class="line">  source-ports: </span><br><span class="line">  icmp-blocks: </span><br><span class="line">  rich rules: </span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">public (active)</span><br><span class="line">  target: default</span><br><span class="line">  icmp-block-inversion: no</span><br><span class="line">  interfaces: eth0</span><br><span class="line">  sources: </span><br><span class="line">  services: dhcpv6-client ssh</span><br><span class="line">  ports: 20/tcp 21/tcp 22/tcp 80/tcp 443/tcp 32210/tcp 39000-40000/tcp</span><br><span class="line">  protocols: </span><br><span class="line">  masquerade: no</span><br><span class="line">  forward-ports: </span><br><span class="line">  source-ports: </span><br><span class="line">  icmp-blocks: </span><br><span class="line">  rich rules: </span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">trusted</span><br><span class="line">  target: ACCEPT</span><br><span class="line">  icmp-block-inversion: no</span><br><span class="line">  interfaces: </span><br><span class="line">  sources: </span><br><span class="line">  services: </span><br><span class="line">  ports: </span><br><span class="line">  protocols: </span><br><span class="line">  masquerade: no</span><br><span class="line">  forward-ports: </span><br><span class="line">  source-ports: </span><br><span class="line">  icmp-blocks: </span><br><span class="line">  rich rules: </span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">work</span><br><span class="line">  target: default</span><br><span class="line">  icmp-block-inversion: no</span><br><span class="line">  interfaces: </span><br><span class="line">  sources: </span><br><span class="line">  services: dhcpv6-client ssh</span><br><span class="line">  ports: </span><br><span class="line">  protocols: </span><br><span class="line">  masquerade: no</span><br><span class="line">  forward-ports: </span><br><span class="line">  source-ports: </span><br><span class="line">  icmp-blocks: </span><br><span class="line">  rich rules: </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><p><code>firewalld</code> 可以根据特定网络服务的预定义规则来允许相关流量。你可以创建自己的自定义系统规则，并将它们添加到任何区域。 默认支持的服务的配置文件位于 <code>/usr/lib/firewalld/services/</code>，用户创建的服务文件在 <code>/etc/firewalld/services/</code> 中</p>
<h3 id="查看默认的可用服务"><a href="#查看默认的可用服务" class="headerlink" title="查看默认的可用服务"></a>查看默认的可用服务</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">firewall-cmd --get-services</span></span><br><span class="line">RH-Satellite-6 RH-Satellite-6-capsule amanda-client amanda-k5-client amqp amqps apcupsd audit bacula bacula-client \</span><br><span class="line">bgp bitcoin bitcoin-rpc bitcoin-testnet bitcoin-testnet-rpc ceph ceph-mon cfengine condor-collector ctdb dhcp dhcpv6 \</span><br><span class="line">dhcpv6-client distcc dns docker-registry docker-swarm dropbox-lansync elasticsearch etcd-client etcd-server finger \</span><br><span class="line">freeipa-ldap freeipa-ldaps freeipa-replication freeipa-trust ftp ganglia-client ganglia-master git gre high-availability \</span><br><span class="line">http https imap imaps ipp ipp-client ipsec irc ircs iscsi-target isns jenkins kadmin kerberos kibana klogin kpasswd \</span><br><span class="line">kprop kshell ldap ldaps libvirt libvirt-tls lightning-network llmnr managesieve matrix mdns minidlna mongodb mosh mountd \</span><br><span class="line">mqtt mqtt-tls ms-wbt mssql murmur mysql nfs nfs3 nmea-0183 nrpe ntp nut openvpn ovirt-imageio ovirt-storageconsole \</span><br><span class="line">ovirt-vmconsole plex pmcd pmproxy pmwebapi pmwebapis pop3 pop3s postgresql privoxy proxy-dhcp ptp pulseaudio puppetmaster \</span><br><span class="line">quassel radius redis rpc-bind rsh rsyncd rtsp salt-master samba samba-client samba-dc sane sip sips slp smtp smtp-submission \</span><br><span class="line">smtps snmp snmptrap spideroak-lansync squid ssh steam-streaming svdrp svn syncthing syncthing-gui synergy syslog syslog-tls \</span><br><span class="line">telnet tftp tftp-client tinc tor-socks transmission-client upnp-client vdsm vnc-server wbem-http wbem-https wsman wsmans \</span><br><span class="line">xdmcp xmpp-bosh xmpp-client xmpp-local xmpp-server zabbix-agent zabbix-server</span><br></pre></td></tr></table></figure>

<h3 id="启用或禁用-HTTP-服务"><a href="#启用或禁用-HTTP-服务" class="headerlink" title="启用或禁用 HTTP 服务"></a>启用或禁用 HTTP 服务</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-service=http --permanent</span><br><span class="line">firewall-cmd --zone=public --remove-service=http --permanent</span><br></pre></td></tr></table></figure>

<h3 id="允许或者拒绝任意端口-x2F-协议"><a href="#允许或者拒绝任意端口-x2F-协议" class="headerlink" title="允许或者拒绝任意端口&#x2F;协议"></a>允许或者拒绝任意端口&#x2F;协议</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=12345/tcp --permanent</span><br><span class="line">firewall-cmd --zone=public --remove-port=12345/tcp --permanent</span><br></pre></td></tr></table></figure>

<h2 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h2><h3 id="同一台服务器上将-80-端口的流量转发到-12345-端口"><a href="#同一台服务器上将-80-端口的流量转发到-12345-端口" class="headerlink" title="同一台服务器上将 80 端口的流量转发到 12345 端口"></a>同一台服务器上将 80 端口的流量转发到 12345 端口</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=&quot;public&quot; --add-forward-port=port=80:proto=tcp:toport=12345</span><br></pre></td></tr></table></figure>

<h3 id="将端口转发到另外一台服务器上"><a href="#将端口转发到另外一台服务器上" class="headerlink" title="将端口转发到另外一台服务器上"></a>将端口转发到另外一台服务器上</h3><ol>
<li>在需要的区域中激活 <code>masquerade</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-masquerade</span><br></pre></td></tr></table></figure></li>
<li>添加转发规则<br>例子中是将 IP 地址为 ：123.456.78.9 的远程服务器上 80 端口的流量转发到 8080 上<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=&quot;public&quot; --add-forward-port=port=80:proto=tcp:toport=8080:toaddr=123.456.78.9</span><br></pre></td></tr></table></figure>
要删除规则，用 <code>--remove</code> 替换 <code>--add</code>。比如：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --remove-masquerade</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.linuxprobe.com/centos-firewalld.html">FirewallD入门手册</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>fswatch 安装使用</title>
    <url>/202306081308/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos 7</li>
<li>fswatch-1.17.1</li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>Centos 7 默认安装的 gcc 版本太低，无法满足 fswatch-1.17.1 的编译配置要求，需要首先<a href="https://csms.tech/202306081314/#安装-gcc-8.3.0">升级 gcc 版本</a>，本示例中 gcc-8.3.0 安装位置为 <code>/usr/local/gcc-8.3.0/</code>，如果系统安装的 gcc 版本符合要求，无需在 <code>./configure</code> 时指定 gcc 环境变量 <code>CXX=/usr/local/gcc-8.3.0/bin/g++</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://github.com/emcrisostomo/fswatch/archive/refs/tags/1.17.1.tar.gz</span><br><span class="line">tar -xf 1.17.1.tar.gz</span><br><span class="line">cd fswatch-1.17.1/</span><br><span class="line">sh autogen.sh</span><br><span class="line"></span><br><span class="line">./configure CXX=/usr/local/gcc-8.3.0/bin/g++ --prefix=/usr/local/fswatch-1.17.1</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>常用选项。<a href="https://csms.tech/202306091031/">参考文档安装 <code>man</code> 手册</a> 后可以查看详细的帮助文档</p>
<p><code>fswatch</code> 会为监控到的每条事件记录以下信息</p>
<ul>
<li><code>timestamp</code> - 事件发生的时间戳</li>
<li><code>path</code> - 触发事件的文件（夹）路径</li>
<li><code>event types</code> - 空格分割的事件类型</li>
</ul>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>-0, --print0</code></td>
<td>ASCII NUL character (<code>\0</code>) as line separator<br/>Since file names can potentially contain any character but <code>NUL</code>, this option assures that the output of fswatch can be safely parsed using <code>NUL</code> as delimiter, such as using <code>xargs -0</code> and the shell builtin <code>read -d &#39;&#39;</code>.</td>
<td><a href="#%E8%BE%93%E5%87%BA%E4%BA%8B%E4%BB%B6%E7%9A%84%E8%A1%8C%E5%88%86%E9%9A%94%E7%AC%A6">使用示例</a></td>
</tr>
<tr>
<td><code>-1, --one-event</code></td>
<td>Exit fswatch after the first set of events is received</td>
<td></td>
</tr>
<tr>
<td><code>--event name</code></td>
<td>can be used multiple times</td>
<td></td>
</tr>
<tr>
<td><code>-e, --exclude regexp</code></td>
<td>Exclude paths matching regexp, Multiple exclude filters can be specified using this option multiple times</td>
<td></td>
</tr>
<tr>
<td><code>-i, --include regexp</code></td>
<td>Include paths matching regexp</td>
<td></td>
</tr>
<tr>
<td><code>-f, --format-time format</code></td>
<td>Print the event time using the specified format</td>
<td></td>
</tr>
<tr>
<td><code>-I, --insensitive</code></td>
<td>Use case insensitive regular expressions</td>
<td></td>
</tr>
<tr>
<td><code>-m, --monitor name</code></td>
<td>Uses the monitor specified by name<br/> 可用的 monitor： <br/>- <code>inotify_monitor</code><br/>- <code>poll_monitor</code></td>
<td></td>
</tr>
<tr>
<td><code>-r, --recursive</code></td>
<td>Watch subdirectories recursively</td>
<td></td>
</tr>
<tr>
<td><code>-t, --timestamp</code></td>
<td>Print the event timestamp.</td>
<td></td>
</tr>
<tr>
<td><code>-u, --utf-time</code></td>
<td>Print the event time in UTC format.  When this option is not specified, the time is printed using the system local time, as defined by localtime</td>
<td></td>
</tr>
<tr>
<td><code>-l, --latency latency</code></td>
<td>监听间隔，默认1s</td>
<td></td>
</tr>
</tbody></table>
<p>常用事件</p>
<table>
<thead>
<tr>
<th>事件</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>NoOp</code></td>
<td>Idle event, optionally issued when no changes were detected</td>
<td></td>
</tr>
<tr>
<td><code>Created</code></td>
<td>The object has been created.</td>
<td></td>
</tr>
<tr>
<td><code>Updated</code></td>
<td>The object has been updated. The kind of update is monitor-dependent.</td>
<td></td>
</tr>
<tr>
<td><code>Removed</code></td>
<td>The object has been removed.</td>
<td></td>
</tr>
<tr>
<td><code>Renamed </code></td>
<td>The object has been renamed.</td>
<td></td>
</tr>
<tr>
<td><code>OwnerModified</code></td>
<td>The object’s owner has changed.</td>
<td></td>
</tr>
<tr>
<td><code>AttributeModified</code></td>
<td>An object’s attribute has changed.</td>
<td></td>
</tr>
<tr>
<td><code>MovedFrom  </code></td>
<td>The object has moved from this location to a new location of the same file system.</td>
<td></td>
</tr>
<tr>
<td><code>MovedTo </code></td>
<td>The object has moved from another location in the same file system into this location.</td>
<td></td>
</tr>
<tr>
<td><code>IsFile </code></td>
<td>The object is a regular file.</td>
<td></td>
</tr>
<tr>
<td><code>IsDir  </code></td>
<td>The object is a directory.</td>
<td></td>
</tr>
<tr>
<td><code>IsSymLink</code></td>
<td>The object is a symbolic link.</td>
<td></td>
</tr>
<tr>
<td><code>Link </code></td>
<td>The object link count has changed.</td>
<td></td>
</tr>
<tr>
<td><code>Overflow</code></td>
<td>The monitor has overflowed.</td>
<td></td>
</tr>
</tbody></table>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><h3 id="输出事件的行分隔符"><a href="#输出事件的行分隔符" class="headerlink" title="输出事件的行分隔符"></a>输出事件的行分隔符</h3><p>以下示例中监视文件 <code>nohup.out</code>，输出事件的每一行使用 <code>\0</code> 分割，<code>read</code> 读取时也使用 <code>\0</code> (<code>&quot;&quot;</code>) 分割，可以防止文件名中包含了空格，使用 <code>read</code> 时读取文件名不全。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">fswatch -0 nohup.out | <span class="keyword">while</span> <span class="built_in">read</span> -d <span class="string">&quot;&quot;</span> file; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$&#123;file&#125;</span>; <span class="keyword">done</span></span></span><br><span class="line">/root/nohup.out</span><br><span class="line">/root/nohup.out</span><br><span class="line">/root/nohup.out</span><br></pre></td></tr></table></figure>

<h3 id="使用-xargs-处理监听事件"><a href="#使用-xargs-处理监听事件" class="headerlink" title="使用 xargs 处理监听事件"></a>使用 xargs 处理监听事件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">fswatch -0 [opts] [paths] | xargs -0 -n 1 -I &#123;&#125; [<span class="built_in">command</span>]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>fswatch -0</code> will split records using the NUL character.</p>
</li>
<li><p><code>xargs -0</code> will split records using the NUL character. This is required to correctly match impedance with fswatch.</p>
</li>
<li><p><code>xargs -n 1</code> will invoke command every record.  If you want to do it every x records, then use xargs -n x.</p>
</li>
<li><p><code>xargs -I &#123;&#125;</code> will substitute occurrences of {} in command with the parsed argument.  If the command you are running<br>       does not need the event path name, just delete this option.  If you prefer using another replacement string, substi‐<br>       tute {} with yours.</p>
</li>
</ul>
<p>以下示例监视文件变化后进行备份</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fswatch -0 nohup.out | xargs -0 -I &#123;&#125; cp &#123;&#125; &#123;&#125;.`date +%Y%m%d%H%M%S`</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上命令中 <code>date +%Y%m%d%H%M%S</code> 只会被计算一次，假如第一次执行时 <code>date +%Y%m%d%H%M%S</code> &#x3D; <code>nohup.out.20230609132143</code>，那么之后每次触发 <code>xargs</code>，变量 <code>date +%Y%m%d%H%M%S</code> 的值都是 <code>nohup.out.20230609132143</code>，<strong>不会被重新计算</strong></p>
</blockquote>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="Event-queue-overflow"><a href="#Event-queue-overflow" class="headerlink" title="Event queue overflow"></a>Event queue overflow</h2><p>执行以下命令，过一段时间后会输出 <code>Event queue overflow</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">fswatch -0 nohup.out | xargs -0 -I &#123;&#125; <span class="built_in">cp</span> &#123;&#125; &#123;&#125;.`<span class="built_in">date</span> +%Y%m%d%H%M%S`</span></span><br><span class="line">Event queue overflow.</span><br><span class="line">Status code: 1</span><br></pre></td></tr></table></figure>

<p><strong>解决方法</strong> 可以选择以下之一。</p>
<ol>
<li><p>使用 <code>poll_monitor</code> monitor 而不是默认的 <code>inotify_monitor</code></p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fswatch -0 --monitor=poll_monitor nohup.out | xargs -0 -I &#123;&#125; cp &#123;&#125; &#123;&#125;.`date +%Y%m%d%H%M%S`</span><br></pre></td></tr></table></figure></li>
<li><p>此限制是因为内核参数限制，主要参数 <code>fs.inotify.max_queued_events</code> <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[OVERFLOW in event queue - Solution is to tune fs.inotify.max_queued_events](https://stackoverflow.com/questions/62501928/lsyncd-overflow-in-event-queue-solution-is-to-tune-fs-inotify-max-queued-eve)">[1]</span></a></sup></p>
<p> 查看内核参数 <code>fs.inotify.max_queued_events</code> 的值，默认值为 16384</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sysctl fs.inotify.max_queued_events</span></span><br><span class="line">fs.inotify.max_queued_events = 16384</span><br></pre></td></tr></table></figure>
<p>修改默认值后，重新测试，结果正常</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sysctl fs.inotify.max_queued_events=1000000</span></span><br><span class="line">fs.inotify.max_queued_events = 1000000</span><br><span class="line">   </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sysctl fs.inotify.max_queued_events</span></span><br><span class="line">fs.inotify.max_queued_events = 1000000</span><br></pre></td></tr></table></figure>
<p> 永久修改此参数的值，可以将其写入内核配置文件 <code>/etc/sysctl.conf</code></p>
</li>
</ol>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://stackoverflow.com/questions/62501928/lsyncd-overflow-in-event-queue-solution-is-to-tune-fs-inotify-max-queued-eve">OVERFLOW in event queue - Solution is to tune fs.inotify.max_queued_events</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>git 常见错误</title>
    <url>/202209131721/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><h2 id="error-RPC-failed-HTTP-403-curl-22-The-requested-URL-returned-error-403"><a href="#error-RPC-failed-HTTP-403-curl-22-The-requested-URL-returned-error-403" class="headerlink" title="error: RPC failed; HTTP 403 curl 22 The requested URL returned error: 403"></a>error: RPC failed; HTTP 403 curl 22 The requested URL returned error: 403</h2><p><strong>错误场景</strong> ： windows 系统中 <code>git push</code> 报错<br><img src="https://i.csms.tech/img_55.png"></p>
<p><strong>错误原因</strong> ： 大概率为用户密码错误</p>
<p><strong>排查步骤</strong> ： </p>
<ol>
<li>清除 windows 凭据管理中的 git 密码，或更改为正确的密码</li>
<li>编辑 <code>.git/config</code> 文件，对 <code>url</code> 按照如下格式配置：<figure class="highlight shell"><figcaption><span>.git/config</span></figcaption><table><tr><td class="code"><pre><span class="line">url = http://USERNAME@git.server.com/test.git</span><br></pre></td></tr></table></figure>
其中 <code>USERNAME</code> 为用户名，重新执行 <code>git push</code>，此时会要求输入用户密码，输入正确的用户密码后，可正常执行</li>
</ol>
<h2 id="There-is-no-tracking-information-for-the-current-branch"><a href="#There-is-no-tracking-information-for-the-current-branch" class="headerlink" title="There is no tracking information for the current branch"></a>There is no tracking information for the current branch</h2><p>执行 <code>git pull</code> 命令时报错：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git pull</span></span><br><span class="line">There is no tracking information for the current branch.</span><br><span class="line">Please specify which branch you want to merge with.</span><br><span class="line">See git-pull(1) for details</span><br><span class="line"></span><br><span class="line">    git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line">If you wish to set tracking information for this branch you can do so with:</span><br><span class="line"></span><br><span class="line">    git branch --set-upstream-to=origin/&lt;branch&gt; activity</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>此错误原因为本地的分支（<code>activity</code>）未和远程分支建立关联，根据提示，执行以下命令建立关联关系</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch --set-upstream-to=origin/activity origin/xhy-activity</span></span><br><span class="line">warning: refname &#x27;origin/activity&#x27; is ambiguous.</span><br><span class="line">fatal: Ambiguous object name: &#x27;origin/activity&#x27;.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行报错： <code>fatal: Ambiguous object name: &#39;origin/activity&#39;.</code>，此报错原因为本地已存在分支 <code>origin/activity</code>，远程也存在此分支，导致 git 无法分辨。可以执行以下命令重命名本地分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -m origin/activity activity</span><br></pre></td></tr></table></figure>
<p>重新建立关联关系</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch --set-upstream-to=origin/activity activity</span></span><br><span class="line">Branch activity set up to track remote branch activity from origin.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>关联正常后，执行 <code>git pull</code> 正常。</p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>gitlab 安装配置及 git 命令使用</title>
    <url>/8db58ebc/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><a href="https://about.gitlab.com/install/#centos-7">安装步骤</a></p>
<blockquote>
<p>安装完成之后使用 <code>gitlab-ctl reconfigure</code> 启动服务<br>访问页面，默认使用 <code>root</code> 登录<br>每次重新更改配置，都需要使用 <code>reconfigure</code> 重新启动</p>
</blockquote>
<span id="more"></span>

<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p>启动所有 gitlab 组件；  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo gitlab-ctl start </span><br></pre></td></tr></table></figure>
<p>停止所有 gitlab 组件；  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo gitlab-ctl stop </span><br></pre></td></tr></table></figure>
<p>重启所有 gitlab 组件；  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo gitlab-ctl restart  </span><br></pre></td></tr></table></figure>
<p>查看服务状态；  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo gitlab-ctl status    </span><br></pre></td></tr></table></figure>
<p>启动服务；  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo gitlab-ctl reconfigure    </span><br></pre></td></tr></table></figure>
<p>修改默认的配置文件；  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/gitlab/gitlab.rb </span><br></pre></td></tr></table></figure>
<p>检查gitlab；  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gitlab-rake gitlab:check SANITIZE=true --trace  </span><br></pre></td></tr></table></figure>
<p>查看日志；  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo gitlab-ctl tail</span><br></pre></td></tr></table></figure>

<h1 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h1><h2 id="初始化空目录-通过-git-init-命令把这个目录变成-git-可以管理的仓库"><a href="#初始化空目录-通过-git-init-命令把这个目录变成-git-可以管理的仓库" class="headerlink" title="初始化空目录,通过 git init 命令把这个目录变成 git 可以管理的仓库"></a>初始化空目录,通过 <code>git init</code> 命令把这个目录变成 git 可以管理的仓库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<h2 id="已有文件的目录创建为-git-仓库"><a href="#已有文件的目录创建为-git-仓库" class="headerlink" title="已有文件的目录创建为 git 仓库"></a>已有文件的目录创建为 git 仓库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init </span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;XX&quot;</span><br><span class="line">git remote add origin https://a.com/p.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<h2 id="更改-git-仓库地址"><a href="#更改-git-仓库地址" class="headerlink" title="更改 git 仓库地址"></a>更改 git 仓库地址</h2><ol>
<li>方法1   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote set-url origin https://a.com/p.git</span><br></pre></td></tr></table></figure></li>
<li>方法2 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote rm origin</span><br><span class="line">git remote add origin https://a.com/p.git</span><br></pre></td></tr></table></figure></li>
<li>方法3<br> 编辑 <code>.git/config</code> 文件, 修改 <code>[remote “origin”]</code> 下面的url即可 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[core]</span><br><span class="line">        repositoryformatversion = 0</span><br><span class="line">        filemode = true</span><br><span class="line">        bare = false</span><br><span class="line">        logallrefupdates = true</span><br><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">        url = https://a.com/p.git</span><br><span class="line">        fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">[branch &quot;main&quot;]</span><br><span class="line">        remote = origin</span><br><span class="line">        merge = refs/heads/main</span><br><span class="line">[branch &quot;master&quot;]</span><br><span class="line">        remote = origin</span><br><span class="line">        merge = refs/heads/master</span><br><span class="line">[pull]</span><br><span class="line">        rebase = true</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h2><p>查看当前分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch </span><br></pre></td></tr></table></figure>
<p>查看所有分支，结果中 <code>*</code> 表示当前分支  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure>

<h2 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h2><p>切换到指定分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -b origin/master-dev</span><br></pre></td></tr></table></figure>
<p>切换主分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure>

<h2 id="撤销当前工作区中对指定文件的修改"><a href="#撤销当前工作区中对指定文件的修改" class="headerlink" title="撤销当前工作区中对指定文件的修改"></a>撤销当前工作区中对指定文件的修改</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout FILE</span><br><span class="line">git checkout .</span><br></pre></td></tr></table></figure>

<h2 id="查看历史记录"><a href="#查看历史记录" class="headerlink" title="查看历史记录"></a>查看历史记录</h2><p>显示当前分支的 commit 历史</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>
<p>查看 git 命令记录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reflog --date=iso</span><br></pre></td></tr></table></figure>

<p>查看指定 commit 的代码变化记录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git show 048bc53e65dda5</span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_2.png"></p>
<h2 id="git-clone-指定分支"><a href="#git-clone-指定分支" class="headerlink" title="git clone 指定分支"></a>git clone 指定分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone -b $&#123;branch&#125; https://git.com/daemo.git</span><br></pre></td></tr></table></figure>
<h2 id="gitignore-配置"><a href="#gitignore-配置" class="headerlink" title=".gitignore 配置"></a>.gitignore 配置</h2><h3 id="gitignore-语法规范"><a href="#gitignore-语法规范" class="headerlink" title=".gitignore 语法规范"></a>.gitignore 语法规范</h3><ul>
<li>空行或是以 <code>#</code> 开头的行即注释行将被忽略。</li>
<li>可以在前面添加正斜杠 <code>/</code> 来避免递归,下面的例子中可以很明白的看出来与下一条的区别。</li>
<li>可以在后面添加正斜杠 <code>/</code> 来忽略文件夹，例如 <code>build/</code> 即忽略 <code>build文件夹</code>。</li>
<li>可以使用 <code>!</code> 来否定忽略，即比如在前面用了 <code>*.apk</code>，然后使用 <code>!a.apk</code>，则这个 <code>a.apk</code> 不会被忽略。</li>
<li><code>*</code> 用来匹配零个或多个字符，如 <code>*.[oa]</code> 忽略所有以 <code>.o</code> 或 <code>.a</code> 结尾，<code>*~</code> 忽略所有以 <code>~</code> 结尾的文件（这种文件通常被许多编辑器标记为临时文件）；</li>
<li><code>[]</code> 用来匹配括号内的任一字符，如 <code>[abc]</code>，也可以在括号内加连接符，如 <code>[0-9]</code> 匹配0至9的数；</li>
<li><code>?</code> 用来匹配单个字符。</li>
</ul>
<h3 id="gitignore-示例"><a href="#gitignore-示例" class="headerlink" title=".gitignore 示例"></a>.gitignore 示例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">忽略 .a 文件</span></span><br><span class="line">*.a</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">但否定忽略 lib.a, 尽管已经在前面忽略了 .a 文件</span></span><br><span class="line">!lib.a</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">仅在当前目录下忽略 TODO 文件， 但不包括子目录下的 subdir/TODO</span></span><br><span class="line">/TODO</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">忽略 build/ 文件夹下的所有文件</span></span><br><span class="line">build/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">忽略 doc/notes.txt, 不包括 doc/server/arch.txt</span></span><br><span class="line">doc/*.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">忽略所有的 .pdf 文件 在 doc/ directory 下的</span></span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure>

<h3 id="gitignore-不生效的原因及处理办法"><a href="#gitignore-不生效的原因及处理办法" class="headerlink" title=".gitignore 不生效的原因及处理办法"></a>.gitignore 不生效的原因及处理办法</h3><p>原因是 <code>.gitignore</code> 只能忽略那些原来没有被 track 的文件，如果某些文件已经被纳入了版本管理中，则修改 <code>.gitignore</code> 是无效的。</p>
<p>解决方法就是先把本地缓存删除（改变成未 track 状态），然后再提交。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rm -r --cached .</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m &#x27;update .gitignore&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="强制同步-Git-仓库代码到本地"><a href="#强制同步-Git-仓库代码到本地" class="headerlink" title="强制同步 Git 仓库代码到本地"></a>强制同步 Git 仓库代码到本地</h2><ol>
<li>确保您已经保存了本地的更改，并且没有其他未提交的更改。可以使用以下命令查看本地代码的状态： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">On branch master</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Your branch is ahead of <span class="string">&#x27;origin/master&#x27;</span> by 1 commit.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  (use <span class="string">&quot;git push&quot;</span> to publish your <span class="built_in">local</span> commits)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">nothing to commit, working directory clean</span></span><br></pre></td></tr></table></figure>
 确保所有更改都已经被提交或者存储起来，以便后续操作。</li>
<li>然后，执行以下命令来强制拉取远程仓库的最新代码 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git fetch --all</span><br><span class="line"></span><br><span class="line">git reset --hard origin/master</span><br></pre></td></tr></table></figure>
 <code>git fetch --all</code> 将获取远程仓库的最新代码，而 <code>git reset --hard origin/master</code> 将强制将本地分支重置为与远程分支完全相同的状态。<blockquote>
<p>这将丢弃本地分支上的任何未提交更改，并将其重置为与远程分支相同的状态。请确保您了解操作的后果，并且您的本地更改已经保存或提交。</p>
</blockquote>
</li>
<li>在需要时，执行以下命令将本地分支的更改强制推送到远程仓库 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push -f origin &lt;branch_name&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><h2 id="Git-fatal-Unable-to-find-remote-helper-for-‘https’"><a href="#Git-fatal-Unable-to-find-remote-helper-for-‘https’" class="headerlink" title="Git fatal: Unable to find remote helper for ‘https’"></a>Git fatal: Unable to find remote helper for ‘https’</h2><p><strong>问题原因</strong>: 未安装curl-devel，安装curl-devel后重新编译<br><strong>解决方法</strong>： 安装curl-devel后重新编译</p>
<h2 id="error-failed-to-push-some-refs-to-‘http-git-39"><a href="#error-failed-to-push-some-refs-to-‘http-git-39" class="headerlink" title="error: failed to push some refs to ‘http://git&#39;"></a>error: failed to push some refs to ‘<a href="http://git&/#39;">http://git&#39;</a></h2><p>push 代码到 Git 仓库报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">To http://git/domain.git</span><br><span class="line"> ! [rejected]        master -&gt; master (non-fast-forward)</span><br><span class="line">error: failed to push some refs to &#x27;http://git/domain.git&#x27;</span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Merge the remote changes (e.g. &#x27;git pull&#x27;)</span><br><span class="line">hint: before pushing again.</span><br><span class="line">hint: See the &#x27;Note about fast-forwards&#x27; in &#x27;git push --help&#x27; for details.</span><br></pre></td></tr></table></figure>
<p>原因为 Git 仓库中的代码比本地代码更新。如要强制同步本地代码到 Git 仓库，可参考以下步骤</p>
<ol>
<li>确保您已经保存了本地的更改，并且没有其他未提交的更改。可以使用以下命令查看本地代码的状态： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">On branch master</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Your branch is ahead of <span class="string">&#x27;origin/master&#x27;</span> by 1 commit.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  (use <span class="string">&quot;git push&quot;</span> to publish your <span class="built_in">local</span> commits)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">nothing to commit, working directory clean</span></span><br></pre></td></tr></table></figure>
 确保所有更改都已经被提交或者存储起来，以便后续操作。</li>
<li>执行以下命令来拉取远程分支的最新更改，此处要同步的分支为 master。这将拉取远程分支的最新更改并尝试将其合并到本地分支。 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure></li>
<li>如果发生合并冲突并且您已经解决了冲突，请执行以下命令标记冲突已解决 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure></li>
<li>接下来，提交您的更改： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;Merge remote changes&quot;</span><br></pre></td></tr></table></figure></li>
<li>最后，将本地更改强制推送到远程仓库 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push -f origin &lt;branch_name&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title>Godaddy api 使用</title>
    <url>/202302251333/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="https://developer.godaddy.com/getstarted">Godaddy API 参考文档</a></p>
<p>根据参考文档说明，获取到 <code>key</code> 和 <code>secret</code></p>
<p>Python3 sdk 可以使用 <code>godaddypy</code></p>
<h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Python 3.11.2</li>
<li>godaddypy</li>
</ul>
<p><code>godaddypy</code> 主要提供了 2 个类，分别为</p>
<ul>
<li><code>account</code> - 使用 <code>key</code> 和 <code>secret</code> 为 <code>client</code> 生成鉴权头部</li>
<li><code>client</code> - 连接 Godaddy API 并执行相应的请求</li>
</ul>
<p>具体使用方法可以查看帮助信息，或者查看 Godaddy API 参考文档</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">help</span>(godaddypy)</span><br></pre></td></tr></table></figure>
<h1 id="godaddypy-常见用法示例"><a href="#godaddypy-常见用法示例" class="headerlink" title="godaddypy 常见用法示例"></a>godaddypy 常见用法示例</h1><h2 id="获取账号中的所有域名"><a href="#获取账号中的所有域名" class="headerlink" title="获取账号中的所有域名"></a>获取账号中的所有域名</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> godaddypy</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ak = <span class="string">&#x27;AAAAAAAAAAAAAA&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sk = <span class="string">&#x27;BBBBBBBBBBBBBBB&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>account = godaddypy.Account(ak, sk)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>client = godaddypy.Client(account)</span><br></pre></td></tr></table></figure>
<p>根据 Godaddy API 文档说明，获取域名，每次默认获取 500 个，最多可以一次性获取 1000 个。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取域名，默认 100 个。如果账户内的域名数量少于 100，则一次性可以获取完毕，多于 100，获取前 100 个</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>client.get_domains()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取前 1000 个，最多一次性获取 1000 个。如果账户内的域名数量少于 1000，则一次性可以获取完毕，多于 1000，获取前 1000 个</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>client.get_domains(limit=<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 超过 1000 会报错</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>client.get_domains(limit=<span class="number">1001</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.11/site-packages/godaddypy/client.py&quot;</span>, line <span class="number">105</span>, <span class="keyword">in</span> _validate_response_success</span><br><span class="line">    response.raise_for_status()</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.11/site-packages/requests/models.py&quot;</span>, line <span class="number">1021</span>, <span class="keyword">in</span> raise_for_status</span><br><span class="line">    <span class="keyword">raise</span> HTTPError(http_error_msg, response=self)</span><br><span class="line">requests.exceptions.HTTPError: <span class="number">422</span> Client Error: Unprocessable Entity <span class="keyword">for</span> url: https://api.godaddy.com/v1/domains?limit=<span class="number">1001</span></span><br><span class="line"></span><br><span class="line">During handling of the above exception, another exception occurred:</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.11/site-packages/godaddypy/client.py&quot;</span>, line <span class="number">149</span>, <span class="keyword">in</span> get_domains</span><br><span class="line">    data = self._get_json_from_response(url, params=params)</span><br><span class="line">           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.11/site-packages/godaddypy/client.py&quot;</span>, line <span class="number">75</span>, <span class="keyword">in</span> _get_json_from_response</span><br><span class="line">    <span class="keyword">return</span> self._request_submit(requests.get, url=url, json=json, **kwargs).json()</span><br><span class="line">           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.11/site-packages/godaddypy/client.py&quot;</span>, line <span class="number">97</span>, <span class="keyword">in</span> _request_submit</span><br><span class="line">    self._validate_response_success(resp)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.11/site-packages/godaddypy/client.py&quot;</span>, line <span class="number">107</span>, <span class="keyword">in</span> _validate_response_success</span><br><span class="line">    <span class="keyword">raise</span> BadResponse(response.json())</span><br><span class="line">godaddypy.client.BadResponse: Response Data: &#123;<span class="string">&#x27;code&#x27;</span>: <span class="string">&#x27;VALUE_OVER&#x27;</span>, <span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;Limit must have a value no greater than 1000&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>如果账户内域名数量大于 1000，可以通过 API 提供的 <code>marker</code> 标记，获取到所有域名。流程为获取到前 100 个域名，使用第 100 个域名作为 <code>marker</code>，会获取到第 101 - 200 个域名，以此类推，获取所有域名</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>client.get_domains()</span><br><span class="line">[..., <span class="string">&#x27;100.com&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>client.get_domains(limit=<span class="number">100</span>, marker=<span class="string">&#x27;100.com&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;101.com&#x27;</span>, ..., <span class="string">&#x27;200.com&#x27;</span>]</span><br></pre></td></tr></table></figure>


<h2 id="获取指定域名的详细信息"><a href="#获取指定域名的详细信息" class="headerlink" title="获取指定域名的详细信息"></a>获取指定域名的详细信息</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>client.get_domain_info(<span class="string">&#x27;test.app&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h1 id="API-REST-接口用法示例"><a href="#API-REST-接口用法示例" class="headerlink" title="API REST 接口用法示例"></a>API REST 接口用法示例</h1><p><code>godaddypy</code> 库无法实现的功能需要调用原生的 API 实现。 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Using the GoDaddy API](https://developer.godaddy.com/getstarted)
">[1]</span></a></sup></p>
<p>API 调用示例 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Using the GoDaddy API](https://developer.godaddy.com/getstarted)
">[1]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -X GET -H <span class="string">&quot;Authorization: sso-key TtbYHEHLWmyVvXB:CrezwNmyEsh&quot;</span> <span class="string">&quot;https://api.godaddy.com/v1/domains/available?domain=example.guru&quot;</span></span></span><br><span class="line">&#123;&quot;available&quot;:false,&quot;definitive&quot;:true,&quot;domain&quot;:&quot;example.guru&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>部分接口需要传入 <code>customerId</code>，需要通过 <code>shopperId</code> 来获取到 <code>customerId</code> <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Documentation: Shoppers API](https://developer.godaddy.com/doc/endpoint/shoppers#/v1/get)">[2]</span></a></sup></p>
<blockquote>
<p><code>shopperId</code> 登陆 godaddy 账号后，在账号信息中可以看到<br><img src="https://i.csms.tech/img_147.png"></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -X GET -H <span class="string">&quot;Authorization: sso-key e42pmipGG8rv:JYHg2i&quot;</span> <span class="string">&quot;https://api.godaddy.com/v1/shoppers/208231111/?includes=customerId&quot;</span></span></span><br><span class="line">&#123;&quot;shopperId&quot;:&quot;208231111&quot;,&quot;marketId&quot;:&quot;en-PH&quot;,&quot;email&quot;:&quot;kdjgies@163.com&quot;,&quot;externalId&quot;:null,&quot;nameFirst&quot;:&quot;dgeaf&quot;,&quot;nameLast&quot;:&quot;F&quot;,&quot;customerId&quot;:&quot;5d072871-6f2d-42d6-96ed-kd09rkjkkg&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>以下示例查询域名的续费信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -X GET -H <span class="string">&quot;Authorization: sso-key e42pmipGG8rv:JYHg2i&quot;</span> <span class="string">&quot;https://api.godaddy.com/v2/customers/5d072871-6f2d-42d6-96ed-kd09rkjkkg/domains/1af7.com&quot;</span></span></span><br><span class="line">&#123;&quot;createdAt&quot;:&quot;2020-12-23T06:26:02.000Z&quot;,&quot;domain&quot;:&quot;1af7.com&quot;,&quot;domainId&quot;:335211690,&quot;expirationProtected&quot;:false,&quot;expiresAt&quot;:&quot;2023-12-23T06:26:02.000Z&quot;,&quot;holdRegistrar&quot;:false,&quot;locked&quot;:true,&quot;modifiedAt&quot;:&quot;2022-11-13T18:54:35.730Z&quot;,&quot;nameServers&quot;:[&quot;b.ns.cloudflare.com&quot;,&quot;d.ns.cloudflare.com&quot;],&quot;privacy&quot;:true,&quot;redemption&quot;:&#123;&quot;redeemable&quot;:false&#125;,&quot;registrarCreatedAt&quot;:&quot;2020-12-23T04:20:54.913Z&quot;,&quot;renewAuto&quot;:false,&quot;renewDeadline&quot;:&quot;2024-02-06T06:26:02.000Z&quot;,&quot;renewal&quot;:&#123;&quot;currency&quot;:&quot;USD&quot;,&quot;price&quot;:9450000,&quot;renewable&quot;:true&#125;,&quot;status&quot;:&quot;ACTIVE&quot;,&quot;transferProtected&quot;:false&#125;</span><br></pre></td></tr></table></figure>

<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://developer.godaddy.com/getstarted">Using the GoDaddy API</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://developer.godaddy.com/doc/endpoint/shoppers#/v1/get">Documentation: Shoppers API</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>云平台</category>
        <category>Godaddy</category>
      </categories>
      <tags>
        <tag>云平台</tag>
        <tag>Godaddy</tag>
      </tags>
  </entry>
  <entry>
    <title>Grafana 使用</title>
    <url>/202306051707/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Grafana 是一款用 GO 语言开发的开源数据可视化工具，可以做数据监控和数据统计，带有告警功能。</p>
<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="组织-Organization-与用户-User"><a href="#组织-Organization-与用户-User" class="headerlink" title="组织(Organization) 与用户(User)"></a>组织(Organization) 与用户(User)</h2><p><strong>Organization</strong> 相当于一个 Namespace，一个 Organization 完全独立于另一个 Organization，包括 <code>datasource</code>、<code>dashboard</code> 等，创建一个 Organization 就相当于打开了一个全新的视图，所有的 <code>datasource</code>、<code>dashboard</code> 等都需要重新创建。一个用户(User) 可以属于多个 Organization。</p>
<p><strong>User</strong> 是 Grafana 里面的用户，用户可以有以下 <strong>角色</strong></p>
<ul>
<li><code>admin</code> - 管理员权限，可以执行任何操作。</li>
<li><code>editor</code> - <em>p</em>不可以创建用户<strong>、</strong>不可以新增 <code>Datasource</code><strong>、</strong>可以创建 Dashboard**</li>
<li><code>viewer</code> - 仅可以查看 Dashboard</li>
<li><code>read only editor</code> - 允许用户修改 Dashboard，但是 <strong>不允许保存</strong></li>
</ul>
<h2 id="数据源-Datasource"><a href="#数据源-Datasource" class="headerlink" title="数据源 Datasource"></a>数据源 Datasource</h2><p>Grafana 中操作的数据集、可视化数据的来源</p>
<h2 id="Dashboard"><a href="#Dashboard" class="headerlink" title="Dashboard"></a>Dashboard</h2><p>在 Dashboard 页面中，可以组织可视化数据图表。</p>
<ul>
<li><code>Panel</code> - 在一个 Dashboard 中，Panel 是最基本的可视化单元。通过 Panel 的 <code>Query Editor</code> 可以为每一个 Panel 添加查询的数据源以及数据查询方式。每一个 Panel 都是独立的，可以选择一种或者多种数据源进行查询。<strong>一个 Panel 中可以有多个 <code>Query Editor</code> 来汇聚多个可视化数据集</strong></li>
<li><code>Row</code> - 在 Dashboard 中，可以定义一个 <code>Row</code>，来组织和管理一组相关的 <code>Panel</code></li>
</ul>
<h3 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h3><p>在 Dashboard 的设置页面中，有 <code>Variables</code> 页面，在其中可以为 Dashboard 配置变量，之后可以在 Panel 的 <code>Query Editor</code> 中使用这些预定义的变量。<strong>变量的值也可以是通过表达式获取的值</strong>。也可以在 <strong>Panel 的标题中使用变量</strong></p>
<p>例如以下 Variables 配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Node    label_values(kubernetes_io_hostname)</span><br></pre></td></tr></table></figure>

<p><img src="https://i.csms.tech/img_169.png"></p>
<p><img src="https://i.csms.tech/img_168.png"></p>
<p>在 Dashboard 中定义了这些变量后，可以在 Panel 的 <code>Query Editor</code> 中使用，在 <code>Query Editor</code> 中使用了 Variables 中定义的变量后，在 Dashboard 的顶部下拉菜单中可以选择预定义的变量的值（<strong>需要在定义 Variables 时配置 <code>Show on dashboard</code> 为 <code>Label and Value</code> 以使在 Dashboard 顶部显示下拉菜单</strong>），Panel 中的 <code>Query</code> 表达式就会使用这些变量的值进行计算以及显示图表。<br><img src="https://i.csms.tech/img_170.png"></p>
<span id="more"></span>


<h1 id="常用配置示例"><a href="#常用配置示例" class="headerlink" title="常用配置示例"></a>常用配置示例</h1><h2 id="Gauge-类型"><a href="#Gauge-类型" class="headerlink" title="Gauge 类型"></a>Gauge 类型</h2><p>Gauge 类型的数据是一个标量值，代表了当前的值。</p>
<h3 id="选择图标显示的数据格式"><a href="#选择图标显示的数据格式" class="headerlink" title="选择图标显示的数据格式"></a>选择图标显示的数据格式</h3><p>例如要配置百分比类型的图标，可以在 <code>Panel</code> 配置中的 <code>Standard options</code> 中选择 <code>Unit</code> 为 <code>Misc</code> -&gt; <code>Percent(0-100)</code></p>
<p><img src="https://i.csms.tech/img_171.png"></p>
<h3 id="配置-Gauge-图标显示渐变色"><a href="#配置-Gauge-图标显示渐变色" class="headerlink" title="配置 Gauge 图标显示渐变色"></a>配置 Gauge 图标显示渐变色</h3><p>要配置 Gauge 仪表盘的渐变色，可以在 <code>Panel</code> 配置中的 <code>Thresholds</code> 中添加渐变颜色<br><img src="https://i.csms.tech/img_172.png"></p>
<p>要使 Gauge 仪表盘内部显示度量值，需要配置 <code>Standard options</code> –&gt; <code>Min</code>、<code>Standard options</code> –&gt; <code>Max</code>、 <code>Standard options</code> –&gt; <code>Decimals</code><br><img src="https://i.csms.tech/img_173.png"></p>
<h2 id="Time-series"><a href="#Time-series" class="headerlink" title="Time series"></a>Time series</h2><h3 id="自定义图形的-Legend"><a href="#自定义图形的-Legend" class="headerlink" title="自定义图形的 Legend"></a>自定义图形的 Legend</h3><p>默认情况下，Legend 会显示指标中的所有标签，会比较长，为了缩短简化 Legend，需要自定义 Legend。在 <strong>图形的编辑界面</strong>，表达式下的 Options 中，选择 <code>Legend</code> 进行自定义，可以使用已有的标签 <code>&#123;&#123;label&#125;&#125;</code>，或者 Variables <code>$variable</code> 来格式化 Lengend</p>
<p>下图为默认的 Legend<br><img src="https://i.csms.tech/img_178.png"></p>
<p>下图为为自定义后的 Legend<br><img src="https://i.csms.tech/img_180.png"></p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title>helm 安装及使用</title>
    <url>/202210071543/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h2><ul>
<li>centos7 5.4.212-1.el7</li>
<li>kubernetes Server Version: v1.25.0</li>
<li>Helm 3.10.0</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li><p>下载 <a href="https://github.com/helm/helm/releases">需要的版本</a></p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://get.helm.sh/helm-v3.10.0-linux-amd64.tar.gz</span><br></pre></td></tr></table></figure></li>
<li><p>解压</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -xf helm-v3.10.0-linux-amd64.tar.gz</span><br></pre></td></tr></table></figure></li>
<li><p>在解压目中找到 <code>helm</code> 程序，移动到需要的目录中</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp linux-amd64/helm /usr/local/bin/</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ helm version</span><br><span class="line"> version.BuildInfo&#123;Version:&quot;v3.10.0&quot;, GitCommit:&quot;ce66412a723e4d89555dc67217607c6579ffcb21&quot;, GitTreeState:&quot;clean&quot;, GoVersion:&quot;go1.18.6&quot;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h2><h3 id="查看已安装的-release"><a href="#查看已安装的-release" class="headerlink" title="查看已安装的 release"></a>查看已安装的 release</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">helm ls</span><br><span class="line"></span><br><span class="line">helm ls -A</span><br></pre></td></tr></table></figure>

<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">helm <span class="built_in">ls</span> -A</span></span><br><span class="line">NAME        	NAMESPACE    	REVISION	UPDATED                                	STATUS	CHART                APP VERSION</span><br><span class="line">cert-manager	cert-manager 	1       	2022-11-01 09:57:11.373366484 +0800 CST	failed	cert-manager-v1.7.1  v1.7.1     </span><br><span class="line">rancher     	cattle-system	1       	2022-11-01 10:05:07.370131566 +0800 CST	failed	rancher-2.6.9        v2.6.9     </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">helm uninstall rancher -n cattle-system</span></span><br><span class="line">W1101 10:21:32.764269   11113 warnings.go:70] policy/v1beta1 PodSecurityPolicy is deprecated in v1.21+, unavailable in v1.25+</span><br><span class="line">W1101 10:21:34.043445   11113 warnings.go:70] policy/v1beta1 PodSecurityPolicy is deprecated in v1.21+, unavailable in v1.25+</span><br><span class="line">W1101 10:21:39.809766   11113 warnings.go:70] policy/v1beta1 PodSecurityPolicy is deprecated in v1.21+, unavailable in v1.25+</span><br><span class="line">release &quot;rancher&quot; uninstalled</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>helm</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo Next 添加 canvas-nest 特效</title>
    <url>/b12589273/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>os: linux 3.10.0-1160.62.1.el7.x86_64 CentOS Linux 7 (Core)</li>
<li>hexo: 6.2.0</li>
<li>hexo-cli: 4.3.0</li>
<li>node: 16.16.0</li>
<li>Next 8.12.2</li>
</ul>
<h3 id="安装-canvas-nest"><a href="#安装-canvas-nest" class="headerlink" title="安装 canvas-nest"></a>安装 canvas-nest</h3><p>参考 <a href="https://github.com/hustcc/canvas-nest.js#install">canva-nest 官网</a> 安装</p>
<figure class="highlight shell"><figcaption><span>npm</span></figcaption><table><tr><td class="code"><pre><span class="line">npm install --save canvas-nest.js</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可选操作，主要是为了生成 <code>canvas-nest.js</code> 文件</p>
</blockquote>
<h3 id="配置-Next"><a href="#配置-Next" class="headerlink" title="配置 Next"></a>配置 Next</h3><p>编辑 <code>next配置文件</code>，新增以下配置</p>
<figure class="highlight shell"><figcaption><span>_config.next.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">background settings</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">add canvas-nest effect</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">see detail from https://github.com/hustcc/canvas-nest.js</span></span><br><span class="line">canvas_nest: </span><br><span class="line">  enable: true </span><br><span class="line">  url: https://s.csms.tech/js/canvas-nest.js</span><br><span class="line">  color: 0,0,255</span><br><span class="line">  opacity: 0.7</span><br><span class="line">  zIndex: -2</span><br><span class="line">  count: 99</span><br></pre></td></tr></table></figure>

<h3 id="引入-canvas-nest-js"><a href="#引入-canvas-nest-js" class="headerlink" title="引入 canvas-nest.js"></a>引入 canvas-nest.js</h3><p>编辑文件 <code>themes/next/layout/_layout.njk</code>, 在<code>&lt;/body&gt;</code> 之前新增以下内容</p>
<figure class="highlight shell"><figcaption><span>themes/next/layout/_layout.njk</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;% if theme.canvas_nest.enable %&#125;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot; color=&quot;&#123;&#123; theme.canvas_nest.color &#125;&#125;&quot; opacity=&#x27;&#123;&#123; theme.canvas_nest.opacity &#125;&#125;&#x27; zIndex=&quot;&#123;&#123; theme.canvas_nest.zIndex &#125;&#125;&quot; count=&quot;&#123;&#123; theme.canvas_nest.count &#125;&#125;&quot; src=&quot;&#123;&#123; theme.canvas_nest.url &#125;&#125;&quot;&gt;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>canvas-nest</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>Huawei 云 SDK 使用</title>
    <url>/202301270909/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Python 3.10</li>
<li>huaweicloudsdk 3.1.23</li>
</ul>
<h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><p><a href="https://console.huaweicloud.com/apiexplorer/#/sdkcenter/ECS?lang=Python">华为云 Python SDK 安装方法官网说明</a></p>
<h2 id="获取云服务器-ECS-实例信息"><a href="#获取云服务器-ECS-实例信息" class="headerlink" title="获取云服务器 (ECS) 实例信息"></a>获取云服务器 (ECS) 实例信息</h2><p>通过华为云提供的 Python SDK 获取云服务器实例信息 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[查询云服务器详情列表](https://console.huaweicloud.com/apiexplorer/#/apidebug/ECS/sdk?api=ListServersDetails)">[1]</span></a></sup></p>
<figure class="highlight shell"><figcaption><span>python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from huaweicloudsdkcore.auth.credentials import BasicCredentials</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from huaweicloudsdkecs.v2.region.ecs_region import EcsRegion</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from huaweicloudsdkcore.exceptions import exceptions</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from huaweicloudsdkecs.v2 import *</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; ak = <span class="string">&#x27;QONOKCeljdngdsEGSAM&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; sk = <span class="string">&#x27;uD4ndlLqP5xDGSrgRRRPJGF8hg^HGkGl2&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; credentials = BasicCredentials(ak, sk)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; client = EcsClient.new_builder().with_credentials(credentials).with_region(EcsRegion.value_of(<span class="string">&quot;cn-east-2&quot;</span>)).build()</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; request = ListServersDetailsRequest()</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; response = client.list_servers_details(request)</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>response</code> 返回一个 <code>huaweicloudsdkecs.v2.model.list_servers_details_response.ListServersDetailsResponse</code> 对象，其中包含了服务器数量和服务器详情列表，要转换为 Python 字典对象，可以通过以下方法</p>
<figure class="highlight shell"><figcaption><span>python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import json</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; server_info = json.loads(str(response))</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">type</span>(server_info)</span></span><br><span class="line">&lt;class &#x27;dict&#x27;&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 获取查询出的机器数量</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; server_info[<span class="string">&#x27;count&#x27;</span>]</span></span><br><span class="line">2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 云服务器列表 list[dict]</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; server_info[<span class="string">&#x27;servers&#x27;</span>]</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 获取云服务器的名称及 id</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; server_info[<span class="string">&#x27;servers&#x27;</span>][0][<span class="string">&#x27;name&#x27;</span>]</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; server_info[<span class="string">&#x27;servers&#x27;</span>][0][<span class="string">&#x27;id&#x27;</span>]</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 获取云服务器的配置规格信息</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; server_info[<span class="string">&#x27;servers&#x27;</span>][0][<span class="string">&#x27;flavor&#x27;</span>]</span></span><br><span class="line">&#123;&#x27;id&#x27;: &#x27;c3.xlarge.2&#x27;, &#x27;name&#x27;: &#x27;c3.xlarge.2&#x27;, &#x27;disk&#x27;: &#x27;0&#x27;, &#x27;vcpus&#x27;: &#x27;4&#x27;, &#x27;ram&#x27;: &#x27;8192&#x27;&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 获取云服务器挂载的磁盘id</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; server_info[<span class="string">&#x27;servers&#x27;</span>][0][<span class="string">&#x27;os-extended-volumes:volumes_attached&#x27;</span>]</span></span><br><span class="line">[&#123;&#x27;id&#x27;: &#x27;1fd566f2-82bb-49d3-95d1-7452a5868f80&#x27;, &#x27;delete_on_termination&#x27;: &#x27;false&#x27;, &#x27;device&#x27;: &#x27;/dev/vdb&#x27;&#125;, &#123;&#x27;id&#x27;: &#x27;2deefa5c-e92b-4ec5-9914-10af9919c121&#x27;, &#x27;delete_on_termination&#x27;: &#x27;false&#x27;, &#x27;bootIndex&#x27;: &#x27;0&#x27;, &#x27;device&#x27;: &#x27;/dev/vda&#x27;&#125;]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 获取云服务器 IP 信息</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 首先在 &#x27;metadata&#x27; 中获取云服务器的 VPC id 信息，根据 VPC id 获取对应的 ip 信息</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; server_info[<span class="string">&#x27;servers&#x27;</span>][0][<span class="string">&#x27;metadata&#x27;</span>]</span></span><br><span class="line">&#123;&#x27;lockScene&#x27;: &#x27;&#x27;, &#x27;charging_mode&#x27;: &#x27;1&#x27;, &#x27;vpc_id&#x27;: &#x27;6827d6f5-4614-42a5-9762-15d3d173411c&#x27;, &#x27;metering.product_id&#x27;: &#x27;00301-15033-0--0&#x27;, &#x27;lockSource&#x27;: &#x27;&#x27;, &#x27;lockSourceId&#x27;: &#x27;&#x27;, &#x27;metering.imagetype&#x27;: &#x27;gold&#x27;, &#x27;metering.order_id&#x27;: &#x27;CS23010203413KRGB&#x27;, &#x27;image_name&#x27;: &#x27;Windows Server 2016 Standard 64bit&#x27;, &#x27;metering.resourcespeccode&#x27;: &#x27;c3.xlarge.2.win&#x27;, &#x27;os_type&#x27;: &#x27;Windows&#x27;, &#x27;metering.resourcetype&#x27;: &#x27;1&#x27;, &#x27;metering.image_id&#x27;: &#x27;dd714f2c-f470-43b6-afc8-34d8ec689516&#x27;, &#x27;os_bit&#x27;: &#x27;64&#x27;, &#x27;EcmResStatus&#x27;: &#x27;&#x27;, &#x27;lockCheckEndpoint&#x27;: &#x27;&#x27;, &#x27;cascaded.instance_extrainfo&#x27;: &#x27;clock_adjustment:28800,pcibridge:1&#x27;&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; server_info[<span class="string">&#x27;servers&#x27;</span>][0][<span class="string">&#x27;metadata&#x27;</span>][<span class="string">&#x27;vpc_id&#x27;</span>]</span></span><br><span class="line">&#x27;6827d6f5-4614-42a5-9762-15d3d173411c&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 其中 &#123;&#x27;OS-EXT-IPS:type&#x27;: &#x27;floating&#x27;&#125; 表示公网 IP</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; server_info[<span class="string">&#x27;servers&#x27;</span>][0][<span class="string">&#x27;addresses&#x27;</span>][<span class="string">&#x27;6827d6f5-4614-42a5-9762-15d3d173411c&#x27;</span>]</span></span><br><span class="line">[&#123;&#x27;version&#x27;: &#x27;4&#x27;, &#x27;addr&#x27;: &#x27;192.168.0.65&#x27;, &#x27;OS-EXT-IPS:type&#x27;: &#x27;fixed&#x27;, &#x27;OS-EXT-IPS-MAC:mac_addr&#x27;: &#x27;fa:16:3e:00:76:2a&#x27;, &#x27;OS-EXT-IPS:port_id&#x27;: &#x27;c1ec2783-6d3c-4d8a-9c55-abb59c2c648d&#x27;&#125;, &#123;&#x27;version&#x27;: &#x27;4&#x27;, &#x27;addr&#x27;: &#x27;159.138.38.203&#x27;, &#x27;OS-EXT-IPS:type&#x27;: &#x27;floating&#x27;, &#x27;OS-EXT-IPS-MAC:mac_addr&#x27;: &#x27;fa:16:3e:00:76:2a&#x27;, &#x27;OS-EXT-IPS:port_id&#x27;: &#x27;c1ec2783-6d3c-4d8a-9c55-abb59c2c648d&#x27;&#125;]</span><br></pre></td></tr></table></figure>

<p>根据云服务器 id，查询云服务器挂载的磁盘信息 <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[查询弹性云服务器磁盘信息](https://console.huaweicloud.com/apiexplorer/#/apidebug/EVS/sdk?api=ListVolumes)">[2]</span></a></sup></p>
<figure class="highlight shell"><figcaption><span>python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; request = ListServerBlockDevicesRequest(server_id=<span class="string">&#x27;a7dd4502-cb3e-4754-b7b7-73bcb5696a1c&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; response = client.list_server_block_devices(request)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; response</span></span><br><span class="line">&#123;&quot;attachableQuantity&quot;: &#123;&quot;free_scsi&quot;: 58, &quot;free_blk&quot;: 22, &quot;free_disk&quot;: 58&#125;, \</span><br><span class="line"> &quot;volumeAttachments&quot;: [&#123;&quot;bootIndex&quot;: 0, &quot;pciAddress&quot;: &quot;0000:02:01.0&quot;, &quot;volumeId&quot;: &quot;2deefa5c-e92b-4ec5-9914-10af9919c121&quot;, &quot;device&quot;: &quot;/dev/vda&quot;, &quot;serverId&quot;: &quot;a7dd4502-cb3e-4754-b7b7-73bcb5696a1c&quot;, \</span><br><span class="line">                        &quot;id&quot;: &quot;2deefa5c-e92b-4ec5-9914-10af9919c121&quot;, &quot;size&quot;: 100, &quot;bus&quot;: &quot;virtio&quot;&#125;, \</span><br><span class="line">                        &#123;&quot;pciAddress&quot;: &quot;0000:02:02.0&quot;, &quot;volumeId&quot;: &quot;1fd566f2-82bb-49d3-95d1-7452a5868f80&quot;, \</span><br><span class="line">                        &quot;device&quot;: &quot;/dev/vdb&quot;, &quot;serverId&quot;: &quot;a7dd4502-cb3e-4754-b7b7-73bcb5696a1c&quot;, &quot;id&quot;: &quot;1fd566f2-82bb-49d3-95d1-7452a5868f80&quot;, &quot;size&quot;: 100, &quot;bus&quot;: &quot;virtio&quot;&#125;]&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="CDN-数据统计"><a href="#CDN-数据统计" class="headerlink" title="CDN 数据统计"></a>CDN 数据统计</h2><p>获取 CDN 域名统计数据 <sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[查询加速域名](https://apiexplorer.developer.intl.huaweicloud.com/apiexplorer/sdk?product=CDN&version=v1&api=ListDomains)">[3]</span></a></sup> </p>
<figure class="highlight shell"><figcaption><span>python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from huaweicloudsdkcore.auth.credentials import GlobalCredentials</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from huaweicloudsdkcdn.v1.region.cdn_region import CdnRegion</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from huaweicloudsdkcore.exceptions import exceptions</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from huaweicloudsdkcdn.v1 import *</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; ak = <span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; sk = <span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; credentials = GlobalCredentials(ak, sk)</span> </span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; client = CdnClient.new_builder() \</span></span><br><span class="line"><span class="language-bash">...         .with_credentials(credentials) \</span></span><br><span class="line"><span class="language-bash">...         .with_region(CdnRegion.value_of(<span class="string">&quot;cn-north-1&quot;</span>)) \</span></span><br><span class="line"><span class="language-bash">...         .build()</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; request = ListDomainsRequest()</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; response = client.list_domains(request)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">response 数据转换为 Python 数据格式</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; response = json.loads(str(response))</span></span><br></pre></td></tr></table></figure>
<p>输出中包含已经配置在 CDN 上面的域名列表。</p>
<p>查询 CDN 加速域名的流量 <sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[查询域名统计数据-区域运营商](https://apiexplorer.developer.intl.huaweicloud.com/apiexplorer/sdk?product=CDN&version=v1&api=ShowDomainLocationStats)">[4]</span></a></sup></p>
<figure class="highlight shell"><figcaption><span>python</span></figcaption><table><tr><td class="code"><pre><span class="line">request = ShowDomainLocationStatsRequest(action=&#x27;location_summary&#x27;, interval=86400, \</span><br><span class="line">                                         start_time=1669852800000, end_time=1672531200000, \</span><br><span class="line">                                         domain_name=&quot;test.a.com&quot;, stat_type=&quot;flux&quot;)</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; response = client.show_domain_location_stats(request)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; response</span></span><br><span class="line">&#123;&quot;result&quot;: &#123;&quot;flux&quot;: 1050601&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="获取-EIP-信息及统计-IP-流量"><a href="#获取-EIP-信息及统计-IP-流量" class="headerlink" title="获取 EIP 信息及统计 IP 流量"></a>获取 EIP 信息及统计 IP 流量</h2><p>本示例演示获取到指定账号和区域的所有 EIP 信息，并根据 EIP ID 统计对应 IP 的公网出口流量。<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[查询弹性公网IP列表](https://apiexplorer.developer.intl.huaweicloud.com/apiexplorer/sdk?product=EIP&version=v2&api=ListPublicips)">[5]</span></a></sup> </p>
<figure class="highlight shell"><figcaption><span>python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from huaweicloudsdkcore.auth.credentials import BasicCredentials</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from huaweicloudsdkeip.v2.region.eip_region import EipRegion</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from huaweicloudsdkcore.exceptions import exceptions</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from huaweicloudsdkeip.v2 import *</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import json</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; zone = <span class="string">&#x27;ap-southeast-1&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; credentials = BasicCredentials(ak, sk)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; client = EipClient.new_builder() \</span></span><br><span class="line"><span class="language-bash">...         .with_credentials(credentials) \</span></span><br><span class="line"><span class="language-bash">...         .with_region(EipRegion.value_of(zone)) \</span></span><br><span class="line"><span class="language-bash">...         .build()</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; request = ListPublicipsRequest()</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; response = client.list_publicips(request)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; r = json.loads(str(response))</span></span><br></pre></td></tr></table></figure>
<p>输出中包含了此区域内的所有 EIP 信息，查询 IP 的流量统计信息需要 EIP ID，以下输出 EIP ID</p>
<figure class="highlight shell"><figcaption><span>python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; r[<span class="string">&#x27;publicips&#x27;</span>][0][<span class="string">&#x27;id&#x27;</span>]</span></span><br><span class="line">&#x27;3fda9feb-b8e3-440d-8fda-16b5728a6e1f&#x27;</span><br></pre></td></tr></table></figure>

<p>根据 EIP ID 信息获取 IP 公网流量统计数据，<code>ShowMetricDataRequest</code> 方法的帮助信息可以通过 <code>help(ShowMetricDataRequest)</code> 查看 <sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[查询监控数据](https://apiexplorer.developer.intl.huaweicloud.com/apiexplorer/doc?product=CES&version=v1&api=ShowMetricData)">[6]</span></a></sup></p>
<figure class="highlight shell"><figcaption><span>python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from huaweicloudsdkcore.auth.credentials import BasicCredentials</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from huaweicloudsdkces.v1.region.ces_region import CesRegion</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from huaweicloudsdkcore.exceptions import exceptions</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from huaweicloudsdkces.v1 import *</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; name_space = <span class="string">&quot;SYS.VPC&quot;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; metric_name = <span class="string">&quot;up_stream&quot;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; dim_01 = <span class="string">&quot;publicip_id,f0304346-2388-4c9b-a9d0-6f321238f2be&quot;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; credentials = BasicCredentials(ak, sk)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span> </span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; client = CesClient.new_builder() \</span></span><br><span class="line"><span class="language-bash">...         .with_credentials(credentials) \</span></span><br><span class="line"><span class="language-bash">...         .with_region(CesRegion.value_of(zone)) \</span></span><br><span class="line"><span class="language-bash">...         .build()</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; request = ShowMetricDataRequest()</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; request.namespace = name_space</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; request.metric_name = metric_name</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; request.dim_0 = dim_01</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; request.filter = <span class="string">&#x27;sum&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; request.period = 86400</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; request._from = start_timestamp</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; request.to = end_timestamp</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; response = client.show_metric_data(request)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; r  = json.loads(str(response))</span></span><br></pre></td></tr></table></figure>
<p>输出中包含了按天分割的流量数据</p>
<figure class="highlight shell"><figcaption><span>python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; r</span></span><br><span class="line">&#123;&#x27;datapoints&#x27;: [&#123;&#x27;sum&#x27;: 4768802.0, &#x27;timestamp&#x27;: 1672531200000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 1331712163.0, &#x27;timestamp&#x27;: 1672617600000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 12761506.0, &#x27;timestamp&#x27;: 1672704000000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 17119425.0, &#x27;timestamp&#x27;: 1672790400000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 16735886.0, &#x27;timestamp&#x27;: 1672876800000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 186881526.0, &#x27;timestamp&#x27;: 1672963200000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 22091616.0, &#x27;timestamp&#x27;: 1673049600000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 9926109.0, &#x27;timestamp&#x27;: 1673136000000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 14668113.0, &#x27;timestamp&#x27;: 1673222400000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 4655251.0, &#x27;timestamp&#x27;: 1673308800000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 151734721.0, &#x27;timestamp&#x27;: 1673395200000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 65481126.0, &#x27;timestamp&#x27;: 1673481600000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 1236561691.0, &#x27;timestamp&#x27;: 1673568000000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 47856976.0, &#x27;timestamp&#x27;: 1673654400000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 1352841.0, &#x27;timestamp&#x27;: 1673740800000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 265917499.0, &#x27;timestamp&#x27;: 1673827200000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 35810298.0, &#x27;timestamp&#x27;: 1673913600000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 23425333.0, &#x27;timestamp&#x27;: 1674000000000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 20177091.0, &#x27;timestamp&#x27;: 1674086400000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 18610343.0, &#x27;timestamp&#x27;: 1674172800000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 8464183.0, &#x27;timestamp&#x27;: 1674259200000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 4749783.0, &#x27;timestamp&#x27;: 1674345600000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 12750334.0, &#x27;timestamp&#x27;: 1674432000000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 12662461.0, &#x27;timestamp&#x27;: 1674518400000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 15664751.0, &#x27;timestamp&#x27;: 1674604800000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 16539739.0, &#x27;timestamp&#x27;: 1674691200000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 27175842.0, &#x27;timestamp&#x27;: 1674777600000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 784220244.0, &#x27;timestamp&#x27;: 1674864000000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 23921455.0, &#x27;timestamp&#x27;: 1674950400000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 30317158.0, &#x27;timestamp&#x27;: 1675036800000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 141162735.0, &#x27;timestamp&#x27;: 1675123200000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;, &#123;&#x27;sum&#x27;: 309507524.0, &#x27;timestamp&#x27;: 1675209600000, &#x27;unit&#x27;: &#x27;Byte&#x27;&#125;], &#x27;metric_name&#x27;: &#x27;up_stream&#x27;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://console.huaweicloud.com/apiexplorer/#/apidebug/ECS/sdk?api=ListServersDetails">查询云服务器详情列表</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://console.huaweicloud.com/apiexplorer/#/apidebug/EVS/sdk?api=ListVolumes">查询弹性云服务器磁盘信息</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://apiexplorer.developer.intl.huaweicloud.com/apiexplorer/sdk?product=CDN&amp;version=v1&amp;api=ListDomains">查询加速域名</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://apiexplorer.developer.intl.huaweicloud.com/apiexplorer/sdk?product=CDN&amp;version=v1&amp;api=ShowDomainLocationStats">查询域名统计数据-区域运营商</a><a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://apiexplorer.developer.intl.huaweicloud.com/apiexplorer/sdk?product=EIP&amp;version=v2&amp;api=ListPublicips">查询弹性公网IP列表</a><a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://apiexplorer.developer.intl.huaweicloud.com/apiexplorer/doc?product=CES&amp;version=v1&amp;api=ShowMetricData">查询监控数据</a><a href="#fnref:6" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>云平台</category>
        <category>Huawei</category>
      </categories>
      <tags>
        <tag>Huawei</tag>
      </tags>
  </entry>
  <entry>
    <title>inotify 安装使用</title>
    <url>/512c7c5/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos 7</li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ul>
<li><p>使用系统软件包管理器安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y inotify-tools</span><br></pre></td></tr></table></figure>
<p>安装后包含2个命令： <code>inotifywait </code>, <code>inotifywatch</code>,较为常用的命令是 <code>inotifywait</code></p>
</li>
<li><p>编译安装<br>此处安装版本 <code>3.22.6.0</code> <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[源码安装官方文档](https://github.com/inotify-tools/inotify-tools/wiki#everyone-else)">[1]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://github.com/inotify-tools/inotify-tools/archive/refs/tags/3.22.6.0.tar.gz</span><br><span class="line">tar -xf 3.22.6.0.tar.gz</span><br><span class="line">cd inotify-tools-3.22.6.0/</span><br><span class="line">yum install -y dh-autoreconf</span><br><span class="line">./autogen.sh &amp;&amp; ./configure --prefix=/usr/local/inotify-tools-3.22.6.0  &amp;&amp; make &amp;&amp; su -c &#x27;make install&#x27;</span><br></pre></td></tr></table></figure></li>
</ul>
<span id="more"></span>

<h1 id="inotifywait-参数说明"><a href="#inotifywait-参数说明" class="headerlink" title="inotifywait 参数说明"></a>inotifywait 参数说明</h1><p>语法：<br>inotifywait [-hcmrq] [-e modify,access…] [-t ] [–format ] [–timefmt ] [ … ]</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@</span><br><span class="line">排除不需要监视的文件，可以是相对路径，也可以是绝对路径。</span><br><span class="line"></span><br><span class="line">--fromfile</span><br><span class="line">从文件读取需要监视的文件或排除的文件，一个文件一行，排除的文件以 @ 开头。</span><br><span class="line"></span><br><span class="line">-m|--monitor</span><br><span class="line">接收到一个事情而不退出，无限期地执行。默认的行为是接收到一个事情后立即退出。</span><br><span class="line"></span><br><span class="line">-d|--daemon</span><br><span class="line">跟 –-monitor 一样，除了是在后台运行，需要指定 -–outfile 把事情输出到一个文件。也意味着使用了 –-syslog。</span><br><span class="line"></span><br><span class="line">-o|--outfile</span><br><span class="line">输出事情到一个文件而不是标准输出。</span><br><span class="line"></span><br><span class="line">-s|--syslog</span><br><span class="line">输出错误信息到系统日志</span><br><span class="line"></span><br><span class="line">-r|--recursive</span><br><span class="line">监视一个目录下的所有子目录。</span><br><span class="line"></span><br><span class="line">-q|--quiet</span><br><span class="line">指定一次，不会输出详细信息，指定二次，除了致命错误，不会输出任何信息。</span><br><span class="line"></span><br><span class="line">--exclude</span><br><span class="line">正则匹配需要排除的文件，大小写敏感。</span><br><span class="line"></span><br><span class="line">--excludei</span><br><span class="line">正则匹配需要排除的文件，忽略大小写。</span><br><span class="line"></span><br><span class="line">-t|--timeout</span><br><span class="line">设置超时时间，如果为 0，则无限期地执行下去。</span><br><span class="line"></span><br><span class="line">-e|--event</span><br><span class="line">指定监视的事件。</span><br><span class="line"></span><br><span class="line">-c|--csv </span><br><span class="line">输出 csv 格式。</span><br><span class="line"></span><br><span class="line">--timefmt </span><br><span class="line">指定时间格式，用于 –-format 选项中的%T格式。</span><br><span class="line"></span><br><span class="line">--format</span><br><span class="line">指定输出格式。</span><br><span class="line">    %w 表示发生事件的目录</span><br><span class="line">    %f 表示发生事件的文件</span><br><span class="line">    %e 表示发生的事件</span><br><span class="line">    %Xe 事件以“X”分隔</span><br><span class="line">    %T 使用由 --timefmt 定义的时间格式</span><br></pre></td></tr></table></figure>

<h1 id="可监听事件列表"><a href="#可监听事件列表" class="headerlink" title="可监听事件列表"></a>可监听事件列表</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">access	文件读取</span><br><span class="line">modify	文件更改。</span><br><span class="line">attrib	文件属性更改，如权限，时间戳等。</span><br><span class="line">close_write	以可写模式打开的文件被关闭，不代表此文件一定已经写入数据。</span><br><span class="line">close_nowrite	以只读模式打开的文件被关闭。</span><br><span class="line">close	文件被关闭，不管它是如何打开的。</span><br><span class="line">open	文件打开。</span><br><span class="line">moved_to	一个文件或目录移动到监听的目录，即使是在同一目录内移动，此事件也触发。</span><br><span class="line">moved_from	一个文件或目录移出监听的目录，即使是在同一目录内移动，此事件也触发。</span><br><span class="line">move	包括moved_to和 moved_from</span><br><span class="line">move_self	文件或目录被移除，之后不再监听此文件或目录。</span><br><span class="line">create	文件或目录创建</span><br><span class="line">delete	文件或目录删除</span><br><span class="line">delete_self	文件或目录移除，之后不再监听此文件或目录</span><br><span class="line">unmount	文件系统取消挂载，之后不再监听此文件系统。</span><br></pre></td></tr></table></figure>

<h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">inotifywait -m -r -e modify /source/ | while read dir action filename</span><br><span class="line">do </span><br><span class="line">  echo $&#123;dir&#125;</span><br><span class="line">  echo $&#123;action&#125;</span><br><span class="line">  echo $&#123;filename&#125;</span><br><span class="line">  rsync -a -u /source/ /dest/</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><h2 id="inotify-监听文件-modify-一段时间后监控不到文件的变化"><a href="#inotify-监听文件-modify-一段时间后监控不到文件的变化" class="headerlink" title="inotify 监听文件 modify 一段时间后监控不到文件的变化"></a>inotify 监听文件 modify 一段时间后监控不到文件的变化</h2><p>使用 <code>inotifywait</code> 监听文件内容的变化，开始时正常，过几分钟后，文件发生了变化，<code>inotifywait</code> 未监控到任何事件，亦未退出或中断。</p>
<p>inotify 的支持，依赖于，以下内核参数</p>
<ul>
<li><code>fs.inotify.max_queued_events</code> - 默认值 16384。inotify 的事件队列大小。超出后会报 <code>Event queue overflow</code></li>
<li><code>fs.inotify.max_user_watches</code> - 默认值 8192。指定了当前文件系统允许的最大监控数量。</li>
<li><code>fs.inotify.max_user_instances</code> - 默认值 128。单个用户可以创建的 inotify 实例的最大数量。当遇到 <code>inotify_init: Too many open files</code> 报错，需要修改此值。</li>
</ul>
<p>inotify 无法监控文件或者目录的变动时，很可能是以上内核参数的限制导致。</p>
<p>本示例通过修改 <code>sysctl fs.inotify.max_queued_events=1000000</code> 后，inotify 功能正常。</p>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://github.com/inotify-tools/inotify-tools/wiki#everyone-else">源码安装官方文档</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>internetbs API 使用</title>
    <url>/202303071425/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="https://internetbs.net/internet-bs-api.pdf">internetbs 域名注册平台 API 接口稳定</a></p>
<p>调用 API 接口需要使用 API key 及账号密码。API 接口申请 key 时需要添加 IP 白名单，只允许从添加的白名单 IP 请求 API。</p>
<h1 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h1><h2 id="获取域名数量"><a href="#获取域名数量" class="headerlink" title="获取域名数量"></a>获取域名数量</h2><p>API 默认返回的数据格式为 <code>TEXT</code>，建议指定数据返回格式为 <code>JSON</code>，通过 <code>eval(response.content)</code> 将返回的字节类型数据转换为字典类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>params = &#123;<span class="string">&#x27;ApiKey&#x27;</span>: <span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;Password&#x27;</span>: <span class="string">&#x27;pswd&#x27;</span>, <span class="string">&#x27;ResponseFormat&#x27;</span>: <span class="string">&#x27;JSON&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>response = requests.get(<span class="string">&#x27;https://api.internet.bs/Domain/Count&#x27;</span>, params=params, )</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>response.content</span><br><span class="line"><span class="string">b&#x27;&#123;&quot;transactid&quot;:&quot;3b3df8bfdfcc215ea7e6575a97adcea3&quot;,&quot;status&quot;:&quot;SUCCESS&quot;,&quot;app&quot;:9,&quot;com&quot;:6,&quot;de&quot;:1,&quot;in&quot;:1,&quot;live&quot;:1,&quot;tv&quot;:2,&quot;vip&quot;:1,&quot;world&quot;:1,&quot;totaldomains&quot;:22&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(response.content)</span><br><span class="line">&#123;<span class="string">&#x27;transactid&#x27;</span>: <span class="string">&#x27;3b3df8bfdfcc215ea7e6575a97adcea3&#x27;</span>, <span class="string">&#x27;status&#x27;</span>: <span class="string">&#x27;SUCCESS&#x27;</span>, <span class="string">&#x27;app&#x27;</span>: <span class="number">9</span>, <span class="string">&#x27;com&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;de&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;in&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;live&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;tv&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;vip&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;world&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;totaldomains&#x27;</span>: <span class="number">22</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取所有域名"><a href="#获取所有域名" class="headerlink" title="获取所有域名"></a>获取所有域名</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>params = &#123;<span class="string">&#x27;ApiKey&#x27;</span>: <span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;Password&#x27;</span>: <span class="string">&#x27;pswd&#x27;</span>, <span class="string">&#x27;ResponseFormat&#x27;</span>: <span class="string">&#x27;JSON&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>response = requests.get(<span class="string">&#x27;https://api.internet.bs/Domain/List&#x27;</span>, params=params, )</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>云平台</category>
        <category>internetbs</category>
      </categories>
      <tags>
        <tag>云平台</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins + gitlab 自动构建</title>
    <url>/202210261456/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Jenkins jenkinsci&#x2F;blueocean:2.346.3</li>
<li>GitLab Community Edition 13.9.6</li>
<li>Docker 19.03.15</li>
</ul>
<p>本文档记录 GitLab 上面的代码更新时，使用 Jenkins 自动构建 Docker 镜像的过程。 </p>
<h1 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h1><h2 id="使用-docker-启动-Jenkins-容器"><a href="#使用-docker-启动-Jenkins-容器" class="headerlink" title="使用 docker 启动 Jenkins 容器"></a>使用 docker 启动 Jenkins 容器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8080:8080 --name jenkins \</span><br><span class="line">          -v /var/run/docker.sock:/var/run/docker.sock  \</span><br><span class="line">          -v /data/JenkinsData_blueocean/:/var/jenkins_home/ \</span><br><span class="line">          -u root \</span><br><span class="line">          jenkinsci/blueocean</span><br></pre></td></tr></table></figure>

<h2 id="Jenkins-配置"><a href="#Jenkins-配置" class="headerlink" title="Jenkins 配置"></a>Jenkins 配置</h2><p>以下分别记录使用 <code>freestyle</code> 和 <code>Pipeline</code> 类型的构建镜像的配置过程</p>
<h3 id="创建-freestyle-类型的-Item-构建镜像"><a href="#创建-freestyle-类型的-Item-构建镜像" class="headerlink" title="创建 freestyle 类型的 Item 构建镜像"></a>创建 <code>freestyle</code> 类型的 Item 构建镜像</h3><p>在 <code>源码管理（Source Code Management）</code> 中配置 git 地址，并配置认证</p>
<blockquote>
<p>默认情况下，在构建时，Jenkins 会先从配置的 Git 地址拉取代码到 Jenkins 目录： <code>/var/jenkins_home/workspace/$&#123;PROJECT_NAME&#125;</code></p>
</blockquote>
<p>在 <code>构建（Build）</code> 中 <code>Add build step</code> ，选择构建类型为 <code>Execute shell</code>，此处构建的示例项目代码结构如下，其中 Dockerfile 路径为 <code>k8s/server/Dockerfile</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.:</span><br><span class="line">index.html	k8s</span><br><span class="line"></span><br><span class="line">./k8s:</span><br><span class="line">server</span><br><span class="line"></span><br><span class="line">./k8s/server:</span><br><span class="line">Dockerfile</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用如下 shell 脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">DATA=`date +%Y%m%d%H%M`</span><br><span class="line"></span><br><span class="line">DIR=&#x27;.&#x27;</span><br><span class="line"></span><br><span class="line">LOG=$&#123;DIR&#125;/docker_build_result.log</span><br><span class="line"></span><br><span class="line">DOCKER_REGISTRY=&#x27;harbor.a.com&#x27;</span><br><span class="line"></span><br><span class="line">DOCKER_REGISTRY_PROJECT=&#x27;test&#x27;</span><br><span class="line"></span><br><span class="line">PROJECT=&#x27;test_project&#x27;</span><br><span class="line">ENV=&#x27;uat&#x27;</span><br><span class="line"></span><br><span class="line">docker build -t $&#123;PROJECT&#125;-$&#123;ENV&#125;-$&#123;Branch&#125;:$&#123;DATA&#125; -f k8s/server/Dockerfile $&#123;DIR&#125; | tee $&#123;LOG&#125;</span><br><span class="line"></span><br><span class="line">docker tag $&#123;PROJECT&#125;-$&#123;ENV&#125;-$&#123;Branch&#125;:$&#123;DATA&#125; $&#123;DOCKER_REGISTRY&#125;/$&#123;DOCKER_REGISTRY_PROJECT&#125;/$&#123;PROJECT&#125;-$&#123;ENV&#125;-$&#123;Branch&#125;:$&#123;DATA&#125;</span><br><span class="line"></span><br><span class="line">docker login -u admin -p Harbor12345 $&#123;DOCKER_REGISTRY&#125;</span><br><span class="line"></span><br><span class="line">docker push $&#123;DOCKER_REGISTRY&#125;/$&#123;DOCKER_REGISTRY_PROJECT&#125;/$&#123;PROJECT&#125;-$&#123;ENV&#125;-$&#123;Branch&#125;:$&#123;DATA&#125;</span><br><span class="line"></span><br><span class="line">RESULT=`cat $&#123;LOG&#125; | tail -n 1`</span><br><span class="line"></span><br><span class="line">grep &quot;Successfully tagged &quot; $&#123;LOG&#125;</span><br><span class="line"></span><br><span class="line">exit $?</span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_71.png"></p>
<blockquote>
<p>其中的 <code>$&#123;Branch&#125;</code> 来自 <strong>参数化的构建</strong><br><img src="https://i.csms.tech/img_69.png"></p>
</blockquote>
<span id="more"></span>

<h3 id="使用-Jenkins-Pipeline-构建镜像"><a href="#使用-Jenkins-Pipeline-构建镜像" class="headerlink" title="使用 Jenkins Pipeline 构建镜像"></a>使用 Jenkins Pipeline 构建镜像</h3><p>创建 <code>Pipeline</code> 类型的工程</p>
<p><code>Advanced Project Options</code> 中选择 <code>Pipeline from SCM</code>，并配置 Git 的 url 及认证信息。<code>Script Path</code> 默认为 <code>Jenkinsfile</code>(位于代码根目录)</p>
<p><code>Jenkinsfile</code> 内容如下：</p>
<figure class="highlight shell"><figcaption><span>Jenkinsfile</span></figcaption><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    environment &#123;</span><br><span class="line">        PROJECT=&#x27;test_admin&#x27;</span><br><span class="line">        </span><br><span class="line">        HARBOR_CREDENTIALS = credentials(&#x27;habor&#x27;)</span><br><span class="line">		GIT_CREDENTIALS = credentials(&#x27;git&#x27;)</span><br><span class="line">		</span><br><span class="line">        GIT_URL = &quot;http://$&#123;GIT_CREDENTIALS_USR&#125;:$&#123;GIT_CREDENTIALS_PSW&#125;@git.wkctrlsys.com:18081/jiafeimao/api.git&quot;</span><br><span class="line">        </span><br><span class="line">        DATA=&quot;$&#123;sh(script: &#x27;date +%Y%m%d%H%M&#x27;, returnStdout:true)&#125;&quot;</span><br><span class="line">        LOG=&#x27;./docker_build_result.log&#x27;</span><br><span class="line">        </span><br><span class="line">        DOCKER_REGISTRY=&#x27;harbor.my.com&#x27;</span><br><span class="line">        DOCKER_REGISTRY_PROJECT=&#x27;test&#x27;</span><br><span class="line">        </span><br><span class="line">        BRANCH = &quot;$&#123;params.Branch&#125;&quot;</span><br><span class="line">        </span><br><span class="line">        DIR = &#x27;.&#x27;</span><br><span class="line">		</span><br><span class="line">		TAG = &quot;$&#123;PROJECT&#125;-$&#123;BRANCH&#125;:$&#123;DATA&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&#x27;CHECKOUT&#x27;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                // 清空 workspace</span><br><span class="line">                sh &quot;rm -rf $&#123;env.WORKSPACE&#125;/*&quot;</span><br><span class="line">                sh &quot;rm -rf $&#123;env.WORKSPACE&#125;/.git&quot;</span><br><span class="line">                sh &quot;git clone -b $&#123;BRANCH&#125; $&#123;GIT_URL&#125; .&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(&#x27;BUILD&#x27;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh &#x27;docker build -t $&#123;TAG&#125; -f k8s/server/Dockerfile $&#123;DIR&#125; | tee $&#123;LOG&#125;&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(&#x27;PUSH&#x27;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh &#x27;docker tag $&#123;TAG&#125; $&#123;DOCKER_REGISTRY&#125;/$&#123;DOCKER_REGISTRY_PROJECT&#125;/$&#123;TAG&#125;&#x27;</span><br><span class="line">                </span><br><span class="line">                sh &#x27;docker login -u $&#123;HARBOR_CREDENTIALS_USR&#125; -p $&#123;HARBOR_CREDENTIALS_PSW&#125; $&#123;DOCKER_REGISTRY&#125;&#x27;</span><br><span class="line">                </span><br><span class="line">                sh &#x27;docker push $&#123;DOCKER_REGISTRY&#125;/$&#123;DOCKER_REGISTRY_PROJECT&#125;/$&#123;TAG&#125;&#x27;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">		</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><h2 id="Cannot-connect-to-the-Docker-daemon-at-unix-x2F-x2F-x2F-var-x2F-run-x2F-docker-sock-Is-the-docker-daemon-running"><a href="#Cannot-connect-to-the-Docker-daemon-at-unix-x2F-x2F-x2F-var-x2F-run-x2F-docker-sock-Is-the-docker-daemon-running" class="headerlink" title="Cannot connect to the Docker daemon at unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock. Is the docker daemon running?"></a>Cannot connect to the Docker daemon at unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock. Is the docker daemon running?</h2><p><strong>错误场景</strong></p>
<p>使用 Docker 部署的 Jenkins，在构建 Docker 镜像时，Jenkins 中的 docker 为客户端，使用的 Server 端是宿主机的 Docker Daemon，默认情况下，docker 客户端是通过 <code>unix:///var/run/docker.sock</code> 连接 Docker 服务端，此文件在 Jenkins 容器中不能直接访问，所以导致出现上述错误。</p>
<p><strong>解决思路</strong></p>
<p>针对此种情况，需要让 docker 客户端可以正确的连接到 docker 服务端</p>
<p><strong>解救方法</strong></p>
<p>为 docker 客户端指定 docker 服务端，可以采取以下方法</p>
<ul>
<li>将宿主机的 <code>/var/run/docker.sock</code> 挂载到 Jenkins 容器<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8080:8080 --name jenkins -v /var/run/docker.sock:/var/run/docker.sock  jenkinsci/blueocean</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Got-permission-denied-while-trying-to-connect-to-the-Docker-daemon-socket-at-unix-x2F-x2F-x2F-var-x2F-run-x2F-docker-sock"><a href="#Got-permission-denied-while-trying-to-connect-to-the-Docker-daemon-socket-at-unix-x2F-x2F-x2F-var-x2F-run-x2F-docker-sock" class="headerlink" title="Got permission denied while trying to connect to the Docker daemon socket at unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock"></a>Got permission denied while trying to connect to the Docker daemon socket at unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock</h2><p><strong>错误场景</strong></p>
<p>使用 Docker 部署的 Jenkins，默认情况下，容器中使用 <code>jenkins</code> 用户运行，无权限访问 <code>/var/run/docker.sock</code>，可以使用如下命令，在启动容器时使用 <code>root</code> 用户运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8080:8080 --name jenkins \</span><br><span class="line">          -v /var/run/docker.sock:/var/run/docker.sock  \</span><br><span class="line">          -v /data/JenkinsData_blueocean/:/var/jenkins_home/ \</span><br><span class="line">          -u root \</span><br><span class="line">          jenkinsci/blueocean</span><br></pre></td></tr></table></figure>

<h2 id="WorkflowScript-3-Invalid-agent-type-“docker”-specified-Must-be-one-of-any-label-none"><a href="#WorkflowScript-3-Invalid-agent-type-“docker”-specified-Must-be-one-of-any-label-none" class="headerlink" title="WorkflowScript: 3: Invalid agent type “docker” specified. Must be one of [any, label, none]"></a>WorkflowScript: 3: Invalid agent type “docker” specified. Must be one of [any, label, none]</h2><p><strong>错误原因</strong></p>
<p>没有 docker 相关的插件导致，安装插件 <code>Docker Pipeline</code></p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
        <tag>gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes 上部署 cert-manager 及使用</title>
    <url>/202301050935/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Kubernetes 1.24</li>
<li>cert-manager v1.7.1</li>
</ul>
<p>随着 HTTPS 不断普及，越来越多的网站都在从 HTTP 升级到 HTTPS，使用 HTTPS 就需要向权威机构申请证书，需要付出一定的成本，如果需求数量多，也是一笔不小的开支。cert-manager 是 Kubernetes 上的全能证书管理工具，如果对安全级别和证书功能要求不高，可以利用 cert-manager 基于 ACME 协议与 Let’s Encrypt 来签发免费证书并自动续期，实现永久免费使用证书。</p>
<h1 id="cert-manager-工作原理"><a href="#cert-manager-工作原理" class="headerlink" title="cert-manager 工作原理"></a>cert-manager 工作原理</h1><p>cert-manager 部署到 Kubernetes 集群后，它会 watch 它所支持的 CRD 资源，我们通过创建 CRD 资源来指示 cert-manager 为我们签发证书并自动续期: <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[cert-manager 工作原理](https://imroc.cc/k8s/trick/sign-free-certs-with-cert-manager/#cert-manager-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86)">[1]</span></a></sup><br><img src="https://i.csms.tech/img_111.png"></p>
<p>解释下几个关键的资源:</p>
<ul>
<li><code>Issuer/ClusterIssuer</code>: 用于指示 cert-manager 用什么方式签发证书，本文主要讲解签发免费证书的 ACME 方式。<code>ClusterIssuer</code> 与 <code>Issuer</code> 的唯一区别就是 <code>Issuer</code> 只能用来签发自己所在 <code>namespace</code> 下的证书，<code>ClusterIssuer</code> 可以签发任意 <code>namespace</code> 下的证书。</li>
<li><code>Certificate</code>: 用于告诉 cert-manager 我们想要什么域名的证书以及签发证书所需要的一些配置，包括对 <code>Issuer/ClusterIssuer</code> 的引用。</li>
</ul>
<span id="more"></span>

<h1 id="免费证书签发原理"><a href="#免费证书签发原理" class="headerlink" title="免费证书签发原理"></a>免费证书签发原理</h1><p>Let’s Encrypt 利用 ACME 协议来校验域名是否真的属于你，校验成功后就可以自动颁发免费证书，证书有效期只有 90 天，在到期前需要再校验一次来实现续期，幸运的是 cert-manager 可以自动续期，这样就可以使用永久免费的证书了。如何校验这个域名是否属于你呢？主流的两种校验方式是 HTTP-01 和 DNS-01，详细校验原理可参考 Let’s Encrypt 的运作方式，下面将简单描述下。</p>
<h2 id="HTTP-01-校验原理"><a href="#HTTP-01-校验原理" class="headerlink" title="HTTP-01 校验原理"></a>HTTP-01 校验原理</h2><p>HTTP-01 的校验原理是给你域名指向的 HTTP 服务增加一个临时 location ，Let’s Encrypt 会发送 http 请求到 http:&#x2F;&#x2F;<YOUR_DOMAIN>&#x2F;.well-known&#x2F;acme-challenge&#x2F;<TOKEN>，YOUR_DOMAIN 就是被校验的域名，TOKEN 是 ACME 协议的客户端负责放置的文件，在这里 ACME 客户端就是 cert-manager，它通过修改或创建 Ingress 规则来增加这个临时校验路径并指向提供 TOKEN 的服务。Let’s Encrypt 会对比 TOKEN 是否符合预期，校验成功后就会颁发证书。此方法仅适用于给使用 Ingress 暴露流量的服务颁发证书，并且不支持泛域名证书。</p>
<h2 id="DNS-01-校验原理"><a href="#DNS-01-校验原理" class="headerlink" title="DNS-01 校验原理"></a>DNS-01 校验原理</h2><p>DNS-01 的校验原理是利用 DNS 提供商的 API Key 拿到你的 DNS 控制权限， 在 Let’s Encrypt 为 ACME 客户端提供令牌后，ACME 客户端 (cert-manager) 将创建从该令牌和您的帐户密钥派生的 TXT 记录，并将该记录放在 _acme-challenge.<YOUR_DOMAIN>。 然后 Let’s Encrypt 将向 DNS 系统查询该记录，如果找到匹配项，就可以颁发证书。此方法不需要你的服务使用 Ingress，并且支持泛域名证书。</p>
<h2 id="校验方式对比"><a href="#校验方式对比" class="headerlink" title="校验方式对比"></a>校验方式对比</h2><p>HTTP-01 的校验方式的优点是: 配置简单通用，不管使用哪个 DNS 提供商都可以使用相同的配置方法；缺点是：需要依赖 Ingress，如果你的服务不是用 Ingress 暴露流量的就不适用，而且不支持泛域名证书。</p>
<p>DNS-01 的校验方式的优点是没有 HTTP-01 校验方式缺点，不依赖 Ingress，也支持泛域名；缺点就是不同 DNS 提供商的配置方式不一样，而且 DNS 提供商有很多，cert-manager 的 Issuer 不可能每个都去支持，不过有一些可以通过部署实现了 cert-manager 的 Webhook 的服务来扩展 Issuer 进行支持，比如 DNSPod 和 阿里 DNS，详细 Webhook 列表请参考: <a href="https://cert-manager.io/docs/configuration/acme/dns01/#webhook">https://cert-manager.io/docs/configuration/acme/dns01/#webhook</a></p>
<p>选择哪种方式呢？条件允许的话，建议是尽量用 DNS-01 的方式，限制更少，功能更全。 <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[免费证书签发原理](https://imroc.cc/k8s/trick/sign-free-certs-with-cert-manager/#%E5%85%8D%E8%B4%B9%E8%AF%81%E4%B9%A6%E7%AD%BE%E5%8F%91%E5%8E%9F%E7%90%86)">[2]</span></a></sup></p>
<h1 id="cert-manager-部署"><a href="#cert-manager-部署" class="headerlink" title="cert-manager 部署"></a>cert-manager 部署</h1><p><a href="https://csms.tech/202210071716/#安装-cert-manager">安装参考文档</a></p>
<h1 id="cert-manager-使用"><a href="#cert-manager-使用" class="headerlink" title="cert-manager 使用"></a>cert-manager 使用</h1><h2 id="DNS-01-校验方式签发证书"><a href="#DNS-01-校验方式签发证书" class="headerlink" title="DNS-01 校验方式签发证书"></a>DNS-01 校验方式签发证书</h2><p>下面以 cloudflare 为例来签发证书：</p>
<ol>
<li><p>登录 cloudflare，点到 My Profile &gt; API Tokens &gt; Create Token 来创建 Token:<br><img src="https://i.csms.tech/img_112.png"><br>复制 Token 并妥善保管:<br><img src="https://i.csms.tech/img_113.png"></p>
</li>
<li><p>将 Token 保存到 Secret 中:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  name: cloudflare-api-token-secret</span><br><span class="line">  namespace: cert-manager</span><br><span class="line">type: Opaque</span><br><span class="line">stringData:</span><br><span class="line">  api-token: &lt;API Token&gt; # 粘贴 Token 到这里，不需要 base64 加密。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果是要创建 ClusterIssuer，Secret 需要创建在 cert-manager 所在命名空间中，如果是 Issuer，那就创建在 Issuer 所在命名空间中。 <sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[DNS-01 校验方式签发证书](https://imroc.cc/k8s/trick/sign-free-certs-with-cert-manager/#dns-01-%E6%A0%A1%E9%AA%8C%E6%96%B9%E5%BC%8F%E7%AD%BE%E5%8F%91%E8%AF%81%E4%B9%A6)">[3]</span></a></sup></p>
</blockquote>
</li>
<li><p>创建 ClusterIssuer:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: cert-manager.io/v1</span><br><span class="line">kind: ClusterIssuer</span><br><span class="line">metadata:</span><br><span class="line">  name: letsencrypt-dns01</span><br><span class="line">spec:</span><br><span class="line">  acme:</span><br><span class="line">    privateKeySecretRef:</span><br><span class="line">      name: letsencrypt-dns01     # 用于储存 ACME Account 私钥的 Secret</span><br><span class="line">    email: my-cloudflare-acc@example.com</span><br><span class="line">    server: https://acme-v02.api.letsencrypt.org/directory</span><br><span class="line">    solvers:</span><br><span class="line">    - dns01:</span><br><span class="line">        cloudflare:</span><br><span class="line">          email: my-cloudflare-acc@example.com # 替换成你的 cloudflare 邮箱账号，API Token 方式认证非必需，API Keys 认证是必需</span><br><span class="line">          apiTokenSecretRef:</span><br><span class="line">            key: api-token               # 引用 secret 中的配置数据，key 为 secret 中配置的名称</span><br><span class="line">            name: cloudflare-api-token-secret    # 引用保存 cloudflare 认证信息的 Secret</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建 Certificate:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: cert-manager.io/v1</span><br><span class="line">kind: Certificate</span><br><span class="line">metadata:</span><br><span class="line">  name: test-mydomain-com</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  dnsNames:</span><br><span class="line">  - test.mydomain.com # 要签发证书的域名</span><br><span class="line">  - &quot;*.mydomain.com&quot; </span><br><span class="line">  issuerRef:</span><br><span class="line">    kind: ClusterIssuer</span><br><span class="line">    name: letsencrypt-dns01 # 引用 ClusterIssuer，指示采用 dns01 方式进行校验</span><br><span class="line">  secretName: test-mydomain-com-tls # 最终签发出来的证书会保存在这个 Secret 里面</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取和使用证书</p>
<p>创建好 Certificate 后，等一小会儿，我们可以 kubectl 查看是否签发成功:</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ kubectl get certificate -n prod</span><br><span class="line"> NAME                READY   SECRET                  AGE</span><br><span class="line"> test-mydomain-com   True    test-mydomain-com-tls   1m</span><br></pre></td></tr></table></figure>
<p> 如果 READY 为 <code>False</code> 表示失败，可以通过 <code>describe</code> 查看 <code>event</code> 来排查失败原因:</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ kubectl describe certificate test-mydomain-com -n prod</span><br></pre></td></tr></table></figure>
<p> 如果为 <code>True</code> 表示签发成功，证书就保存在我们所指定的 <code>Secret 中</code> (上面的例子是 <code>default/test-mydomain-com-tls</code>)，可以通过 <code>kubectl</code> 查看:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ kubectl get secret test-mydomain-com-tls -n default</span><br><span class="line"> ...</span><br><span class="line"> data:</span><br><span class="line">   tls.crt: &lt;cert&gt;</span><br><span class="line">   tls.key: &lt;private key&gt;</span><br></pre></td></tr></table></figure>
<p> 其中 <code>tls.crt</code> 就是证书，<code>tls.key</code> 是密钥。</p>
<p> 你可以将它们挂载到你需要证书的应用中，或者使用 Ingress，可以直接在 Ingress 中引用 <code>secret</code>，示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1beta1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: test-ingress</span><br><span class="line">  annotations:</span><br><span class="line">    kubernetes.io/Ingress.class: nginx</span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">  - host: test.mydomain.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path: /web</span><br><span class="line">        backend:</span><br><span class="line">          serviceName: web</span><br><span class="line">          servicePort: 80</span><br><span class="line">  tls:</span><br><span class="line">    hosts:</span><br><span class="line">    - test.mydomain.com</span><br><span class="line">    secretName: test-mydomain-com-tls</span><br></pre></td></tr></table></figure>
<p>签发证书异常，可以检查 cert-manager 的 pod 的日志，查看报错信息。</p>
<p>nginx 使用 cert-manager 颁发的证书，可以将 cert 和 key 文件内容追加到同一个文件中(pem)，Nginx 配置证书和 key 都使用此文件。</p>
</li>
</ol>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://imroc.cc/k8s/trick/sign-free-certs-with-cert-manager/#cert-manager-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">cert-manager 工作原理</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://imroc.cc/k8s/trick/sign-free-certs-with-cert-manager/#%E5%85%8D%E8%B4%B9%E8%AF%81%E4%B9%A6%E7%AD%BE%E5%8F%91%E5%8E%9F%E7%90%86">免费证书签发原理</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://imroc.cc/k8s/trick/sign-free-certs-with-cert-manager/#dns-01-%E6%A0%A1%E9%AA%8C%E6%96%B9%E5%BC%8F%E7%AD%BE%E5%8F%91%E8%AF%81%E4%B9%A6">DNS-01 校验方式签发证书</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes 常用命令示例</title>
    <url>/202209131536/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos-7 3.10.0-1062.9.1</li>
<li>Docker 19.03.15</li>
<li>containerd.io-1.4.13</li>
<li>kubectl-1.25.0</li>
<li>kubeadm-1.25.0</li>
<li>kubelet-1.25.0</li>
</ul>
<h1 id="kubeadm-常用命令"><a href="#kubeadm-常用命令" class="headerlink" title="kubeadm 常用命令"></a>kubeadm 常用命令</h1><h2 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm init --pod-network-cidr=10.244.0.0/16 --cri-socket=unix:///var/run/cri-dockerd.sock</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>--pod-network-cidr</code></td>
<td>指定 pod 的 cidr</td>
<td></td>
</tr>
<tr>
<td><code>--cri-socket</code></td>
<td>配置集群使用的 CRI，不指定时系统会扫描主机，如果有多个可用 CRI，会出现提示</td>
<td></td>
</tr>
</tbody></table>
<h2 id="添加节点到集群"><a href="#添加节点到集群" class="headerlink" title="添加节点到集群"></a>添加节点到集群</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm join 172.31.10.19:6443 --token 8ca35s.butdpihinkdczvqb --discovery-token-ca-cert-hash sha256:b2793f9a6bea44a64640f99042f11c4ff6 \ </span><br><span class="line">        --cri-socket=unix:///var/run/cri-dockerd.sock</span><br></pre></td></tr></table></figure>
<p>其中的 <code>token</code> 可以在 master 上使用以下命令查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubeadm token list</span></span><br><span class="line">TOKEN                     TTL         EXPIRES                USAGES                   DESCRIPTION                                                EXTRA GROUPS</span><br><span class="line">8ca35s.butdpihinkdczvqb   19h         2022-09-14T02:54:55Z   authentication,signing   The default bootstrap token generated by &#x27;kubeadm init&#x27;.   system:bootstrappers:kubeadm:default-node-token</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>默认情况下，令牌会在 24 小时后过期。如果要在当前令牌过期后将节点加入集群， 则可以通过在控制平面节点上运行以下命令来创建新令牌：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm token create</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果你没有 <code>--discovery-token-ca-cert-hash</code> 的值，则可以通过在控制平面节点上执行以下命令链来获取它<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[使用 kubeadm 创建集群](https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#join-nodes)">[1]</span></a></sup>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | \</span><br><span class="line">   openssl dgst -sha256 -hex | sed &#x27;s/^.* //&#x27;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="kubectl-常用命令"><a href="#kubectl-常用命令" class="headerlink" title="kubectl 常用命令"></a>kubectl 常用命令</h1><p>kubectl 常用选项</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>-n, --namespace=&#39;&#39;</code></td>
<td>指定操作的 namespace</td>
<td></td>
</tr>
<tr>
<td><code>-A, --all-namespaces</code></td>
<td>列出所有的 namespace 中的资源</td>
<td></td>
</tr>
<tr>
<td><code>-o, --output=</code></td>
<td>输出格式，常用值包含：<br/>- <code>json</code><br/>- <code>yaml</code><br/>- <code>wide</code></td>
<td><a href="#%E6%9F%A5%E7%9C%8B-Pod-%E7%9A%84-yaml-%E6%8F%8F%E8%BF%B0%E6%96%87%E4%BB%B6">显示 Pod 详细信息</a></td>
</tr>
<tr>
<td><code>--show-labels</code></td>
<td>显示资源对象的标签</td>
<td><a href="#label">label</a></td>
</tr>
<tr>
<td><code>-l, --selector=&#39;&#39;</code></td>
<td>使用标签选择算符选择对象</td>
<td><a href="#%E4%BD%BF%E7%94%A8%E6%A0%87%E7%AD%BE%E9%80%89%E6%8B%A9%E5%99%A8%E5%88%97%E5%87%BA-Pod">使用标签选择器列出 Pod</a>    <br/>具体用法可以参考帮助信息 <code>kubectl get --help | grep &#39;\-l&#39;</code></td>
</tr>
</tbody></table>
<h2 id="node"><a href="#node" class="headerlink" title="node"></a>node</h2><h3 id="查看-node-信息"><a href="#查看-node-信息" class="headerlink" title="查看 node 信息"></a>查看 node 信息</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get nodes</span></span><br><span class="line">NAME              STATUS   ROLES           AGE     VERSION</span><br><span class="line">ops-kubernetes1   Ready    control-plane   5h31m   v1.25.0</span><br><span class="line">ops-kubernetes2   Ready    &lt;none&gt;          3h6m    v1.25.0</span><br><span class="line">ops-kubernetes3   Ready    &lt;none&gt;          179m    v1.25.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看指定节点的状态及其他详细信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl describe node &lt;节点名称&gt;</span><br></pre></td></tr></table></figure>

<h3 id="标记-node-为不可调度"><a href="#标记-node-为不可调度" class="headerlink" title="标记 node 为不可调度"></a>标记 node 为不可调度</h3><p>如果标记节点为不可调度（unschedulable），将阻止新 Pod 调度到该 Node 之上， 但不会影响任何已经在其上的 Pod。 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl cordon $NODENAME</span><br></pre></td></tr></table></figure>
<h2 id="检查集群控制组件的健康状态"><a href="#检查集群控制组件的健康状态" class="headerlink" title="检查集群控制组件的健康状态"></a>检查集群控制组件的健康状态</h2><p>API 服务器对外暴露了一个名为 <code>componentstatuses</code> 的 <a href="#%E6%9F%A5%E7%9C%8B%E9%9B%86%E7%BE%A4%E4%B8%AD%E5%8F%AF%E4%BD%BF%E7%94%A8%E7%9A%84%E8%B5%84%E6%BA%90%E9%A1%B9">API 资源</a>，用来显示每个控制平面组件的健康状态。可以通过以下命令列出各个控制平面组件的健康状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get componentstatuses</span></span><br><span class="line">Warning: v1 ComponentStatus is deprecated in v1.19+</span><br><span class="line">NAME                 STATUS    MESSAGE                         ERROR</span><br><span class="line">controller-manager   Healthy   ok                              </span><br><span class="line">scheduler            Healthy   ok                              </span><br><span class="line">etcd-0               Healthy   &#123;&quot;health&quot;:&quot;true&quot;,&quot;reason&quot;:&quot;&quot;&#125; </span><br></pre></td></tr></table></figure>

<h2 id="pod"><a href="#pod" class="headerlink" title="pod"></a>pod</h2><h3 id="列出所有-pod"><a href="#列出所有-pod" class="headerlink" title="列出所有 pod"></a>列出所有 pod</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods -A</span></span><br><span class="line">NAMESPACE      NAME                                      READY   STATUS              RESTARTS         AGE</span><br><span class="line">kube-flannel   kube-flannel-ds-7q2hp                     0/1     CrashLoopBackOff    52 (86s ago)     4h3m</span><br><span class="line">kube-flannel   kube-flannel-ds-k8wd6                     0/1     CrashLoopBackOff    47 (16s ago)     135m</span><br><span class="line">kube-flannel   kube-flannel-ds-x6ck2                     0/1     CrashLoopBackOff    29 (3m57s ago)   128m</span><br><span class="line">kube-system    coredns-565d847f94-b4sgn                  0/1     ContainerCreating   0                4h39m</span><br><span class="line">kube-system    coredns-565d847f94-ml6k5                  0/1     ContainerCreating   0                4h39m</span><br><span class="line">kube-system    etcd-ops-kubernetes1                      1/1     Running             0                4h39m</span><br><span class="line">kube-system    kube-apiserver-ops-kubernetes1            1/1     Running             0                4h39m</span><br><span class="line">kube-system    kube-controller-manager-ops-kubernetes1   1/1     Running             0                4h39m</span><br><span class="line">kube-system    kube-proxy-9vwxl                          1/1     Running             0                135m</span><br><span class="line">kube-system    kube-proxy-qxsc7                          1/1     Running             0                128m</span><br><span class="line">kube-system    kube-proxy-v5msf                          1/1     Running             0                4h39m</span><br><span class="line">kube-system    kube-scheduler-ops-kubernetes1            1/1     Running             0                4h39m</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="查看-Pod-的-yaml-描述文件"><a href="#查看-Pod-的-yaml-描述文件" class="headerlink" title="查看 Pod 的 yaml 描述文件"></a>查看 Pod 的 yaml 描述文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get pod -n testns test-pod-d6bd6996c-dcfgq -o yaml</span><br></pre></td></tr></table></figure>
<p>输出中也会包含 Pod 内部容器的详细状态</p>
<h3 id="使用-kubectl-重启-pod"><a href="#使用-kubectl-重启-pod" class="headerlink" title="使用 kubectl 重启 pod"></a>使用 kubectl 重启 pod</h3><p>以下命令重启 kubernetes-dashboard</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get pod kubernetes-dashboard -n kubernetes-dashboard -o yaml | kubectl replace --force -f -</span><br></pre></td></tr></table></figure>

<p>这条命令的意思是 <code>get</code> 当前运行的 pod 的 yaml 声明，并管道重定向输出到 <code>kubectl replace</code> 命令的标准输入，从而达到重启的目的。</p>
<h3 id="连接-Pod-中的容器"><a href="#连接-Pod-中的容器" class="headerlink" title="连接 Pod 中的容器"></a>连接 Pod 中的容器</h3><p><a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#exec">命令格式参考</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl <span class="built_in">exec</span> test-nginx-deployment-59d795fbf6-bjgcz -it -n default -- bash</span></span><br><span class="line">root@test-nginx-deployment-59d795fbf6-bjgcz:/#</span><br></pre></td></tr></table></figure>
<p>使用 root 用户登陆容器。分别使用以下命令查询 POD 所在的节点和 容器 ID</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods -n spinnaker -o wide</span></span><br><span class="line">NAME                                READY   STATUS    RESTARTS   AGE     IP            NODE        NOMINATED NODE   READINESS GATES</span><br><span class="line">spin-clouddriver-85d4985d4c-5rj4d   1/1     Running   0          6d20h   10.244.1.29   k8s-work1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl describe pod -n spinnaker spin-clouddriver-85d4985d4c-5rj4d</span></span><br><span class="line">...</span><br><span class="line">Containers:</span><br><span class="line">  clouddriver:</span><br><span class="line">    Container ID:   docker://010226eaa372bab53c30f82af6a5918ebc46f158ecc6e379ed44f9e2994ed432</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如上命令可以查到所在节点和容器 ID （<code>010226eaa372bab53c30f82af6a5918ebc46f158ecc6e379ed44f9e2994ed432</code>），登陆到对应节点，使用 <code>docker</code> 命令以 <code>root</code> 用户登陆容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it -u root 010226eaa372bab53c bash</span><br></pre></td></tr></table></figure>

<h3 id="实时监控-Pod-资源状态的变化"><a href="#实时监控-Pod-资源状态的变化" class="headerlink" title="实时监控 Pod 资源状态的变化"></a>实时监控 Pod 资源状态的变化</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods -n frtg --watch</span></span><br><span class="line">NAME                          READY   STATUS    RESTARTS   AGE</span><br><span class="line">frtg-admin-698bfc4998-8mccv   1/1     Running   0          13d</span><br><span class="line">frtg-api-748dc4bf87-dptbb     1/1     Running   0          43d</span><br><span class="line">frtg-api-748dc4bf87-xnsbr     1/1     Running   0          12d</span><br><span class="line">frtg-front-58796b88f7-k58sz   1/1     Running   0          13d</span><br><span class="line">frtg-search-d6bd6996c-dcfgq   1/1     Running   0          13d</span><br></pre></td></tr></table></figure>
<p>使用 <code>--watch</code> 选项可以实时监听资源的变化情况。其原理是通过 API Server 的通知客户端资源变更的能力实现。当资源请求变更，API Server 处理变更后，会像订阅了资源变更的客户端发送资源变更的通知。</p>
<h2 id="查看集群中可使用的资源项"><a href="#查看集群中可使用的资源项" class="headerlink" title="查看集群中可使用的资源项"></a>查看集群中可使用的资源项</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl api-resources</span></span><br><span class="line">NAME                              SHORTNAMES   APIVERSION                             NAMESPACED   KIND</span><br><span class="line">bindings                                       v1                                     true         Binding</span><br><span class="line">endpoints                         ep           v1                                     true         Endpoints</span><br><span class="line">events                            ev           v1                                     true         Event</span><br><span class="line">namespaces                        ns           v1                                     false        Namespace</span><br><span class="line">nodes                             no           v1                                     false        Node</span><br><span class="line">pods                              po           v1                                     true         Pod</span><br><span class="line">podtemplates                                   v1                                     true         PodTemplate</span><br><span class="line">secrets                                        v1                                     true         Secret</span><br><span class="line">serviceaccounts                   sa           v1                                     true         ServiceAccount</span><br><span class="line">services                          svc          v1                                     true         Service</span><br><span class="line">apiservices                                    apiregistration.k8s.io/v1              false        APIService</span><br><span class="line">controllerrevisions                            apps/v1                                true         ControllerRevision</span><br><span class="line">deployments                       deploy       apps/v1                                true         Deployment</span><br><span class="line">replicasets                       rs           apps/v1                                true         ReplicaSet</span><br><span class="line">jobs                                           batch/v1                               true         Job</span><br><span class="line">endpointslices                                 discovery.k8s.io/v1                    true         EndpointSlice</span><br><span class="line">events                            ev           events.k8s.io/v1                       true         Event</span><br><span class="line">ingresses                         ing          networking.k8s.io/v1                   true         Ingress</span><br><span class="line">networkpolicies                   netpol       networking.k8s.io/v1                   true         NetworkPolicy</span><br><span class="line">runtimeclasses                                 node.k8s.io/v1                         false        RuntimeClass</span><br><span class="line">clusterrolebindings                            rbac.authorization.k8s.io/v1           false        ClusterRoleBinding</span><br><span class="line">clusterroles                                   rbac.authorization.k8s.io/v1           false        ClusterRole</span><br><span class="line">rolebindings                                   rbac.authorization.k8s.io/v1           true         RoleBinding</span><br><span class="line">roles                                          rbac.authorization.k8s.io/v1           true         Role</span><br><span class="line">csidrivers                                     storage.k8s.io/v1                      false        CSIDriver</span><br><span class="line">csinodes                                       storage.k8s.io/v1                      false        CSINode</span><br><span class="line">storageclasses                    sc           storage.k8s.io/v1                      false        StorageClass</span><br><span class="line">volumeattachments                              storage.k8s.io/v1                      false        VolumeAttachment</span><br></pre></td></tr></table></figure>
<p>以下命令可以分别查看在 namespace 中的资源和不在 namespace 中的资源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">位于名字空间中的资源</span></span><br><span class="line">kubectl api-resources --namespaced=true</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不在名字空间中的资源</span></span><br><span class="line">kubectl api-resources --namespaced=false</span><br></pre></td></tr></table></figure>

<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>查看指定 namespace 中的指定 pod 的日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl logs kube-flannel-ds-7q2hp -n kube-flannel</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>默认将显示当前容器的日志，如果要看前一个已经被终止的容器的日志，可以使用选项 <code>--previous</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl logs -n spinnaker spin-clouddriver-cd5999f64-ktxkp --previous</span><br></pre></td></tr></table></figure>

<h2 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h2><h3 id="删除-namespace"><a href="#删除-namespace" class="headerlink" title="删除 namespace"></a>删除 namespace</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl delete ns kubernetes-dashboard</span><br></pre></td></tr></table></figure>

<h2 id="label"><a href="#label" class="headerlink" title="label"></a>label</h2><p>查看 Pod 的 lables</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get pod --show-labels</span><br></pre></td></tr></table></figure>
<p>查看 Pod 中指定的 lables 的值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get pod -L app,project -n agmjys</span><br></pre></td></tr></table></figure>

<h3 id="使用标签选择器列出-Pod"><a href="#使用标签选择器列出-Pod" class="headerlink" title="使用标签选择器列出 Pod"></a>使用标签选择器列出 Pod</h3><p><a href="https://csms.tech/202209241108/#标签和选择算符">标签选择器</a>允许我们选择标记有特定标签的资源对象的子集</p>
<p>以下示例，选择<strong>拥有标签</strong> <code>app</code> 的 Pod，不管其值为何。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pod -n <span class="built_in">test</span> -l app</span></span><br><span class="line">NAME                             READY   STATUS    RESTARTS   AGE</span><br><span class="line">testpod-admin-698bfc4998-8mccv   1/1     Running   0          8d</span><br><span class="line">testpod-api-748dc4bf87-dptbb     1/1     Running   0          38d</span><br><span class="line">testpod-api-748dc4bf87-xnsbr     1/1     Running   0          7d3h</span><br><span class="line">testpod-front-58796b88f7-k58sz   1/1     Running   0          8d</span><br><span class="line">testpod-search-d6bd6996c-dcfgq   1/1     Running   0          8d</span><br></pre></td></tr></table></figure>
<p>以下示例，选择<strong>没有标签</strong> <code>app</code> 的 Pod。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get pod -n test -l &#x27;!app&#x27;</span><br></pre></td></tr></table></figure>

<p>以下示例，选择<strong>符合标签和值</strong> <code>app=testpod-api</code> 的 Pod</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pod -n <span class="built_in">test</span> -l app=testpod-api</span></span><br><span class="line">NAME                           READY   STATUS    RESTARTS   AGE</span><br><span class="line">testpod-api-748dc4bf87-dptbb   1/1     Running   0          38d</span><br><span class="line">testpod-api-748dc4bf87-xnsbr   1/1     Running   0          7d3h</span><br></pre></td></tr></table></figure>

<p>以下示例，选择<strong>具体有标签 <code>app</code>，但是值不为 <code>testpod-api</code> 的 Pod</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pod -n <span class="built_in">test</span> -l app!=testpod-api</span></span><br><span class="line">NAME                             READY   STATUS    RESTARTS   AGE</span><br><span class="line">testpod-admin-698bfc4998-8mccv   1/1     Running   0          8d</span><br><span class="line">testpod-front-58796b88f7-k58sz   1/1     Running   0          8d</span><br><span class="line">testpod-search-d6bd6996c-dcfgq   1/1     Running   0          8d</span><br></pre></td></tr></table></figure>
<p>以下示例，列出<strong>拥有标签 <code>app</code>，且其值为 <code>testpod-api</code> 或者 <code>testpod-front</code> 的 Pod</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pod -n <span class="built_in">test</span> -l <span class="string">&#x27;app in (testpod-api,testpod-front)&#x27;</span></span></span><br><span class="line">NAME                             READY   STATUS    RESTARTS   AGE</span><br><span class="line">testpod-api-748dc4bf87-dptbb     1/1     Running   0          38d</span><br><span class="line">testpod-api-748dc4bf87-xnsbr     1/1     Running   0          7d3h</span><br><span class="line">testpod-front-58796b88f7-k58sz   1/1     Running   0          8d</span><br></pre></td></tr></table></figure>
<p>以下示例，列出<strong>拥有标签 <code>app</code>，且其值不为 <code>testpod-api</code> 或者 <code>testpod-front</code> 的 Pod</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pod -n <span class="built_in">test</span> -l <span class="string">&#x27;app notin (testpod-api,testpod-front)&#x27;</span></span> </span><br><span class="line">NAME                            READY   STATUS    RESTARTS   AGE</span><br><span class="line">testpod-admin-698bfc4998-8mccv  1/1     Running   0          8d</span><br><span class="line">testpod-search-d6bd6996c-dcfgq  1/1     Running   0          8d</span><br></pre></td></tr></table></figure>
<p>以下示例，列出<strong>同时拥有标签 <code>app=testpod-api</code> 和 <code>project=testpod</code> 的 Pod</strong>。使用逗号分割的多个条件时，必须满足所有匹配才算成功匹配到选择算符。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pod -n <span class="built_in">test</span> -l <span class="string">&#x27;app=testpod-api,project=testpod&#x27;</span></span></span><br><span class="line">NAME                          READY   STATUS    RESTARTS   AGE</span><br><span class="line">testpod-api-748dc4bf87-dptbb   1/1     Running   0          38d</span><br><span class="line">testpod-api-748dc4bf87-xnsbr   1/1     Running   0          7d3h</span><br></pre></td></tr></table></figure>
<h1 id="其他常见操作"><a href="#其他常见操作" class="headerlink" title="其他常见操作"></a>其他常见操作</h1><h2 id="获取节点上的-kube-proxy-代理模式"><a href="#获取节点上的-kube-proxy-代理模式" class="headerlink" title="获取节点上的 kube-proxy 代理模式"></a>获取节点上的 kube-proxy 代理模式</h2><p><code>kube-proxy</code> 负责 Service 到后端 Pod 的转发规则管理，默认使用 <code>iptables</code>，可选模式还包括 <code>IPVS</code> 和 <code>userspace</code> （性能太差，几乎不使用），要查看节点使用的 <code>kube-proxy</code> 模式，可以执行以下命令查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get nodes</span></span><br><span class="line">NAME                           STATUS     ROLES    AGE     VERSION</span><br><span class="line">kubernetes-node-6jst   Ready      &lt;none&gt;   2h      v1.13.0</span><br><span class="line">kubernetes-node-cx31   Ready      &lt;none&gt;   2h      v1.13.0</span><br><span class="line">kubernetes-node-jj1t   Ready      &lt;none&gt;   2h      v1.13.0</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>例如查看节点 <code>kubernetes-node-jj1t</code> 上的 <code>kube-proxy</code> 的模式，登陆到节点 <code>kubernetes-node-jj1t</code>，执行命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl http://localhost:10249/proxyMode</span></span><br><span class="line">iptables</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>kube-proxy</code> 监听在端口 <code>127.0.0.1:10249</code>，只能本机访问。</p>
</blockquote>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands"><code>kubectl</code> 命令参考</a></p>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#join-nodes">使用 kubeadm 创建集群</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes 常见错误总结</title>
    <url>/202209281614/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos7 5.4.212-1</li>
<li>Docker 20.10.18</li>
<li>containerd.io-1.6.8</li>
<li>kubectl-1.25.0</li>
<li>kubeadm-1.25.0</li>
<li>kubelet-1.25.0</li>
</ul>
<h1 id="POD-状态异常"><a href="#POD-状态异常" class="headerlink" title="POD 状态异常"></a>POD 状态异常</h1><h2 id="CrashLoopBackOff"><a href="#CrashLoopBackOff" class="headerlink" title="CrashLoopBackOff"></a>CrashLoopBackOff</h2><p><strong>错误场景</strong> ： </p>
<p><code>Pod</code> 状态显示 <code>CrashLoopBackOff</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods</span></span><br><span class="line">NAME                                     READY   STATUS             RESTARTS       AGE</span><br><span class="line">test-centos7-7cc5dc6987-jz486            0/1     CrashLoopBackOff   8 (111s ago)   17m</span><br></pre></td></tr></table></figure>
<p>查看 <code>Pod</code> 详细信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl describe pod test-centos7-7cc5dc6987-jz486</span></span><br><span class="line">...</span><br><span class="line">Events:</span><br><span class="line">  Type     Reason     Age                  From               Message</span><br><span class="line">  ----     ------     ----                 ----               -------</span><br><span class="line">  Normal   Scheduled  18m                  default-scheduler  Successfully assigned default/test-centos7-7cc5dc6987-jz486 to ops-kubernetes3</span><br><span class="line">  Normal   Pulled     16m (x5 over 18m)    kubelet            Container image &quot;centos:centos7.9.2009&quot; already present on machine</span><br><span class="line">  Normal   Created    16m (x5 over 18m)    kubelet            Created container centos7</span><br><span class="line">  Normal   Started    16m (x5 over 18m)    kubelet            Started container centos7</span><br><span class="line">  Warning  BackOff    3m3s (x71 over 18m)  kubelet            Back-off restarting failed container</span><br></pre></td></tr></table></figure>
<p>结果显示，<code>Reason</code> 为 <code>BackOff</code>，<code>Message</code> 显示 <code>Back-off restarting failed container</code></p>
<p><strong>可能原因</strong> ：</p>
<p><code>Back-off restarting failed container</code> 的原因，通常是因为，容器内 PID 为 1 的进程退出导致（通常用户在构建镜像执行 <code>CMD</code> 时，启动的程序，均是 PID 为1）<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Back-off restarting failed container 怎么办](https://cloud.tencent.com/developer/article/1931089)">[1]</span></a></sup></p>
<p>容器进程退出（命令执行结束或者进程异常结束），则容器生命周期结束。kubernetes 控制器检查到容器退出，会持续重启容器。针对此种情况，需要检查镜像，是否不存在常驻进程，或者常驻进程异常。</p>
<p>针对此种情况，可以单独使用 <code>docker</code> 客户端部署镜像，查看镜像的运行情况，如果部署后，容器中的进程立马结束或退出，则容器也会随之结束。</p>
<span id="more"></span>
<h2 id="POD-状态为-InvalidImageName"><a href="#POD-状态为-InvalidImageName" class="headerlink" title="POD 状态为 InvalidImageName"></a>POD 状态为 InvalidImageName</h2><p><strong>错误场景</strong> ： </p>
<p><code>Pod</code> 状态显示 <code>InvalidImageName</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get pods -n cs</span><br><span class="line">NAME               READY   STATUS              RESTARTS   AGE</span><br><span class="line">54fdc56754-qrlt6   0/2     InvalidImageName    0          14s</span><br><span class="line">8486f49b89-zp25b   0/2     Init:ErrImagePull   0          7s</span><br></pre></td></tr></table></figure>

<p><strong>可能原因</strong> ：</p>
<p>镜像的 url 地址中，以 <code>http://</code> 或 <code>https://</code> 开头。配置中镜像的 url 地址中无需指定协议（<code>http://</code> 或 <code>https://</code>） </p>
<h2 id="Pod-状态为-Error"><a href="#Pod-状态为-Error" class="headerlink" title="Pod 状态为 Error"></a>Pod 状态为 Error</h2><h3 id="The-node-was-low-on-resource-ephemeral-storage"><a href="#The-node-was-low-on-resource-ephemeral-storage" class="headerlink" title="The node was low on resource: ephemeral-storage"></a>The node was low on resource: ephemeral-storage</h3><p><strong>错误场景</strong>：</p>
<p>查看 Pod 状态，显示 Error</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods</span></span><br><span class="line">NAME                     READY   STATUS                   RESTARTS   AGE</span><br><span class="line">front-7df8ccc4c7-xhp6s    0/1     Error                    0          5h42m</span><br></pre></td></tr></table></figure>
<p>检查 Pod 的具体信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl describe pod front-7df8ccc4c7-xhp6s</span></span><br><span class="line">...</span><br><span class="line">Status:       Failed</span><br><span class="line">Reason:       Evicted</span><br><span class="line">Message:      The node was low on resource: ephemeral-storage. Container php was using 394, which exceeds its request of 0. </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>其中包含异常的关键信息：<code>Status:       Failed</code>，<code>Reason:       Evicted</code>，具体原因为 <code>The node was low on resource: ephemeral-storage</code></p>
<p>检查节点上的 Kuberlet 日志，搜索关键字 <code>evicte</code> 或者 <code>disk</code> ，也可以看到系统上文件系统空间使用率超过了阈值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">journalctl -u kubelet  | grep -i -e disk -e evict</span></span><br><span class="line"> image_gc_manager.go:310] &quot;Dis usage on image filesystem is over the high threshold, trying to free bytes down to the low threshold&quot; usage=85 highThreshold=85 amountToFree=5122092236 lowThreshold=80</span><br><span class="line"> eviction_manager.go:349] &quot;Eviction manager: must evict pod(s) to reclaim&quot; resourceName=&quot;ephemeral-storage&quot;</span><br><span class="line"> eviction_manager.go:338] &quot;Eviction manager: attempting to reclaim&quot; resourceName=&quot;ephemeral-storage&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>可能原因</strong> ：</p>
<p>根据以上信息，可知 Pod 异常是因为 <code>The node was low on resource: ephemeral-storage</code>，表示 <strong>临时存储资源</strong> 不足导致节点处于 <code>Tainted</code> ，其上的 Pod 被驱逐(<code>Evicted</code>)</p>
<p><strong><a href="https://kubernetes.io/zh-cn/docs/concepts/configuration/manage-resources-containers/#local-ephemeral-storage">本地临时存储说明</a></strong></p>
<p>针对此种情况，如果某 Pod 的临时存储用量超出了你所允许的范围，kubelet 会向其发出逐出（<code>eviction</code>）信号，触发该 Pod 被逐出所在节点。</p>
<p>如果用于可写入容器镜像层、节点层面日志或者 <code>emptyDir</code> 卷的文件系统中可用空间太少， 节点会为自身设置本地存储不足的污点(<code>Tainted</code>)标签。 这一污点会触发对那些无法容忍该污点的 Pod 的逐出操作。</p>
<p><strong>解决方法</strong> ：</p>
<ul>
<li><p>增加磁盘空间</p>
</li>
<li><p>调整 <code>kubelet</code> 的 <code>nodefs.available</code> 的 threshold 值</p>
<p>  修改节点上的 <code>kubelet</code> 的启动配置文件 <code>/usr/lib/systemd/system/kubelet.service.d/10-kubeadm.conf</code>，添加以下启动参数，主要为定义环境变量 <code>KUBELET_EVICT_NODEFS_THRESHOLD_ARGS</code>，并将其添加到启动参数中</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Environment=&quot;KUBELET_EVICT_NODEFS_THRESHOLD_ARGS=--eviction-hard=nodefs.available&lt;5%&quot;</span><br><span class="line">ExecStart=/usr/bin/kubelet $KUBELET_KUBECONFIG_ARGS $KUBELET_CONFIG_ARGS $KUBELET_KUBEADM_ARGS $KUBELET_EXTRA_ARGS $KUBELET_EVICT_NODEFS_THRESHOLD_ARGS</span><br></pre></td></tr></table></figure>
<p>  修改之后重启 <code>kubelet</code> 服务，并通过日志查看 <code>nodefs.available</code> 的新值是否生效</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ systemctl daemon-reload</span><br><span class="line">$ systemctl restart kubelet</span><br><span class="line"></span><br><span class="line">$ journalctl -u kubelet | grep -i nodefs</span><br><span class="line">17604 container_manager_linux.go:267] &quot;Creating Container Manager object based on Node Config&quot; nodeConfig=&#123;RuntimeCgroupsName: SystemCgroupsName: KubeletCgroupsName: KubeletOOMScoreAdj:-999 ContainerRuntime: CgroupsPerQOS:true CgroupRoot:/ CgroupDriver:systemd KubeletRootDir:/var/lib/kubelet ProtectKernelDefaults:false NodeAllocatableConfig:&#123;KubeReservedCgroupName: SystemReservedCgroupName: ReservedSystemCPUs: EnforceNodeAllocatable:map[pods:&#123;&#125;] KubeReserved:map[] SystemReserved:map[] HardEvictionThresholds:[&#123;Signal:nodefs.available Operator:LessThan Value:&#123;Quantity:&lt;nil&gt; Percentage:0.05&#125; GracePeriod:0s MinReclaim:&lt;nil&gt;&#125;]&#125; QOSReserved:map[] ExperimentalCPUManagerPolicy:none ExperimentalCPUManagerPolicyOptions:map[] ExperimentalTopologyManagerScope:container ExperimentalCPUManagerReconcilePeriod:10s ExperimentalMemoryManagerPolicy:None ExperimentalMemoryManagerReservedMemory:[] ExperimentalPodPidsLimit:-1 EnforceCPULimits:true CPUCFSQuotaPeriod:100ms ExperimentalTopologyManagerPolicy:none&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>日志中看到 <code>Signal:nodefs.available Operator:LessThan Value:&#123;Quantity:&lt;nil&gt; Percentage:0.05</code>，表明更改生效。<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[ephemeral-storage 问题](https://tonybai.com/2017/10/16/out-of-node-resource-handling-in-kubernetes-cluster/)">[2]</span></a></sup></p>
</li>
</ul>
<h2 id="Pod-状态为-Init"><a href="#Pod-状态为-Init" class="headerlink" title="Pod 状态为 Init"></a>Pod 状态为 Init</h2><h3 id="Unable-to-attach-or-mount-volumes"><a href="#Unable-to-attach-or-mount-volumes" class="headerlink" title="Unable to attach or mount volumes"></a>Unable to attach or mount volumes</h3><p>Pod 启动异常，查看 Pod 状态为 <code>Init:0/1</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods</span></span><br><span class="line">NAME                          READY   STATUS     RESTARTS   AGE</span><br><span class="line">admin-cbb479556-j9qg2    0/1     Init:0/1   0          3m37s</span><br></pre></td></tr></table></figure>
<p>查看 Pod 的详细描述信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl describe pod admin-cbb479556-j9qg2</span></span><br><span class="line">Events:</span><br><span class="line">  Type     Reason       Age    From               Message</span><br><span class="line">  ----     ------       ----   ----               -------</span><br><span class="line">  Normal   Scheduled    3m41s  default-scheduler  Successfully assigned admin-cbb479556-j9qg2 to k8s-work2</span><br><span class="line">  Warning  FailedMount  99s    kubelet            Unable to attach or mount volumes: unmounted volumes=[logs], unattached volumes=[wwwroot kube-api-access-z8745 logs]: timed out waiting for the condition</span><br><span class="line">  Warning  FailedMount  42s    kubelet            MountVolume.SetUp failed for volume &quot;uat-nfs-pv&quot; : mount failed: exit status 32</span><br><span class="line">Mounting command: mount</span><br><span class="line">Mounting arguments: -t nfs 34.230.1.1:/data/NFSDataHome /var/lib/kubelet/pods/9d9a4807-706c-4369-b8be-b5727ee6aa8f/volumes/kubernetes.io~nfs/uat-nfs-pv</span><br><span class="line">Output: mount.nfs: Connection timed out</span><br></pre></td></tr></table></figure>

<p>根据 <code>Events</code> 中输出的信息，<code>MountVolume.SetUp failed for volume &quot;uat-nfs-pv&quot; : mount failed: exit status 32</code>，显示挂载卷失败，输出中包含了挂载卷时使用的命令和参数（<code>mount -t nfs 34.230.1.1:/data/NFSDataHome /var/lib/kubelet/pods/9d9a4807-706c-4369-b8be-b5727ee6aa8f/volumes/kubernetes.io~nfs/uat-nfs-pv</code>）及命令失败后的返回结果（<code>mount.nfs: Connection timed out</code>）</p>
<p>根据 <code>Events</code> 中的信息，查看配置，发现此卷为 NFS 类型的 PV，根据报错排查，此例原因为 NFS 的服务器地址填写错误，更新 PV 配置中的 NFS Server 的地址后，Pod 正常启动。</p>
<h1 id="网络问题"><a href="#网络问题" class="headerlink" title="网络问题"></a>网络问题</h1><h2 id="同一个节点上的-Pod-之间网络不通"><a href="#同一个节点上的-Pod-之间网络不通" class="headerlink" title="同一个节点上的 Pod 之间网络不通"></a>同一个节点上的 Pod 之间网络不通</h2><p><strong>问题现象</strong>：</p>
<p>同一个节点上的 <code>Pod</code> 之间网络不通</p>
<p><strong>排查思路</strong>：</p>
<ul>
<li>检查系统内核配置是否开启转发 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sysctl -a | grep net.ipv4.ip_forward</span></span><br><span class="line">net.ipv4.ip_forward = 1</span><br></pre></td></tr></table></figure></li>
<li>检查 <code>iptables</code> 是否禁止转发，<a href="https://csms.tech/202209121102/#集群中所有计算机之间具有完全的网络连接"><code>iptables</code> 防火墙配置参考</a></li>
<li>为了定位是否为 <code>iptables</code> 影响，开关闭 <code>iptables</code> 再进行测试，如果关闭防火墙后可以通信，可以确定是防火墙规则导致，需要检查防火墙规则。</li>
<li>更深入的排查，可以部署 <a href="https://hub.docker.com/r/antrea/netshoot/tags"><code>netshoot</code> 容器</a> 进行抓包定位，</li>
</ul>
<h2 id="Pod-无法访问到外部-Internet-网络"><a href="#Pod-无法访问到外部-Internet-网络" class="headerlink" title="Pod 无法访问到外部 Internet 网络"></a>Pod 无法访问到外部 Internet 网络</h2><p>某个节点上，Pod 无法外部主机的服务（端口 6603&#x2F;tcp）。分别在 Pod ，节点 <code>cni0</code> 网卡，节点出口网卡 <code>eth0</code> ，目标服务网卡上抓包。此例中 Pod IP 为 <code>10.244.4.173</code>，目标服务的 IP 地址为 <code>50.18.6.225</code></p>
<p>查看 Pod 抓包结果</p>
<p><img src="https://i.csms.tech/img_102.png"></p>
<p>可以看到源 IP 为 Pod 地址，目标为服务 IP 的 <code>6603/tcp</code> 的请求发送后，未收到 TCP 连接建立的响应。查看 节点 <code>cni0</code> 网卡 的抓包</p>
<p><img src="https://i.csms.tech/img_103.png"></p>
<p>可以看到源 IP 为 Pod 地址，目标为服务 IP 的 <code>6603/tcp</code> 的请求发送后，未收到 TCP 连接建立的响应。查看节点出口网卡 <code>eth0</code> 的抓包。</p>
<p><img src="https://i.csms.tech/img_104.png"></p>
<p><strong>此处看到的源 IP 依然是  Pod 的 IP 地址，此处存在问题</strong>。在云主机的场景中，如果数据包以这种结构发送出去，数据包到了 Internet 网关将拒绝它，因为网关 NAT（将 VM 的 IP 转换为公网 IP） 只了解连接到 VM 的 IP 地址。</p>
<p>正常情况下，Pod 的流量到节点的出口网卡之前，是应该经过 <code>iptables</code> 执行源 NAT - <strong>更改数据包源，使数据包看起来来自 VM 而不是 Pod</strong>。有了正确的源 IP，数据包才可以离开 VM 进入 Internet</p>
<p>此种情况下，数据包可以从节点的出口网卡发送出去，但是到了 Internet 网关将会被丢弃，因此目标服务无法接收到请求，查看目标服务器上的抓包，确实未收到来自此 Pod 的请求。</p>
<p>此处的 <strong>源 NAT</strong> 是由 <code>iptables</code>  负责执行，流入节点出口网卡的数据包未被正确的 <strong>源 NAT</strong>，有可能是因为 <code>kube-proxy</code> 维护的网络规则错误，或者因为 <code>iptables</code> 规则配置错误。可以通过重启 <code>kube-proxy</code> （由服务 <code>kubelet</code> 管理）和 <code>iptables</code> 服务尝试恢复。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart kubelet</span><br><span class="line">systemctl restart iptables</span><br></pre></td></tr></table></figure>
<p>本示例中，重启这 2 个服务后，Pod 恢复正常。</p>
<h2 id="Pod-间歇性无法连接外部数据库"><a href="#Pod-间歇性无法连接外部数据库" class="headerlink" title="Pod 间歇性无法连接外部数据库"></a>Pod 间歇性无法连接外部数据库</h2><p>集群中的 Pod 出现连接集群之外的数据库服务超时，且出现频率较高</p>
<p><a href="https://blog.csdn.net/qq_42684642/article/details/105775436">参考文章</a></p>
<h2 id="跨节点-Pod-无法访问"><a href="#跨节点-Pod-无法访问" class="headerlink" title="跨节点 Pod 无法访问"></a>跨节点 Pod 无法访问</h2><h3 id="环境信息-1"><a href="#环境信息-1" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Centos 7 5.4.242-1</li>
<li>Kubernetes v1.25.4</li>
<li>kubernetes-cni-1.2.0-0</li>
<li>flannel v0.21.4</li>
</ul>
<p>集群中有 1 个 master 节点， 2 个 work 节点，节点状态均正常，master 无法 ping worker1 上面的 Pod，可以 ping 通 worker2 节点上面的 Pod</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get nodes -A -o wide</span></span><br><span class="line">NAME          STATUS   ROLES           AGE   VERSION   INTERNAL-IP      EXTERNAL-IP   OS-IMAGE                KERNEL-VERSION                CONTAINER-RUNTIME</span><br><span class="line">k8s-master1   Ready    control-plane   23h   v1.25.4   192.168.142.10   &lt;none&gt;        CentOS Linux 7 (Core)   5.4.242-1.el7.elrepo.x86_64   docker://20.10.9</span><br><span class="line">k8s-worker1   Ready    &lt;none&gt;          23h   v1.25.4   192.168.142.11   &lt;none&gt;        CentOS Linux 7 (Core)   5.4.242-1.el7.elrepo.x86_64   docker://20.10.9</span><br><span class="line">k8s-worker2   Ready    &lt;none&gt;          22h   v1.25.4   192.168.142.12   &lt;none&gt;        CentOS Linux 7 (Core)   5.4.242-1.el7.elrepo.x86_64   docker://20.10.9</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods -A -o wide</span></span><br><span class="line">NAMESPACE      NAME                                  READY   STATUS    RESTARTS        AGE   IP               NODE          NOMINATED NODE   READINESS GATES</span><br><span class="line">default        tet-deployment-fbc96cc5d-hlqkg        1/1     Running   1 (4m17s ago)   28m   10.244.1.4       k8s-worker1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        tet-deployment-fbc96cc5d-mcjzg        1/1     Running   0               50m   10.244.2.3       k8s-worker2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ping 10.244.1.4</span></span><br><span class="line">PING 10.244.1.4 (10.244.1.4) 56(84) bytes of data.</span><br><span class="line">^C</span><br><span class="line">--- 10.244.1.4 ping statistics ---</span><br><span class="line">2 packets transmitted, 0 received, 100% packet loss, time 1001ms</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ping 10.244.2.3</span></span><br><span class="line">PING 10.244.2.3 (10.244.2.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.244.2.3: icmp_seq=1 ttl=63 time=4.27 ms</span><br><span class="line">64 bytes from 10.244.2.3: icmp_seq=2 ttl=63 time=0.468 ms</span><br><span class="line">64 bytes from 10.244.2.3: icmp_seq=3 ttl=63 time=0.443 ms</span><br><span class="line">^C</span><br><span class="line">--- 10.244.2.3 ping statistics ---</span><br><span class="line">3 packets transmitted, 3 received, 0% packet loss, time 2056ms</span><br><span class="line">rtt min/avg/max/mdev = 0.443/1.729/4.277/1.801 ms</span><br></pre></td></tr></table></figure>
<p>由此可判断问题大概率出现在 worker1 节点，首先检查 worker1 节点上的 <code>flannel</code> 容器是否正常</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods -A -o wide</span></span><br><span class="line">NAMESPACE      NAME                                  READY   STATUS    RESTARTS      AGE    IP               NODE          NOMINATED NODE   READINESS GATES</span><br><span class="line">default        tet-deployment-fbc96cc5d-hlqkg        1/1     Running   0             9m8s   10.244.1.4       k8s-worker1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        tet-deployment-fbc96cc5d-mcjzg        1/1     Running   0             31m    10.244.2.3       k8s-worker2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-flannel   kube-flannel-ds-d42lm                 1/1     Running   0             22h    192.168.142.11   k8s-worker1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-flannel   kube-flannel-ds-lqp5v                 1/1     Running   0             22h    192.168.142.10   k8s-master1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-flannel   kube-flannel-ds-w675f                 1/1     Running   0             70m    192.168.142.12   k8s-worker2   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>
<p>看到 worker1 节点上的 flannel 容器运行正常。在 worker1 节点上检查 <code>flannel</code> 进程及端口信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">netstat -anutp</span></span><br><span class="line">Active Internet connections (servers and established)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 127.0.0.1:10248         0.0.0.0:*               LISTEN      1817/kubelet        </span><br><span class="line">tcp        0      0 127.0.0.1:10249         0.0.0.0:*               LISTEN      2224/kube-proxy     </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1039/sshd           </span><br><span class="line">tcp        0      0 192.168.142.11:47468    192.168.142.10:6443     ESTABLISHED 2224/kube-proxy     </span><br><span class="line">tcp        0      0 192.168.142.11:56584    192.168.142.10:6443     ESTABLISHED 1817/kubelet        </span><br><span class="line">tcp        0     44 192.168.142.11:22       192.168.142.1:62099     ESTABLISHED 1108/sshd: root@pts </span><br><span class="line">tcp        0      0 192.168.142.11:40574    10.96.0.1:443           ESTABLISHED 2566/flanneld       </span><br><span class="line">tcp6       0      0 :::34939                :::*                    LISTEN      1433/cri-dockerd    </span><br><span class="line">tcp6       0      0 :::10250                :::*                    LISTEN      1817/kubelet        </span><br><span class="line">tcp6       0      0 :::10256                :::*                    LISTEN      2224/kube-proxy     </span><br><span class="line">tcp6       0      0 :::22                   :::*                    LISTEN      1039/sshd</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps -elf | grep flannel</span></span><br><span class="line">4 S root       2566   2539  0  80   0 - 353654 futex_ 14:44 ?       00:00:02 /opt/bin/flanneld --ip-masq --kube-subnet-mgr</span><br></pre></td></tr></table></figure>
<p>检查发现 <code>flanneld</code> 进程存在，但是端口未启动，检查 <code>flannel</code> 容器日志输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker ps -a | grep flannel | grep -v <span class="string">&quot;Exited&quot;</span></span></span><br><span class="line">92fab879c75b   11ae74319a21                 &quot;/opt/bin/flanneld -…&quot;   34 minutes ago      Up 34 minutes                           k8s_kube-flannel_kube-flannel-ds-77bwd_kube-flannel_078dde8c-573b-4db4-939e-d3dd353477f7_1</span><br><span class="line">237a82c1378a   registry.k8s.io/pause:3.6    &quot;/pause&quot;                 34 minutes ago      Up 34 minutes                           k8s_POD_kube-flannel-ds-77bwd_kube-flannel_078dde8c-573b-4db4-939e-d3dd353477f7_1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker logs 92fab879c75b</span></span><br><span class="line">failed to add vxlanRoute</span><br><span class="line"></span><br><span class="line">network is down</span><br></pre></td></tr></table></figure>
<p>关键错误信息 <code>failed to add vxlanRoute</code>, <code>network is down</code>，<a href="https://github.com/flannel-io/flannel/issues/844">参考案例</a>，重启服务器。恢复正常。</p>
<h2 id="coredns-无法解析域名"><a href="#coredns-无法解析域名" class="headerlink" title="coredns 无法解析域名"></a>coredns 无法解析域名</h2><p>Pod 中无法解析域名。</p>
<p>集群相关信息如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get svc -A</span></span><br><span class="line">NAMESPACE     NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)                  AGE</span><br><span class="line">default       kubernetes   ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP                  25h</span><br><span class="line">kube-system   kube-dns     ClusterIP   10.96.0.10   &lt;none&gt;        53/UDP,53/TCP,9153/TCP   25h</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在容器中测试 dns 相关信息，访问外部 IP 和 Kubernetes API Server 的 Service 地址均正常</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ping 8.8.8.8</span></span><br><span class="line">PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data.</span><br><span class="line">64 bytes from 8.8.8.8: icmp_seq=1 ttl=127 time=37.2 ms</span><br><span class="line">64 bytes from 8.8.8.8: icmp_seq=2 ttl=127 time=36.9 ms</span><br><span class="line">^C</span><br><span class="line">--- 8.8.8.8 ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 1001ms</span><br><span class="line">rtt min/avg/max/mdev = 36.946/37.085/37.224/0.139 ms</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -v 10.96.0.1:443</span></span><br><span class="line">* About to connect() to 10.96.0.1 port 443 (#0)</span><br><span class="line">*   Trying 10.96.0.1...</span><br><span class="line">* Connected to 10.96.0.1 (10.96.0.1) port 443 (#0)</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">GET / HTTP/1.1</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">User-Agent: curl/7.29.0</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Host: 10.96.0.1:443</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Accept: */*</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">* HTTP 1.0, assume close after body</span></span><br><span class="line">&lt; HTTP/1.0 400 Bad Request</span><br><span class="line">&lt; </span><br><span class="line">Client sent an HTTP request to an HTTPS server.</span><br><span class="line">* Closing connection 0</span><br></pre></td></tr></table></figure>
<p>容器中的 dns 配置为 <code>kube-dns</code> 的 Service 的 IP，测试其端口，显示 <code>Connection refused</code>。测试解析集群内部域名，结果无法解析。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /etc/resolv.conf</span> </span><br><span class="line">nameserver 10.96.0.10</span><br><span class="line">search default.svc.cluster.local svc.cluster.local cluster.local</span><br><span class="line">options ndots:5</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl 10.96.0.10:53</span></span><br><span class="line">curl: (7) Failed connect to 10.96.0.10:53; Connection refused</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ping svc.cluster.local</span></span><br><span class="line">ping: svc.cluster.local: Name or service not known</span><br></pre></td></tr></table></figure>
<p>通过以上步骤，大概可以确定，Pod 的网络正常，应该是 <code>kube-dns</code> 出问题，导致 Pod 无法解析域名。</p>
<p>Service 是通过 Endpoint 和后端的具体的 Pod 关联起来向外提供服务，首先检查 <code>kube-dns</code> 的 Service 对应的 Endpoint，看是否正常。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get ep -A</span></span><br><span class="line">NAMESPACE     NAME         ENDPOINTS             AGE</span><br><span class="line">default       kubernetes   192.168.142.10:6443   25h</span><br><span class="line">kube-system   kube-dns                           25h</span><br></pre></td></tr></table></figure>
<p>检查发现，<code>kube-dns</code> 对应的 ENDPOINTS 列表为空。删除 <code>coredns</code> 容器，重新创建。再次检查后，发现 <code>kube-dns</code> 的 Service 对应的 Endpoint 恢复正常。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl delete pod -n kube-system coredns-565d847f94-bzr62 coredns-565d847f94-vmddh</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods -A</span></span><br><span class="line">NAMESPACE      NAME                                  READY   STATUS    RESTARTS       AGE</span><br><span class="line">default        tet-deployment-fbc96cc5d-hlqkg        1/1     Running   1 (115m ago)   139m</span><br><span class="line">default        tet-deployment-fbc96cc5d-mcjzg        1/1     Running   0              162m</span><br><span class="line">kube-flannel   kube-flannel-ds-77bwd                 1/1     Running   1 (115m ago)   129m</span><br><span class="line">kube-flannel   kube-flannel-ds-lqp5v                 1/1     Running   0              25h</span><br><span class="line">kube-flannel   kube-flannel-ds-w675f                 1/1     Running   0              3h21m</span><br><span class="line">kube-system    coredns-565d847f94-8wmg7              1/1     Running   0              9s</span><br><span class="line">kube-system    coredns-565d847f94-csc9f              0/1     Running   0              9s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get ep -A</span></span><br><span class="line">NAMESPACE     NAME         ENDPOINTS                                     AGE</span><br><span class="line">default       kubernetes   192.168.142.10:6443                           25h</span><br><span class="line">kube-system   kube-dns     10.244.1.7:53,10.244.1.7:53,10.244.1.7:9153   25h</span><br></pre></td></tr></table></figure>

<p>在 Pod 中重新测试解析，结果正常</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -v 10.96.0.10:53</span></span><br><span class="line">* About to connect() to 10.96.0.10 port 53 (#0)</span><br><span class="line">*   Trying 10.96.0.10...</span><br><span class="line">* Connected to 10.96.0.10 (10.96.0.10) port 53 (#0)</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">GET / HTTP/1.1</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">User-Agent: curl/7.29.0</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Host: 10.96.0.10:53</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Accept: */*</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">* Empty reply from server</span></span><br><span class="line">* Connection #0 to host 10.96.0.10 left intact</span><br><span class="line">curl: (52) Empty reply from server</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ping qq.com</span></span><br><span class="line">PING qq.com (61.129.7.47) 56(84) bytes of data.</span><br><span class="line">64 bytes from 61.129.7.47 (61.129.7.47): icmp_seq=1 ttl=127 time=308 ms</span><br><span class="line">64 bytes from 61.129.7.47 (61.129.7.47): icmp_seq=2 ttl=127 time=312 ms</span><br><span class="line">64 bytes from 61.129.7.47 (61.129.7.47): icmp_seq=3 ttl=127 time=312 ms</span><br><span class="line">^C</span><br><span class="line">--- qq.com ping statistics ---</span><br><span class="line">3 packets transmitted, 3 received, 0% packet loss, time 2001ms</span><br><span class="line">rtt min/avg/max/mdev = 308.493/310.873/312.106/1.743 ms</span><br></pre></td></tr></table></figure>

<h3 id="dns-文件定位参考文档"><a href="#dns-文件定位参考文档" class="headerlink" title="dns 文件定位参考文档"></a>dns 文件定位参考文档</h3><p><a href="https://www.gylinux.cn/4299.html">故障排查：Kubernetes 中 Pod 无法正常解析域名</a></p>
<h1 id="集群状态异常"><a href="#集群状态异常" class="headerlink" title="集群状态异常"></a>集群状态异常</h1><h2 id="节点状态-NotReady"><a href="#节点状态-NotReady" class="headerlink" title="节点状态 NotReady"></a>节点状态 NotReady</h2><h3 id="PLEG-is-not-healthy-pleg-was-last-seen-active-10m13-755045415s-ago"><a href="#PLEG-is-not-healthy-pleg-was-last-seen-active-10m13-755045415s-ago" class="headerlink" title="PLEG is not healthy: pleg was last seen active 10m13.755045415s ago"></a>PLEG is not healthy: pleg was last seen active 10m13.755045415s ago</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get nodes</span></span><br><span class="line">NAME          STATUS     ROLES           AGE   VERSION</span><br><span class="line">k8s-master1   Ready      control-plane   14d   v1.24.7</span><br><span class="line">k8s-master2   Ready      control-plane   14d   v1.24.7</span><br><span class="line">k8s-master3   Ready      control-plane   14d   v1.24.7</span><br><span class="line">k8s-work1     NotReady   &lt;none&gt;          14d   v1.24.7</span><br><span class="line">k8s-work2     Ready      &lt;none&gt;          14d   v1.24.7</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看节点详细信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl describe node k8s-work1</span></span><br><span class="line">...</span><br><span class="line">Conditions:</span><br><span class="line">  Ready                False   Tue, 15 Nov 2022 10:14:49 +0800   Tue, 15 Nov 2022 10:07:39 +0800   KubeletNotReady              PLEG is not healthy: pleg was last seen active 10m13.755045415s ago; threshold is 3m0s</span><br></pre></td></tr></table></figure>

<h4 id="异常原因"><a href="#异常原因" class="headerlink" title="异常原因"></a>异常原因</h4><p>集群因为此原因（<code>PLEG is not healthy: pleg was last seen active ***h**m***s ago;</code>）状态变为 <code>NotReady</code>，通常是因为节点超负载。</p>
<h3 id="container-runtime-is-down-container-runtime-not-ready"><a href="#container-runtime-is-down-container-runtime-not-ready" class="headerlink" title="container runtime is down, container runtime not ready"></a>container runtime is down, container runtime not ready</h3><p><strong>排查过程</strong>：</p>
<p>检查集群中的 Pod 分布情况时，发现某一节点上几乎所有的 Pod 都被调度去了其他节点，当前检查时此节点的状态已经是 <code>Ready</code>，针对此情况进行分析。</p>
<ol>
<li><p>确定问题发生的大概时间段</p>
<p> 根据 Pod 在其他节点上面被启动的时间，可以大概确定节点异常的时间，根据此时间段可以缩小排查的时间范围。此示例中问题发生的时间大概在 <code>Nov 25 04:49:00</code> 前后。</p>
</li>
<li><p>检查 <code>kubelet</code> 日志</p>
<p> 根据已经推断出的时间段，在 <strong>问题节点</strong> 上，检查 <code>kubelet</code> 日志</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ journalctl -u kubelet --since &quot;2022-11-25 4:40&quot; | grep -v -e &quot;failed to get fsstats&quot; -e &quot;invalid bearer token&quot; | more</span><br><span class="line">Nov 25 04:49:00 k8s-work2 kubelet[17604]: E1125 04:49:00.153132   17604 generic.go:205] &quot;GenericPLEG: Unable to retrieve pods&quot; err=&quot;rpc error: code = Unknown desc = operation timeout: context deadline exceeded&quot;</span><br><span class="line">Nov 25 04:49:00 k8s-work2 kubelet[17604]: E1125 04:49:00.375524   17604 remote_runtime.go:356] &quot;ListPodSandbox with filter from runtime service failed&quot; err=&quot;rpc error: code = Unknown desc = operation timeout: context deadline exceeded&quot; filter=&quot;&amp;PodSandboxFilter&#123;Id:,State:&amp;PodSandboxStateValue&#123;State:SANDBOX_READY,&#125;,LabelSelector:map[string]string&#123;&#125;,&#125;&quot;</span><br><span class="line">Nov 25 04:49:00 k8s-work2 kubelet[17604]: E1125 04:49:00.375559   17604 kuberuntime_sandbox.go:292] &quot;Failed to list pod sandboxes&quot; err=&quot;rpc error: code = Unknown desc = operation timeout: context deadline exceeded&quot;</span><br><span class="line">Nov 25 04:49:00 k8s-work2 kubelet[17604]: E1125 04:49:00.375578   17604 kubelet_pods.go:1153] &quot;Error listing containers&quot; err=&quot;rpc error: code = Unknown desc = operation timeout: context deadline exceeded&quot;</span><br><span class="line">Nov 25 04:49:00 k8s-work2 kubelet[17604]: E1125 04:49:00.375589   17604 kubelet.go:2162] &quot;Failed cleaning pods&quot; err=&quot;rpc error: code = Unknown desc = operation timeout: context deadline exceeded&quot;</span><br><span class="line">Nov 25 04:49:00 k8s-work2 kubelet[17604]: E1125 04:49:00.375603   17604 kubelet.go:2166] &quot;Housekeeping took longer than 15s&quot; err=&quot;housekeeping took too long&quot; seconds=119.005290203</span><br><span class="line">Nov 25 04:49:00 k8s-work2 kubelet[17604]: E1125 04:49:00.476011   17604 kubelet.go:2010] &quot;Skipping pod synchronization&quot; err=&quot;container runtime is down&quot;</span><br><span class="line">Nov 25 04:49:00 k8s-work2 kubelet[17604]: E1125 04:49:00.507861   17604 remote_runtime.go:680] &quot;ExecSync cmd from runtime service failed&quot; err=&quot;rpc error: code = Unknown desc = operation timeout: context deadline exceeded&quot; containerID=&quot;5cd867ce2a52311e79a20a113c7cedd2a233b3a52b556065b479f2dd11a14eac&quot; cmd=[wget --no-check-certificate --spider -q http://localhost:8088/health]</span><br><span class="line">Nov 25 04:49:00 k8s-work2 kubelet[17604]: E1125 04:49:00.676271   17604 kubelet.go:2010] &quot;Skipping pod synchronization&quot; err=&quot;container runtime is down&quot;</span><br><span class="line"></span><br><span class="line">Nov 25 04:49:01 k8s-work2 kubelet[17604]: E1125 04:49:01.076918   17604 kubelet.go:2010] &quot;Skipping pod synchronization&quot; err=&quot;container runtime is down&quot;</span><br><span class="line">Nov 25 04:49:01 k8s-work2 kubelet[17604]: E1125 04:49:01.178942   17604 kubelet.go:2359] &quot;Container runtime not ready&quot; runtimeReady=&quot;RuntimeReady=false reason:DockerDaemonNotReady message:docker: failed to get docker version: operation timeout: context deadline exceeded&quot;</span><br><span class="line">Nov 25 04:49:01 k8s-work2 kubelet[17604]: E1125 04:49:01.878007   17604 kubelet.go:2010] &quot;Skipping pod synchronization&quot; err=&quot;[container runtime is down, container runtime not ready: RuntimeReady=false reason:DockerDaemonNotReady message:docker: failed to get docker version: operation timeout: context deadline exceeded]&quot;</span><br><span class="line">Nov 25 04:49:03 k8s-work2 kubelet[17604]: E1125 04:49:03.329558   17604 remote_runtime.go:536] &quot;ListContainers with filter from runtime service failed&quot; err=&quot;rpc error: code = Unknown desc = operation timeout: context deadline exceeded&quot; filter=&quot;&amp;ContainerFilter&#123;Id:,State:nil,PodSandboxId:,LabelSelector:map[string]string&#123;&#125;,&#125;&quot;</span><br><span class="line">Nov 25 04:49:03 k8s-work2 kubelet[17604]: E1125 04:49:03.329585   17604 container_log_manager.go:183] &quot;Failed to rotate container logs&quot; err=&quot;failed to list containers: rpc error: code = Unknown desc = operation timeout: context deadline exceeded&quot;</span><br><span class="line"></span><br><span class="line">Nov 25 04:49:09 k8s-work2 kubelet[17604]: E1125 04:49:09.485356   17604 remote_runtime.go:168] &quot;Version from runtime service failed&quot; err=&quot;rpc error: code = Unknown desc = failed to get docker version: operation timeout: context deadline exceeded&quot;</span><br><span class="line">Nov 25 04:49:09 k8s-work2 kubelet[17604]: I1125 04:49:09.485486   17604 setters.go:532] &quot;Node became not ready&quot; node=&quot;k8s-work2&quot; condition=&#123;Type:Ready Status:False LastHeartbeatTime:2022-11-25 04:49:09.485445614 +0800 CST m=+227600.229789769 LastTransitionTime:2022-11-25 04:49:09.485445614 +0800 CST m=+227600.229789769 Reason:KubeletNotReady Message:[container runtime is down, container runtime not ready: RuntimeReady=false reason:DockerDaemonNotReady message:docker: failed to get docker version: operation timeout: context deadline exceeded]&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p> 从以上日志中，可以看到关键的日志信息：</p>
<p> <code>&quot;Skipping pod synchronization&quot; err=&quot;container runtime is down&quot;</code></p>
<p> <code>setters.go:532] &quot;Node became not ready&quot;</code>，    <code>Reason:KubeletNotReady Message:[container runtime is down, container runtime not ready: RuntimeReady=false reason:DockerDaemonNotReady message:docker: failed to get docker version: operation timeout: context deadline exceeded]&#125;</code></p>
<p> 从以上日志信息可以看出，节点状态变为了 <code>not ready</code>，原因为 <code>container runtime is down, container runtime not ready</code>，本示例中 <code>container runtime</code> 为 <code>docker</code></p>
</li>
<li><p>检查 docker 服务日志</p>
<p> 根据上面的日志时间，检查 docker 服务的日志</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">journalctl -u docker --since &quot;2022-11-25 04:0&quot; | more</span><br><span class="line">Nov 25 04:49:06 k8s-work2 dockerd[15611]: http: superfluous response.WriteHeader call from github.com/docker/docker/api/server/httputils.WriteJSON (httputils_write_json.go:11)</span><br><span class="line">Nov 25 04:49:06 k8s-work2 dockerd[15611]: time=&quot;2022-11-25T04:49:06.410127201+08:00&quot; level=error msg=&quot;Handler for GET /v1.40/containers/5cd867ce2a52311e79a20a113c7cedd2a233b3a52b556065b479f2dd11a14eac/json returned error: write unix /var/run/docker.sock-&gt;@: write: broken pipe&quot;</span><br><span class="line">Nov 25 04:49:06 k8s-work2 dockerd[15611]: time=&quot;2022-11-25T04:49:06.410342223+08:00&quot; level=error msg=&quot;Handler for GET /v1.40/containers/41e0dfe97b87c2b8ae941653fa8adbf93bf9358d91e967646e4549ab71b2f004/json returned error: write unix /var/run/docker.sock-&gt;@: write: broken pipe&quot;</span><br><span class="line">Nov 25 04:49:06 k8s-work2 dockerd[15611]: http: superfluous response.WriteHeader call from github.com/docker/docker/api/server/httputils.WriteJSON (httputils_write_json.go:11)</span><br><span class="line">Nov 25 04:49:06 k8s-work2 dockerd[15611]: time=&quot;2022-11-25T04:49:06.414773158+08:00&quot; level=error msg=&quot;Handler for GET /v1.40/containers/json returned error: write unix /var/run/docker.sock-&gt;@: write: broken pipe&quot;</span><br><span class="line">Nov 25 04:49:06 k8s-work2 dockerd[15611]: http: superfluous response.WriteHeader call from github.com/docker/docker/api/server/httputils.WriteJSON (httputils_write_json.go:11)</span><br><span class="line">Nov 25 04:49:06 k8s-work2 dockerd[15611]: time=&quot;2022-11-25T04:49:06.416474238+08:00&quot; level=error msg=&quot;Handler for GET /v1.40/containers/json returned error: write unix /var/run/docker.sock-&gt;@: write: broken pipe&quot;</span><br><span class="line">Nov 25 04:49:06 k8s-work2 dockerd[15611]: http: superfluous response.WriteHeader call from github.com/docker/docker/api/server/httputils.WriteJSON (httputils_write_json.go:11)</span><br><span class="line">Nov 25 04:49:06 k8s-work2 dockerd[15611]: time=&quot;2022-11-25T04:49:06.422844592+08:00&quot; level=error msg=&quot;Handler for GET /v1.40/containers/json returned error: write unix /var/run/docker.sock-&gt;@: write: broken pipe&quot;</span><br></pre></td></tr></table></figure>
<p>根据日志可以看到关键日志 <code>write unix /var/run/docker.sock-&gt;@: write: broken pipe</code></p>
</li>
<li><p>检查 messages 日志</p>
<p> 查看对应时间段的系统日志</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Nov 25 04:49:00 k8s-work2 kubelet: E1125 04:49:00.153089   17604 remote_runtime.go:356] &quot;ListPodSandbox with filter from runtime service failed&quot; err=&quot;rpc error: code = Unknown desc = operation timeout: context deadline exceeded&quot; filter=&quot;nil&quot;</span><br><span class="line">Nov 25 04:49:00 k8s-work2 kubelet: E1125 04:49:00.375603   17604 kubelet.go:2166] &quot;Housekeeping took longer than 15s&quot; err=&quot;housekeeping took too long&quot; seconds=119.005290203</span><br><span class="line">Nov 25 04:49:00 k8s-work2 kubelet: E1125 04:49:00.375614   17604 kubelet.go:2010] &quot;Skipping pod synchronization&quot; err=&quot;container runtime is down&quot;</span><br><span class="line">Nov 25 04:49:01 k8s-work2 kubelet: E1125 04:49:01.178942   17604 kubelet.go:2359] &quot;Container runtime not ready&quot; runtimeReady=&quot;RuntimeReady=false reason:DockerDaemonNotReady message:docker: failed to get docker version: operation timeout: context deadline exceeded&quot;</span><br><span class="line">Nov 25 04:49:01 k8s-work2 kubelet: E1125 04:49:01.878007   17604 kubelet.go:2010] &quot;Skipping pod synchronization&quot; err=&quot;[container runtime is down, container runtime not ready: RuntimeReady=false reason:DockerDaemonNotReady message:docker: failed to get docker version: operation timeout: context deadline exceeded]&quot;</span><br><span class="line">Nov 25 04:49:06 k8s-work2 dockerd: time=&quot;2022-11-25T04:49:06.410127201+08:00&quot; level=error msg=&quot;Handler for GET /v1.40/containers/5cd867ce2a52311e79a20a113c7cedd2a233b3a52b556065b479f2dd11a14eac/json returned error: write unix /var/run/docker.sock-&gt;@: write: broken pipe&quot;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>根据 <code>kubelet</code> 服务日志，节点 <code>Not Ready</code> 的原因为 <code>docker down</code>，根据 docker 服务日志，docker 存在异常，但是此时执行 <code>docker</code> 相关命令，未发现异常。此问题多次出现，<code>docker engine</code> 版本为 <code>19.03.15-3</code>，之后尝试将 <code>docker engine</code> 版本升级为最新版本 <code>20.10.9</code>，问题未在出现。<a href="https://csms.tech/202208041317/#docker-ce-19-03-15-升级到-docker-ce-20-10-9"><code>docker engine</code> 升级参考</a> </p>
<h3 id="“Container-runtime-network-not-ready”-networkReady-x3D-”NetworkReady-x3D-false-reason-NetworkPluginNotReady-message-docker-network-plugin-is-not-ready-cni-config-uninitialized”"><a href="#“Container-runtime-network-not-ready”-networkReady-x3D-”NetworkReady-x3D-false-reason-NetworkPluginNotReady-message-docker-network-plugin-is-not-ready-cni-config-uninitialized”" class="headerlink" title="“Container runtime network not ready” networkReady&#x3D;”NetworkReady&#x3D;false reason:NetworkPluginNotReady message:docker: network plugin is not ready: cni config uninitialized”"></a>“Container runtime network not ready” networkReady&#x3D;”NetworkReady&#x3D;false reason:NetworkPluginNotReady message:docker: network plugin is not ready: cni config uninitialized”</h3><h4 id="环境信息-2"><a href="#环境信息-2" class="headerlink" title="环境信息"></a>环境信息</h4><ul>
<li>Kubernetes v1.21.2</li>
</ul>
<p>新增节点后，节点状态为 <code>NotReady</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get nodes</span></span><br><span class="line">NAME            STATUS     ROLES                  AGE     VERSION</span><br><span class="line">work2           Ready      &lt;none&gt;                 17d     v1.21.2</span><br><span class="line">work3           Ready      &lt;none&gt;                 17d     v1.21.2</span><br><span class="line">work4           Ready      &lt;none&gt;                 10d     v1.21.2</span><br><span class="line">work5           NotReady   &lt;none&gt;                 8m36s   v1.21.2</span><br><span class="line">master          Ready      control-plane,master   191d    v1.21.2</span><br></pre></td></tr></table></figure>
<p>Master 上查看节点的描述信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl describe node k8s-api-work5</span> </span><br><span class="line">Name:               work5</span><br><span class="line">Roles:              &lt;none&gt;</span><br><span class="line">Labels:             beta.kubernetes.io/arch=amd64</span><br><span class="line">                    beta.kubernetes.io/os=linux</span><br><span class="line">                    kubernetes.io/arch=amd64</span><br><span class="line">                    kubernetes.io/hostname=work5</span><br><span class="line">                    kubernetes.io/os=linux</span><br><span class="line"></span><br><span class="line">Taints:             node.kubernetes.io/not-ready:NoExecute</span><br><span class="line">                    node.kubernetes.io/not-ready:NoSchedule</span><br><span class="line">Unschedulable:      false</span><br><span class="line">Lease:</span><br><span class="line">  HolderIdentity:  work5</span><br><span class="line">  AcquireTime:     &lt;unset&gt;</span><br><span class="line">  RenewTime:       Wed, 05 Apr 2023 13:50:16 +0800</span><br><span class="line">Conditions:</span><br><span class="line">  Type                 Status  LastHeartbeatTime                 LastTransitionTime                Reason                       Message</span><br><span class="line">  ----                 ------  -----------------                 ------------------                ------                       -------</span><br><span class="line">  NetworkUnavailable   False   Wed, 05 Apr 2023 13:48:19 +0800   Wed, 05 Apr 2023 13:48:19 +0800   FlannelIsUp                  Flannel is running on this node</span><br><span class="line">  MemoryPressure       False   Wed, 05 Apr 2023 13:48:33 +0800   Wed, 05 Apr 2023 13:48:03 +0800   KubeletHasSufficientMemory   kubelet has sufficient memory available</span><br><span class="line">  DiskPressure         False   Wed, 05 Apr 2023 13:48:33 +0800   Wed, 05 Apr 2023 13:48:03 +0800   KubeletHasNoDiskPressure     kubelet has no disk pressure</span><br><span class="line">  PIDPressure          False   Wed, 05 Apr 2023 13:48:33 +0800   Wed, 05 Apr 2023 13:48:03 +0800   KubeletHasSufficientPID      kubelet has sufficient PID available</span><br><span class="line">  Ready                False   Wed, 05 Apr 2023 13:48:33 +0800   Wed, 05 Apr 2023 13:48:03 +0800   KubeletNotReady              container runtime network not ready: NetworkReady=false reason:NetworkPluginNotReady message:docker: network plugin is not ready: cni config uninitialized</span><br></pre></td></tr></table></figure>
<p>看到异常原因为 <code>container runtime network not ready: NetworkReady=false reason:NetworkPluginNotReady message:docker: network plugin is not ready: cni config uninitialized</code></p>
<p>在 <code>work5</code> 节点上查看 <code>kubelet</code> 日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">journalctl -u kubelet -f</span></span><br><span class="line">Apr 05 13:52:03 work5 kubelet[19520]: E0405 13:52:03.952395   19520 kubelet.go:2211] &quot;Container runtime network not ready&quot; networkReady=&quot;NetworkReady=false reason:NetworkPluginNotReady message:docker: network plugin is not ready: cni config uninitialized&quot;</span><br><span class="line"></span><br><span class="line">Apr 05 13:52:08 work5 kubelet[19520]: I0405 13:52:08.498481   19520 cni.go:204] &quot;Error validating CNI config list&quot; configList=&quot;&#123;\n  \&quot;name\&quot;: \&quot;cbr0\&quot;,\n  \&quot;cniVersion\&quot;: \&quot;0.3.1\&quot;,\n  \&quot;plugins\&quot;: [\n    &#123;\n      \&quot;type\&quot;: \&quot;flannel\&quot;,\n      \&quot;delegate\&quot;: &#123;\n        \&quot;hairpinMode\&quot;: true,\n        \&quot;isDefaultGateway\&quot;: true\n      &#125;\n    &#125;,\n    &#123;\n      \&quot;type\&quot;: \&quot;portmap\&quot;,\n      \&quot;capabilities\&quot;: &#123;\n        \&quot;portMappings\&quot;: true\n      &#125;\n    &#125;\n  ]\n&#125;\n&quot; err=&quot;[failed to find plugin \&quot;flannel\&quot; in path [/opt/cni/bin]]&quot;</span><br><span class="line">Apr 05 13:52:08 work5 kubelet[19520]: I0405 13:52:08.498501   19520 cni.go:239] &quot;Unable to update cni config&quot; err=&quot;no valid networks found in /etc/cni/net.d&quot;</span><br></pre></td></tr></table></figure>

<p>在 Master 节点上查看异常节点上的 <code>kube-flannel</code> POD 状态正常</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods -o wide -n kube-system</span></span><br><span class="line">NAME                             READY   STATUS    RESTARTS   AGE    IP              NODE            NOMINATED NODE   READINESS GATES</span><br><span class="line">coredns-558bd4d5db-6wf7m         1/1     Running   0          18d    10.244.4.132    admin           &lt;none&gt;           &lt;none&gt;</span><br><span class="line">coredns-558bd4d5db-zh9mw         1/1     Running   0          18d    10.244.4.144    admin           &lt;none&gt;           &lt;none&gt;</span><br><span class="line">etcd-master                      1/1     Running   1          191d   192.168.100.38   master          &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-apiserver-master            1/1     Running   1          191d   192.168.100.38   master          &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-controller-manager-master   1/1     Running   1          191d   192.168.100.38   master          &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-flannel-ds-2lg9x            1/1     Running   0          18d    192.168.100.38   master          &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-flannel-ds-5fpn8            1/1     Running   0          10d    192.168.100.69   work4       	  &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-flannel-ds-7ln98            1/1     Running   0          30m    192.168.100.59   work5   		  &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-flannel-ds-kvhhq            1/1     Running   0          17d    192.168.14.7     work3           &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-flannel-ds-vz4th            1/1     Running   0          17d    192.168.8.197    work2           &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-flannel-ds-xr84k            1/1     Running   0          18d    192.168.100.86   admin           &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-proxy-9b7kt                 1/1     Running   0          30m    192.168.100.59   work5           &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-proxy-c6ggk                 1/1     Running   1          191d   192.168.100.38   master          &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-proxy-gtlqt                 1/1     Running   0          17d    192.168.14.7     work3           &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-proxy-n6s7p                 1/1     Running   0          10d    192.168.100.69   work4           &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-proxy-p8m9d                 1/1     Running   0          17d    192.168.8.197    work2           &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-proxy-qvks4                 1/1     Running   2          191d   192.168.100.86   admin           &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-scheduler-master            1/1     Running   1          191d   192.168.100.38   master          &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>
<p>接着检查新增节点上提供 <code>flannel</code> 组件的安装包，及相关目录中的文件是否存在异常 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rpm -qa | grep kubernetes</span></span><br><span class="line">kubernetes-cni-1.2.0-0.x86_64</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> /opt/cni/bin/</span></span><br><span class="line">bandwidth  dhcp   firewall     host-local  loopback  portmap  sbr     tuning  vrf</span><br><span class="line">bridge     dummy  host-device  ipvlan      macvlan   ptp      static  vlan</span><br></pre></td></tr></table></figure>

<p>比对其他已存在的正常节点上的 <code>kubernetes-cni</code> 信息，发现其他节点上的 <code>kubernetes-cni</code> 版本为 <code>kubernetes-cni-0.8.7-0</code>，怀疑为版本问题导致，卸载问题节点上的 <code>kubernetes-cni-1.2.0-0</code>，重新安装 <code>kubernetes-cni-0.8.7-0</code>。卸载 <code>kubernetes-cni</code> 会导致之前安装的 <code>kubeadm</code> 和 <code>kubelet</code> 被卸载，也需要重新安装。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum remove kubernetes-cni-1.2.0-0</span></span><br><span class="line">...</span><br><span class="line">Removed:</span><br><span class="line">  kubernetes-cni.x86_64 0:1.2.0-0                                                                                                      </span><br><span class="line"></span><br><span class="line">Dependency Removed:</span><br><span class="line">  kubeadm.x86_64 0:1.21.2-0                                          kubelet.x86_64 0:1.21.2-0</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum install -y kubelet-1.21.2 kubeadm-1.21.2 kubectl-1.21.2 kubernetes-cni-0.8.7-0</span></span><br></pre></td></tr></table></figure>

<p>安装 <code>kubernetes-cni-0.8.7-0</code> 版本后，再次查看节点状态，变为 <code>Ready</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get nodes</span></span><br><span class="line">NAME            STATUS     ROLES                  AGE     VERSION</span><br><span class="line">work2           Ready      &lt;none&gt;                 17d     v1.21.2</span><br><span class="line">work3           Ready      &lt;none&gt;                 17d     v1.21.2</span><br><span class="line">work4           Ready      &lt;none&gt;                 10d     v1.21.2</span><br><span class="line">work5           Ready      &lt;none&gt;                 8m36s   v1.21.2</span><br><span class="line">master          Ready      control-plane,master   191d    v1.21.2</span><br></pre></td></tr></table></figure>

<h3 id="Container-runtime-network-not-ready”-networkReady-x3D-”NetworkReady-x3D-false-reason-NetworkPluginNotReady-message-docker-network-plugin-is-not-ready-cni-config-uninitialized”"><a href="#Container-runtime-network-not-ready”-networkReady-x3D-”NetworkReady-x3D-false-reason-NetworkPluginNotReady-message-docker-network-plugin-is-not-ready-cni-config-uninitialized”" class="headerlink" title="Container runtime network not ready” networkReady&#x3D;”NetworkReady&#x3D;false reason:NetworkPluginNotReady message:docker: network plugin is not ready: cni config uninitialized”"></a>Container runtime network not ready” networkReady&#x3D;”NetworkReady&#x3D;false reason:NetworkPluginNotReady message:docker: network plugin is not ready: cni config uninitialized”</h3><p>节点状态 NotReady，检查节点上的 kubelet日志，显示 <code>Container runtime network not ready&quot; networkReady=&quot;NetworkReady=false reason:NetworkPluginNotReady message:docker: network plugin is not ready: cni config uninitialized&quot;</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get nodes -o wide</span></span><br><span class="line">NAME          STATUS     ROLES           AGE   VERSION   INTERNAL-IP      EXTERNAL-IP   OS-IMAGE                KERNEL-VERSION                CONTAINER-RUNTIME</span><br><span class="line">k8s-master1   Ready      control-plane   35m   v1.25.4   192.168.142.10   &lt;none&gt;        CentOS Linux 7 (Core)   5.4.242-1.el7.elrepo.x86_64   docker://20.10.9</span><br><span class="line">k8s-worker1   Ready      &lt;none&gt;          30m   v1.25.4   192.168.142.11   &lt;none&gt;        CentOS Linux 7 (Core)   5.4.242-1.el7.elrepo.x86_64   docker://20.10.9</span><br><span class="line">k8s-worker2   NotReady   &lt;none&gt;          21m   v1.25.4   192.168.142.12   &lt;none&gt;        CentOS Linux 7 (Core)   5.4.242-1.el7.elrepo.x86_64   docker://20.10.9</span><br></pre></td></tr></table></figure>

<p>检查发现节点上没有 CNI 配置文件 <code>/etc/cni/net.d/10-flannel.conflist</code>，拷贝正常节点上的配置到异常节点后，状态恢复正常。</p>
<h2 id="api-server-启动失败"><a href="#api-server-启动失败" class="headerlink" title="api-server 启动失败"></a>api-server 启动失败</h2><h3 id="错误场景"><a href="#错误场景" class="headerlink" title="错误场景"></a>错误场景</h3><p>api server 启动失败，执行 <code>kubectl</code> 命令输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get nodes</span></span><br><span class="line">The connection to the server kube-apiserver.uat.148962587001:6443 was refused - did you specify the right host or port?</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>检查 Api Server 监听的端口 6443 ，显示端口未启动。</p>
<p>检查 Api Server 对应的容器状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker ps -a | grep api</span></span><br><span class="line">81688b9cbe45  1f38c0b6a9d1   &quot;kube-apiserver --ad…&quot;   14 seconds ago      Exited (1) 13 seconds ago                       k8s_kube-apiserver_kube-apiserver-k8s-uat-master1.148962587001_kube-system_c8a87f4921623c7bff57f5662ea486cc_25</span><br></pre></td></tr></table></figure>

<p>容器状态为 <code>Exited</code>，检查容器日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker logs 81688b9cbe45</span></span><br><span class="line">I1116 07:43:53.775588       1 server.go:558] external host was not specified, using 172.31.30.123</span><br><span class="line">I1116 07:43:53.776035       1 server.go:158] Version: v1.24.7</span><br><span class="line">I1116 07:43:53.776057       1 server.go:160] &quot;Golang settings&quot; GOGC=&quot;&quot; GOMAXPROCS=&quot;&quot; GOTRACEBACK=&quot;&quot;</span><br><span class="line">E1116 07:43:53.776298       1 run.go:74] &quot;command failed&quot; err=&quot;open /etc/kubernetes/pki/apiserver.crt: no such file or directory&quot;</span><br></pre></td></tr></table></figure>
<p>日志显示 <code>err=&quot;open /etc/kubernetes/pki/apiserver.crt: no such file or directory&quot;</code>，检查文件 <code>/etc/kubernetes/pki/apiserver.crt</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> /etc/kubernetes/pki/apiserver.crt</span></span><br><span class="line">ls: cannot access /etc/kubernetes/pki/apiserver.crt: No such file or directory</span><br></pre></td></tr></table></figure>

<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ul>
<li>发现此文件确实不存在。若有备份，从备份中恢复此文件。如果没有备份，<a href="https://cloud.tencent.com/developer/article/1801882">参考文档</a> 恢复证书<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /k8s/backup/pki/apiserver.key /etc/kubernetes/pki/</span><br><span class="line">cp /k8s/backup/pki/apiserver.crt /etc/kubernetes/pki/</span><br></pre></td></tr></table></figure>
重启 <code>kubelet</code> 后检查 Api Server，发现服务正常启动<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart kubelet</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>如果只是缺少了 <code>apiserver.key</code>，<code>apiserver.crt</code> 证书文件，可通过以下命令重新生成证书文件，<a href="https://csms.tech/202209121102/#集群之外的服务器使用-kubectl-报错">生成原理参考</a><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubeadm init phase certs apiserver \</span></span><br><span class="line"><span class="language-bash">     --apiserver-advertise-address  10.150.0.21 \</span></span><br><span class="line"><span class="language-bash">     --apiserver-cert-extra-sans  10.96.0.1 \</span></span><br><span class="line"><span class="language-bash">     --apiserver-cert-extra-sans 34.150.1.1</span></span><br><span class="line"> </span><br><span class="line">[certs] Generating &quot;apiserver&quot; certificate and key</span><br><span class="line">[certs] apiserver serving cert is signed for DNS names [k8s-master kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.96.0.1 10.150.0.21 34.150.1.1]</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="Ingress-接入异常"><a href="#Ingress-接入异常" class="headerlink" title="Ingress 接入异常"></a>Ingress 接入异常</h1><h2 id="503-Service-Temporarily-Unavailable"><a href="#503-Service-Temporarily-Unavailable" class="headerlink" title="503 Service Temporarily Unavailable"></a>503 Service Temporarily Unavailable</h2><p><code>Deployment</code>，<code>Service</code>，<code>Ingress</code> 部署后，通过 <code>Ingress</code> 配置的域名访问，显示 <code>503 Service Temporarily Unavailable</code><br><img src="https://i.csms.tech/img_110.png"></p>
<p><strong>排查步骤</strong></p>
<p>检查 <code>Ingress-Nginx</code> Pod 的日志，检索对应域名日志，显示返回码为 503</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">52.77.198.154 - - [15/Dec/2022:02:10:59 +0000] &quot;GET /graph HTTP/1.1&quot; 503 592 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36&quot; 507 0.000 [prometheus-prometheus-service-8080] [] - - - - 00b07fe234401054153fdbd0ffafb158</span><br></pre></td></tr></table></figure>

<p>查看 Ingress 对应的 <code>Service</code>，从以下输出中可以看到对应的 <code>Service</code> 为 <code>prometheus-service</code>，端口为 8080</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get ingress -n prometheus -o wide</span></span><br><span class="line">NAME            CLASS   HOSTS                     ADDRESS                      PORTS   AGE</span><br><span class="line">prometheus-ui   nginx   prometheus.example.com    172.31.23.72,172.31.27.193   80      19h</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl describe ingress prometheus-ui -n prometheus</span> </span><br><span class="line">Name:             prometheus-ui</span><br><span class="line">Labels:           &lt;none&gt;</span><br><span class="line">Namespace:        prometheus</span><br><span class="line">Address:          172.31.23.72,172.31.27.193</span><br><span class="line">Ingress Class:    nginx</span><br><span class="line">Default backend:  &lt;default&gt;</span><br><span class="line">Rules:</span><br><span class="line">  Host                     Path  Backends</span><br><span class="line">  ----                     ----  --------</span><br><span class="line">  prometheus.example.com  </span><br><span class="line">                           /   prometheus-service:8080 ()</span><br><span class="line">Annotations:               field.cattle.io/publicEndpoints:</span><br><span class="line">                             [&#123;&quot;addresses&quot;:[&quot;172.31.23.72&quot;,&quot;172.31.27.193&quot;],&quot;port&quot;:80,&quot;protocol&quot;:&quot;HTTP&quot;,&quot;serviceName&quot;:&quot;prometheus:prometheus-service&quot;,&quot;ingressName&quot;:&quot;pr...</span><br><span class="line">Events:                    &lt;none&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看 <code>Service</code> 信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get services -n prometheus -o wide</span></span><br><span class="line">NAME                 TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)    AGE   SELECTOR</span><br><span class="line">prometheus-service   ClusterIP   10.99.75.232   &lt;none&gt;        8090/TCP   19h   app=prometheus-server</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl describe service -n prometheus prometheus-service</span></span><br><span class="line">Name:              prometheus-service</span><br><span class="line">Namespace:         prometheus</span><br><span class="line">Labels:            &lt;none&gt;</span><br><span class="line">Annotations:       &lt;none&gt;</span><br><span class="line">Selector:          app=prometheus-server</span><br><span class="line">Type:              ClusterIP</span><br><span class="line">IP Family Policy:  SingleStack</span><br><span class="line">IP Families:       IPv4</span><br><span class="line">IP:                10.99.75.232</span><br><span class="line">IPs:               10.99.75.232</span><br><span class="line">Port:              prometheus-port  8090/TCP</span><br><span class="line">TargetPort:        9090/TCP</span><br><span class="line">Endpoints:         10.244.3.95:9090</span><br><span class="line">Session Affinity:  None</span><br><span class="line">Events:            &lt;none&gt;</span><br></pre></td></tr></table></figure>
<p>从以上信息可以看到，服务的端口为 <code>Port: prometheus-port  8090/TCP</code>，而 Ingress 中配置的服务端口为 <code>8080</code> ，修改 Ingress 配置，将服务端口修改正确。修改后访问正常。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://cloud.tencent.com/developer/article/1456389">相关参考</a></p>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://cloud.tencent.com/developer/article/1931089">Back-off restarting failed container 怎么办</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://tonybai.com/2017/10/16/out-of-node-resource-handling-in-kubernetes-cluster/">ephemeral-storage 问题</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes 配置文件说明</title>
    <url>/202211291130/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos7 5.4.212-1</li>
<li>Docker 20.10.18</li>
<li>containerd.io-1.6.8</li>
<li>kubectl-1.25.0</li>
<li>kubeadm-1.25.0</li>
<li>kubelet-1.25.0</li>
<li>kube-flannel</li>
</ul>
<h1 id="常见配置文件说明"><a href="#常见配置文件说明" class="headerlink" title="常见配置文件说明"></a>常见配置文件说明</h1><table>
<thead>
<tr>
<th>文件&#x2F;目录</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>/etc/kubernetes/&#123;admin.conf, controller-manager.conf, kubelet.conf, scheduler.conf &#125;</code></td>
<td>master 管理节点上的管理节点（<code>admin</code>，<code>controller-manager</code>，<code>kubelet</code>，<code>scheduler</code>）配置文件 <br/><code>admin</code> 配置文件具有全局管理员权限，可以跳过 RBAC 权限控制系统，应该禁止其共享。</td>
<td></td>
</tr>
<tr>
<td><code>/etc/kubernetes/kubelet.conf</code></td>
<td>worker 节点上，<code>kubelet</code> 配置文件</td>
<td></td>
</tr>
<tr>
<td><code>/etc/kubernetes/manifests/</code></td>
<td>管理节点上，管理节点的启动参数配置文件，主要包括 <code>etcd.yaml</code>，  <code>kube-apiserver.yaml</code>，  <code>kube-controller-manager.yaml</code>，  <code>kube-scheduler.yaml</code>。是静态 Pod 的主要配置路径</td>
<td></td>
</tr>
<tr>
<td><code>/etc/kubernetes/pki/</code></td>
<td>- 管理节点上，存放所有节点之间的通信证书文件， <br/>- worker 节点上，存放集群 CA 证书文件。  只有 <code>ca.crt</code></td>
<td></td>
</tr>
<tr>
<td><code>/etc/cni/net.d/10-flannel.conflist</code></td>
<td>管理节点上，<code>flannel</code> 配置文件</td>
<td></td>
</tr>
</tbody></table>
<span id="more"></span>]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes ConfigMap 使用说明</title>
    <url>/202212071353/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Kubernetes 1.24</li>
</ul>
<p><code>ConfigMap</code> 是 Kubernetes 用来向应用 Pod 中注入配置数据的方法。<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[配置 Pod 使用 ConfigMap](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-pod-configmap/)">[1]</span></a></sup></p>
<h1 id="使用-ConfigMap-数据定义容器环境变量"><a href="#使用-ConfigMap-数据定义容器环境变量" class="headerlink" title="使用 ConfigMap 数据定义容器环境变量"></a>使用 ConfigMap 数据定义容器环境变量</h1><h2 id="使用单个-ConfigMap-中的数据定义容器环境变量"><a href="#使用单个-ConfigMap-中的数据定义容器环境变量" class="headerlink" title="使用单个 ConfigMap 中的数据定义容器环境变量"></a>使用单个 ConfigMap 中的数据定义容器环境变量</h2><ol>
<li>在 <code>ConfigMap</code> 中将环境变量定义为键值对: <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create configmap special-config --from-literal=special.how=very</span><br></pre></td></tr></table></figure></li>
<li>将 ConfigMap 中定义的 special.how 赋值给 Pod 规约中的 SPECIAL_LEVEL_KEY 环境变量。 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">   </span><br><span class="line">kind: Pod</span><br><span class="line">   </span><br><span class="line">metadata:</span><br><span class="line">   </span><br><span class="line">  name: dapi-test-pod</span><br><span class="line">   </span><br><span class="line">spec:</span><br><span class="line">   </span><br><span class="line">  containers:</span><br><span class="line">   </span><br><span class="line">    - name: test-container</span><br><span class="line">   </span><br><span class="line">      image: registry.k8s.io/busybox</span><br><span class="line">   </span><br><span class="line">      command: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;env&quot; ]</span><br><span class="line">   </span><br><span class="line">      env:</span><br><span class="line">   </span><br><span class="line">        # 定义环境变量</span><br><span class="line">   </span><br><span class="line">        - name: SPECIAL_LEVEL_KEY</span><br><span class="line">   </span><br><span class="line">          valueFrom:</span><br><span class="line">   </span><br><span class="line">            configMapKeyRef:</span><br><span class="line">   </span><br><span class="line">              # ConfigMap 包含你要赋给 SPECIAL_LEVEL_KEY 的值</span><br><span class="line">   </span><br><span class="line">              name: special-config</span><br><span class="line">   </span><br><span class="line">              # 指定与取值相关的键名</span><br><span class="line">   </span><br><span class="line">              key: special.how</span><br><span class="line">   </span><br><span class="line">  restartPolicy: Never</span><br></pre></td></tr></table></figure>
 现在，Pod 的输出包含环境变量 <code>SPECIAL_LEVEL_KEY=very</code>。</li>
</ol>
<span id="more"></span>

<h2 id="使用来自多个-ConfigMap-的数据定义容器环境变量"><a href="#使用来自多个-ConfigMap-的数据定义容器环境变量" class="headerlink" title="使用来自多个 ConfigMap 的数据定义容器环境变量"></a>使用来自多个 ConfigMap 的数据定义容器环境变量</h2><p>创建 <code>ConfigMap</code> <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[使用来自多个 ConfigMap 的数据定义容器环境变量](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-pod-configmap/#define-container-environment-variables-with-data-from-multiple-configmaps)
">[2]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">  </span><br><span class="line">kind: ConfigMap</span><br><span class="line">  </span><br><span class="line">metadata:</span><br><span class="line">  </span><br><span class="line">  name: special-config</span><br><span class="line">  </span><br><span class="line">  namespace: default</span><br><span class="line">  </span><br><span class="line">data:</span><br><span class="line">  </span><br><span class="line">  special.how: very</span><br><span class="line">  </span><br><span class="line">---</span><br><span class="line">  </span><br><span class="line">apiVersion: v1</span><br><span class="line">  </span><br><span class="line">kind: ConfigMap</span><br><span class="line">  </span><br><span class="line">metadata:</span><br><span class="line">  </span><br><span class="line">  name: env-config</span><br><span class="line">  </span><br><span class="line">  namespace: default</span><br><span class="line">  </span><br><span class="line">data:</span><br><span class="line">  </span><br><span class="line">  log_level: INFO</span><br></pre></td></tr></table></figure>
<p>在 Pod 规约中定义环境变量。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">  </span><br><span class="line">kind: Pod</span><br><span class="line">  </span><br><span class="line">metadata:</span><br><span class="line">  </span><br><span class="line">  name: dapi-test-pod</span><br><span class="line">  </span><br><span class="line">spec:</span><br><span class="line">  </span><br><span class="line">  containers:</span><br><span class="line">  </span><br><span class="line">    - name: test-container</span><br><span class="line">  </span><br><span class="line">      image: registry.k8s.io/busybox</span><br><span class="line">  </span><br><span class="line">      command: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;env&quot; ]</span><br><span class="line">  </span><br><span class="line">      env:</span><br><span class="line">  </span><br><span class="line">        - name: SPECIAL_LEVEL_KEY</span><br><span class="line">  </span><br><span class="line">          valueFrom:</span><br><span class="line">  </span><br><span class="line">            configMapKeyRef:</span><br><span class="line">  </span><br><span class="line">              name: special-config</span><br><span class="line">  </span><br><span class="line">              key: special.how</span><br><span class="line">  </span><br><span class="line">        - name: LOG_LEVEL</span><br><span class="line">  </span><br><span class="line">          valueFrom:</span><br><span class="line">  </span><br><span class="line">            configMapKeyRef:</span><br><span class="line">  </span><br><span class="line">              name: env-config</span><br><span class="line">  </span><br><span class="line">              key: log_level</span><br><span class="line">  </span><br><span class="line">  restartPolicy: Never</span><br></pre></td></tr></table></figure>
<h2 id="将-ConfigMap-中的所有键值对配置为容器环境变量"><a href="#将-ConfigMap-中的所有键值对配置为容器环境变量" class="headerlink" title="将 ConfigMap 中的所有键值对配置为容器环境变量"></a>将 ConfigMap 中的所有键值对配置为容器环境变量</h2><p>创建一个包含多个键值对的 ConfigMap。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">  </span><br><span class="line">kind: ConfigMap</span><br><span class="line">  </span><br><span class="line">metadata:</span><br><span class="line">  </span><br><span class="line">  name: special-config</span><br><span class="line">  </span><br><span class="line">  namespace: default</span><br><span class="line">  </span><br><span class="line">data:</span><br><span class="line">  </span><br><span class="line">  SPECIAL_LEVEL: very</span><br><span class="line">  </span><br><span class="line">  SPECIAL_TYPE: charm</span><br></pre></td></tr></table></figure>
<p>使用 <code>envFrom</code> 将所有 <code>ConfigMap</code> 的数据定义为容器环境变量，<code>ConfigMap</code> 中的键成为 Pod 中的环境变量名称。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">  </span><br><span class="line">kind: Pod</span><br><span class="line">  </span><br><span class="line">metadata:</span><br><span class="line">  </span><br><span class="line">  name: dapi-test-pod</span><br><span class="line">  </span><br><span class="line">spec:</span><br><span class="line">  </span><br><span class="line">  containers:</span><br><span class="line">  </span><br><span class="line">    - name: test-container</span><br><span class="line">  </span><br><span class="line">      image: registry.k8s.io/busybox</span><br><span class="line">  </span><br><span class="line">      command: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;env&quot; ]</span><br><span class="line">  </span><br><span class="line">      envFrom:</span><br><span class="line">  </span><br><span class="line">      - configMapRef:</span><br><span class="line">  </span><br><span class="line">          name: special-config</span><br><span class="line">  </span><br><span class="line">  restartPolicy: Never</span><br></pre></td></tr></table></figure>

<h2 id="将-ConfigMap-内容挂载到容器中的文件"><a href="#将-ConfigMap-内容挂载到容器中的文件" class="headerlink" title="将 ConfigMap 内容挂载到容器中的文件"></a>将 ConfigMap 内容挂载到容器中的文件</h2><p>下面是一个将 ConfigMap 以卷的形式进行挂载的 Pod 示例： <sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[在 Pod 中将 ConfigMap 当做文件使用](https://kubernetes.io/zh-cn/docs/concepts/configuration/configmap/#%E5%9C%A8-pod-%E4%B8%AD%E5%B0%86-configmap-%E5%BD%93%E5%81%9A%E6%96%87%E4%BB%B6%E4%BD%BF%E7%94%A8)">[3]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: mypod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: mypod</span><br><span class="line">    image: redis</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: foo</span><br><span class="line">      mountPath: &quot;/etc/foo&quot;</span><br><span class="line">      readOnly: true</span><br><span class="line">  volumes:</span><br><span class="line">  - name: foo</span><br><span class="line">    configMap:</span><br><span class="line">      name: myconfigmap</span><br></pre></td></tr></table></figure>

<p>挂载之后，<code>configMap</code> 中的每个键会变成 <code>spec.containers[].volumeMounts[].mountPath</code> 下面的一个文件名。</p>
<p>将 <code>configMap</code> 暴露为卷可以达到配置热更新的效果，当 <code>configMap</code> 更新后，卷中引用它的所有文件也会相应更新，进程发现文件被改变后进行重载（需要进程有此功能），无需重新创建 Pod 或者重启容器。</p>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-pod-configmap/">配置 Pod 使用 ConfigMap</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-pod-configmap/#define-container-environment-variables-with-data-from-multiple-configmaps">使用来自多个 ConfigMap 的数据定义容器环境变量</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/concepts/configuration/configmap/#%E5%9C%A8-pod-%E4%B8%AD%E5%B0%86-configmap-%E5%BD%93%E5%81%9A%E6%96%87%E4%BB%B6%E4%BD%BF%E7%94%A8">在 Pod 中将 ConfigMap 当做文件使用</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes dns</title>
    <url>/202305031339/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos 7 5.4.225-1</li>
<li>Kubernetes v1.24.7</li>
</ul>
<p>Kubernetes DNS 服务的功能，是用来解析 Kubernetes 集群内的 Pod 和 Service 的域名，一般只供集群内部使用，不给外部使用。</p>
<p>默认情况下，Kubernetes DNS 应用部署后，会对外暴露一个 Service，集群内的容器通过访问该 Service 获得域名解析服务，这个 Service 的 ClusterIP 一般情况下都是固定的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get services -n kube-system -o wide</span></span><br><span class="line">NAME       TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)                  AGE    SELECTOR</span><br><span class="line">kube-dns   ClusterIP   10.96.0.10   &lt;none&gt;        53/UDP,53/TCP,9153/TCP   147d   k8s-app=kube-dns</span><br></pre></td></tr></table></figure>

<p>当 Kubernetes DNS 服务获得 ClusterIP 后，系统会给 Kubelet 配置启动参数指定 DNS Service 的 ClusterIP，DNS Service 的 IP 会在容器启动时传入，并写入容器系统的 DNS 配置中（一般为 <code>/etc/resolv.conf</code> 文件）</p>
<p>根据 <code>kubelet</code> 服务的启动命令，配置参数可以写在以下相关配置文件中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl status kubelet -l</span></span><br><span class="line">● kubelet.service - kubelet: The Kubernetes Node Agent</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/kubelet.service; enabled; vendor preset: disabled)</span><br><span class="line">  Drop-In: /usr/lib/systemd/system/kubelet.service.d</span><br><span class="line">           └─10-kubeadm.conf</span><br><span class="line">   Active: active (running) since Tue 2023-05-02 16:06:16 CST; 21h ago</span><br><span class="line">     Docs: https://kubernetes.io/docs/</span><br><span class="line"> Main PID: 1413 (kubelet)</span><br><span class="line">    Tasks: 29</span><br><span class="line">   Memory: 203.0M</span><br><span class="line">   CGroup: /system.slice/kubelet.service</span><br><span class="line">           └─1413 /usr/bin/kubelet --bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf \</span><br><span class="line">                                   --kubeconfig=/etc/kubernetes/kubelet.conf \</span><br><span class="line">                                   --config=/var/lib/kubelet/config.yaml \</span><br><span class="line">                                   --container-runtime=remote \</span><br><span class="line">                                   --container-runtime-endpoint=unix:///var/run/cri-dockerd.sock \</span><br><span class="line">                                   --pod-infra-container-image=k8s.gcr.io/pause:3.7</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps aux | grep kubelet</span></span><br><span class="line">/usr/bin/kubelet --bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf 、</span><br><span class="line">                 --kubeconfig=/etc/kubernetes/kubelet.conf \</span><br><span class="line">                 --config=/var/lib/kubelet/config.yaml \</span><br><span class="line">                 --container-runtime=remote \</span><br><span class="line">                 --container-runtime-endpoint=unix:///var/run/cri-dockerd.sock \</span><br><span class="line">                 --pod-infra-container-image=k8s.gcr.io/pause:3.7</span><br></pre></td></tr></table></figure>
<p>DNS 的相关配置在文件 <code>/var/lib/kubelet/config.yaml</code> 中，主要选项为 <code>clusterDNS</code></p>
<figure class="highlight shell"><figcaption><span>/var/lib/kubelet/config.yaml</span></figcaption><table><tr><td class="code"><pre><span class="line">apiVersion: kubelet.config.k8s.io/v1beta1</span><br><span class="line">authentication:</span><br><span class="line">  anonymous:</span><br><span class="line">    enabled: false</span><br><span class="line">  webhook:</span><br><span class="line">    cacheTTL: 0s</span><br><span class="line">    enabled: true</span><br><span class="line">  x509:</span><br><span class="line">    clientCAFile: /etc/kubernetes/pki/ca.crt</span><br><span class="line">authorization:</span><br><span class="line">  mode: Webhook</span><br><span class="line">  webhook:</span><br><span class="line">    cacheAuthorizedTTL: 0s</span><br><span class="line">    cacheUnauthorizedTTL: 0s</span><br><span class="line">cgroupDriver: systemd</span><br><span class="line">clusterDNS:</span><br><span class="line">- 10.96.0.10</span><br><span class="line">clusterDomain: cluster.local</span><br><span class="line">cpuManagerReconcilePeriod: 0s</span><br><span class="line">evictionPressureTransitionPeriod: 0s</span><br><span class="line">fileCheckFrequency: 0s</span><br><span class="line">healthzBindAddress: 127.0.0.1</span><br><span class="line">healthzPort: 10248</span><br><span class="line">httpCheckFrequency: 0s</span><br><span class="line">imageMinimumGCAge: 0s</span><br><span class="line">kind: KubeletConfiguration</span><br><span class="line">logging:</span><br><span class="line">  flushFrequency: 0</span><br><span class="line">  options:</span><br><span class="line">    json:</span><br><span class="line">      infoBufferSize: &quot;0&quot;</span><br><span class="line">  verbosity: 0</span><br><span class="line">memorySwap: &#123;&#125;</span><br><span class="line">nodeStatusReportFrequency: 0s</span><br><span class="line">nodeStatusUpdateFrequency: 0s</span><br><span class="line">rotateCertificates: true</span><br><span class="line">runtimeRequestTimeout: 0s</span><br><span class="line">shutdownGracePeriod: 0s</span><br><span class="line">shutdownGracePeriodCriticalPods: 0s</span><br><span class="line">staticPodPath: /etc/kubernetes/manifests</span><br><span class="line">streamingConnectionIdleTimeout: 0s</span><br><span class="line">syncFrequency: 0s</span><br><span class="line">volumeStatsAggPeriod: 0s</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="Kubernetes-DNS-解析基本原理"><a href="#Kubernetes-DNS-解析基本原理" class="headerlink" title="Kubernetes DNS 解析基本原理"></a>Kubernetes DNS 解析基本原理</h1><p>对于 Service，Kubernetes NDS 会生成三类记录，分别是 A 记录、SRV 记录、CNAME 记录。</p>
<h2 id="A-记录"><a href="#A-记录" class="headerlink" title="A 记录"></a>A 记录</h2><p>A 记录用于做正向解析，将域名解析到对应的 IP 地址。Kubernetes 为 <code>normal</code> 和 <a href="https://csms.tech/202209241108/#无头服务（Headless-Services）"><code>headless</code></a> 类型的服务分配不同的 A 记录，不同之处在于 <code>headless</code> 类型的服务未分配 ClusterIP 且不执行负载均衡。</p>
<ul>
<li>DNS 为 <code>normal</code> 类型的 Service 分配一个 A 记录，域名遵循 <code>$&#123;your-svc-name&#125;.$&#123;your-namespace&#125;.svc.cluster.local</code>（其中 <code>cluster.local</code> 为集群默认的根域，可在 <code>kubelet</code> 设置 <code>clusterDomain</code> 中更改），A 记录指向 Service 的 ClusterIP。</li>
<li>DNS 为 <code>headless</code> 类型的 Service 分配一个 A 记录，域名遵循 <code>$&#123;your-svc-name&#125;.$&#123;your-namespace&#125;.svc.cluster.local</code>（其中 <code>cluster.local</code> 为集群默认的根域，可在 <code>kubelet</code> 设置 <code>clusterDomain</code> 中更改），A 记录指向就绪的 Pod 的 IP。DNS 不会自动将此 IP 配置为特定 Pod 的 IP，后端如果有多个就绪的 Pod，DNS 会添加所有解析。</li>
</ul>
<p>在集群内部，可以通过 <code>$&#123;your-svc-name&#125;.$&#123;your-namespace&#125;.svc.cluster.local</code> 访问任何服务，也可以通过简写 <code>$&#123;your-svc-name&#125;.$&#123;your-namespace&#125;</code> 直接访问。如果 Pod 和 Service 在同一个 namespace，可以通过 Service name （${your-svc-name}） 直接访问</p>
<h3 id="Pod-IP-的-A-记录"><a href="#Pod-IP-的-A-记录" class="headerlink" title="Pod IP 的 A 记录"></a>Pod IP 的 A 记录</h3><p>启用了 DNS 后，Pod 将被分配一个 DNS A 记录，格式如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;Pod-ip&#125;.<span class="variable">$&#123;Pod namespace&#125;</span>.pod.<span class="variable">$&#123;clusterDomain &#125;</span> --&gt; Pod IP</span></span><br></pre></td></tr></table></figure>
<p>${Pod-ip} 为 Pod 的 IP 地址使用 <code>-</code> 替换 <code>.</code>，如 Pod IP 为 <code>1.2.3.4</code>，${Pod-ip} 为 <code>1-2-3-4</code></p>
<p>如果在 Pod Spec 中指定了 <code>hostname</code> 和 <code>subdomain</code>，那么 Kubernetes DNS 会为 Pod 额外生产 A 记录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;hostname&#125;.<span class="variable">$&#123;subdomain&#125;</span>.<span class="variable">$&#123;Pod namespace&#125;</span>.pod.<span class="variable">$&#123;clusterDomain &#125;</span> --&gt; Pod IP</span></span><br></pre></td></tr></table></figure>

<h2 id="SRV-记录"><a href="#SRV-记录" class="headerlink" title="SRV 记录"></a>SRV 记录</h2><p>SRV 记录通过在 DNS 中定义服务协议和地址（域名及端口）来促进服务发现。SRV 记录通常定义了 服务名称、协议、请求端口、请求域名（主机）、权重、优先级等内容。以下是一个 SRV 记录的示例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">_sip._tcp.example.com    3600    IN    SRV    10    70  5060    srvrecord.example.com</span><br><span class="line">_sip._tcp.example.com    3600    IN    SRV    10    30  5060    srvrecord2.example.com</span><br></pre></td></tr></table></figure>

<p>在上面的示例中：</p>
<ul>
<li><code>_sip</code> - 是服务的名称</li>
<li><code>_tcp</code> - 服务使用的协议</li>
<li><code>10</code> - 表示优先级</li>
<li><code>70</code> - 表示权重</li>
<li><code>5060</code> - 服务要连接的 端口</li>
<li><code>srvrecord.example.com</code> - 服务要连接的主机</li>
</ul>
<p>Kubernetes 的 DNS 服务遵循以下规则为 Service 提供了服务端口的解析</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">_$</span><span class="language-bash">&#123;port name&#125;._tcp.<span class="variable">$&#123;service name&#125;</span>.<span class="variable">$&#123;service namespace&#125;</span>.svc.cluster.local --&gt; Service Port</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>解析到的域名（主机）是 <code>$&#123;service name&#125;.$&#123;service namespace&#125;.svc.cluster.local</code><br>如果是 <code>headless</code> 类型的 Service ，解析到的域名（主机）是 Pod 的 域名。</p>
</blockquote>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>ingress-nginx 安装配置</title>
    <url>/202209301604/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h2><ul>
<li>Centos7 5.4.212-1</li>
<li>Docker 20.10.18</li>
<li>containerd.io-1.6.8</li>
<li>kubectl-1.25.0</li>
<li>kubeadm-1.25.0</li>
<li>kubelet-1.25.0</li>
</ul>
<h2 id="安装-ingress-nginx-controller"><a href="#安装-ingress-nginx-controller" class="headerlink" title="安装 ingress-nginx controller"></a>安装 ingress-nginx controller</h2><p>此文档中的配置主要针对基于部署在裸机（安装通用 Linux 发行版的物理机或者云主机系统）上的 Kebernetes 集群</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.3.1/deploy/static/provider/cloud/deploy.yaml</span><br><span class="line">mv deploy.yaml ingress-nginx-controller-v1.3.1.yaml</span><br></pre></td></tr></table></figure>

<h3 id="基于-hostNetwork-的-ingress-nginx-controller"><a href="#基于-hostNetwork-的-ingress-nginx-controller" class="headerlink" title="基于 hostNetwork 的 ingress-nginx controller"></a>基于 hostNetwork 的 ingress-nginx controller</h3><p>编辑 <code>ingress-nginx-controller</code> 的 <code>Deployment</code> 配置文件，在 <code>Deployment</code> 中的 <code>.spec.template.spec</code> 下添加字段 <code>hostNetwork: true</code>，以使 <code>ingress-nginx-controller</code> 可以使用节点的主机网络提供对外访问<br><img src="https://i.csms.tech/img_61.png"></p>
<span id="more"></span>

<p>默认情况下，使用了 <code>hostNetwork: true</code> 配置的 <code>Pod</code>，无法使用集群内部的 DNS （如 <code>CoreDNS</code>）进行域名解析，除非 <code>dnsPolicy</code> 字段配置值为 <code>ClusterFirstWithHostNet</code>。</p>
<p>如果 <code>ingress-nginx-controller</code> 需要解析集群内部的域名，需要在 <code>Deployment</code> 中的 <code>.spec.template.spec</code> 修改以下配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dnsPolicy: ClusterFirstWithHostNet</span><br></pre></td></tr></table></figure>


<p>此种模式之下，<code>ingress-nginx-controller</code> 的 <code>Pod</code> 会绑定主机端口的 80 和 443 端口。此方式不需要创建暴露 <code>ingress-nginx-controller</code> 的 <code>Service</code>，如果有，建议删除<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Via the host network](https://kubernetes.github.io/ingress-nginx/deploy/baremetal/#via-the-host-network)">[1]</span></a></sup> </p>
<figure class="highlight shell"><figcaption><span>ingress-nginx-controller-v1.3.1.yaml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">---</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">apiVersion: v1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">kind: Service</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">metadata:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> labels:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   app.kubernetes.io/component: controller</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   app.kubernetes.io/instance: ingress-nginx</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   app.kubernetes.io/name: ingress-nginx</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   app.kubernetes.io/part-of: ingress-nginx</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   app.kubernetes.io/version: 1.3.1</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> name: ingress-nginx-controller</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> namespace: ingress-nginx</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">spec:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> externalTrafficPolicy: Local</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> ipFamilies:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> - IPv4</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> ipFamilyPolicy: SingleStack</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> ports:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> - appProtocol: http</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   name: http</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   port: 80</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   protocol: TCP</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   targetPort: http</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> - appProtocol: https</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   name: https</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   port: 443</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   protocol: TCP</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   targetPort: https</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> selector:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   app.kubernetes.io/component: controller</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   app.kubernetes.io/instance: ingress-nginx</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   app.kubernetes.io/name: ingress-nginx</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> <span class="built_in">type</span>: LoadBalancer</span></span><br></pre></td></tr></table></figure>

<p>在没有 <code>Service</code> 暴露 <code>ingress-nginx-controller</code> 的 <code>Pod</code> 情况下，容器启动参数中的 <code>--publish-service</code> 将会为空（未使用），需要注释或删除此启动参数。部署之后 <code>Ingress</code> 对象中的 <code>ADDRESS</code> 将为空</p>
<figure class="highlight shell"><figcaption><span>Deployment.spec.template.spec.containers[*].args</span></figcaption><table><tr><td class="code"><pre><span class="line">spec:</span><br><span class="line">  hostNetwork: true</span><br><span class="line">  containers:</span><br><span class="line">  - args:</span><br><span class="line">    - /nginx-ingress-controller</span><br><span class="line">    #- --publish-service=$(POD_NAMESPACE)/ingress-nginx-controller</span><br><span class="line">    - --election-id=ingress-controller-leader</span><br><span class="line">    - --controller-class=k8s.io/ingress-nginx</span><br><span class="line">    - --ingress-class=nginx</span><br><span class="line">    - --configmap=$(POD_NAMESPACE)/ingress-nginx-controller</span><br><span class="line">    - --validating-webhook=:8443</span><br><span class="line">    - --validating-webhook-certificate=/usr/local/certificates/cert</span><br><span class="line">    - --validating-webhook-key=/usr/local/certificates/key</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>部署成功后，查看 <code>Service</code> 对象，结果中不包含 <code>service/ingress-nginx-controller</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get services -n ingress-nginx</span></span><br><span class="line">NAME                                 TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">ingress-nginx-controller-admission   ClusterIP   10.103.195.162   &lt;none&gt;        443/TCP   39s</span><br></pre></td></tr></table></figure>
<p>查看 <code>Ingress</code> 对象，<code>ADDRESS</code> 为空</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get ingress -A</span></span><br><span class="line">NAMESPACE   NAME              CLASS   HOSTS          ADDRESS   PORTS   AGE</span><br><span class="line">default     example-ingress   nginx   cs1.k8s.info             80      26h</span><br></pre></td></tr></table></figure>
<p>如果希望显示节点 IP 地址，可以为容器添加启动参数 <code>- --report-node-internal-ip-address</code></p>
<figure class="highlight shell"><figcaption><span>Deployment.spec.template.spec.containers[*].args</span></figcaption><table><tr><td class="code"><pre><span class="line">spec:</span><br><span class="line">  hostNetwork: true</span><br><span class="line">  containers:</span><br><span class="line">  - args:</span><br><span class="line">    - /nginx-ingress-controller</span><br><span class="line">    #- --publish-service=$(POD_NAMESPACE)/ingress-nginx-controller</span><br><span class="line">    - --election-id=ingress-controller-leader</span><br><span class="line">    - --controller-class=k8s.io/ingress-nginx</span><br><span class="line">    - --ingress-class=nginx</span><br><span class="line">    - --configmap=$(POD_NAMESPACE)/ingress-nginx-controller</span><br><span class="line">    - --validating-webhook=:8443</span><br><span class="line">    - --validating-webhook-certificate=/usr/local/certificates/cert</span><br><span class="line">    - --validating-webhook-key=/usr/local/certificates/key</span><br><span class="line">    - --report-node-internal-ip-address</span><br></pre></td></tr></table></figure>
<p>成功部署后，再次查看 <code>Ingress</code> 资源，<code>ADDRESS</code> 会上报节点的 IP</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get ingress -o wide</span></span><br><span class="line">NAME              CLASS   HOSTS          ADDRESS        PORTS   AGE</span><br><span class="line">example-ingress   nginx   cs1.k8s.info   172.31.0.230   80      27h</span><br></pre></td></tr></table></figure>

<p>此种模式下，集群中的每个节点上，只能有一个 <code>ingress-nginx-controller</code> 的 <code>Pod</code> 存在，因为不可能让同一个端口绑定多次。为了确保每个节点上只能调度一个 <code>ingress-nginx-controller</code> ，可以使用 <code>DaemonSet</code> 代替 <code>Deployment</code> 的方式来部署 <code>ingress-nginx-controller</code></p>
<p>默认情况下，<code>ingress-nginx-controller</code> 日志输出到 <code>stdout</code>，可以添加启动参数 <code>--log_dir=/var/log/nginx/</code> 指定日志输出目录</p>
<figure class="highlight shell"><figcaption><span>Deployment.spec.template.spec.containers[*].args</span></figcaption><table><tr><td class="code"><pre><span class="line">spec:</span><br><span class="line">  hostNetwork: true</span><br><span class="line">  containers:</span><br><span class="line">  - args:</span><br><span class="line">    - /nginx-ingress-controller</span><br><span class="line">    #- --publish-service=$(POD_NAMESPACE)/ingress-nginx-controller</span><br><span class="line">    - --election-id=ingress-controller-leader</span><br><span class="line">    - --controller-class=k8s.io/ingress-nginx</span><br><span class="line">    - --ingress-class=nginx</span><br><span class="line">    - --configmap=$(POD_NAMESPACE)/ingress-nginx-controller</span><br><span class="line">    - --validating-webhook=:8443</span><br><span class="line">    - --validating-webhook-certificate=/usr/local/certificates/cert</span><br><span class="line">    - --validating-webhook-key=/usr/local/certificates/key</span><br><span class="line">    - --report-node-internal-ip-address</span><br><span class="line">    </span><br><span class="line">    # controller 日志选项</span><br><span class="line">    - --log_dir=/var/log/nginx/</span><br><span class="line">    - --logtostderr=false</span><br></pre></td></tr></table></figure>
<p>修改配置后，使用以下命令使配置生效：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl apply -f ingress-nginx-controller-v1.3.1.yaml</span><br></pre></td></tr></table></figure>
<p>使用以下命令删除此配置部署得相关资源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl delete -f ingress-nginx-controller-v1.3.1.yaml</span><br></pre></td></tr></table></figure>

<h2 id="ingress-nginx-相关配置"><a href="#ingress-nginx-相关配置" class="headerlink" title="ingress-nginx 相关配置"></a>ingress-nginx 相关配置</h2><p>自定义 nginx 配置，可以使用以下 3 种方式</p>
<ul>
<li><code>ConfigMap</code> - 使用 <code>Configmap</code> 配置部署 nginx 全局配置</li>
<li><code>Annotations</code> - 使用 <code>Annotations</code> 为特定的 <code>Ingress rule</code> 部署个性化的配置</li>
<li><code>Custom template</code> -</li>
</ul>
<h3 id="Annotations-配置说明"><a href="#Annotations-配置说明" class="headerlink" title="Annotations 配置说明"></a>Annotations 配置说明</h3><p><strong><code>Annotation</code> 配置中，<code>key</code> 和 <code>value</code> 只能是字符串类型的值</strong>。 </p>
<h4 id="rewrite-target"><a href="#rewrite-target" class="headerlink" title="rewrite-target"></a>rewrite-target</h4><p><code>rewrite-target</code> 示例 <sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Rewrite Target](https://kubernetes.github.io/ingress-nginx/examples/rewrite/#examples)">[3]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    nginx.ingress.kubernetes.io/rewrite-target: /$2</span><br><span class="line">  name: rewrite</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  ingressClassName: nginx</span><br><span class="line">  rules:</span><br><span class="line">  - host: rewrite.bar.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path: /something(/|$)(.*)</span><br><span class="line">        pathType: Prefix</span><br><span class="line">        backend:</span><br><span class="line">          service:</span><br><span class="line">            name: http-svc</span><br><span class="line">            port: </span><br><span class="line">              number: 80</span><br></pre></td></tr></table></figure>
<p><code>path</code> 中捕获到的匹配组会被分别放置在 <code>$1</code>,<code>$2</code>,’$3’…<code>$n</code>，可在 <code>rewrite-target</code> 中使用</p>
<p>本示例中，会产生如下效果：</p>
<ul>
<li><code>rewrite.bar.com/something</code> rewrites to <code>rewrite.bar.com/</code></li>
<li><code>rewrite.bar.com/something/</code> rewrites to <code>rewrite.bar.com/</code></li>
<li><code>rewrite.bar.com/something/new</code> rewrites to <code>rewrite.bar.com/new</code></li>
</ul>
<h4 id="app-root"><a href="#app-root" class="headerlink" title="app-root"></a>app-root</h4><p>将 <code>path</code> 中的 <code>/</code> 重写为 <code>nginx.ingress.kubernetes.io/app-root</code> 定义的内容 <sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[App Root](https://kubernetes.github.io/ingress-nginx/examples/rewrite/#app-root)">[4]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    nginx.ingress.kubernetes.io/app-root: /app1</span><br><span class="line">  name: approot</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  ingressClassName: nginx</span><br><span class="line">  rules:</span><br><span class="line">  - host: approot.bar.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path: /</span><br><span class="line">        pathType: Prefix</span><br><span class="line">        backend:</span><br><span class="line">          service:</span><br><span class="line">            name: http-svc</span><br><span class="line">            port: </span><br><span class="line">              number: 80</span><br></pre></td></tr></table></figure>
<p>验证结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -I -k http://approot.bar.com/</span></span><br><span class="line">HTTP/1.1 302 Moved Temporarily</span><br><span class="line">Server: nginx/1.11.10</span><br><span class="line">Date: Mon, 13 Mar 2017 14:57:15 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 162</span><br><span class="line">Location: http://approot.bar.com/app1</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>

<h4 id="ssl-redirect"><a href="#ssl-redirect" class="headerlink" title="ssl-redirect"></a>ssl-redirect</h4><p>默认情况下，如果 <code>Ingress</code> 中配置了 tls ，HTTP 请求会被重定向到 HTTPS （308），要更改此行为，可以配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx.ingress.kubernetes.io/ssl-redirect: &quot;false&quot;</span><br></pre></td></tr></table></figure>

<h4 id="Redirect-from-x2F-to-www"><a href="#Redirect-from-x2F-to-www" class="headerlink" title="Redirect from&#x2F;to www"></a>Redirect from&#x2F;to www</h4><p>将 <code>www.domain.com</code> 重定向到 <code>domain.com</code>，或者将 <code>domain.com</code> 重定向到 <code>www.domain.com</code> <sup id="fnref:7"><a href="#fn:7" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Redirect from/to www](https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#redirect-fromto-www)">[7]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx.ingress.kubernetes.io/from-to-www-redirect: &quot;true&quot;</span><br></pre></td></tr></table></figure>

<h4 id="Session-Affinity"><a href="#Session-Affinity" class="headerlink" title="Session Affinity"></a>Session Affinity</h4><ul>
<li><code>nginx.ingress.kubernetes.io/affinity: cookie</code><br>会话亲和性，会话保持。<code>ingress-nginx</code> 支持的值唯有 <code>cookie</code> <sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Session Affinity](https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#session-affinity)">[5]</span></a></sup></li>
<li><code>nginx.ingress.kubernetes.io/affinity-mode</code><br>定义会话保持的黏合程度。可取以下值：<ul>
<li><code>balanced</code> - <code>Pod</code> 扩容或缩减后重新分配 sessions</li>
<li><code>persistent</code> - <code>Pod</code> 扩容或缩减后依旧保持会话，不重新分配 sessions</li>
</ul>
</li>
</ul>
<h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><p>跨域相关配置 <sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Enable CORS](https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#enable-cors)">[6]</span></a></sup></p>
<table>
<thead>
<tr>
<th>key</th>
<th>value</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>cors-allow-methods</code></td>
<td>默认值 <code>GET, PUT, POST, DELETE, PATCH, OPTIONS</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>cors-allow-headers</code></td>
<td>Default: <code>DNT,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>cors-allow-origin</code></td>
<td>Default: <code>*</code></td>
<td></td>
<td><code>nginx.ingress.kubernetes.io/cors-allow-origin: &quot;https://origin-site.com:4443, http://origin-site.com, https://example.org:1199&quot;</code></td>
</tr>
</tbody></table>
<h4 id="Server-snippet"><a href="#Server-snippet" class="headerlink" title="Server snippet"></a>Server snippet</h4><p>通过此配置，可以添加自定义配置到 nginx 的 <code>server</code> 配置中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    nginx.ingress.kubernetes.io/server-snippet: |</span><br><span class="line">        set $agentflag 0;</span><br><span class="line"></span><br><span class="line">        if ($http_user_agent ~* &quot;(Mobile)&quot; )&#123;</span><br><span class="line">          set $agentflag 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if ( $agentflag = 1 ) &#123;</span><br><span class="line">          return 301 https://m.example.com;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>


<h4 id="Client-Body-Buffer-Size"><a href="#Client-Body-Buffer-Size" class="headerlink" title="Client Body Buffer Size"></a>Client Body Buffer Size</h4><figure class="highlight shell"><figcaption><span>Example</span></figcaption><table><tr><td class="code"><pre><span class="line">nginx.ingress.kubernetes.io/client-body-buffer-size: &quot;1000&quot; # 1000 bytes</span><br><span class="line">nginx.ingress.kubernetes.io/client-body-buffer-size: 1k # 1 kilobyte</span><br><span class="line">nginx.ingress.kubernetes.io/client-body-buffer-size: 1K # 1 kilobyte</span><br><span class="line">nginx.ingress.kubernetes.io/client-body-buffer-size: 1m # 1 megabyte</span><br><span class="line">nginx.ingress.kubernetes.io/client-body-buffer-size: 1M # 1 megabyte</span><br></pre></td></tr></table></figure>
<h4 id="Permanent-Redirect"><a href="#Permanent-Redirect" class="headerlink" title="Permanent Redirect"></a>Permanent Redirect</h4><p>返回永久重定向 （301）</p>
<figure class="highlight shell"><figcaption><span>Example</span></figcaption><table><tr><td class="code"><pre><span class="line">nginx.ingress.kubernetes.io/permanent-redirect: &#x27;https://www.google.com&#x27;</span><br></pre></td></tr></table></figure>


<h4 id="Temporal-Redirect"><a href="#Temporal-Redirect" class="headerlink" title="Temporal Redirect"></a>Temporal Redirect</h4><p>临时重定向 （302）</p>
<figure class="highlight shell"><figcaption><span>Example</span></figcaption><table><tr><td class="code"><pre><span class="line">nginx.ingress.kubernetes.io/temporal-redirect: &#x27;https://www.google.com&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="Whitelist-source-range"><a href="#Whitelist-source-range" class="headerlink" title="Whitelist source range"></a>Whitelist source range</h4><p>访问白名单配置 <sup id="fnref:8"><a href="#fn:8" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Whitelist source range](https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#whitelist-source-range)">[8]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx.ingress.kubernetes.io/whitelist-source-range: &#x27;10.0.0.0/24,172.10.0.1&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="Custom-timeouts"><a href="#Custom-timeouts" class="headerlink" title="Custom timeouts"></a>Custom timeouts</h4><p>自定义超时时间，所有的超时时间单位为秒 <sup id="fnref:9"><a href="#fn:9" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Custom timeouts](https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#custom-timeouts)">[9]</span></a></sup></p>
<ul>
<li><code>nginx.ingress.kubernetes.io/proxy-connect-timeout</code></li>
<li><code>nginx.ingress.kubernetes.io/proxy-send-timeout</code></li>
<li><code>nginx.ingress.kubernetes.io/proxy-read-timeout</code></li>
<li><code>nginx.ingress.kubernetes.io/proxy-next-upstream</code></li>
<li><code>nginx.ingress.kubernetes.io/proxy-next-upstream-timeout</code></li>
<li><code>nginx.ingress.kubernetes.io/proxy-next-upstream-tries</code></li>
<li><code>nginx.ingress.kubernetes.io/proxy-request-buffering</code></li>
</ul>
<h4 id="Custom-max-body-size"><a href="#Custom-max-body-size" class="headerlink" title="Custom max body size"></a>Custom max body size</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx.ingress.kubernetes.io/proxy-body-size: 8m</span><br></pre></td></tr></table></figure>
<h3 id="ConfigMaps-配置说明"><a href="#ConfigMaps-配置说明" class="headerlink" title="ConfigMaps 配置说明"></a>ConfigMaps 配置说明</h3><p>使用 <code>ConfigMaps</code> 方式配置 nginx 参数 <sup id="fnref:10"><a href="#fn:10" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Configuration options](https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/#configuration-options)">[10]</span></a></sup></p>
<blockquote>
<p>The key and values in a ConfigMap can only be strings. This means that we want a value with boolean values we need to quote the values, like “true” or “false”. Same for numbers, like “100”.</p>
</blockquote>
<h4 id="Log-format"><a href="#Log-format" class="headerlink" title="Log format"></a>Log format</h4><p>默认情况下，Access 日至输出到 <code>/var/log/nginx/access.log</code>，软链接到了 <code>/dev/stdout</code> <sup id="fnref:11"><a href="#fn:11" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[access-log-path](https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/#access-log-path)">[11]</span></a></sup></p>
<p><a href="https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/log-format/">默认日志格式及可用变量</a></p>
<p>要更改默认的日志格式，编辑 <code>ingress-nginx-controller</code> 的部署配置文件，部署 <code>ConfigMap</code> </p>
<figure class="highlight shell"><figcaption><span>ingress-nginx-controller-v1.3.1.yaml</span></figcaption><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app.kubernetes.io/component: controller</span><br><span class="line">    app.kubernetes.io/instance: ingress-nginx</span><br><span class="line">    app.kubernetes.io/name: ingress-nginx</span><br><span class="line">    app.kubernetes.io/part-of: ingress-nginx</span><br><span class="line">    app.kubernetes.io/version: 1.3.1</span><br><span class="line">  name: ingress-nginx-controller</span><br><span class="line">  namespace: ingress-nginx</span><br><span class="line">data:</span><br><span class="line">  allow-snippet-annotations: &quot;true&quot;</span><br><span class="line"></span><br><span class="line">  log-format-upstream: &quot;&#123; time: $time_iso8601|http_host:$http_host|cdn_ip:$remote_addr|request:$request|request_method:$request_method|http_user_agent:$http_user_agent|size:$body_bytes_sent|responsetime:$request_time|upstreamtime:$upstream_response_time|upstreamhost:$upstream_addr|upstreamstatus:$upstream_status|url:$http_host$uri|http_x_forwarded_for:$http_x_forwarded_for|referer:$http_referer|server_protocol:$server_protocol|status:$status&#125;&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>部署 <code>ingress-nginx-controller</code> 后，检查 nginx 配置中的 <code>log-format</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl <span class="built_in">cp</span> -n ingress-nginx ingress-nginx-controller-nxkwq:/etc/nginx/nginx.conf temp.nginx.conf</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> temp.nginx.conf</span></span><br><span class="line">...</span><br><span class="line">log_format upstreaminfo &#x27;&#123; time: $time_iso8601|http_host:$http_host|cdn_ip:$remote_addr|request:$request|reque</span><br><span class="line">st_method:$request_method|http_user_agent:$http_user_agent|size:$body_bytes_sent|responsetime:$request_time|upstreamti</span><br><span class="line">me:$upstream_response_time|upstreamhost:$upstream_addr|upstreamstatus:$upstream_status|url:$http_host$uri|http_x_forwa</span><br><span class="line">rded_for:$http_x_forwarded_for|referer:$http_referer|server_protocol:$server_protocol|status:$status&#125;&#x27;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在 <code>Ingress</code> 资源中使用此 <code>log_format</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kind: Ingress</span><br><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">metadata:</span><br><span class="line">  name: example-ingress</span><br><span class="line">  namespace: default</span><br><span class="line"></span><br><span class="line">  annotations:</span><br><span class="line">    nginx.ingress.kubernetes.io/configuration-snippet: |</span><br><span class="line">      access_log /var/log/nginx/example-ingress.access.log upstreaminfo;</span><br><span class="line">      error_log /var/log/nginx/example-ingress.err.log;</span><br></pre></td></tr></table></figure>
<p>部署成功后，查看 nginx 配置中关于域名的配置，在此 <code>Ingress</code> 资源中配置的每个域名的 <code>server</code> 配置段中会包含此日志配置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl <span class="built_in">cp</span> -n ingress-nginx ingress-nginx-controller-nxkwq:/etc/nginx/nginx.conf temp.nginx.conf</span></span><br><span class="line">cat temp.nginx.conf</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">access_log /var/log/nginx/example-ingress.access.log upstreaminfo if=$loggable;</span><br><span class="line">error_log /var/log/nginx/example-ingress.err.log;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><h3 id="证书部署后未生效"><a href="#证书部署后未生效" class="headerlink" title="证书部署后未生效"></a>证书部署后未生效</h3><p>证书部署后，通过域名访问，浏览器提示域名不安全，未使用证书。检查 <code>ingress-nginx-controller</code> 日志，报错 <code>Error getting SSL certificate &quot;default/cs.k8s.info&quot;: local SSL certificate default/cs.k8s.info was not found. Using default certificate</code></p>
<p>将 nginx 配置文件拷贝出来查看，发现配置中未配置相关域名的证书</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl cp -n ingress-nginx ingress-nginx-controller-cjxt5:/etc/nginx/nginx.conf temp.nginx.conf</span><br></pre></td></tr></table></figure>



<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://kubernetes.github.io/ingress-nginx/deploy/baremetal/">裸机注意事项</a></p>
<h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.github.io/ingress-nginx/deploy/baremetal/#via-the-host-network">Via the host network</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/">Ingress NGINX Configuration</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.github.io/ingress-nginx/examples/rewrite/#examples">Rewrite Target</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.github.io/ingress-nginx/examples/rewrite/#app-root">App Root</a><a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#session-affinity">Session Affinity</a><a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#enable-cors">Enable CORS</a><a href="#fnref:6" rev="footnote"> ↩</a></span></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#redirect-fromto-www">Redirect from/to www</a><a href="#fnref:7" rev="footnote"> ↩</a></span></li><li id="fn:8"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">8.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#whitelist-source-range">Whitelist source range</a><a href="#fnref:8" rev="footnote"> ↩</a></span></li><li id="fn:9"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">9.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#custom-timeouts">Custom timeouts</a><a href="#fnref:9" rev="footnote"> ↩</a></span></li><li id="fn:10"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">10.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/#configuration-options">Configuration options</a><a href="#fnref:10" rev="footnote"> ↩</a></span></li><li id="fn:11"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">11.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/#access-log-path">access-log-path</a><a href="#fnref:11" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes 监控</title>
    <url>/202305231329/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos 7</li>
<li>Kubernetes 1.24</li>
</ul>
<h1 id="Kubernetes-Metrics-Server"><a href="#Kubernetes-Metrics-Server" class="headerlink" title="Kubernetes Metrics Server"></a>Kubernetes Metrics Server</h1><p>Kubernetes Metrics Server 从 <code>kubelet</code> 收集资源使用指标（情况）并通过 Metrics API 将其暴露给 Kubernetes API Server，以供 HPA(Horizontal Pod Autoscaler) 和 VPA(Vertical Pod Autoscaler) 使用。<code>kubectl top</code> 也使用 Metrics API。<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[metrics-server](https://github.com/kubernetes-sigs/metrics-server)">[1]</span></a></sup></p>
<h2 id="安装-Kubernetes-Metrics-Server"><a href="#安装-Kubernetes-Metrics-Server" class="headerlink" title="安装 Kubernetes Metrics Server"></a>安装 Kubernetes Metrics Server</h2><p>Kubernetes Metrics Server 安装之前必须要开启 kube api-server 的聚合层功能以及认证鉴权功能 <sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[配置聚合层](https://kubernetes.io/zh-cn/docs/tasks/extend-kubernetes/configure-aggregation-layer/)">[3]</span></a></sup> </p>
<p>检查 Kubernetes API Server 是否启用了聚合层功能及认证鉴权功能</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps -ef | grep apiserver | grep -E <span class="string">&quot;authorization-mode|enable-aggregator-routing&quot;</span></span></span><br><span class="line">root       390   369  7 13:55 ?        00:00:37 kube-apiserver --advertise-address=172.31.26.116 \</span><br><span class="line">                                                               --allow-privileged=true \</span><br><span class="line">                                                               --authorization-mode=Node,RBAC \</span><br><span class="line">                                                               --client-ca-file=/etc/kubernetes/pki/ca.crt \</span><br><span class="line">                                                               --enable-admission-plugins=NodeRestriction \</span><br><span class="line">                                                               --enable-bootstrap-token-auth=true \</span><br><span class="line">                                                               --etcd-cafile=/etc/kubernetes/pki/etcd/ca.crt \</span><br><span class="line">                                                               --etcd-certfile=/etc/kubernetes/pki/apiserver-etcd-client.crt \</span><br><span class="line">                                                               --etcd-keyfile=/etc/kubernetes/pki/apiserver-etcd-client.key \</span><br><span class="line">                                                               --etcd-servers=https://127.0.0.1:2379 \</span><br><span class="line">                                                               --kubelet-client-certificate=/etc/kubernetes/pki/apiserver-kubelet-client.crt --kubelet-client-key=/etc/kubernetes/pki/apiserver-kubelet-client.key \</span><br><span class="line">                                                               --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname \</span><br><span class="line">                                                               --proxy-client-cert-file=/etc/kubernetes/pki/front-proxy-client.crt \</span><br><span class="line">                                                               --proxy-client-key-file=/etc/kubernetes/pki/front-proxy-client.key \</span><br><span class="line">                                                               --requestheader-allowed-names=front-proxy-client \</span><br><span class="line">                                                               --requestheader-client-ca-file=/etc/kubernetes/pki/front-proxy-ca.crt \</span><br><span class="line">                                                               --requestheader-extra-headers-prefix=X-Remote-Extra- \</span><br><span class="line">                                                               --requestheader-group-headers=X-Remote-Group \</span><br><span class="line">                                                               --requestheader-username-headers=X-Remote-User \</span><br><span class="line">                                                               --secure-port=6443 --service-account-issuer=https://kubernetes.default.svc.cluster.local \</span><br><span class="line">                                                               --service-account-key-file=/etc/kubernetes/pki/sa.pub \</span><br><span class="line">                                                               --service-account-signing-key-file=/etc/kubernetes/pki/sa.key \</span><br><span class="line">                                                               --service-cluster-ip-range=10.96.0.0/12 \</span><br><span class="line">                                                               --tls-cert-file=/etc/kubernetes/pki/apiserver.crt --tls-private-key-file=/etc/kubernetes/pki/apiserver.key \</span><br><span class="line">                                                               --enable-aggregator-routing=true</span><br></pre></td></tr></table></figure>
<p>输出中包含了 <code>--authorization-mode=Node,RBAC</code> 和 <code>--enable-aggregator-routing=true</code>，表示已开启对应功能。如若未开启，修改 <code>api-server</code> 的 manifest 文件 <code>/etc/kubernetes/manifests/kube-apiserver.yaml</code>，在 <code>kube-apiserver</code> 的启动参数中添加 <code>--enable-aggregator-routing=true</code> 和 <code>--authorization-mode=Node,RBAC</code></p>
<p>以下命令使用 yaml 文件安装最新版本 Metrics Server <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[metrics-server installation](https://github.com/kubernetes-sigs/metrics-server#installation)">[2]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml</span><br></pre></td></tr></table></figure>

<h2 id="Kubernetes-Metrics-Server-部署配置常见错误"><a href="#Kubernetes-Metrics-Server-部署配置常见错误" class="headerlink" title="Kubernetes Metrics Server 部署配置常见错误"></a>Kubernetes Metrics Server 部署配置常见错误</h2><h3 id="Failed-to-scrape-node"><a href="#Failed-to-scrape-node" class="headerlink" title="Failed to scrape node"></a>Failed to scrape node</h3><p><a href="#%E5%AE%89%E8%A3%85-Kubernetes-Metrics-Server">参考部署步骤</a> 部署后，Metrics Server 的 Pod 一直处于未就绪状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods -A | grep metrics</span></span><br><span class="line">kube-system                 metrics-server-5cdf47479d-rwtd6             0/1     Running       0              5m53s</span><br></pre></td></tr></table></figure>
<p>检查 Pod 日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl logs -n kube-system metrics-server-5cdf47479d-rwtd6</span></span><br><span class="line">1 scraper.go:140] &quot;Failed to scrape node&quot; err=&quot;Get \&quot;https://172.31.21.3:10250/metrics/resource\&quot;: x509: cannot validate certificate for 172.31.21.3 because it doesn&#x27;t contain any IP SANs&quot; node=&quot;k8smaster3&quot;</span><br><span class="line">1 scraper.go:140] &quot;Failed to scrape node&quot; err=&quot;Get \&quot;https://172.31.26.116:10250/metrics/resource\&quot;: x509: cannot validate certificate for 172.31.26.116 because it doesn&#x27;t contain any IP SANs&quot; node=&quot;k8smaster1&quot;</span><br><span class="line">1 scraper.go:140] &quot;Failed to scrape node&quot; err=&quot;Get \&quot;https://172.31.19.164:10250/metrics/resource\&quot;: x509: cannot validate certificate for 172.31.19.164 because it doesn&#x27;t contain any IP SANs&quot; node=&quot;k8smaster2&quot;</span><br></pre></td></tr></table></figure>
<p>根据日志提示，由于 metrics-server 未获得TLS Bootstrap 签发证书的导致访问各节点资源时报错。</p>
<ol>
<li><a href="https://www.modb.pro/db/408792">参考解决办法</a></li>
<li>添加选项 <code>--kubelet-insecure-tls</code> 不验证 Kubelet 的 CA 证书 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - args:</span><br><span class="line">    - --cert-dir=/tmp</span><br><span class="line">    - --secure-port=4443</span><br><span class="line">    - --kubelet-preferred-address-types=InternalIP</span><br><span class="line">    - --kubelet-use-node-status-port</span><br><span class="line">    - --metric-resolution=15s</span><br><span class="line">    - --kubelet-insecure-tls</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="no-such-host"><a href="#no-such-host" class="headerlink" title="no such host"></a>no such host</h3><p><a href="#%E5%AE%89%E8%A3%85-Kubernetes-Metrics-Server">参考部署步骤</a> 部署后，Metrics Server 的 Pod 一直处于未就绪状态，检查 Pod 日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl logs -n kube-system metrics-server-5cdf47479d-rwtd6</span></span><br><span class="line">&quot;Failed to scrape node&quot; err=&quot;Get \&quot;https://k8smaster1:10250/metrics/resource\&quot;: dial tcp: lookup k8smaster1 on 10.96.0.10:53: no such host&quot; node=&quot;k8smaster1&quot;</span><br><span class="line">&quot;Failed probe&quot; probe=&quot;metric-storage-ready&quot; err=&quot;no metrics to serve&quot;</span><br><span class="line">&quot;Failed to scrape node&quot; err=&quot;Get \&quot;https://k8smaster1:10250/metrics/resource\&quot;: dial tcp: lookup k8smaster1 on 10.96.0.10:53: no such host&quot; node=&quot;k8smaster1&quot;</span><br><span class="line">&quot;Failed to scrape node&quot; err=&quot;Get \&quot;https://k8smaster3:10250/metrics/resource\&quot;: dial tcp: lookup k8smaster3 on 10.96.0.10:53: no such host&quot; node=&quot;k8smaster3&quot;</span><br><span class="line">&quot;Failed to scrape node&quot; err=&quot;Get \&quot;https://k8sworker1:10250/metrics/resource\&quot;: dial tcp: lookup k8sworker1 on 10.96.0.10:53: no such host&quot; node=&quot;k8sworker1&quot;</span><br><span class="line">&quot;Failed to scrape node&quot; err=&quot;Get \&quot;https://k8sworker2:10250/metrics/resource\&quot;: dial tcp: lookup k8sworker2 on 10.96.0.10:53: no such host&quot; node=&quot;k8sworker2&quot;</span><br><span class="line">&quot;Failed to scrape node&quot; err=&quot;Get \&quot;https://k8smaster2:10250/metrics/resource\&quot;: dial tcp: lookup k8smaster2 on 10.96.0.10:53: no such host&quot; node=&quot;k8smaster2&quot;</span><br><span class="line">&quot;Failed probe&quot; probe=&quot;metric-storage-ready&quot; err=&quot;no metrics to serve&quot;</span><br><span class="line">I0524 09:32:43.033797       1 server.go:187] &quot;Failed probe&quot; probe=&quot;metric-storage-ready&quot; err=&quot;no metrics to serve&quot;</span><br></pre></td></tr></table></figure>
<p>根据日志显示，API Server 的主机名解析存在问题。这是因为节点主机名在集群的 DNS 中无法解析导致，可以通过在 Metrics Server 的 Pod 中手动添加解析解决</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: metrics-server</span><br><span class="line">spec:</span><br><span class="line">  hostAliases:</span><br><span class="line">  - ip: &#x27;172.31.26.116&#x27;</span><br><span class="line">    hostnames:</span><br><span class="line">    - &#x27;fm-k8s-c1-master1&#x27;</span><br><span class="line">  - ip: &#x27;172.31.19.164&#x27;</span><br><span class="line">    hostnames:</span><br><span class="line">    - &#x27;fm-k8s-c1-master2&#x27;</span><br><span class="line">  - ip: &#x27;172.31.21.3&#x27;</span><br><span class="line">    hostnames:</span><br><span class="line">    - &#x27;fm-k8s-c1-master3&#x27;</span><br><span class="line">  - ip: &#x27;172.31.16.124&#x27;</span><br><span class="line">    hostnames:</span><br><span class="line">    - &#x27;fm-k8s-c1-worker1&#x27;</span><br><span class="line">  - ip: &#x27;172.31.22.159&#x27;</span><br><span class="line">    hostnames:</span><br><span class="line">    - &#x27;fm-k8s-c1-worker2&#x27;</span><br><span class="line">  containers:</span><br><span class="line">  - args:</span><br><span class="line">    - --cert-dir=/tmp</span><br><span class="line">    - --secure-port=4443</span><br><span class="line">    - --kubelet-preferred-address-types=Hostname</span><br><span class="line">    - --kubelet-use-node-status-port</span><br><span class="line">    - --metric-resolution=15s</span><br><span class="line">    image: registry.k8s.io/metrics-server/metrics-server:v0.6.3</span><br></pre></td></tr></table></figure>

<h2 id="Metrics-Server-无法获取所在节点的主机的监控信息"><a href="#Metrics-Server-无法获取所在节点的主机的监控信息" class="headerlink" title="Metrics Server 无法获取所在节点的主机的监控信息"></a>Metrics Server 无法获取所在节点的主机的监控信息</h2><p>Metrics Server 部署成功后，无法获取所在节点的主机的监控信息，获取其他主机的监控信息正常，具体信息如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get nodes -o wide</span></span><br><span class="line">NAME          STATUS   ROLES           AGE    VERSION   INTERNAL-IP     EXTERNAL-IP   OS-IMAGE                KERNEL-VERSION                CONTAINER-RUNTIME</span><br><span class="line">k8s-master1   Ready    control-plane   169d   v1.24.7   172.31.26.116   &lt;none&gt;        CentOS Linux 7 (Core)   5.4.225-1.el7.elrepo.x86_64   docker://20.10.9</span><br><span class="line">k8s-master2   Ready    control-plane   169d   v1.24.7   172.31.19.164   &lt;none&gt;        CentOS Linux 7 (Core)   5.4.225-1.el7.elrepo.x86_64   docker://20.10.9</span><br><span class="line">k8s-master3   Ready    control-plane   169d   v1.24.7   172.31.21.3     &lt;none&gt;        CentOS Linux 7 (Core)   5.4.225-1.el7.elrepo.x86_64   docker://20.10.9</span><br><span class="line">k8s-worker1   Ready    &lt;none&gt;          169d   v1.24.7   172.31.16.124   &lt;none&gt;        CentOS Linux 7 (Core)   5.4.225-1.el7.elrepo.x86_64   docker://20.10.9</span><br><span class="line">k8s-worker2   Ready    &lt;none&gt;          169d   v1.24.7   172.31.22.159   &lt;none&gt;        CentOS Linux 7 (Core)   3.10.0-1160.80.1.el7.x86_64   docker://20.10.9</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods -A | grep met</span></span><br><span class="line">metrics-server-c48655c66-jxwpt             1/1     Running   0              12m    10.244.4.138    k8s-worker1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl top node</span></span><br><span class="line">NAME          CPU(cores)   CPU%        MEMORY(bytes)   MEMORY%     </span><br><span class="line">k8s-master1   381m         9%          3263Mi          43%         </span><br><span class="line">k8s-master2   149m         3%          3432Mi          45%         </span><br><span class="line">k8s-master3   166m         4%          3163Mi          41%         </span><br><span class="line">k8s-worker2   2093m        13%         21933Mi         71%         </span><br><span class="line">k8s-worker1   &lt;unknown&gt;    &lt;unknown&gt;   &lt;unknown&gt;       &lt;unknown&gt; </span><br></pre></td></tr></table></figure>

<p>查看 Metrics Server Pod 日志，显示</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl logs -n kube-system metrics-server-c48655c66-jxwpt</span></span><br><span class="line">E0525 05:19:42.085468       1 scraper.go:140] &quot;Failed to scrape node&quot; err=&quot;Get \&quot;https://172.31.16.124:10250/metrics/resource\&quot;: dial tcp 172.31.16.124:10250: connect: no route to host&quot; node=&quot;fm-k8s-c1-worker1&quot;</span><br><span class="line">E0525 05:19:57.125457       1 scraper.go:140] &quot;Failed to scrape node&quot; err=&quot;Get \&quot;https://172.31.16.124:10250/metrics/resource\&quot;: dial tcp 172.31.16.124:10250: connect: no route to host&quot; node=&quot;fm-k8s-c1-worker1&quot;</span><br><span class="line">E0525 05:20:12.101468       1 scraper.go:140] &quot;Failed to scrape node&quot; err=&quot;Get \&quot;https://172.31.16.124:10250/metrics/resource\&quot;: dial tcp 172.31.16.124:10250: connect: no route to host&quot; node=&quot;fm-k8s-c1-worker1&quot;</span><br><span class="line">E0525 05:20:27.077495       1 scraper.go:140] &quot;Failed to scrape node&quot; err=&quot;Get \&quot;https://172.31.16.124:10250/metrics/resource\&quot;: dial tcp 172.31.16.124:10250: connect: no route to host&quot; node=&quot;fm-k8s-c1-worker1&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>根据日志显示，是因为无法连接节点的 kubelet (端口 10250) 导致。为了定位问题，修改 Metrics Server 的部署 Yaml 文件，在其中加入一个容器，来方便使用工具测试问题。参考以下内容，在 Pod 中加入容器 <code>centos:centos7.9.2009</code></p>
<figure class="highlight shell"><figcaption><span>metrics-server.yaml</span></figcaption><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: metrics-server</span><br><span class="line">  name: metrics-server</span><br><span class="line">  namespace: kube-system</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      k8s-app: metrics-server</span><br><span class="line">  strategy:</span><br><span class="line">    rollingUpdate:</span><br><span class="line">      maxUnavailable: 0</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        k8s-app: metrics-server</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - image: centos:centos7.9.2009</span><br><span class="line">        command:</span><br><span class="line">        - ping</span><br><span class="line">        - 127.0.0.1</span><br><span class="line">        name: centos7</span><br><span class="line">      - args:</span><br><span class="line">        - --cert-dir=/tmp</span><br><span class="line">        - --secure-port=4443</span><br><span class="line">        - --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname</span><br><span class="line">        - --kubelet-use-node-status-port</span><br><span class="line">        - --metric-resolution=15s</span><br><span class="line">        - --kubelet-insecure-tls</span><br><span class="line">        image: registry.k8s.io/metrics-server/metrics-server:v0.6.3</span><br><span class="line">        imagePullPolicy: IfNotPresent</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<p>重新部署后，登陆容器 <code>centos7</code>，安装所需工具进行测试。根据日志信息，首先测试 Pod 是否能连接到节点的 kubelet</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -v 172.31.16.124:10250</span></span><br><span class="line">* About to connect() to 172.31.16.124 port 10250 (#0)</span><br><span class="line">*   Trying 172.31.16.124...</span><br><span class="line">* No route to host</span><br><span class="line">* Failed connect to 172.31.16.124:10250; No route to host</span><br><span class="line">* Closing connection 0</span><br><span class="line">curl: (7) Failed connect to 172.31.16.124:10250; No route to host</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -v 172.31.22.159:10250</span></span><br><span class="line">* About to connect() to 172.31.22.159 port 10250 (#0)</span><br><span class="line">*   Trying 172.31.22.159...</span><br><span class="line">* Connected to 172.31.22.159 (172.31.22.159) port 10250 (#0)</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">GET / HTTP/1.1</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">User-Agent: curl/7.29.0</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Host: 172.31.22.159:10250</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Accept: */*</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">* HTTP 1.0, assume close after body</span></span><br><span class="line">&lt; HTTP/1.0 400 Bad Request</span><br><span class="line">&lt; </span><br><span class="line">Client sent an HTTP request to an HTTPS server.</span><br><span class="line">* Closing connection 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>根据以上测试，Metrics Server 的 Pod 无法连接所在节点 k8s-worker1（<code>172.31.16.124</code>）的 kubelet （<code>172.31.16.124:10250</code>），可以正常连接其他节点的 kubelet。由此可以确定问题原因。</p>
<p>考虑到 Metrics Server 的 Pod 只是访问不到宿主节点所在的 kubelet，可以访问其他节点的 kubelet，梳理其中的网络连同流程发现，<strong>在访问其他节点的 kubelet 时，Metrics Server Pod 的报文在流出宿主节点前，会被 SNAT 为宿主节点的出口 IP，报文源 IP 为 宿主节点的 IP。而访问宿主节点的 kubelet 的报文，其源 IP 为 Metrics Server Pod 的 IP，目的 IP 为宿主节点的 IP。怀疑可能因为集群节点上的 iptables 允许集群节点的 IP 访问 kubelet，而 Pod 的 IP 未被允许访问 kubelet</strong>。为验证此猜想，在节点 <code>k8s-worker1</code> 的 iptables 添加允许 Metrics Server Pod 的 IP 访问的规则进行测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -I INPUT 7 -s 10.244.4.138 -j ACCEPT</span><br></pre></td></tr></table></figure>
<p>再次测试和 kubelet 的连通性，发现可以正常连通，再次检查 <code>kubectl top node</code>，可以查到所有节点的监控数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -v 172.31.16.124:10250</span></span><br><span class="line">* About to connect() to 172.31.16.124 port 10250 (#0)</span><br><span class="line">*   Trying 172.31.16.124...</span><br><span class="line">* Connected to 172.31.16.124 (172.31.16.124) port 10250 (#0)</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">GET / HTTP/1.1</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">User-Agent: curl/7.29.0</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Host: 172.31.16.124:10250</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Accept: */*</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">* HTTP 1.0, assume close after body</span></span><br><span class="line">&lt; HTTP/1.0 400 Bad Request</span><br><span class="line">&lt; </span><br><span class="line">Client sent an HTTP request to an HTTPS server.</span><br><span class="line">* Closing connection 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl top node</span></span><br><span class="line">NAME                CPU(cores)   CPU%   MEMORY(bytes)   MEMORY%   </span><br><span class="line">fm-k8s-c1-master1   286m         7%     3242Mi          42%       </span><br><span class="line">fm-k8s-c1-master2   150m         3%     3262Mi          43%       </span><br><span class="line">fm-k8s-c1-master3   251m         6%     3247Mi          42%       </span><br><span class="line">fm-k8s-c1-worker1   166m         1%     4317Mi          13%       </span><br><span class="line">fm-k8s-c1-worker2   2013m        12%    21684Mi         70%</span><br></pre></td></tr></table></figure>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://github.com/kubernetes-sigs/metrics-server">metrics-server</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://github.com/kubernetes-sigs/metrics-server#installation">metrics-server installation</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/tasks/extend-kubernetes/configure-aggregation-layer/">配置聚合层</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes 网络数据包抓包分析</title>
    <url>/202210250956/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos7</li>
<li>Kubernetes 1.21</li>
<li>flannel 0.20</li>
</ul>
<p>为观察 Kubernetes 集群中跨主机 POD 之间的网络通信数据流，本文通过 tcpdump 抓包，对数据流向进行记录观察。</p>
<p>本示例中的 Kubernetes 集群由以下节点组成：</p>
<table>
<thead>
<tr>
<th>节点主机名</th>
<th>节点角色</th>
<th>节点 IP</th>
<th>节点上测试 POD IP</th>
</tr>
</thead>
<tbody><tr>
<td>master</td>
<td>master</td>
<td>eth0： 10.150.0.21</td>
<td>10.244.0.2</td>
</tr>
<tr>
<td>worker1</td>
<td>worker</td>
<td>eth0： 10.150.0.19</td>
<td>10.244.1.38</td>
</tr>
<tr>
<td>worker2</td>
<td>worker</td>
<td>eth0： 10.150.0.20</td>
<td>10.244.2.27</td>
</tr>
</tbody></table>
<h1 id="Flannel-简介"><a href="#Flannel-简介" class="headerlink" title="Flannel 简介"></a>Flannel 简介</h1><p>Kubernetes 系统上 POD 网络的实现依赖于第三方插件，Kubernetes 只负责提供了 CNI（容器网络接口），只要符合 CNI 规则的第三方插件都可以用于为 POD 提供网络实现。而 Flannel 是由 CoreOS 主推的目前比较主流的容器网络解决方案。</p>
<p>Flannel 支持三种不同后端实现，分别是：</p>
<ul>
<li>UDP</li>
<li>VXLAN</li>
<li>host-gw</li>
</ul>
<p>UDP 是 Flannel 项目最早支持的一种方式，是性能最差的方式，目前已被废弃。</p>
<p>用的最多的是 VXLAN 和 host-gw 模式的部署。</p>
<span id="more"></span>

<h2 id="VXLAN"><a href="#VXLAN" class="headerlink" title="VXLAN"></a>VXLAN</h2><p>Flannel 默认使用 VXLAN 模式。flannel 运行后，在各个宿主机配置了一个网络接口 <code>flannel.1</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ifconfig flannel.1</span></span><br><span class="line">flannel.1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1410</span><br><span class="line">        inet 10.244.0.0  netmask 255.255.255.255  broadcast 0.0.0.0</span><br><span class="line">        inet6 fe80::7c63:25ff:fea9:a780  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 7e:63:25:a9:a7:80  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 2857781  bytes 1505969406 (1.4 GiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 1946111  bytes 1603736503 (1.4 GiB)</span><br><span class="line">        TX errors 0  dropped 8 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>默认分配给集群 POD 的网段为 <code>10.244.0.0/16</code></p>
<p>flannel 给 master 节点配置的 Pod 网络为 <code>10.244.0.0/24</code> 段，给 <code>worker1</code> 节点配置的 Pod 网络为 <code>10.244.1.0/24</code> 段，如果有更多的节点，以此类推。</p>
<p>当有容器运行之后，flannel 会在节点上配置虚拟接口 <code>cni0</code>，比如在节点 <code>worker1</code>，IP 地址默认为 <code>10.244.1.1</code>，在 master 节点上 IP 为 <code>10.244.0.1</code>。</p>
<p>此 <code>cni0</code> 接口是一个网桥设备，会作为此节点上的 POD 的默认网关</p>
<p>在 POD 启动时，flannel 会创建一对 veth 虚拟设备，一端连接到容器，一端连接到 <code>cni0</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ifconfig cni0</span></span><br><span class="line">cni0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1410</span><br><span class="line">        inet 10.244.0.1  netmask 255.255.255.0  broadcast 10.244.0.255</span><br><span class="line">        inet6 fe80::f054:6bff:fe0e:f9ef  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether f2:54:6b:0e:f9:ef  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 3795780  bytes 469016599 (447.2 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 3832558  bytes 408850763 (389.9 MiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一旦节点启动并加入集群后，其他节点上的 flanneld 会添加路由规则，将到其他节点上的 POD 网段的流量路由到本节点的 flannel.1 接口，即进入二层隧道，然后封装 VXLAN 包，到达目标节点后(pod 网段和节点 ip 的映射关系，flannel 保存在 etcd 或者 k8s 中)，由目标节点上的 flannel.1 解封装，这就是 flannel 默认的 VXLAN 模式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip route show</span></span><br><span class="line">default via 10.150.0.1 dev eth0 </span><br><span class="line">10.150.0.1 dev eth0 scope link </span><br><span class="line">10.244.0.0/24 dev cni0 proto kernel scope link src 10.244.0.1 </span><br><span class="line">10.244.1.0/24 via 10.244.1.0 dev flannel.1 onlink </span><br><span class="line">10.244.2.0/24 via 10.244.2.0 dev flannel.1 onlink </span><br><span class="line">169.254.0.0/16 dev eth0 scope link metric 1002 </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于 VXLAN 额外的封包解包，导致其性能较差，所以 Flannel 就有了 <code>host-gw</code> 模式，即把宿主机当作网关，除了本地路由之外没有额外开销，性能和 calico 差不多，由于没有叠加来实现报文转发，这样会导致路由表庞大。因为一个节点对应一个网络，也就对应一条路由条目。</p>
<p><code>host-gw</code> 虽然比 VXLAN 网络性能要强很多，但是种方式有个缺陷：<strong>要求各物理节点必须在同一个二层网络中</strong>。物理节点必须在同一网段中。这样会使得一个网段中的主机量会非常多，万一发一个广播报文就会产生干扰。在私有云场景下，宿主机不在同一网段是很常见的状态，所以就不能使用 <code>host-gw</code> 了。</p>
<p>VXLAN 还有另外一种功能，VXLAN 也支持类似 host-gw 的方案，如果两个节点在同一网段时使用 host-gw 通信，如果不在同一网段中，即当前 pod 所在节点与目标 pod 所在节点中间有路由器，就使用 VXLAN 这种方式，使用叠加网络。</p>
<p>结合了 Host-gw 和 VXLAN，这就是 VXLAN 的 <code>Directrouting</code> 模式</p>
<p>因此 Flannel 的 VXLAN 模式有两种：</p>
<ul>
<li>VXLAN： 原生的 VXLAN，即扩展的虚拟 LAN</li>
<li>Directrouting：直接路由型</li>
</ul>
<p>配置 Directrouting 模式</p>
<p>修改 <code>kube-flannel.yml</code>，修改以下内容：</p>
<figure class="highlight shell"><figcaption><span>kube-flannel.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">net-conf.json: |</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;Network&quot;: &quot;10.244.0.0/16&quot;,</span><br><span class="line">    &quot;Backend&quot;: &#123;</span><br><span class="line">      &quot;Type&quot;: &quot;vxlan&quot;,</span><br><span class="line">      &quot;Directrouting&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="抓包示例"><a href="#抓包示例" class="headerlink" title="抓包示例"></a>抓包示例</h1><p>在 Flannel 的 VXLAN 模式下，overlay 流量需要通过节点的 <code>8472/udp</code> 端口（隧道）进行跨节点通信，如果跨节点 POD 网络通信存在异常，可以在两个节点上对 <code>8472/udp</code> 抓包观察流量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth0 -nnn &#x27;udp port 8472 and host 10.150.0.19&#x27;</span><br></pre></td></tr></table></figure>


<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://juejin.cn/post/6963106745468059684">详解Kubernetes网络原理</a></p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>tcpdump</tag>
        <tag>Flannel</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes 网络</title>
    <url>/202212020941/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos7 3.10.0-1160</li>
<li>Docker Engine - Community 23.0.3</li>
<li>kubernetes 1.21.2-0</li>
<li>kubernetes-cni-0.8.7-0</li>
</ul>
<p>Kubernetes 对任何网络实现都规定了以下要求： <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[万字长文，带你搞懂 Kubernetes 网络模型](https://www.51cto.com/article/714336.html)">[1]</span></a></sup></p>
<ul>
<li><p><strong>所有 Pod 都可以在不使用网络地址转换 (NAT) 的情况下与所有其他 Pod 通信。</strong></p>
<p>  容器之间直接通信，不需要额外的 NAT，不存在源地址伪装的情况</p>
</li>
<li><p><strong>所有节点都可以在没有 NAT 的情况下与所有 Pod 通信。</strong></p>
<p>  Node 与容器直接通信，不需要额外的 NAT</p>
</li>
<li><p><strong>Pod 认为自己的 IP 与其他人认为的 IP 相同。</strong></p>
</li>
</ul>
<h1 id="CNI"><a href="#CNI" class="headerlink" title="CNI"></a>CNI</h1><p>CNI 是 Kubernetes 容器网络的标准，CNI 是 Kubernetes 和底层网络插件之间的一个抽象层，为 Kubernetes 屏蔽了底层网络实现的负责度，同时解耦了 Kubernetes 和具体的网络插件实现。</p>
<h2 id="安装-CNI"><a href="#安装-CNI" class="headerlink" title="安装 CNI"></a>安装 CNI</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum install kubernetes-cni</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rpm -qa | grep kube</span></span><br><span class="line">kubeadm-1.21.2-0.x86_64</span><br><span class="line">kubectl-1.21.2-0.x86_64</span><br><span class="line">kubelet-1.21.2-0.x86_64</span><br><span class="line">kubernetes-cni-0.8.7-0.x86_64</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rpm -ql kubernetes-cni-0.8.7-0</span></span><br><span class="line">/opt/cni</span><br><span class="line">/opt/cni/bin</span><br><span class="line">/opt/cni/bin/bandwidth</span><br><span class="line">/opt/cni/bin/bridge</span><br><span class="line">/opt/cni/bin/dhcp</span><br><span class="line">/opt/cni/bin/firewall</span><br><span class="line">/opt/cni/bin/flannel</span><br><span class="line">/opt/cni/bin/host-device</span><br><span class="line">/opt/cni/bin/host-local</span><br><span class="line">/opt/cni/bin/ipvlan</span><br><span class="line">/opt/cni/bin/loopback</span><br><span class="line">/opt/cni/bin/macvlan</span><br><span class="line">/opt/cni/bin/portmap</span><br><span class="line">/opt/cni/bin/ptp</span><br><span class="line">/opt/cni/bin/sbr</span><br><span class="line">/opt/cni/bin/static</span><br><span class="line">/opt/cni/bin/tuning</span><br><span class="line">/opt/cni/bin/vlan</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Kubernetes 要使用 CNI，需要在 kubelet 启动时配置启动参数 <code>--network-plugin=cni</code>（默认配置，可使用 <code>systemctl status kubelet -l</code> 查看启动参数）。</p>
<p>kubelet 从 <code>--cni-config-dir</code> （默认为 <code>/etc/cni/net.d/</code>）中读取网络插件的配置文件，并使用该文件中的 CNI 配置来配置每个 Pod 网络。如果该目录 （<code>/etc/cni/net.d/</code>）中有多个配置文件，则使用文件名字典序列中的第一个文件。</p>
<p>CNI 插件的二进制文件放置的目录是通过 kubelet 的 <code>--cni-bin-dir</code> 参数指定，默认为 <code>/opt/cni/bin/</code></p>
<span id="more"></span>

<h1 id="flannel"><a href="#flannel" class="headerlink" title="flannel"></a>flannel</h1><p>flannel 最早由 CoreOS 开发，它是容器编排系统中最成熟的网络插件之一。随着 CNI 概念的兴起，flannel 也是最早实现 CNI 标准的网络插件，CNI 标准也是由 CoreOS 提出的。flannel 的功能非常明确，主要解决以下容器跨接点访问的问题</p>
<ul>
<li><strong>容器 IP 地址的重复问题</strong>。由于 Docker 等容器管理工具只是利用 Linux 内核的 network namespace 实现了网络隔离，各个节点上的容器 IP 由各个节点自动分配，可能出现重复。为了解决这个问题，flannel 设计了一种全局的 IP 地址分配机制，即使用 etcd 存储网段和节点 IP 之间的映射关系，然后配置 docker 只在当前节点对应的网段里面为容器分配 IP。</li>
<li><strong>容器 IP 地址的路由问题</strong>。flannel 使用多种后端（底层）技术（如 overlay 网络、Host-Gateway 网络等）解决了容器跨节点的直接通信问题。</li>
</ul>
<p>flannel 在架构上分为<strong>管理面</strong>和<strong>数据面</strong>。</p>
<ul>
<li><strong>管理面</strong>主要是 <code>etcd</code>。用于存储各个节点的 IP 及其上容器应该分配的网段</li>
<li><strong>数据面</strong>是每个节点上运行一个 <code>flanneld</code> 进程，负责从管理面读取节点 IP 及对应的网段信息，并根据这些信息对容器跨接点通信的数据包进行路由转发。</li>
</ul>
<p>集群内所有的 flannel 节点共享一个大网段，比如 <code>10.0.0.0/16</code>，flanneld 启动后便会读取 etcd 中的信息，得知其他节点的 IP 及其使用的子网段，然后向 etcd 申请本节点可使用的子网段（在大网段中划分一个子网段），比如 10.0.0.1&#x2F;24，并将该信息上报记录到 etcd。</p>
<p>flannel 目前已经支持的底层网络实现（backend）包括：</p>
<ul>
<li><code>UDP</code></li>
<li><code>VXLAN</code></li>
<li><code>Host-Gateway</code></li>
<li><code>Alloc</code></li>
<li><code>AWS VPC</code></li>
<li><code>GCE 路由</code></li>
</ul>
<p>其中，性能最好的是 <code>Host-Gateway</code>。<code>AWS VPC</code> 和 <code>GCE 路由</code>都需要 L2 网络支持，并且最好是接入云服务。<code>Alloc</code> 只为本机创建子网，多个节点上的子网之间不能通信。</p>
<h2 id="flannel-backend-详解"><a href="#flannel-backend-详解" class="headerlink" title="flannel backend 详解"></a>flannel backend 详解</h2><p>flannel 通过在每个节点上启动 <code>flanneld</code> 进程，负责每个节点上的子网划分，并将相关配置（如节点的 IP，划分的子网网段等）上报保存到 etcd，而具体的网络报文转发交给具体的 backend 实现。</p>
<p><code>flanneld</code> 可以在启动时通过配置文件指定不同的 backend 进行跨节点的容器之间的网络报文的路由转发，目前比较成熟的 backend 有  <code>UDP</code>、 <code>VXLAN</code> 、<code>Host-Gateway</code>，也有 <code>AWS VPC</code>、<code>GCE 路由</code> 等专门针对云服务的 backend。目前 <code>VXLAN</code> 是官方最推崇的 backend 实现，<code>Host-Gateway</code> 是网络性能最好的 backend 实现，但是需要所有节点在同一个二层网络中互通。<code>UDP</code> 性能相对较差，建议用于测试及比较老的不支持 VXLAN 的 Linux 内核。</p>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>UDP 模式基于 <a href="/202304241633/" title="Linux tun 设备">Linux tun 设备</a>。</p>
<p>当采用 UDP 模式时，<code>flanneld</code> 启动时会通过打开 <code>/dev/net/tun</code> 的方式生成一个 tun 设备。当 <code>flanneld</code> 进程运行之后，查看系统上的网卡信息，可以看到多了 <code>flannel0</code> 的网卡，通过命令 <code>ip -d link show flannel0</code>，可以看到其类型为 <code>tun</code> 设备。此模式下 <code>flanneld</code> 进程监听 8285 端口。</p>
<h4 id="flannel-UDP-模式跨主机通信流程详解"><a href="#flannel-UDP-模式跨主机通信流程详解" class="headerlink" title="flannel UDP 模式跨主机通信流程详解"></a>flannel UDP 模式跨主机通信流程详解</h4><p>本说明使用架构图形如下<br><img src="https://i.csms.tech/img_140.png"></p>
<p>以 ICMP 报文为例，<code>container A</code> 和 <code>container B</code> 的通信过程如下</p>
<ol>
<li><p><code>container A</code> 发起 ICMP 请求报文，根据 <code>container A</code> 中的路由信息，报文被发送到网关 <code>10.244.1.1</code>，对应设备为 <code>Host A</code> 主机上面的 <code>cni0</code> 网卡。此时报文内容如下<br>  <img src="https://i.csms.tech/img_141.png"></p>
</li>
<li><p>到达 cni0 的报文，目的 IP 为 <code>10.244.2.149</code>，内核根据 <code>host A</code> 上的路由信息（<code>10.244.0.0 0.0.0.0 255.255.0.0 U 0 0 0 flannel0</code>），应该将报文发送到 <code>flannel0</code> 网卡。</p>
</li>
<li><p><code>flannel0</code> 是个 tun  设备，数据会被 <code>flanneld</code> 接受，<code>flanneld</code> 会对数据包进行 UDP 封装。</p>
<ul>
<li>报文会被添加上 UDP 头部，其源端口为 <code>host A</code> 上的随机端口，目标端口为 8285</li>
<li>添加 IP 头部，源 IP 为本节点出口 IP （eth0：172.16.130.140），目标 IP 为目标容器所在节点的 IP（eth0：172.16.130.146）。<blockquote>
<p><code>flanneld</code> 进程是如何知道目标容器所在节点的 IP 地址？<strong>是通过 etcd 中的记录，<code>flanneld</code> 进程很容易根据目标容器的 IP 子网段，获取到对应节点的 IP</strong><br>  <img src="https://i.csms.tech/img_142.png"></p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>flanneld</code> 进程封装后的报文重新进入内核协议栈，内核根据主机上的路由信息，从主机 eth0 网卡发送出去，到达了目标主机 <code>host B</code></p>
</li>
<li><p><code>host B</code> 主机内核接收到此网络数据报文，通过 UDP 端口号 8285 将数据包交给监听在此端口上的 <code>flanneld</code> 进程。</p>
</li>
<li><p><code>host B</code> 主机上的 <code>flanneld</code> 进程对数据报文解封，获取到下图所示的报文，在网络层，源 IP 为容器 A 的 IP：10.244.1.96，目标 IP 为容器 B 的 IP：10.244.2.194。解封后的数据报文重新进入内核路由，根据主机 B 的主机路由表（<code>10.244.2.0 0.0.0.0 255.255.255.0 U 0 0 0 cni0</code>），报文被路由到 cni0<br> <img src="https://i.csms.tech/img_143.png"></p>
</li>
<li><p>cni0 网桥将数据包根据 MAC 地址（可以 ARP 寻址得到）将报文转发到容 B。</p>
</li>
<li><p>回程报文将按照上面的数据流原路返回。</p>
</li>
</ol>
<p>纵观以上整个过程，<code>flanneld</code> 进程在其中主要有以下作用</p>
<ul>
<li>UDP 封包解封包，根据目标容器的 IP，将其转发到正确的主机节点（IP）</li>
<li>主机节点上动态更新路由表，根据 etcd 的数据刷新本节点路由表</li>
</ul>
<p>容器 A 和容器 B 虽然物理上网络未相连，但是逻辑上确是在一个三层网络，这种在物理网络之上构建的上层网络称之为 <strong>overlay 网络或者隧道网络</strong></p>
<p><strong>flannel UDP 模式的缺点</strong></p>
<ul>
<li>数据报文先通过 tun 设备从内核态复制到了用户态 <code>flanneld</code> 进行封装，然后再传输到了内核，仅一次网络传输就进行了 2 次用户态到内核态的切换，效率不高。</li>
<li>因为报文封装的关系，flannel0 网卡的 MTU 要比主机 eth0 网卡小 28 个字节。</li>
</ul>
<h3 id="VXLAN"><a href="#VXLAN" class="headerlink" title="VXLAN"></a>VXLAN</h3><p><code>flanneld</code> 进程配置为 <code>vxlan</code> 类型的 backend ，<code>flanneld</code> 进程启动时会在主机上创建名为 <code>flannel.1</code> 的网卡（VTEP），网卡命名格式遵循 <code>flannel.[VNI]</code>，VNI 默认为 1。</p>
<p>通过以下命令查看 VTEP 设备 <code>flannel.1</code> 的信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip -d <span class="built_in">link</span> show flannel.1</span></span><br><span class="line">6: flannel.1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 8951 qdisc noqueue state UNKNOWN mode DEFAULT group default </span><br><span class="line">    link/ether 8a:32:fc:1d:b8:88 brd ff:ff:ff:ff:ff:ff promiscuity 0 </span><br><span class="line">    vxlan id 1 local 172.31.16.124 dev eth0 srcport 0 0 dstport 8472 nolearning ageing 300 udpcsum noudp6zerocsumtx noudp6zerocsumrx addrgenmode eui64 numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535</span><br><span class="line">    </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip -d add show flannel.1</span></span><br><span class="line">6: flannel.1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 8951 qdisc noqueue state UNKNOWN group default </span><br><span class="line">    link/ether 8a:32:fc:1d:b8:88 brd ff:ff:ff:ff:ff:ff promiscuity 0 </span><br><span class="line">    vxlan id 1 local 172.31.16.124 dev eth0 srcport 0 0 dstport 8472 nolearning ageing 300 udpcsum noudp6zerocsumtx noudp6zerocsumrx numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535 </span><br><span class="line">    inet 10.244.4.0/32 scope global flannel.1</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::8832:fcff:fe1d:b888/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>从以上信息可以看到，<code>flannel.1</code> 类型为 <code>vxlan</code>，local IP 为 172.31.16.124，使用的是 UDP 端口 8472</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">netstat -anutp</span> </span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">udp        0      0 0.0.0.0:8472            0.0.0.0:*                           -</span><br></pre></td></tr></table></figure>
<p>以上使用 <code>netstat -anutp</code> 命令的输出中，<code>PID/Program name</code> 显示的是 <code>-</code>，说明 8472 这个 UDP 端口不是由用户态的程序监听，而是 <strong>flannel 的 VXLAN 模式工作在内核态</strong>。</p>
<p>Kubernetes 中，VXLAN 模式的 <code>flanneld</code> 的工作流程：</p>
<ol>
<li><p><code>flanneld</code> 启动时，先确保 <code>flannel.1</code> 存在，若已存在则跳过，并将 VTEP 设备的相关信息（ip，节点 IP，MAC 地址等）上报到 etcd 中</p>
</li>
<li><p>当 flannel 网络中的其他节点加入集群并向 etcd 上报注册时，各个节点的 <code>flanneld</code> 会从 etcd 得到通知，并依次执行下面的步骤</p>
</li>
<li><p>在本节点添加一条新网段的路由信息，主要是让 Pod 中的流量能路由到 <code>flannel.1</code></p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ route -n</span><br><span class="line"> Kernel IP routing table</span><br><span class="line"> Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line"> 0.0.0.0         172.31.16.1     0.0.0.0         UG    100    0        0 eth0</span><br><span class="line"> 10.244.0.0      10.244.0.0      255.255.255.0   UG    0      0        0 flannel.1</span><br><span class="line"> 10.244.1.0      10.244.1.0      255.255.255.0   UG    0      0        0 flannel.1</span><br><span class="line"> 10.244.2.0      10.244.2.0      255.255.255.0   UG    0      0        0 flannel.1</span><br><span class="line"> 10.244.3.0      10.244.3.0      255.255.255.0   UG    0      0        0 flannel.1</span><br><span class="line"> 10.244.4.0      0.0.0.0         255.255.255.0   U     0      0        0 cni0</span><br><span class="line"> 172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</span><br><span class="line"> 172.31.16.0     0.0.0.0         255.255.240.0   U     100    0        0 eth0</span><br></pre></td></tr></table></figure>
</li>
<li><p>在本节点添加一条新增节点的 VTEP 设备的静态 ARP 缓存</p>
</li>
</ol>
<h4 id="flannel-VXLAN-模式跨主机通信流程详解"><a href="#flannel-VXLAN-模式跨主机通信流程详解" class="headerlink" title="flannel VXLAN 模式跨主机通信流程详解"></a>flannel VXLAN 模式跨主机通信流程详解</h4><p>flannel VXLAN 模式时容器跨节点网络通信实现流程<br><img src="https://i.csms.tech/img_144.png"></p>
<ol>
<li>同 UDP Backend 模式，容器 A 当中的 IP 包通过容器 A 内的路由表被发送到 cni0</li>
<li>到达 cni0 当中的 IP 包通过匹配 host A 当中的路由表发现通往 10.244.2.194 的 IP 包应该交给 flannel.1 接口</li>
<li>flannel.1 作为一个 VTEP 设备，收到报文后将按照 VTEP 的配置进行封包，首先通过 etcd 得知 10.244.2.194 属于节点 B，并得到节点 B 的 IP，通过节点 A 当中的转发表得到节点 B 对应的 VTEP 的 MAC，根据 flannel.1 设备创建时的设置的参数（VNI、local IP、Port）进行 VXLAN 封包</li>
<li>通过 host A 跟 host B 之间的网络连接，VXLAN 包到达 host B 的 eth1 接口</li>
<li>通过端口 8472，VXLAN 包被转发给 VTEP 设备 flannel.1 进行解包</li>
<li>解封装后的 IP 包匹配 host B 当中的路由表（10.244.2.0），内核将 IP 包转发给 cni0</li>
<li>cni0 将 IP 包转发给连接在 cni0 上的容器 B</li>
</ol>
<p>在 VXLAN 模式下，数据包的封装解封装及路由转发都是由内核完成，<code>flanneld</code> 不再进行数据包的封装和路由转发，仅动态设置主机的路由表项、ARP 表及 FDB 表项。其效率相比 UDP 模式高效。</p>
<h3 id="host-gw"><a href="#host-gw" class="headerlink" title="host-gw"></a>host-gw</h3><p>要配置使用 <code>host-gw</code> 模式，将 Backend 中的 <code>type</code> 改为 <code>host-gw</code> 即可。</p>
<p>使用 <code>host-gw</code> Backend 的 Flannel 网络的网络包传输过程如下图所示：<br><img src="https://i.csms.tech/img_145.png"></p>
<ol>
<li>同 UDP、VXLAN 模式一致，通过容器 A 的路由表， IP 包到达 cni0</li>
<li>到达 cni0 的 IP 包匹配到 host A 当中的路由规则（10.244.2.0），并且网关为 172.16.130.164，即 host B，所以内核将 IP 包发送给 host B（172.16.130.164）</li>
<li>IP 包通过物理网络到达 host B 的 eth1</li>
<li>到达 host B eth1 的 IP 包匹配到 host B 当中的路由表（10.244.2.0），IP 包被转发给 cni0</li>
<li>cni0 将 IP 包转发给连接在 cni0 上的容器 B</li>
</ol>
<p><code>host-gw</code> 模式其中一个局限性就是，由于是通过节点上的路由表来实现各个节点之间的跨节点网络通信，那么就得保证两个节点是可以直接路由过去的。按照内核当中的路由规则，网关必须在跟主机当中至少一个 IP 处于同一网段，故造成的结果就是采用 <code>host-gw</code> 这种 Backend 方式时集群中所有的节点必须处于同一个网络当中，这对于集群规模比较大时需要对节点进行网段划分的话会存在一定的局限性。另外一个则是随着集群当中节点规模的增大，<code>flanneld</code> 需要维护主机上成千上万条路由表的动态更新也是一个不小的压力。</p>
<p>采用 <code>host-gw</code> 模式后 <code>flanneld</code> 的唯一作用就是负责主机上路由表的动态更新。</p>
<h2 id="Kubernetes-中-flannel-相关配置"><a href="#Kubernetes-中-flannel-相关配置" class="headerlink" title="Kubernetes 中 flannel 相关配置"></a>Kubernetes 中 flannel 相关配置</h2><p>CNI 调用 flannel 插件是通过其配置文件 <code>/etc/cni/net.d/10-flannel.conflist</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /etc/cni/net.d/10-flannel.conflist</span> </span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;cbr0&quot;,</span><br><span class="line">  &quot;cniVersion&quot;: &quot;0.3.1&quot;,</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;flannel&quot;,</span><br><span class="line">      &quot;delegate&quot;: &#123;</span><br><span class="line">        &quot;hairpinMode&quot;: true,</span><br><span class="line">        &quot;isDefaultGateway&quot;: true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;portmap&quot;,</span><br><span class="line">      &quot;capabilities&quot;: &#123;</span><br><span class="line">        &quot;portMappings&quot;: true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>flannel 安装好启动之后，查看 flannel 的配置，可以看到配置的网段信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /run/flannel/subnet.env</span> </span><br><span class="line">FLANNEL_NETWORK=10.244.0.0/16</span><br><span class="line">FLANNEL_SUBNET=10.244.0.1/24</span><br><span class="line">FLANNEL_MTU=8951</span><br><span class="line">FLANNEL_IPMASQ=true</span><br></pre></td></tr></table></figure>

<p>在 Kubernetes 中，要查看 flannel 详细的配置，可以查看以下 configmap</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl edit configmap -n kube-flannel kube-flannel-cfg</span></span><br><span class="line">data:</span><br><span class="line">  cni-conf.json: |</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;cbr0&quot;,</span><br><span class="line">      &quot;cniVersion&quot;: &quot;0.3.1&quot;,</span><br><span class="line">      &quot;plugins&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;type&quot;: &quot;flannel&quot;,</span><br><span class="line">          &quot;delegate&quot;: &#123;</span><br><span class="line">            &quot;hairpinMode&quot;: true,</span><br><span class="line">            &quot;isDefaultGateway&quot;: true</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;type&quot;: &quot;portmap&quot;,</span><br><span class="line">          &quot;capabilities&quot;: &#123;</span><br><span class="line">            &quot;portMappings&quot;: true</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  net-conf.json: |</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;Network&quot;: &quot;10.244.0.0/16&quot;,</span><br><span class="line">      &quot;Backend&quot;: &#123;</span><br><span class="line">        &quot;Type&quot;: &quot;vxlan&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从中可以看到 flannel 使用的大网段 <code>10.244.0.0/16</code>，以及其使用的底层（后端）网络通信的实现技术（<code>Backend</code>）</p>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.51cto.com/article/714336.html">万字长文，带你搞懂 Kubernetes 网络模型</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.infoq.cn/article/qduqfhrisblob7textxe">Kubernetes 网络模型进阶</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes Volume 使用方法</title>
    <url>/202211291450/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="常用-Volume-类型"><a href="#常用-Volume-类型" class="headerlink" title="常用 Volume 类型"></a>常用 Volume 类型</h1><p>以下是几种可用卷类型：</p>
<ul>
<li><code>emptyDir</code> - 用于存储临时数据的简单空目录，生命周期和 Pod 一致。</li>
<li><code>hostPath</code> - 用于将宿主机中的文件系统挂载到 Pod 中，生命周期不与 Pod 绑定。</li>
<li><code>gitRepo</code> - 通过拉取 Git 仓库的内容来初始化的卷。<strong>已弃用</strong></li>
<li><code>nfs</code> - 挂载到 Pod 中的 NFS 共享文件系统。</li>
<li><code>configMap</code>、<code>secret</code> - 用于将 Kubernetes 中的部分资源和集群信息公开给 Pod 的特殊类型的卷</li>
<li><code>persistentVolumeClaim</code> - 简称 PVC，使用预置和动态配置的持久卷。</li>
<li><code>downwardAPI</code> - 在不使用 Kubernetes 客户端或 API 服务器的情况下获得自己或集群的信息 <sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Downward API](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/downward-api/)">[5]</span></a></sup></li>
</ul>
<h1 id="emptyDir-卷"><a href="#emptyDir-卷" class="headerlink" title="emptyDir 卷"></a>emptyDir 卷</h1><p><code>emptyDir</code> 表示与 Pod 生命周期相同的临时目录。<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[emptyDir](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#emptydir)
">[4]</span></a></sup></p>
<p>emptyDir 配置示例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: test-pd</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - image: registry.k8s.io/test-webserver</span><br><span class="line">    name: test-container</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - mountPath: /cache</span><br><span class="line">      name: cache-volume</span><br><span class="line">  volumes:</span><br><span class="line">  - name: cache-volume</span><br><span class="line">    emptyDir:</span><br><span class="line">      sizeLimit: 500Mi</span><br><span class="line">      medium: Memory</span><br></pre></td></tr></table></figure>
<ul>
<li><code>emptyDir.medium</code> - 表示此目录应使用哪种类别的存储介质，默认为 <code>&quot;&quot;</code>，表示使用节点的默认介质（一般是节点的本地磁盘）。可选值必须为 <code>&quot;&quot;</code> 或者 <code>Memory</code>， <code>Memory</code> 表示使用 <code>tmfs</code> (存在内存而非硬盘)</li>
</ul>
<h1 id="PersistentVolume-和-PersistentVolumeClaim"><a href="#PersistentVolume-和-PersistentVolumeClaim" class="headerlink" title="PersistentVolume 和 PersistentVolumeClaim"></a>PersistentVolume 和 PersistentVolumeClaim</h1><p><code>PersistentVolume (PV)</code>（持久化卷），是对底层的共享存储的一种抽象，PV 由管理员进行创建和配置，它和具体的底层的共享存储技术的实现方式有关，比如 <code>Ceph</code>、<code>GlusterFS</code>、<code>NFS</code> 等，都是通过插件机制完成与共享存储的对接。<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[使用 PersistentVolume 作为存储](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-persistent-volume-storage/)">[1]</span></a></sup></p>
<p><code>PersistentVolumeClaim（PVC）</code>是由用户发起的对存储的请求。 它类似于 Pod。 Pod 消耗节点资源，PVC 消耗 PV 资源。Pod 可以请求特定级别的资源（CPU和内存）。PVC 可以请求特定的存储大小和访问模式（例如，可以一次读&#x2F;写或多次只读）匹配的 PV。</p>
<p><code>PVC</code> 和 <code>PV</code> 中的 <code>spec</code> 关键字段要匹配，比如存储（storage）大小、读写模式，才能申请到对应的 PV 中的资源。PV 和 PVC 处于一一对应的关系。 <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[k8s存储持久化（nfs用例）](https://blog.51cto.com/u_15064627/4251683)">[2]</span></a></sup></p>
<p><code>PV</code> 可以设置三种回收策略：</p>
<ul>
<li>保留（Retain） - 保留产生的数据，PV 不进行处理</li>
<li>回收（Recycle） - 将执行清除操作，之后可以被新的pvc使用，需要插件支持。NFS 支持全部 3 种。</li>
<li>删除（Delete） - 删除pv和外部关联的存储资源，需要插件支持。</li>
</ul>
<p>PV卷阶段状态</p>
<ul>
<li><code>Available</code> – 资源尚未被 claim 使用</li>
<li><code>Bound</code> – 卷已经被绑定到 claim 了</li>
<li><code>Released</code> – claim 被删除，卷处于释放状态，但未被集群回收。</li>
<li><code>Failed</code> – 卷自动回收失败</li>
</ul>
<span id="more"></span>

<h2 id="NFS-作为-PV"><a href="#NFS-作为-PV" class="headerlink" title="NFS 作为 PV"></a>NFS 作为 PV</h2><a href="/202210251713/" title="NFS 服务部署参考">NFS 服务部署参考</a>

<h3 id="创建-PV"><a href="#创建-PV" class="headerlink" title="创建 PV"></a>创建 PV</h3><p><strong><code>PV</code> 属于集群级别的资源，不属于任何 namespace</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  name: nfs-pv-1</span><br><span class="line"></span><br><span class="line">spec:</span><br><span class="line">  accessModes:</span><br><span class="line">  - ReadWriteMany</span><br><span class="line">  - ReadOnlyMany</span><br><span class="line">  capacity:</span><br><span class="line">    storage: 100Gi</span><br><span class="line">  nfs:</span><br><span class="line">    path: /data/NFSDataHome</span><br><span class="line">    server: 34.230.1.1</span><br><span class="line">  persistentVolumeReclaimPolicy: Retain</span><br><span class="line">  volumeMode: Filesystem</span><br><span class="line">  </span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  name: nfs-pv-2</span><br><span class="line">  labels:</span><br><span class="line">    name: nfs-pv-2</span><br><span class="line">spec:</span><br><span class="line">  nfs:</span><br><span class="line">    path: /k8s_volumes/v2</span><br><span class="line">    server: 192.168.0.3</span><br><span class="line">  accessModes: [&quot;ReadWriteOnce&quot;]</span><br><span class="line">  persistentVolumeReclaimPolicy: Retain</span><br><span class="line">  capacity:</span><br><span class="line">    storage: 5Gi</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以上配置分别创建了 PV</p>
<ul>
<li><code>nfs-pv-1</code> - <code>accessModes</code> 为 <code>[&quot;ReadWriteMany&quot;, &quot;ReadOnlyMany&quot;]</code>，大小为 <code>100Gi</code></li>
<li><code>nfs-pv-2</code> - <code>accessModes</code> 为 <code>[&quot;ReadWriteOnce&quot;]</code>，大小为 <code>5Gi</code></li>
</ul>
<p>查看 PV</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pv</span></span><br><span class="line">NAME      CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS   REASON   AGE</span><br><span class="line">uat-nfs   100Gi      RWX            Retain           Available                                   100s</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="创建对应的-PVC-申请-PV-存储资源"><a href="#创建对应的-PVC-申请-PV-存储资源" class="headerlink" title="创建对应的 PVC 申请 PV 存储资源"></a>创建对应的 PVC 申请 PV 存储资源</h3><p><code>PVC</code> 属于 <code>Namespace</code> 基本的资源，需要在相应的 <code>Namespace</code> 中使用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">metadata:</span><br><span class="line">  name: mypvc</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  accessModes: [&quot;ReadWriteMany&quot;]</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 100Gi</span><br></pre></td></tr></table></figure>
<p>以上 PVC 会匹配到持久卷 <code>nfs-pv-1</code></p>
<p>查看 PVC</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get pvc -A</span><br></pre></td></tr></table></figure>

<h3 id="使用-PVC"><a href="#使用-PVC" class="headerlink" title="使用 PVC"></a>使用 PVC</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: vol-pvc</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  volumes:</span><br><span class="line">  - name: html</span><br><span class="line">    persistentVolumeClaim:</span><br><span class="line">      claimName: mypvc</span><br><span class="line">  containers:</span><br><span class="line">  - name: myapp</span><br><span class="line">    image: nginx</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: html</span><br><span class="line">      mountPath: /usr/share/nginx/html/</span><br><span class="line">      # subPath: logs/admin</span><br></pre></td></tr></table></figure>
<p><strong>k8s 该 Pod 所在 NODE 节点服务器需要安装 <code>nfs-utils</code>，否则挂载会报错，POD 无法运行。建议每台节点都安装</strong></p>
<p>Pod 成功运行后，进入对应容器，会看到容器中通过 NFS 方式挂载了 NFS 共享存储。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl <span class="built_in">exec</span> -it vol-pvc -- <span class="built_in">df</span> -h</span></span><br><span class="line">Filesystem                   Size  Used Avail Use% Mounted on</span><br><span class="line">overlay                       36G  3.4G   32G  10% /</span><br><span class="line">tmpfs                         64M     0   64M   0% /dev</span><br><span class="line">tmpfs                        2.0G     0  2.0G   0% /sys/fs/cgroup</span><br><span class="line">/dev/mapper/centos-root       36G  3.4G   32G  10% /etc/hosts</span><br><span class="line">shm                           64M     0   64M   0% /dev/shm</span><br><span class="line">192.168.0.3:/k8s_volumes/v4  3.6T  1.9T  1.6T  55% /usr/share/nginx/html</span><br><span class="line">tmpfs                        2.0G   12K  2.0G   1% /run/secrets/kubernetes.io/serviceaccount</span><br><span class="line">tmpfs                        2.0G     0  2.0G   0% /proc/acpi</span><br><span class="line">tmpfs                        2.0G     0  2.0G   0% /proc/scsi</span><br><span class="line">tmpfs                        2.0G     0  2.0G   0% /sys/firmware</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>以上方法创建的 PV 为静态 PV，此种情况下，PV 和 PVC 具有一对一的绑定关系</strong>，即一个 PV 只能绑定到一个 PVC，如果要在另一个 Namespace 中使用同一个的 PV，是不被允许的，此时 PVC 会绑定失败： <code>no persistent volumes available for this claim and no storage class is set</code></p>
<h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><h4 id="PV-处于-Released-状态，新建-PVC-处于-Pending-状态"><a href="#PV-处于-Released-状态，新建-PVC-处于-Pending-状态" class="headerlink" title="PV 处于 Released 状态，新建 PVC 处于 Pending 状态"></a>PV 处于 Released 状态，新建 PVC 处于 Pending 状态</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pv</span></span><br><span class="line">NAME      CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                   STORAGECLASS   REASON   AGE</span><br><span class="line">uat-nfs   100Gi      ROX,RWX        Retain           Bound    default/pvc-admin                               62m</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pvc -A</span></span><br><span class="line">NAMESPACE   NAME             STATUS   VOLUME    CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><br><span class="line">default     pvc-admin        Bound    uat-nfs   100Gi      ROX,RWX                       29s</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如上所示，创建 PVC 后，PV 处于 <code>Bound</code> 状态，此时创建其他内容一样，只是 <code>matadata.name</code> 不同的 PVC ，PVC 无法成功创建，状态为 <code>Pending</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pvc -A</span></span><br><span class="line">NAMESPACE   NAME        STATUS    VOLUME    CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><br><span class="line">default     pvc-api     Pending                                                      2m30s</span><br><span class="line">default     pvc-admin   Bound     uat-nfs   100Gi      ROX,RWX                       71m</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看新建的 PVC <code>pvc-api</code> 的描述信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl describe pvc pvc-api -n default</span></span><br><span class="line">Name:          pvc-api</span><br><span class="line">Namespace:     default</span><br><span class="line">StorageClass:  </span><br><span class="line">Status:        Pending</span><br><span class="line">...</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason         Age                   From                         Message</span><br><span class="line">  ----    ------         ----                  ----                         -------</span><br><span class="line">  Normal  FailedBinding  14s (x12 over 2m48s)  persistentvolume-controller  no persistent volumes available for this claim and no storage class is set</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果显示 <code>no persistent volumes available for this claim and no storage class is set</code>，这是因为 PV 已经分配到了 PVC，无法再进行分配。</p>
<p>此时查看 PV 状态，处于 <code>Bound</code> 状态，<code>CLAIM</code> 为第一次创建 PVC</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pv</span></span><br><span class="line">NAME      CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                   STORAGECLASS   REASON   AGE</span><br><span class="line">uat-nfs   100Gi      ROX,RWX        Retain           Bound    default/pvc-admin                               135m</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此种情况下，执行以下命令手动删除已分配的 PVC</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl delete pvc -n default      pvc-admin</span><br></pre></td></tr></table></figure>
<p>再次查看 PVC</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pvc -A</span></span><br><span class="line">NAMESPACE   NAME       STATUS    VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><br><span class="line">default     pvc-api   Pending</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pv</span></span><br><span class="line">NAME      CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS     CLAIM                   STORAGECLASS   REASON   AGE</span><br><span class="line">uat-nfs   100Gi      ROX,RWX        Retain           Released   default/pvc-admin                               140m</span><br></pre></td></tr></table></figure>
<p>发现 PVC 依然处于 <code>Pending</code> 状态，而 PV 状态变为了 <code>Released</code>，无法再分配给其他 PVC。</p>
<h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><ul>
<li>删除 PV<br>  手动删除 PV，因为之前创建的 PV，其回收策略为 <code>Retain</code>，PV 删除后，数据依然存在。如果需要此存储作为 PV，创建新的 PV 即可，然后针对不同的 Namespace 创建对应的 PVC</li>
<li>修改 PV 的回收策略<br>  执行以下命令，修改 PV 的回收策略 <sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[What to do with Released persistent volume](https://stackoverflow.com/questions/50667437/what-to-do-with-released-persistent-volume)
">[3]</span></a></sup>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl patch pv PV_NAME -p &#x27;&#123;&quot;spec&quot;:&#123;&quot;claimRef&quot;: null&#125;&#125;&#x27;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-persistent-volume-storage/">使用 PersistentVolume 作为存储</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://blog.51cto.com/u_15064627/4251683">k8s存储持久化（nfs用例）</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://stackoverflow.com/questions/50667437/what-to-do-with-released-persistent-volume">What to do with Released persistent volume</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#emptydir">emptyDir</a><a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/downward-api/">Downward API</a><a href="#fnref:5" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes 对象的 yaml 描述语法说明</title>
    <url>/202209241108/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos7 5.4.212-1</li>
<li>Docker 20.10.18</li>
<li>containerd.io-1.6.8</li>
<li>kubectl-1.25.0</li>
<li>kubeadm-1.25.0</li>
<li>kubelet-1.25.0</li>
</ul>
<h1 id="常用字段说明"><a href="#常用字段说明" class="headerlink" title="常用字段说明"></a>常用字段说明</h1><h2 id="必需字段"><a href="#必需字段" class="headerlink" title="必需字段"></a>必需字段</h2><p>在想要创建的 Kubernetes 对象所对应的 <code>.yaml</code> 文件中，必须配置的字段如下：<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[必需字段](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/kubernetes-objects/#required-fields)">[1]</span></a></sup></p>
<ul>
<li><code>apiVersion</code> - 创建该对象所使用的 Kubernetes API 的版本</li>
<li><code>kind</code> - 想要创建的对象的类别</li>
<li><code>metadata</code> - 帮助唯一标识对象的一些数据，包括一个 <code>name</code> 字符串、<code>UID</code> 和可选的 <code>namespace</code></li>
<li><code>spec</code> - 你所期望的该对象的状态</li>
</ul>
<h2 id="metadata"><a href="#metadata" class="headerlink" title="metadata"></a>metadata</h2><p>帮助唯一标识对象的一些数据，包括一个 <code>name</code> 字符串、<code>UID</code> 和可选的 <code>namespace</code> </p>
<p>集群中的每一个对象都有一个 <strong>名称</strong>（<code>name</code>）来标识在同类资源中的唯一性。<code>name</code> 也用来作为 url 中的资源名称 <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[对象名称和 IDs](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names/)">[2]</span></a></sup></p>
<p>每个 Kubernetes 对象也有一个 <strong>UID</strong>（<code>uid</code>）来标识在整个集群中的唯一性。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-deployment</span><br><span class="line">  labels: </span><br><span class="line">    app: nginx-deployment</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  replicas: 2 </span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:1.14.2</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="标签和选择算符"><a href="#标签和选择算符" class="headerlink" title="标签和选择算符"></a>标签和选择算符</h2><p><strong>标签（labels）</strong> 是附加到 Kubernetes 对象（比如 Pod）上的键值对。 标签旨在用于指定对用户有意义且相关的对象的标识属性，但不直接对核心系统有语义含义。 标签可以用于组织和选择对象的子集。标签可以在创建时附加到对象，随后可以随时添加和修改。 每个对象都可以定义一组键&#x2F;值标签。每个键对于给定对象必须是唯一的。<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[标签和选择算符](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/)">[3]</span></a></sup></p>
<p>通过 <strong>标签选择算符</strong>，客户端&#x2F;用户可以识别一组对象。<strong>标签选择算符</strong> 是 Kubernetes 中的核心分组原语。</p>
<blockquote>
<p>对于某些 API 类别（例如 <code>ReplicaSet</code>）而言，两个实例的标签选择算符不得在命名空间内重叠， 否则它们的控制器将互相冲突，无法确定应该存在的副本个数。</p>
</blockquote>
<p>比较新的资源，例如 <code>Job</code>、 <code>Deployment</code>、 <code>ReplicaSet</code> 和 <code>DaemonSet</code>， 也支持基于集合的需求。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">selector:</span><br><span class="line">  matchLabels:</span><br><span class="line">    component: redis</span><br><span class="line">  matchExpressions:</span><br><span class="line">    - &#123;key: tier, operator: In, values: [cache]&#125;</span><br><span class="line">    - &#123;key: environment, operator: NotIn, values: [dev]&#125;</span><br></pre></td></tr></table></figure>
<p><code>matchLabels</code> 是由 {key,value} 对组成的映射。 <code>matchLabels</code> 映射中的单个 {key,value} 等同于 <code>matchExpressions</code> 的元素， 其 key 字段为 “key”，operator 为 <code>In</code>，而 values 数组仅包含 “value”。 <code>matchExpressions</code> 是 Pod 选择算符需求的列表。 有效的运算符包括 <code>In</code>、<code>NotIn</code>、<code>Exists</code> 和 <code>DoesNotExist</code>。 在 <code>In</code> 和 <code>NotIn</code> 的情况下，设置的值必须是非空的。 来自 <code>matchLabels</code> 和 <code>matchExpressions</code> 的所有要求都按 <strong>逻辑与</strong> 的关系组合到一起 – <strong>它们必须都满足才能匹配</strong>。</p>
<h3 id="字段选择器"><a href="#字段选择器" class="headerlink" title="字段选择器"></a>字段选择器</h3><p><strong>字段选择器（Field selectors）</strong> 允许你根据一个或多个资源字段的值 <strong>筛选 Kubernetes 资源</strong></p>
<p>下面是一些使用字段选择器查询的例子：</p>
<ul>
<li><code>metadata.name=my-service</code></li>
<li><code>metadata.namespace!=default</code></li>
<li><code>status.phase=Pending</code></li>
</ul>
<p>下面这个 <code>kubectl</code> 命令将筛选出 <code>status.phase</code> 字段值为 <code>Running</code> 的所有 Pod：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get pods --field-selector status.phase=Running</span><br></pre></td></tr></table></figure>

<p>不同的 Kubernetes 资源类型支持不同的字段选择器。 所有资源类型都支持 <code>metadata.name</code> 和 <code>metadata.namespace</code> 字段。 使用不被支持的字段选择器会产生错误</p>
<p>你可在字段选择器中使用 <code>=</code>、<code>==</code> 和 <code>!=</code> （<code>=</code> 和 <code>==</code> 的意义是相同的）操作符。 例如，下面这个 <code>kubectl</code> 命令将筛选所有不属于 <code>default</code> 命名空间的 Kubernetes 服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get services  --all-namespaces --field-selector metadata.namespace!=default</span><br></pre></td></tr></table></figure>

<p>同标签和其他选择器一样， 字段选择器可以通过使用逗号分隔的列表组成一个选择链。 下面这个 <code>kubectl</code> 命令将筛选 <code>status.phase</code> 字段不等于 <code>Running</code> 同时 <code>spec.restartPolicy</code> 字段等于 <code>Always</code> 的所有 Pod：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get pods --field-selector=status.phase!=Running,spec.restartPolicy=Always</span><br></pre></td></tr></table></figure>
<p>你能够跨多种资源类型来使用字段选择器。 下面这个 <code>kubectl</code> 命令将筛选出所有不在 <code>default</code> 命名空间中的 <code>StatefulSet</code> 和 <code>Service</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get statefulsets,services --all-namespaces --field-selector metadata.namespace!=default</span><br></pre></td></tr></table></figure>

<h2 id="metadata-ownerReferences"><a href="#metadata-ownerReferences" class="headerlink" title="metadata.ownerReferences"></a>metadata.ownerReferences</h2><p>在 Kubernetes 中，一些对象是其他对象的 <strong>属主（Owner）</strong>。 例如，<code>ReplicaSet</code> 是一组 <code>Pod</code> 的属主。 具有属主的对象是属主的 <strong>附属（Dependent）</strong>。<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[属主与附属](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/owners-dependents/)">[4]</span></a></sup></p>
<p>附属对象有一个 <code>metadata.ownerReferences</code> 字段，用于引用其属主对象。 一个有效的属主引用，包含与附属对象同在一个命名空间下的对象名称和一个 UID。 Kubernetes 自动为一些对象的附属资源设置属主引用的值， 这些对象包含 <code>ReplicaSet</code>、<code>DaemonSet</code>、<code>Deployment</code>、<code>Job</code>、<code>CronJob</code>、<code>ReplicationController</code> 等。</p>
<p>附属对象还有一个 <code>ownerReferences.blockOwnerDeletion</code> 字段，该字段使用布尔值， 用于控制特定的附属对象是否可以阻止垃圾收集删除其属主对象。 如果控制器（例如 Deployment 控制器） 设置了 <code>metadata.ownerReferences</code> 字段的值，Kubernetes 会自动设置 <code>blockOwnerDeletion</code> 的值为 <code>true</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ownerReferences:</span><br><span class="line">    - apiVersion: apps/v1</span><br><span class="line">      kind: ReplicaSet</span><br><span class="line">      name: test-nginx-deployment-54cb7448dc</span><br><span class="line">      uid: 34b3353a-bd05-4ac3-959f-d6fbc85a2d2e</span><br><span class="line">      controller: true</span><br><span class="line">      blockOwnerDeletion: true</span><br></pre></td></tr></table></figure>

<h2 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h2><p><a href="https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/workload-resources/pod-v1/">Pod 资源定义官网 API 说明</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: $&#123;NAME&#125;</span><br><span class="line">  namespace: $&#123;NAMESPACE&#125;</span><br><span class="line">spec:</span><br><span class="line">  restartPolicy: Always</span><br><span class="line">  containers:</span><br><span class="line">  - name: $&#123;NAME&#125;</span><br><span class="line">    image: nginx:1.14.2</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 80</span><br><span class="line">      name: http-web</span><br><span class="line">      </span><br><span class="line">    args:</span><br><span class="line">    - sh</span><br><span class="line">    - -c</span><br><span class="line">    - ping 127.0.0.1</span><br><span class="line">    </span><br><span class="line">    command:</span><br><span class="line">      - sh</span><br><span class="line">      - -c</span><br><span class="line">      - cd /code1/ &amp;&amp; python manage.py runserver localhost:8080</span><br><span class="line">    env:</span><br><span class="line">    - name: DEMO_GREETING</span><br><span class="line">      value: &quot;Hello from the environment&quot;</span><br><span class="line">    - name: DEMO_FAREWELL</span><br><span class="line">      value: &quot;Such a sweet sorrow&quot;</span><br><span class="line">    </span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: html</span><br><span class="line">      mountPath: /usr/share/nginx/html/</span><br><span class="line">      # subPath: logs/admin</span><br><span class="line">      </span><br><span class="line">    resources:</span><br><span class="line">      requests:</span><br><span class="line">        cpu: 200m</span><br><span class="line">        memory: 10Mi</span><br><span class="line">      limits:</span><br><span class="line">        cpu: 200m</span><br><span class="line">        memory: 10Mi</span><br><span class="line">    </span><br><span class="line">  nodeSelector:</span><br><span class="line">      disktype: ssd</span><br><span class="line">      </span><br><span class="line">  nodeName: foo-node</span><br><span class="line">  </span><br><span class="line">  imagePullSecrets:</span><br><span class="line">  - name: $&#123;secret_name&#125;</span><br><span class="line">  </span><br><span class="line">  hostAliases:</span><br><span class="line">  - ip: &quot;50.18.1.1&quot;</span><br><span class="line">    hostnames:</span><br><span class="line">    - &quot;mysql.master&quot;</span><br><span class="line">    - &quot;mysql.slave&quot;</span><br><span class="line">    - &quot;mongo.com&quot;</span><br><span class="line">  - ip: &quot;50.18.1.2&quot;</span><br><span class="line">    hostnames:</span><br><span class="line">    - &quot;meta-service.apollo.com&quot;</span><br><span class="line">  - ip: &quot;172.31.88.78&quot;</span><br><span class="line">    hostnames:</span><br><span class="line">    - &quot;redis.com&quot;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>.spec.containers[*].ports[*].containerPort</code> - <code>Pod</code> 暴露的端口</p>
</li>
<li><p><code>.spec.containers[*].ports[*].name</code> - <code>Pod</code> 暴露的端口的自定义名称，可在 <a href="#Service"><code>Service</code></a> 的 <code>targetPort</code> 属性中，Probe 等功能中引用这些名称</p>
</li>
<li><p><code>.spec.restartPolicy</code> -  重启策略，适用于 <code>Pod</code> 中的所有容器，可取值如下</p>
<ul>
<li><code>Always</code> - 默认值</li>
<li><code>OnFailure</code></li>
<li><code>Never</code></li>
</ul>
</li>
<li><p><code>.spec.containers[*].args</code> - 定义容器启动后执行的命令，会替换镜像中定义的默认执行程序</p>
</li>
<li><p><code>.spec.nodeSelector</code>  - 根据节点标签将 <code>Pod</code> 调度到指定节点 <sup id="fnref:13"><a href="#fn:13" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[将 Pod 指派给节点](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/assign-pod-node/#nodename)">[13]</span></a></sup></p>
</li>
<li><p><code>.spec.nodeName: foo-node</code> - 将 <code>Pod</code> 调度到指定节点。 使用 <code>nodeName</code> 规则的优先级会高于使用 <code>nodeSelector</code> 或亲和性与非亲和性的规则，如果所指代的节点不存在，则 Pod 无法运行，而且在某些情况下可能会被自动删除。如果所指代的节点无法提供用来运行 Pod 所需的资源，Pod 会失败， 而其失败原因中会给出是否因为内存或 CPU 不足而造成无法运行。<sup id="fnref:12"><a href="#fn:12" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[nodeName ](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/assign-pod-node/#nodename)">[12]</span></a></sup></p>
</li>
<li><p><code>.spec.containers[*].env</code> - 创建 Pod 时，可以为其下的容器设置环境变量。通过配置文件的 <code>env</code> 或者 <code>envFrom</code> 字段来设置环境变量。 <sup id="fnref:15"><a href="#fn:15" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[为容器设置环境变量](https://kubernetes.io/zh-cn/docs/tasks/inject-data-application/define-environment-variable-container/)">[15]</span></a></sup></p>
</li>
<li><p><code>.spec.containers[*].volumeMounts</code> - 挂载卷，<code>subPath</code> 可用于指定挂载卷（<code>name: html</code>）的子目录到容器路径（<code>mountPath</code>），而不是直接挂载卷目录。</p>
</li>
<li><p><code>.spec.containers[*].resources</code> - <a href="https://csms.tech/202304271425/#Pod-计算资源限制">资源限制</a></p>
</li>
</ul>
<h3 id="容器探针"><a href="#容器探针" class="headerlink" title="容器探针"></a>容器探针</h3><p><strong>探针（Probe）</strong> 主要用来检测 <code>Pod</code> 的状态，主要有 <strong>活跃（Liveness）</strong>、<strong>就绪（Readiness）</strong> 和 <strong>启动（Startup）</strong> 探针 <sup id="fnref:10"><a href="#fn:10" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[配置存活、就绪和启动探针](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/)">[10]</span></a></sup></p>
<ul>
<li><code>livenessProbe</code> - <code>kubelet</code> 使用 <strong>存活探针</strong> 来确定什么时候要重启容器，例如，存活探针可以探测到应用死锁（应用程序在运行，但是无法继续执行后面的步骤）情况。 重启这种状态下的容器有助于提高应用的可用性，即使其中存在缺陷。</li>
<li><code>readinessProbe</code> - <code>kubelet</code> 使用 <strong>就绪探针</strong> 可以知道容器何时准备好接受请求流量，当一个 <code>Pod</code> 内的所有容器都就绪时，才能认为该 <code>Pod</code> 就绪。 这种信号的一个用途就是控制哪个 <code>Pod</code> 作为 <code>Service</code> 的后端。 若 <code>Pod</code> 尚未就绪，会被从 <code>Service</code> 的负载均衡器中剔除。</li>
<li><code>startupProbe</code> - <code>kubelet</code> 使用 <strong>启动探针</strong> 来了解应用容器何时启动。 如果配置了这类探针，你就可以控制容器在启动成功后再进行存活性和就绪态检查， 确保这些存活、就绪探针不会影响应用的启动。 启动探针可以用于对慢启动容器进行存活性检测，避免它们在启动运行之前就被杀掉。</li>
</ul>
<p><code>Probe</code> 是由 <code>kubelet</code> 对容器执行的定期诊断。 要执行诊断，<code>kubelet</code> 既可以在容器内执行代码，也可以发出一个网络请求。<sup id="fnref:11"><a href="#fn:11" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[容器探针](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#container-probes)">[11]</span></a></sup></p>
<p>使用探针来检查容器有四种不同的方法。 每个探针都必须准确定义为这四种机制中的一种：</p>
<ul>
<li><code>exec</code> - 在容器内执行指定命令。如果命令退出时返回码为 0 则认为诊断成功。</li>
<li><code>grpc</code> - 使用 gRPC 执行一个远程过程调用。 目标应该实现 gRPC健康检查。 如果响应的状态是 “SERVING”，则认为诊断成功。 gRPC 探针是一个 alpha 特性，只有在你启用了 “GRPCContainerProbe” 特性门控时才能使用。</li>
<li><code>httpGet</code> - 对容器的 IP 地址上指定端口和路径执行 HTTP GET 请求。如果响应的状态码大于等于 200 且小于 400，则诊断被认为是成功的。</li>
<li><code>tcpSocket</code> - 对容器的 IP 地址上的指定端口执行 TCP 检查。如果端口打开，则诊断被认为是成功的。 如果远程系统（容器）在打开连接后立即将其关闭，这算作是健康的</li>
</ul>
<p>每次探测都将获得以下三种结果之一：</p>
<ul>
<li><code>Success</code>（成功） - 容器通过了诊断。</li>
<li><code>Failure</code>（失败） - 容器未通过诊断。</li>
<li><code>Unknown</code>（未知） - 诊断失败，因此不会采取任何行动。</li>
</ul>
<h4 id="livenessProbe"><a href="#livenessProbe" class="headerlink" title="livenessProbe"></a>livenessProbe</h4><h5 id="exec-方式的-livenessProbe"><a href="#exec-方式的-livenessProbe" class="headerlink" title="exec 方式的 livenessProbe"></a>exec 方式的 livenessProbe</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    test: liveness</span><br><span class="line">  name: liveness-exec</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: liveness</span><br><span class="line">    image: registry.k8s.io/busybox</span><br><span class="line">    args:</span><br><span class="line">    - /bin/sh</span><br><span class="line">    - -c</span><br><span class="line">    - touch /tmp/healthy; sleep 30; rm -f /tmp/healthy; sleep 600</span><br><span class="line">    livenessProbe:</span><br><span class="line">      exec:</span><br><span class="line">        command:</span><br><span class="line">        - cat</span><br><span class="line">        - /tmp/healthy</span><br><span class="line">      initialDelaySeconds: 5</span><br><span class="line">      periodSeconds: 5</span><br><span class="line">      timeoutSeconds: 10</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>.spec.containers[*].args</code> - 容器启动后执行的命令，取代镜像中默认的命令</p>
</li>
<li><p><code>.spec.containers[*].livenessProbe</code> - 配置存活探针</p>
<ul>
<li><code>exec.command</code> - 配置探测方式为 <code>exec</code> 以及在容器内执行的命令，如果命令执行成功并且返回值为 0，<code>kubelet</code> 就会认为这个容器是健康存活的。 如果这个命令返回非 0 值，<code>kubelet</code> 会杀死这个容器并 <strong>重新启动</strong> 它。</li>
<li><code>periodSeconds</code> - 指定 <code>kubelet</code> 应该每 5 秒执行一次存活探测，默认是 10 秒。最小值是 1</li>
<li><code>initialDelaySeconds</code> - <code>kubelet</code> 在执行第一次探测前等待 5 秒， 默认是 0 秒</li>
<li><code>timeoutSeconds</code> - 探测的超时后等待多少秒。默认值是 1 秒。最小值是 1。</li>
<li><code>successThreshold</code> - 探针在失败后，被视为成功的最小连续成功数。默认值是 1。 存活和启动探测的这个值必须是 1。最小值是 1。</li>
<li><code>failureThreshold</code> - 当探测失败时，Kubernetes 的重试次数。默认值是 3。最小值是 1</li>
</ul>
</li>
</ul>
<h5 id="httpGet-方式的-livenessProbe"><a href="#httpGet-方式的-livenessProbe" class="headerlink" title="httpGet 方式的 livenessProbe"></a>httpGet 方式的 livenessProbe</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    test: liveness</span><br><span class="line">  name: liveness-http</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: liveness</span><br><span class="line">    image: registry.k8s.io/liveness</span><br><span class="line">    args:</span><br><span class="line">    - /server</span><br><span class="line">    livenessProbe:</span><br><span class="line">      httpGet:</span><br><span class="line">        path: /healthz</span><br><span class="line">        port: 8080</span><br><span class="line">        </span><br><span class="line">        # 非常用字段</span><br><span class="line">        host: test.domain</span><br><span class="line">        scheme: http </span><br><span class="line">        </span><br><span class="line">        httpHeaders:</span><br><span class="line">        - name: Custom-Header</span><br><span class="line">          value: Awesome</span><br><span class="line">        - name: Accept</span><br><span class="line">          value: application/json</span><br><span class="line">        - name: Host</span><br><span class="line">          value: test.domain</span><br><span class="line">        </span><br><span class="line">      initialDelaySeconds: 3</span><br><span class="line">      periodSeconds: 3</span><br></pre></td></tr></table></figure>

<ul>
<li><code>.spec.containers[*].livenessProbe</code> - 配置存活探针<ul>
<li><code>httpGet.path</code> - 配置存活探针的探测方式为 <code>httpGet</code> ，并指定 HTTP GET 请求的路径（默认为 <code>/</code>）。返回大于或等于 200 并且小于 400 的任何代码都标示成功。其它返回代码都标示失败，失败时 <code>kubelet</code> 会杀死这个容器并将其重启</li>
<li><code>httpGet.port</code> - 指定 HTTP GET 请求的端口</li>
<li><code>httpGet.httpHeaders</code> - 请求中自定义的 HTTP 头。HTTP 头字段允许重复。</li>
<li><code>host</code> - 连接使用的主机名，默认是 <code>Pod</code> 的 IP。也可以在 HTTP 头中设置 <code>Host</code> 来代替</li>
<li><code>scheme</code> - 用于设置连接主机的方式（HTTP 还是 HTTPS）。默认是 “HTTP”</li>
</ul>
</li>
</ul>
<h5 id="tcpSocket-方式的-livenessProbe"><a href="#tcpSocket-方式的-livenessProbe" class="headerlink" title="tcpSocket 方式的 livenessProbe"></a>tcpSocket 方式的 livenessProbe</h5><p><code>kubelet</code> 会尝试在指定端口和容器建立套接字链接。 如果能建立连接，这个容器就被看作是健康的，如果不能则这个容器就被看作是有问题的。</p>
<p>对于 TCP 探测而言，kubelet 在节点上（不是在 <code>Pod</code> 里面）发起探测连接， 这意味着你不能在 <code>host</code> 参数上配置服务名称，因为 <code>kubelet</code> 不能解析服务名称。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: goproxy</span><br><span class="line">  labels:</span><br><span class="line">    app: goproxy</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: goproxy</span><br><span class="line">    image: registry.k8s.io/goproxy:0.1</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 8080</span><br><span class="line">      name: goproxy-port</span><br><span class="line">    readinessProbe:</span><br><span class="line">      tcpSocket:</span><br><span class="line">        port: goproxy-port</span><br><span class="line">      initialDelaySeconds: 5</span><br><span class="line">      periodSeconds: 10</span><br><span class="line">    livenessProbe:</span><br><span class="line">      tcpSocket:</span><br><span class="line">        port: 8080</span><br><span class="line">      initialDelaySeconds: 15</span><br><span class="line">      periodSeconds: 20</span><br></pre></td></tr></table></figure>
<ul>
<li><code>.spec.containers[*].livenessProbe</code> - 配置存活探针<ul>
<li><code>tcpSocket.port</code> - 配置存活探针的探测方式为 <code>tcpSocket</code>，并指定 TCP 探测连接的端口，可以使用命名的端口</li>
</ul>
</li>
</ul>
<h3 id="Pod-拓扑分布约束"><a href="#Pod-拓扑分布约束" class="headerlink" title="Pod 拓扑分布约束"></a>Pod 拓扑分布约束</h3><p>你可以使用 <strong>拓扑分布约束（Topology Spread Constraints）</strong> 来控制 Pod 在集群内故障域之间的分布， 例如区域（Region）、可用区（Zone）、节点和其他用户自定义拓扑域。 这样做有助于实现高可用并提升资源利用率。<sup id="fnref:16"><a href="#fn:16" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Pod 拓扑分布约束](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/topology-spread-constraints/)">[16]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: example-pod</span><br><span class="line">spec:</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">配置一个拓扑分布约束</span></span><br><span class="line">  topologySpreadConstraints:</span><br><span class="line">    - maxSkew: &lt;integer&gt;</span><br><span class="line">      minDomains: &lt;integer&gt; # 可选；自从 v1.25 开始成为 Beta</span><br><span class="line">      topologyKey: &lt;string&gt;</span><br><span class="line">      whenUnsatisfiable: &lt;string&gt;</span><br><span class="line">      labelSelector: &lt;object&gt;</span><br><span class="line">      matchLabelKeys: &lt;list&gt; # 可选；自从 v1.25 开始成为 Alpha</span><br><span class="line">      nodeAffinityPolicy: [Honor|Ignore] # 可选；自从 v1.25 开始成为 Alpha</span><br><span class="line">      nodeTaintsPolicy: [Honor|Ignore] # 可选；自从 v1.25 开始成为 Alpha</span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash"><span class="comment">## 其他 Pod 字段置于此处</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>maxSkew</code> - 描述 Pod 被（由 <code>topologyKey</code> 选中的节点组成的同一区域）均匀分布的程度</li>
<li><code>topologyKey</code> - 节点标签的 <strong>键</strong>，如果节点使用此 <strong>键</strong> 标记并且具有相同的 <strong>标签值</strong>， 则将这些节点视为处于同一拓扑域中</li>
<li><code>whenUnsatisfiable</code> - 指示如果 Pod 不满足分布约束时如何处理：<ul>
<li><code>DoNotSchedule</code> -（默认）告诉调度器不要调度。</li>
<li><code>ScheduleAnyway</code> - 告诉调度器仍然继续调度，只是根据如何能将偏差最小化来对节点进行排序。</li>
</ul>
</li>
</ul>
<h2 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h2><p><a href="https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/workload-resources/deployment-v1/">Deployment 资源定义官网 API 说明</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-deployment</span><br><span class="line">  labels:</span><br><span class="line">    app: nginx</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:1.14.2</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line">        </span><br><span class="line">  strategy:</span><br><span class="line">    rollingUpdate:</span><br><span class="line">      maxSurge: 25%</span><br><span class="line">      maxUnavailable: 25%</span><br><span class="line">    type: RollingUpdate</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>.spec.replicas</code> - Pod 副本的数量，会根据配置产生 <strong><a href="#metadata.ownerReferences">附属对象</a> ReplicaSet</strong></p>
</li>
<li><p><code>.spec.selector</code> - 字段定义了 <code>Deployment</code> 如何查找要管理的 <code>Pod</code></p>
</li>
<li><p><code>.spec.template</code> - 定义了 <code>Pod</code> 相关的必要信息，本质上是定义一个 <a href="#Pod"><code>Pod</code> 对象</a></p>
<ul>
<li><code>.metadata.labels</code> - 为容器添加的标签，<code>slector</code> 可以使用此标签查找要管理的 <code>Pod</code> </li>
<li><code>.spec.containers</code> - 容器相关定义，包含启动的容器名称，使用的镜像，容器暴露的端口等</li>
</ul>
</li>
<li><p><code>.spec.strategy</code> - 指定用于用新 Pod 替换旧 Pod 的策略。<code>.spec.strategy.type</code> 可以是 <code>Recreate</code> 或 <code>RollingUpdate</code>。<code>RollingUpdate</code> 是默认值。<sup id="fnref:17"><a href="#fn:17" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[策略](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#strategy)">[17]</span></a></sup></p>
<ul>
<li><code>.spec.strategy.type==Recreate</code> - 如果值为 <code>Recreate</code>，在创建新 Pod 之前，所有现有的 Pod 会被杀死</li>
<li><code>.spec.strategy.type==RollingUpdate</code> - Deployment 会在 <code>.spec.strategy.type==RollingUpdate</code> 时，采取 滚动更新的方式更新 Pod。你可以指定 <code>maxUnavailable</code> 和 <code>maxSurge</code> 来控制滚动更新 过程。</li>
<li><code>.spec.strategy.rollingUpdate.maxUnavailable</code> -  是一个可选字段，用来指定 更新过程中不可用的 Pod 的个数上限，默认值为 25%。如果 <code>.spec.strategy.rollingUpdate.maxSurge</code> 为 0，则此值不能为 0</li>
<li><code>.spec.strategy.rollingUpdate.maxSurge</code> - 是一个可选字段，用来指定可以创建的超出期望 Pod 个数的 Pod 数量， 如果 <code>MaxUnavailable</code> 为 0，则此值不能为 0，此字段的默认值为 25%</li>
</ul>
</li>
</ul>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p><a href="https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/service-resources/service-v1/">Service 资源定义官网 API 说明</a></p>
<p>将运行在一组 Pods 上的应用程序公开为网络服务的抽象方法。主要为后端的一组 POD （通过选择算符选定）提供 <code>Cluster-IP</code> 和负载均衡（默认轮询）及高可用（只有就绪的 POD 才会被对外公布，未就绪的 POD 不会对外发布）。 <sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[服务（Service）](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/)">[5]</span></a></sup></p>
<h3 id="有选择算符的-Service"><a href="#有选择算符的-Service" class="headerlink" title="有选择算符的 Service"></a>有选择算符的 Service</h3><p><code>Service</code> 所针对的 <code>Pod</code> 集合通常是通过 <strong><a href="#%E6%A0%87%E7%AD%BE%E5%92%8C%E9%80%89%E6%8B%A9%E7%AE%97%E7%AC%A6">选择算符</a></strong> 来确定的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: my-service</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app.kubernetes.io/name: MyApp</span><br><span class="line">  ports:</span><br><span class="line">    # 多端口 Service 时，必须提供所有的端口名称，以使端口无歧义</span><br><span class="line">    - name: http</span><br><span class="line">      protocol: TCP</span><br><span class="line">      port: 80</span><br><span class="line">      targetPort: 9376</span><br><span class="line">    - name: https</span><br><span class="line">      protocol: TCP</span><br><span class="line">      port: 443</span><br><span class="line">      targetPort: 9378</span><br><span class="line">      </span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">非常用字段</span></span><br><span class="line">  sessionAffinity: None</span><br><span class="line">  ipFamilies:</span><br><span class="line">    - IPv4</span><br><span class="line">  ipFamilyPolicy: SingleStack</span><br><span class="line">  internalTrafficPolicy: Cluster</span><br><span class="line">  </span><br><span class="line">  type: ClusterIP</span><br><span class="line">  clusterIPs:</span><br><span class="line">    - 10.107.120.122</span><br><span class="line">  clusterIP: 10.107.120.122</span><br><span class="line">  </span><br><span class="line">  externalTrafficPolicy: Cluster</span><br><span class="line">  internalTrafficPolicy: Cluster</span><br><span class="line">  </span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="built_in">type</span> 为 NodePort 时</span></span><br><span class="line">  type: NodePort</span><br><span class="line">  ports:</span><br><span class="line">    - nodePort: 30443</span><br><span class="line">      port: 443</span><br><span class="line">      targetPort: 8443</span><br><span class="line">  externalTrafficPolicy: Local</span><br><span class="line">  internalTrafficPolicy: Local</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>.spec.selector</code> - 根据 <strong><a href="#%E6%A0%87%E7%AD%BE%E5%92%8C%E9%80%89%E6%8B%A9%E7%AE%97%E7%AC%A6">选择算符</a></strong> 选择后端的 <code>POD</code></p>
</li>
<li><p><code>.spec.ports[*].name</code> - 对于某些服务，可能需要公开多个端口。 Kubernetes 允许在 <code>Service</code> 对象上配置多个端口定义。 <strong>为服务使用多个端口时，必须提供所有端口名称，以使它们无歧义</strong>。</p>
</li>
<li><p><code>.spec.ports[*].protocol</code> - <code>Service</code> 监听的端口协议，默认为 TCP</p>
</li>
<li><p><code>.spec.ports[*].port</code> - <code>Service</code> 监听的端口</p>
</li>
<li><p><code>.spec.ports[*].targetPort</code> - 后端 <code>POD</code> 监听的端口，不指定的情况（默认）下，<code>targetPort</code> 将被设置为与 <code>port</code> 字段相同的值。</p>
</li>
<li><p><code>.spec.sessionAffinity</code> -  要确保每次都将来自特定客户端的连接传递到同一 <code>Pod</code>，可以设置为 <code>ClientIP</code> (默认为 <code>None</code>) 来基于客户端的 IP 地址选择会话亲和性。还可以通过适当设置 <code>.spec.sessionAffinityConfig.clientIP.timeoutSeconds</code> 来设置最大会话停留时间。（默认值为 10800 秒，即 3 小时）</p>
</li>
<li><p><code>.spec.ipFamilies</code> - 定义分配 ip 版本(IPv4,IPv6)的顺序，此字段是不可变的，因为系统无法为已经存在的服务重新分配 <code>.spec.ClusterIP</code>。如果你想改变 <code>.spec.ipFamilies</code>，则需要删除并重新创建服务。可以配置为以下值：</p>
<ul>
<li><code>IPv4</code></li>
<li><code>IPv6</code></li>
<li><code>&quot;IPv4&quot;,&quot;IPv6&quot;</code></li>
<li><code>&quot;IPv6&quot;,&quot;IPv4&quot;</code></li>
</ul>
</li>
<li><p><code>.spec.ipFamilyPolicy</code> - IP 地址族策略。<sup id="fnref:7"><a href="#fn:7" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[配置 IPv4/IPv6 双协议栈](https://kubernetes.io/zh-cn/docs/concepts/services-networking/dual-stack/#%E9%85%8D%E7%BD%AE-ipv4-ipv6-%E5%8F%8C%E5%8D%8F%E8%AE%AE%E6%A0%88)">[7]</span></a></sup></p>
<ul>
<li><code>SingleStack</code> - 默认值。单栈服务。控制面使用第一个配置的服务集群 IP 范围为服务分配集群 IP</li>
<li><code>PreferDualStack</code> - 为服务分配 IPv4 和 IPv6 集群 IP 地址</li>
<li><code>RequireDualStack</code> - 从基于在 <code>.spec.ipFamilies</code> 数组中第一个元素的地址族的 <code>.spec.ClusterIPs</code> 列表中选择 <code>.spec.ClusterIP</code></li>
</ul>
</li>
<li><p><code>.spec.clusterIPs</code> - IP 的主要字段，值根据 <code>ipFamilies</code>, <code>ipFamilyPolicy</code> 的配置计算而出，<a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/dual-stack/#dual-stack-options-on-new-services">规则参考</a></p>
</li>
<li><p><code>.spec.clusterIP</code> - IP 的次要字段，其取值从 <code>.spec.ClusterIPs</code> 计算而来。也可以通过此字段配置自定义的 IP 地址 <sup id="fnref:9"><a href="#fn:9" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[选择自己的 IP 地址](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#%E9%80%89%E6%8B%A9%E8%87%AA%E5%B7%B1%E7%9A%84-ip-%E5%9C%B0%E5%9D%80)">[9]</span></a></sup> </p>
</li>
<li><p><code>.spec.type</code> - 指定 <code>Service</code> 的类型，默认为 <code>ClusterIP</code>，可选值如下<sup id="fnref:8"><a href="#fn:8" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[NodePort 类型](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#type-nodeport)">[8]</span></a></sup>：</p>
<ul>
<li><code>ClusterIP</code> - 通过集群的内部 IP 暴露服务，选择该值时服务只能够在集群内部访问。 这也是默认值。</li>
<li><code>NodePort</code> - 通过每个节点上的 IP 和静态端口（<code>NodePort</code>，默认范围 <code>30000-32767</code>）暴露服务。<code>NodePort</code> 服务会路由到自动创建的 <code>ClusterIP</code> 服务，此种类型，服务可通过节点 ip 和 <code>NodePort</code> (<code>nodeIP:.spec.ports[*].nodePort</code>)对外访问，也可以通过 <code>.spec.clusterIP:.spec.ports[*].port</code> 对外可见。<strong>1.24 及以后版本，<code>nodePort</code> 对应的端口不会在节点上监听</strong></li>
<li><code>LoadBalancer</code> - 使用云提供商的负载均衡器向外部暴露服务。 外部负载均衡器可以将流量路由到自动创建的 <code>NodePort</code> 服务和 <code>ClusterIP</code> 服务上。</li>
<li><code>ExternalName</code> - 通过返回 <code>CNAME</code> 和对应值，可以将服务映射到 <code>externalName</code> 字段的内容（例如，<code>foo.bar.example.com</code>）。 无需创建任何类型代理。</li>
</ul>
</li>
<li><p><code>.spec.externalTrafficPolicy</code> - 控制来自于外部的流量是如何路由的, 可选值有 <code>Cluster</code> 和 <code>Local</code></p>
<ul>
<li><code>Cluster</code> - 将外部流量路由到所有就绪的端点</li>
<li><code>Local</code> - 只路由到当前节点上就绪的端点，如果当前节点上没有就绪的端点，<code>kube-proxy</code> 不会转发请求相关服务的任何流量</li>
</ul>
</li>
<li><p><code>.spec.internalTrafficPolicy</code> - 控制内部来源的流量是如何转发的，可选值有 <code>Cluster</code> 和 <code>Local</code></p>
</li>
</ul>
<p>Kubernetes 为该服务分配一个 IP 地址（有时称为 “集群 IP”），该 IP 地址由服务代理使用。</p>
<p><code>Pod</code> 中的端口定义是有名字的，你可以在 <code>Service</code> 的 <code>targetPort</code> 属性中引用这些名称。 例如，我们可以通过以下方式将 <code>Service</code> 的 <code>targetPort</code> 绑定到 <code>Pod</code> 端口：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">  labels:</span><br><span class="line">    app.kubernetes.io/name: proxy</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx:stable</span><br><span class="line">    ports:</span><br><span class="line">      - containerPort: 80</span><br><span class="line">        name: http-web-svc</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-service</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app.kubernetes.io/name: proxy</span><br><span class="line">  ports:</span><br><span class="line">  - name: name-of-service-port</span><br><span class="line">    protocol: TCP</span><br><span class="line">    port: 80</span><br><span class="line">    targetPort: http-web-svc</span><br></pre></td></tr></table></figure>

<h3 id="没有选择算符的-Service"><a href="#没有选择算符的-Service" class="headerlink" title="没有选择算符的 Service"></a>没有选择算符的 Service</h3><p>由于选择算符的存在，服务最常见的用法是为 Kubernetes Pod 的访问提供抽象， 但是当与相应的 <code>Endpoints</code> 对象一起使用且没有选择算符时， 服务也可以为其他类型的后端提供抽象，包括在集群外运行的后端 <sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[没有选择算符的 Service](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#services-without-selectors)">[6]</span></a></sup></p>
<p>定义没有选择算符的 <code>Service</code> 实例:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: my-service</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">    - protocol: TCP</span><br><span class="line">      port: 80</span><br><span class="line">      targetPort: 9376</span><br></pre></td></tr></table></figure>
<p>由于此服务没有选择算符，因此不会自动创建相应的 <code>Endpoints</code> 对象。 你可以通过手动添加 <code>Endpoints</code> 对象，将服务手动映射到运行该服务的网络地址和端口：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Endpoints</span><br><span class="line">metadata:</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">这里的 name 要与 Service 的名字相同</span></span><br><span class="line">  name: my-service</span><br><span class="line">subsets:</span><br><span class="line">  - addresses:</span><br><span class="line">      - ip: 192.0.2.42</span><br><span class="line">    ports:</span><br><span class="line">      - port: 9376</span><br></pre></td></tr></table></figure>
<p><strong>当你为某个 <code>Service</code> 创建一个 <code>Endpoints</code> 对象时，你要将新对象的名称设置为与 <code>Service</code> 的名称相同。</strong></p>
<blockquote>
<p><strong>说明</strong>：<br>端点 IPs 必须不可以 是：本地回路（IPv4 的 127.0.0.0&#x2F;8, IPv6 的 ::1&#x2F;128） 或本地链接（IPv4 的 169.254.0.0&#x2F;16 和 224.0.0.0&#x2F;24，IPv6 的 fe80::&#x2F;64)。</p>
<p>端点 IP 地址不能是其他 Kubernetes 服务的集群 IP，因为 kube-proxy 不支持将虚拟 IP 作为目标。</p>
</blockquote>
<h3 id="无头服务（Headless-Services）"><a href="#无头服务（Headless-Services）" class="headerlink" title="无头服务（Headless Services）"></a>无头服务（Headless Services）</h3><p>有时不需要或不想要负载均衡，以及单独的 Service IP。 遇到这种情况，可以通过指定 Cluster IP（<code>spec.clusterIP</code>）的值为 <code>None</code> 来创建 <code>Headless Service</code>。<sup id="fnref:14"><a href="#fn:14" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[无头服务（Headless Services）](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#headless-services)">[14]</span></a></sup></p>
<p>创建 <code>Headless Services</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia-headless</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  clusterIP: None              #这使得服务成为 headless service</span><br><span class="line">  ports:</span><br><span class="line">  - port: 80</span><br><span class="line">    targetPort: 8080</span><br><span class="line">  selector:</span><br><span class="line">    app: kubia</span><br></pre></td></tr></table></figure>

<p>使用此配置创建的 <code>Headless Services</code>，系统不会为其分配 <code>CLUSTER-IP</code>。</p>
<p>当通过此服务的 FQDN <code>kubia-headless.default.svc.cluster.local</code> 解析时，系统会返回此服务 <strong>选择算符 <code>.spec.selector</code></strong> 选择的 <strong>就绪</strong> 的后端 POD 的 IP。</p>
<p>如果配置的是 <a href="#%E6%B2%A1%E6%9C%89%E9%80%89%E6%8B%A9%E7%AE%97%E7%AC%A6%E7%9A%84-Service">不带选择算符的服务</a>，<a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#without-selectors">解析规则如是</a>，如果查找到了和 Service 的 <code>name</code> 一样的 <code>endpoint</code>，则解析到此 <code>endpoint</code>。</p>
<h2 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h2><p><code>Ingress</code> 可为 <code>Service</code> 提供外部可访问的 URL、负载均衡流量、终止 SSL&#x2F;TLS，以及基于名称的虚拟托管。</p>
<p><strong><code>Ingress</code> 不会公开任意端口或协议</strong>。 将 HTTP 和 HTTPS 以外的服务公开到 Internet 时，通常使用 <code>Service.Type=NodePort</code> 或 <code>Service.Type=LoadBalancer</code> 类型的 <code>Service</code>。</p>
<p>你必须拥有一个 <code>Ingress 控制器</code> 才能满足 <code>Ingress</code> 的要求。 仅创建 <code>Ingress</code> 资源本身没有任何效果。</p>
<h3 id="安装-ingress-nginx-controller"><a href="#安装-ingress-nginx-controller" class="headerlink" title="安装 ingress-nginx controller"></a>安装 ingress-nginx controller</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.3.1/deploy/static/provider/cloud/deploy.yaml</span><br></pre></td></tr></table></figure>
<p>编辑 <code>ingress-nginx</code> 的 <code>Deployment</code> 配置文件，在 <code>Deployment</code> 中的 <code>.spec.template.spec</code> 下添加字段 <code>hostNetwork: true</code>，以使 <code>ingress-nginx-controller</code> 可以使用节点的主机网络提供对外访问<br><img src="https://i.csms.tech/img_61.png"></p>
<p>创建 <code>Ingress</code> 对象</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: example-ingress</span><br><span class="line">  annotations:</span><br><span class="line">    nginx.ingress.kubernetes.io/rewrite-target: /$1</span><br><span class="line">spec:</span><br><span class="line">  ingressClassName: nginx</span><br><span class="line">  rules:</span><br><span class="line">    - host: hello-world.info</span><br><span class="line">      http:</span><br><span class="line">        paths:</span><br><span class="line">          - path: /</span><br><span class="line">            pathType: Prefix</span><br><span class="line">            backend:</span><br><span class="line">              service:</span><br><span class="line">                name: web</span><br><span class="line">                port:</span><br><span class="line">                  number: 8080</span><br></pre></td></tr></table></figure>
<p>配置完成后，查看 <code>Ingress</code> 资源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get ingress -o wide</span></span><br><span class="line">NAME              CLASS   HOSTS              ADDRESS   PORTS   AGE</span><br><span class="line">example-ingress   nginx   hello-world.info             80      131m</span><br></pre></td></tr></table></figure>
<p>将域名解析到 <code>ingress-nginx-controller</code> 所在节点的 IP，即可在外部访问服务。</p>
<p>为了将 <code>ingress-nginx-controller</code> 固定启动在边缘节点，可以使用 <code>DaemonSet</code> 替代 <code>Deployment</code>。</p>
<blockquote>
<p><code>Ingress Controller</code> 不会将请求转发给 <code>Service</code>，只通过 <code>Service</code> 获取到 <code>Endpoints</code>，从而决定将请求转发到哪个 Pod。从流量的流经路径看，流量是直接从 <code>Ingress Controller</code> 发送到了 Pod   </p>
</blockquote>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/kubernetes-objects/#required-fields">必需字段</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names/">对象名称和 IDs</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/">标签和选择算符</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/owners-dependents/">属主与附属</a><a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/">服务（Service）</a><a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#services-without-selectors">没有选择算符的 Service</a><a href="#fnref:6" rev="footnote"> ↩</a></span></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/dual-stack/#%E9%85%8D%E7%BD%AE-ipv4-ipv6-%E5%8F%8C%E5%8D%8F%E8%AE%AE%E6%A0%88">配置 IPv4/IPv6 双协议栈</a><a href="#fnref:7" rev="footnote"> ↩</a></span></li><li id="fn:8"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">8.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#type-nodeport">NodePort 类型</a><a href="#fnref:8" rev="footnote"> ↩</a></span></li><li id="fn:9"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">9.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#%E9%80%89%E6%8B%A9%E8%87%AA%E5%B7%B1%E7%9A%84-ip-%E5%9C%B0%E5%9D%80">选择自己的 IP 地址</a><a href="#fnref:9" rev="footnote"> ↩</a></span></li><li id="fn:10"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">10.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/">配置存活、就绪和启动探针</a><a href="#fnref:10" rev="footnote"> ↩</a></span></li><li id="fn:11"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">11.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#container-probes">容器探针</a><a href="#fnref:11" rev="footnote"> ↩</a></span></li><li id="fn:12"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">12.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/assign-pod-node/#nodename">nodeName </a><a href="#fnref:12" rev="footnote"> ↩</a></span></li><li id="fn:13"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">13.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/assign-pod-node/#nodename">将 Pod 指派给节点</a><a href="#fnref:13" rev="footnote"> ↩</a></span></li><li id="fn:14"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">14.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#headless-services">无头服务（Headless Services）</a><a href="#fnref:14" rev="footnote"> ↩</a></span></li><li id="fn:15"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">15.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/tasks/inject-data-application/define-environment-variable-container/">为容器设置环境变量</a><a href="#fnref:15" rev="footnote"> ↩</a></span></li><li id="fn:16"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">16.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/topology-spread-constraints/">Pod 拓扑分布约束</a><a href="#fnref:16" rev="footnote"> ↩</a></span></li><li id="fn:17"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">17.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#strategy">策略</a><a href="#fnref:17" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S 上安装 Prometheus 并监控 K8S 集群</title>
    <url>/202212141608/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="版本信息"><a href="#版本信息" class="headerlink" title="版本信息"></a>版本信息</h1><ul>
<li>Centos 7</li>
<li>Kubernetes 1.24</li>
<li>Prometheus 2.44.0</li>
<li>AlertManager 0.24.0</li>
</ul>
<h1 id="Prometheus-部署步骤"><a href="#Prometheus-部署步骤" class="headerlink" title="Prometheus 部署步骤"></a>Prometheus 部署步骤</h1><h2 id="为-Prometheus-创建专用的-Namespace，此处创建-prometheus"><a href="#为-Prometheus-创建专用的-Namespace，此处创建-prometheus" class="headerlink" title="为 Prometheus 创建专用的 Namespace，此处创建 prometheus"></a>为 Prometheus 创建专用的 Namespace，此处创建 <code>prometheus</code></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create namespace prometheus</span><br></pre></td></tr></table></figure>

<h2 id="创建集群角色"><a href="#创建集群角色" class="headerlink" title="创建集群角色"></a>创建集群角色</h2><p>Prometheus 使用 Kubernetes API 从 Nodes、Pods、Deployments 等等中读取所有可用的指标。因此，我们需要创建一个包含 read access 所需 API 组的 RBAC 策略，并将该策略绑定到新建的 <code>prometheus</code> 命名空间。<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[如何部署 Prometheus 监控K8S](https://zhuanlan.zhihu.com/p/456205833)">[1]</span></a></sup></p>
<ol>
<li>创建一个名为 <code>prometheusClusterRole.yaml</code>的文件，并复制以下 RBAC 角色。<blockquote>
<p>在下面给出的角色中，可以看到，我们已经往 <code>nodes</code>, <code>services endpoints</code>, <code>pods</code> 和 <code>ingresses</code> 中添加了 <code>get</code>，<code>list</code> 以及 <code>watch</code> 权限。角色绑定被绑定到监控命名空间。如果有任何要从其他对象中检索指标的用例，则需要将其添加到此集群角色中。</p>
</blockquote>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRole</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus</span><br><span class="line">rules:</span><br><span class="line">- apiGroups: [&quot;&quot;]</span><br><span class="line">  resources:</span><br><span class="line">  - nodes</span><br><span class="line">  - nodes/proxy</span><br><span class="line">  - nodes/metrics</span><br><span class="line">  - services</span><br><span class="line">  - endpoints</span><br><span class="line">  - pods</span><br><span class="line">  verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;]</span><br><span class="line">- apiGroups:</span><br><span class="line">  - extensions</span><br><span class="line">  resources:</span><br><span class="line">  - ingresses</span><br><span class="line">  verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;]</span><br><span class="line">- nonResourceURLs: [&quot;/metrics&quot;]</span><br><span class="line">  verbs: [&quot;get&quot;]</span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: prometheus</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: default</span><br><span class="line">  namespace: prometheus</span><br></pre></td></tr></table></figure></li>
<li>使用下面的命令创建角色<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl apply -f prometheusClusterRole.yaml</span><br></pre></td></tr></table></figure></li>
</ol>
<span id="more"></span>
<h2 id="创建-ConfigMap-以外部化-Prometheus-配置"><a href="#创建-ConfigMap-以外部化-Prometheus-配置" class="headerlink" title="创建 ConfigMap 以外部化 Prometheus 配置"></a>创建 ConfigMap 以外部化 Prometheus 配置</h2><p>Prometheus 的所有配置都是 <code>prometheus.yaml</code> 文件的一部分，而 <code>Alertmanager</code> 的所有警报规则都配置在 <code>prometheus.rules</code></p>
<ul>
<li><code>prometheus.yaml</code> - 这是主要的 Prometheus 配置，包含所有抓取配置、服务发现详细信息、存储位置、数据保留配置等</li>
<li><code>*.rules</code> - 此文件包含所有 Prometheus 警报规则</li>
</ul>
<p>通过将 Prometheus 配置外部化到 Kubernetes 的 <code>ConfigMap</code>，那么就无需当需要添加或删除配置时，再来构建 Prometheus 镜像。这里需要更新配置映射并重新启动 Prometheus Pod 以应用新配置。</p>
<p>使用以下内容创建 <code>ConfigMap</code>。开始学习时可以先使用 <a href="/202211221610/" title="基础配置">基础配置</a>，熟悉之后逐步添加配置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus-server-conf</span><br><span class="line">  labels:</span><br><span class="line">    name: prometheus-server-conf</span><br><span class="line">  namespace: prometheus</span><br><span class="line">data:</span><br><span class="line">  prometheus.rules: |-</span><br><span class="line">    groups:</span><br><span class="line">    - name: devopscube demo alert</span><br><span class="line">      rules:</span><br><span class="line">      - alert: High Pod Memory</span><br><span class="line">        expr: sum(container_memory_usage_bytes) &gt; 1</span><br><span class="line">        for: 1m</span><br><span class="line">        labels:</span><br><span class="line">          severity: slack</span><br><span class="line">        annotations:</span><br><span class="line">          summary: High Memory Usage</span><br><span class="line">          </span><br><span class="line">  prometheus.yml: |-</span><br><span class="line">    global:</span><br><span class="line">      scrape_interval: 5s</span><br><span class="line">      evaluation_interval: 5s</span><br><span class="line">    </span><br><span class="line">    alerting:</span><br><span class="line">      alertmanagers:</span><br><span class="line">        - static_configs:</span><br><span class="line">            - targets: [&#x27;localhost:9093&#x27;]</span><br><span class="line">    </span><br><span class="line">    rule_files:</span><br><span class="line">      - /etc/prometheus/*.rules</span><br><span class="line">    </span><br><span class="line">    scrape_configs:</span><br><span class="line">      - job_name: &#x27;prometheus&#x27;</span><br><span class="line">        static_configs:</span><br><span class="line">        - targets: [&#x27;localhost:9090&#x27;]</span><br><span class="line">        </span><br><span class="line">      - job_name: &#x27;kubernetes-nodes&#x27;</span><br><span class="line">        tls_config:</span><br><span class="line">          ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt</span><br><span class="line">        bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token</span><br><span class="line">        kubernetes_sd_configs:</span><br><span class="line">        - role: node</span><br><span class="line">        relabel_configs:</span><br><span class="line">        - source_labels: [__address__]</span><br><span class="line">          regex: &#x27;(.*):10250&#x27;</span><br><span class="line">          replacement: &#x27;$&#123;1&#125;:9100&#x27;</span><br><span class="line">          target_label: __address__</span><br><span class="line">          action: replace</span><br><span class="line">        - action: labelmap</span><br><span class="line">          regex: __meta_kubernetes_node_label_(.+)</span><br><span class="line">    </span><br><span class="line">      - job_name: &#x27;kubernetes-kubelet&#x27;</span><br><span class="line">        kubernetes_sd_configs:</span><br><span class="line">        - role: node</span><br><span class="line">        scheme: https</span><br><span class="line">        tls_config:</span><br><span class="line">          ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt</span><br><span class="line">          insecure_skip_verify: true</span><br><span class="line">        bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token</span><br><span class="line">        relabel_configs:</span><br><span class="line">        - action: labelmap</span><br><span class="line">          regex: __meta_kubernetes_node_label_(.+)</span><br><span class="line">      - job_name: &#x27;kubernetes-cadvisor&#x27;</span><br><span class="line">        scheme: https</span><br><span class="line">        tls_config:</span><br><span class="line">          ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt</span><br><span class="line">          insecure_skip_verify: true</span><br><span class="line">        kubernetes_sd_configs:</span><br><span class="line">        - role: node</span><br><span class="line">        bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token</span><br><span class="line">        relabel_configs:</span><br><span class="line">        - source_labels: [__meta_kubernetes_node_name]</span><br><span class="line">          regex: (.+)</span><br><span class="line">          target_label: __metrics_path__</span><br><span class="line">          replacement: metrics/cadvisor</span><br><span class="line">        - action: labelmap</span><br><span class="line">          regex: __meta_kubernetes_node_label_(.+)</span><br><span class="line">      </span><br></pre></td></tr></table></figure>

<p><code>prometheus.yaml</code> 包含了用以发现动态运行在 Kubernetes 集群中的资源的配置。</p>
<h2 id="部署-Prometheus-Server"><a href="#部署-Prometheus-Server" class="headerlink" title="部署 Prometheus Server"></a>部署 Prometheus Server</h2><p>使用以下内容创建 Deployment，在此配置中，我们将 Prometheus 的 <code>ConfigMap</code> 作为文件安装在 <code>/etc/prometheus</code> 中，持久化存储使用 PV。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus-pod</span><br><span class="line">  namespace: prometheus</span><br><span class="line">  labels:</span><br><span class="line">    app: prometheus-server</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: prometheus-server</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: prometheus-server</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">        - name: prometheus</span><br><span class="line">          image: prom/prometheus</span><br><span class="line">          args:</span><br><span class="line">            - &quot;--storage.tsdb.retention.time=12h&quot;</span><br><span class="line">            - &quot;--config.file=/etc/prometheus/prometheus.yml&quot;</span><br><span class="line">            - &quot;--storage.tsdb.path=/prometheus/&quot;</span><br><span class="line">          ports:</span><br><span class="line">            - containerPort: 9090</span><br><span class="line">          resources:</span><br><span class="line">            requests:</span><br><span class="line">              cpu: 500m</span><br><span class="line">              memory: 500M</span><br><span class="line">            limits:</span><br><span class="line">              cpu: 1</span><br><span class="line">              memory: 1Gi</span><br><span class="line">          volumeMounts:</span><br><span class="line">            - name: prometheus-config-volume</span><br><span class="line">              mountPath: /etc/prometheus/</span><br><span class="line">            - name: prometheus-storage-volume</span><br><span class="line">              mountPath: /prometheus/</span><br><span class="line">      volumes:</span><br><span class="line">        - name: prometheus-config-volume</span><br><span class="line">          configMap:</span><br><span class="line">            defaultMode: 420</span><br><span class="line">            name: prometheus-server-conf</span><br><span class="line">  </span><br><span class="line">        - name: prometheus-storage-volume</span><br><span class="line">          persistentVolumeClaim:</span><br><span class="line">            claimName: prometheus-pvc</span><br></pre></td></tr></table></figure>

<p>使用以下内容为 Prometheus Server 创建 Ingress</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus-service</span><br><span class="line">  namespace: prometheus</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">    - name: prometheus-port</span><br><span class="line">      port: 8090</span><br><span class="line">      protocol: TCP</span><br><span class="line">      targetPort: 9090</span><br><span class="line">  selector:</span><br><span class="line">    app: prometheus-server</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus-ui</span><br><span class="line">  namespace: prometheus</span><br><span class="line"></span><br><span class="line">spec:</span><br><span class="line">  ingressClassName: nginx</span><br><span class="line">  rules:</span><br><span class="line">  - host: prometheus.example.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - backend:</span><br><span class="line">          service:</span><br><span class="line">            name: prometheus-service</span><br><span class="line">            port: </span><br><span class="line">              number: 8090</span><br><span class="line">        path: /</span><br><span class="line">        pathType: Prefix</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>部署完成后，使用 <code>prometheus.example.com</code> 访问<br><img src="https://i.csms.tech/img_109.png"><br>可以通过 url <code>http://prometheus.example.com/config</code> 查看当前的 prometheus 配置</p>
<h2 id="部署-Grafana"><a href="#部署-Grafana" class="headerlink" title="部署 Grafana"></a>部署 Grafana</h2><p>如需部署 Grafana，可以使用以下配置，需要持久化数据目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus-pod</span><br><span class="line">  namespace: prometheus</span><br><span class="line">  labels:</span><br><span class="line">    app: prometheus-server</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: prometheus-server</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: prometheus-server</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">        - name: prometheus</span><br><span class="line">          image: prom/prometheus</span><br><span class="line">          args:</span><br><span class="line">            - &quot;--storage.tsdb.retention.time=12h&quot;</span><br><span class="line">            - &quot;--config.file=/etc/prometheus/prometheus.yml&quot;</span><br><span class="line">            - &quot;--storage.tsdb.path=/prometheus/&quot;</span><br><span class="line">          ports:</span><br><span class="line">            - containerPort: 9090</span><br><span class="line">          resources:</span><br><span class="line">            requests:</span><br><span class="line">              cpu: 500m</span><br><span class="line">              memory: 500M</span><br><span class="line">            limits:</span><br><span class="line">              cpu: 1</span><br><span class="line">              memory: 1Gi</span><br><span class="line">          volumeMounts:</span><br><span class="line">            - name: prometheus-config-volume</span><br><span class="line">              mountPath: /etc/prometheus/</span><br><span class="line">            - name: prometheus-storage-volume</span><br><span class="line">              mountPath: /prometheus/</span><br><span class="line">              subPath: prometheus</span><br><span class="line">        - name: grafana</span><br><span class="line">          image: grafana/grafana</span><br><span class="line">          ports:</span><br><span class="line">            - containerPort: 3000</span><br><span class="line">          volumeMounts:</span><br><span class="line">            - name: prometheus-storage-volume</span><br><span class="line">              mountPath: /var/lib/grafana</span><br><span class="line">              subPath: grafana</span><br><span class="line">      volumes:</span><br><span class="line">        - name: prometheus-config-volume</span><br><span class="line">          configMap:</span><br><span class="line">            defaultMode: 420</span><br><span class="line">            name: prometheus-server-conf</span><br><span class="line">  </span><br><span class="line">        - name: prometheus-storage-volume</span><br><span class="line">          persistentVolumeClaim:</span><br><span class="line">            claimName: prometheus-pvc</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus-service</span><br><span class="line">  namespace: prometheus</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">    - name: prometheus-port</span><br><span class="line">      port: 8090</span><br><span class="line">      protocol: TCP</span><br><span class="line">      targetPort: 9090</span><br><span class="line">    - name: grafana-port</span><br><span class="line">      port: 3000</span><br><span class="line">      targetPort: 3000</span><br><span class="line">  selector:</span><br><span class="line">    app: prometheus-server</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus-ui</span><br><span class="line">  namespace: prometheus</span><br><span class="line"></span><br><span class="line">spec:</span><br><span class="line">  ingressClassName: nginx</span><br><span class="line">  rules:</span><br><span class="line">  - host: prometheus.example.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - backend:</span><br><span class="line">          service:</span><br><span class="line">            name: prometheus-service</span><br><span class="line">            port: </span><br><span class="line">              number: 8090</span><br><span class="line">        path: /</span><br><span class="line">        pathType: Prefix</span><br><span class="line">  - host: grafana.example.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - backend:</span><br><span class="line">          service:</span><br><span class="line">            name: prometheus-service</span><br><span class="line">            port:</span><br><span class="line">              number: 3000</span><br><span class="line">        path: /</span><br><span class="line">        pathType: Prefix</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="集群节点上部署-node-exporter-对集群节点进行监控"><a href="#集群节点上部署-node-exporter-对集群节点进行监控" class="headerlink" title="集群节点上部署 node-exporter 对集群节点进行监控"></a>集群节点上部署 node-exporter 对集群节点进行监控</h2><p>使用 <code>DaemonSet</code> 方式在每个 Node 上部署 <code>node-exporter</code>，本示例运行在 <code>prometheus</code> 的 Namespace 中。为了暴露 <code>node-exporter</code> 给 Prometheus Server ，可以使用以下方法。建议使用第 2 种方法。</p>
<ol>
<li><p>Service 的 port type 配置为 <code>NodePort</code>。<a href="https://csms.tech/202209121102/#修改-Service-可使用的-nodePort-端口范围">配置 Kubernetes API Server 允许 9100 端口配置为 NodePort 参考</a>，如此可以直接通过节点 IP 访问 <code>node-exporter</code></p>
<p>为了确保 Prometheus Server 请求查询指定节点的监控数据的流量都能被本节点上的 <code>node-exporter</code> 处理，建议配置 <code>externalTrafficPolicy: Local</code>、<code>internalTrafficPolicy: Local</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: DaemonSet</span><br><span class="line">metadata:</span><br><span class="line">  name: node-exporter</span><br><span class="line">  namespace: prometheus</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: node-exporter</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      name: node-exporter</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        name: node-exporter</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: node-exporter</span><br><span class="line">        image: prom/node-exporter</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 9100</span><br><span class="line">          protocol: TCP</span><br><span class="line">          name: http</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: node-exporter</span><br><span class="line">  name: node-exporter</span><br><span class="line">  namespace: prometheus</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - name: http</span><br><span class="line">    port: 9100</span><br><span class="line">    protocol: TCP</span><br><span class="line">    targetPort: 9100</span><br><span class="line">    nodePort: 39100</span><br><span class="line">  selector:</span><br><span class="line">    name: node-exporter</span><br><span class="line">  sessionAffinity: None</span><br><span class="line">  type: NodePort</span><br><span class="line">  externalTrafficPolicy: Local</span><br><span class="line">  internalTrafficPolicy: Local</span><br></pre></td></tr></table></figure></li>
<li><p>不使用 Service，直接配置 Pod 网络为 <code>hostNetwork</code>，如此 Pod 的 Network Namespace 是在节点的 Root Network Namespace，可以直接使用节点的网络资源。同时配置 Pod 使用节点的 PID、IPC 资源。挂载主机的 <code>/dev</code>、<code>/proc</code>、<code>/sys</code> 等目录到容器中，以使 <code>node-exporter</code> 可以监控到节点上的数据。<strong>否则，node-expoter 因为权限问题无法监控到节点的资源</strong></p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: DaemonSet</span><br><span class="line">metadata:</span><br><span class="line">  name: node-exporter</span><br><span class="line">  namespace: prometheus</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: node-exporter</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      name: node-exporter</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        name: node-exporter</span><br><span class="line">    spec:</span><br><span class="line">      hostPid: true</span><br><span class="line">      hostIPC: true</span><br><span class="line">      hostNetwork: true</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      containers:</span><br><span class="line">      - name: node-exporter</span><br><span class="line">        image: prom/node-exporter</span><br><span class="line">        securityContext:</span><br><span class="line">          privileged: true</span><br><span class="line">        args:</span><br><span class="line">          - --path.procfs</span><br><span class="line">          - /host/proc</span><br><span class="line">          - --path.sysfs</span><br><span class="line">          - /host/sys</span><br><span class="line">          - --collector.filesystem.ignored-mount-points</span><br><span class="line">          - &#x27;&quot;^/(sys|proc|dev|host|etc)($|/)&quot;&#x27;</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: dev</span><br><span class="line">          mountPath: /host/dev</span><br><span class="line">        - name: proc</span><br><span class="line">          mountPath: /host/proc</span><br><span class="line">        - name: sys</span><br><span class="line">          mountPath: /host/sys</span><br><span class="line">        - name: rootfs</span><br><span class="line">          mountPath: /rootfs</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 9100</span><br><span class="line">          protocol: TCP</span><br><span class="line">          name: http</span><br><span class="line">      volumes:</span><br><span class="line">      - name: proc</span><br><span class="line">        hostPath:</span><br><span class="line">          path: /proc</span><br><span class="line">      - name: dev</span><br><span class="line">        hostPath:</span><br><span class="line">          path: /dev</span><br><span class="line">      - name: sys</span><br><span class="line">        hostPath:</span><br><span class="line">          path: /sys</span><br><span class="line">      - name: rootfs</span><br><span class="line">        hostPath:</span><br><span class="line">          path: /</span><br></pre></td></tr></table></figure></li>
</ol>
<p>部署之后通过 Grafana 导入 <a href="https://grafana.com/grafana/dashboards/8919">8919 Dashboard</a>，可以通过 <code>node exporter</code> 实现采集 node 节点上的监控数据。</p>
<p>如果部署之后，Dashboard 显示无数据，需要排查 <code>node-exporter</code> 相关的 <code>Service</code>，<code>EndPoint</code> 是否正常。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get services -n prometheus</span></span><br><span class="line">NAME                 TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)             AGE</span><br><span class="line">node-exporter        ClusterIP   10.102.48.208   &lt;none&gt;        9100/TCP            44m</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get endpoints -n prometheus</span></span><br><span class="line">NAME                 ENDPOINTS                             AGE</span><br><span class="line">node-exporter        10.244.3.107:9100,10.244.4.64:9100    49m</span><br></pre></td></tr></table></figure>

<h2 id="配置-Prometheus-支持-Kubernetes-服务发现"><a href="#配置-Prometheus-支持-Kubernetes-服务发现" class="headerlink" title="配置 Prometheus 支持 Kubernetes 服务发现"></a>配置 Prometheus 支持 Kubernetes 服务发现</h2><p>在 Kubernetes 下，Promethues 通过与 Kubernetes API 集成目前主要支持5种服务发现模式，分别是： <sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Kubernetes 服务发现](https://yunlzheng.gitbook.io/prometheus-book/part-iii-prometheus-shi-zhan/readmd/service-discovery-with-kubernetes#fu-wu-fa-xian)">[3]</span></a></sup></p>
<ul>
<li><code>Node</code></li>
<li><code>Service</code></li>
<li><code>Pod</code></li>
<li><code>Endpoints</code></li>
<li><code>Ingress</code></li>
</ul>
<h3 id="配置-Prometheus-支持-Kubernetes-节点自动发现并抓取监控指标"><a href="#配置-Prometheus-支持-Kubernetes-节点自动发现并抓取监控指标" class="headerlink" title="配置 Prometheus 支持 Kubernetes 节点自动发现并抓取监控指标"></a>配置 Prometheus 支持 Kubernetes 节点自动发现并抓取监控指标</h3><p>为了让 Prometheus 能够获取到当前集群中所有节点的信息，在 Promtheus 的配置文件中，添加如下 Job 配置：</p>
<figure class="highlight shell"><figcaption><span>/etc/prometheus/prometheus.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">- job_name: &#x27;kubernetes-nodes&#x27;</span><br><span class="line">  tls_config:</span><br><span class="line">    ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt</span><br><span class="line">  bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token</span><br><span class="line">  kubernetes_sd_configs:</span><br><span class="line">  - role: node</span><br><span class="line">  relabel_configs:</span><br><span class="line">  - source_labels: [__address__]</span><br><span class="line">    regex: &#x27;(.*):10250&#x27;</span><br><span class="line">    replacement: &#x27;$&#123;1&#125;:9100&#x27;</span><br><span class="line">    target_label: __address__</span><br><span class="line">    action: replace</span><br></pre></td></tr></table></figure>
<p>通过指定 <code>kubernetes_sd_config</code> 的模式为 <code>node</code>，Prometheus 会自动从 Kubernetes 中发现到所有的 node 节点并作为当前 Job 监控的 Target 实例。这里需要指定用于 <a href="/202304271425/" title="访问 Kubernetes API 的 ca 以及 token 文件路径">访问 Kubernetes API 的 ca 以及 token 文件路径</a>。</p>
<p>通过以上配置，Prometheus 可以自动从 Kubernetes API Server 中发现节点的信息，并将其作为当前 Job 的 Target 实例，此配置下默认只存在 2 个标签<br><img src="https://i.csms.tech/img_155.png"></p>
<p>要将节点中的所有标签添加到 Prometheus 监控指标中，可以添加以下 <code>labelmap</code> 配置，意思为将正则表达式 <code>__meta_kubernetes_node_label_(.+)</code> 匹配的数据也添加到指标数据的 Lable 中去。</p>
<figure class="highlight shell"><figcaption><span>/etc/prometheus/prometheus.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">- job_name: &#x27;kubernetes-nodes&#x27;</span><br><span class="line">  tls_config:</span><br><span class="line">    ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt</span><br><span class="line">  bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token</span><br><span class="line">  kubernetes_sd_configs:</span><br><span class="line">  - role: node</span><br><span class="line">  relabel_configs:</span><br><span class="line">  - source_labels: [__address__]</span><br><span class="line">    regex: &#x27;(.*):10250&#x27;</span><br><span class="line">    replacement: &#x27;$&#123;1&#125;:9100&#x27;</span><br><span class="line">    target_label: __address__</span><br><span class="line">    action: replace</span><br><span class="line">  - action: labelmap</span><br><span class="line">    regex: __meta_kubernetes_node_label_(.+)</span><br></pre></td></tr></table></figure>
<p>以上配置生效后，重新查看节点的标签信息，可以看到节点的的标签已经添加到了 Prometheus 监控指标中。<br><img src="https://i.csms.tech/img_156.png"></p>
<p>对于 <code>kubernetes_sd_configs</code> 下面可用的元信息标签如下：</p>
<ul>
<li><code>__meta_kubernetes_node_name</code> ：节点对象的名称</li>
<li><code>__meta_kubernetes_node_label</code> ：节点对象中的每个标签</li>
<li><code>__meta_kubernetes_node_annotation</code> ：来自节点对象的每个注释</li>
<li><code>__meta_kubernetes_node_address</code> ：每个节点地址类型的第一个地址（如果存在）</li>
</ul>
<h3 id="配置-Prometheus-自动发现-kubelet-并读取监控指标"><a href="#配置-Prometheus-自动发现-kubelet-并读取监控指标" class="headerlink" title="配置 Prometheus 自动发现 kubelet 并读取监控指标"></a>配置 Prometheus 自动发现 kubelet 并读取监控指标</h3><p>kubelet 监听在节点的 10250 端口，通过以下配置可以使 Prometheus 读取 kubelet 提供的监控数据。这里需要 <a href="#%E5%88%9B%E5%BB%BA%E9%9B%86%E7%BE%A4%E8%A7%92%E8%89%B2">配置好 <code>ServiceAccount</code>的权限，以使 Prometheus 有查询集群资源的权限</a>。</p>
<figure class="highlight shell"><figcaption><span>/etc/prometheus/prometheus.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">global:</span><br><span class="line">  scrape_interval: 5s</span><br><span class="line">  evaluation_interval: 5s</span><br><span class="line"></span><br><span class="line">scrape_configs:</span><br><span class="line">  - job_name: &#x27;prometheus&#x27;</span><br><span class="line">    static_configs:</span><br><span class="line">    - targets: [&#x27;localhost:9090&#x27;]</span><br><span class="line">    </span><br><span class="line">  - job_name: &#x27;kubernetes-nodes&#x27;</span><br><span class="line">    tls_config:</span><br><span class="line">      ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt</span><br><span class="line">    bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token</span><br><span class="line">    kubernetes_sd_configs:</span><br><span class="line">    - role: node</span><br><span class="line">    relabel_configs:</span><br><span class="line">    - source_labels: [__address__]</span><br><span class="line">      regex: &#x27;(.*):10250&#x27;</span><br><span class="line">      replacement: &#x27;$&#123;1&#125;:9100&#x27;</span><br><span class="line">      target_label: __address__</span><br><span class="line">      action: replace</span><br><span class="line">    - action: labelmap</span><br><span class="line">      regex: __meta_kubernetes_node_label_(.+)</span><br><span class="line"></span><br><span class="line">  - job_name: &#x27;kubernetes-kubelet&#x27;</span><br><span class="line">    kubernetes_sd_configs:</span><br><span class="line">    - role: node</span><br><span class="line">    scheme: https</span><br><span class="line">    tls_config:</span><br><span class="line">      ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt</span><br><span class="line">      insecure_skip_verify: true</span><br><span class="line">    bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token</span><br><span class="line">    relabel_configs:</span><br><span class="line">    - action: labelmap</span><br><span class="line">      regex: __meta_kubernetes_node_label_(.+)</span><br></pre></td></tr></table></figure>
<p>以上配置生效后，查看 Prometheus 的 Targets，会看到多了 <code>kubernetes-kubelet</code><br><img src="https://i.csms.tech/img_157.png"></p>
<p>但是请求监控数据错误，返回：<code>server returned HTTP status 403 Forbidden</code>。根据日志提示，可能是因为权限原因被拒绝。</p>
<p>Prometheus 请求 Kubelet 使用的是 Token 鉴权 <sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Kubelet 鉴权](https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/kubelet-authn-authz/#kubelet-authorization)
">[5]</span></a></sup> 。基于 <a href="/202305161451/" title="Kubernetes API Server 的 RBAC">Kubernetes API Server 的 RBAC</a>，大体流程为： </p>
<ol>
<li>Pod 使用启动时系统挂载的 Token （<code>/var/run/secrets/kubernetes.io/serviceaccount/token</code>）向 kubelet 发起查询请求。 Prometheus 使用的 Token 路径是在配置文件中指定 <code>bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token</code> </li>
<li>Kubelet 校验 Token 的权限</li>
</ol>
<p>根据错误消息，可以猜测 Token 权限存在问题。以下步骤针对此猜测进行验证，<a href="/202305161451/" title="其原理参考文档">其原理参考文档</a></p>
<ol>
<li>登陆到 Prometheus 所在的 Pod，执行以下命令，模拟请求 Kubelet，从响应可以看到 <code>Forbidden (user=system:serviceaccount:prometheus:default, verb=get, resource=nodes, subresource=metrics)</code>，说明 Pod 使用的 <code>user=system:serviceaccount:prometheus:default</code> ServiceAccount 账号没有权限，并且具体使用的权限为 <code>verb=get, resource=nodes, subresource=metrics</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -v -k -H <span class="string">&quot;Authorization: Bearer `cat /var/run/secrets/kubernetes.io/serviceaccount/token`&quot;</span> https://172.31.19.164:10250/metrics</span></span><br><span class="line">*   Trying 172.31.19.164:10250...</span><br><span class="line">* Connected to 172.31.19.164 (172.31.19.164) port 10250 (#0)</span><br><span class="line">* using HTTP/2</span><br><span class="line">* h2h3 [:method: GET]</span><br><span class="line">* h2h3 [:path: /metrics]</span><br><span class="line">* h2h3 [:scheme: https]</span><br><span class="line">* h2h3 [:authority: 172.31.19.164:10250]</span><br><span class="line">* h2h3 [user-agent: curl/8.0.1]</span><br><span class="line">* h2h3 [accept: */*]</span><br><span class="line">* h2h3 [authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Ik51eFpuNU9MUlp2QkxmWjlxRVpVMjRYYVRpV3RSQk1HanJsRnBjbjJBSzQifQ.eyJhdWQiOlsiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwiXSwiZXhwIjoxNzE2OTcwODc5LCJpYXQiOjE2ODU0MzQ4NzksImlzcyI6Imh0dHBzOi8va3ViZXJuZXRlc]</span><br><span class="line">* Using Stream ID: 1 (easy handle 0x7f1038310af0)</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">GET /metrics HTTP/2</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Host: 172.31.19.164:10250</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">user-agent: curl/8.0.1</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">accept: */*</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Ik51eFpuNU9MUlp2QkxmWjlxRVpVMjRYYVRpV3RSQk1HanJsRnBjbjJBSzQifQ.eyJhdWQiOlsiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwiXSwiZXhwIjoxNzE2OTcwODc5LCJpYXQiOjE2ODU0MzQ4NzksImlzcyI6Imh0dHBzOi8va3ViZXJuZXRlc]</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">* TLSv1.3 (IN), TLS handshake, Newsession Ticket (4):</span></span><br><span class="line">&lt; HTTP/2 403 </span><br><span class="line">&lt; content-type: text/plain; charset=utf-8</span><br><span class="line">&lt; content-length: 104</span><br><span class="line">&lt; date: Tue, 30 May 2023 08:22:34 GMT</span><br><span class="line">&lt; </span><br><span class="line">* Connection #0 to host 172.31.19.164 left intact</span><br><span class="line">Forbidden (user=system:serviceaccount:prometheus:default, verb=get, resource=nodes, subresource=metrics)</span><br></pre></td></tr></table></figure></li>
<li>检查 Prometheus Namespace 中的默认的 ServiceAccount 绑定的权限，其绑定到了名为 <code>prometheus</code> 的 ClusterRole <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl edit clusterrolebinding prometheus</span></span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: prometheus</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: default</span><br><span class="line">  namespace: prometheus</span><br></pre></td></tr></table></figure></li>
<li>检查名为 <code>prometheus</code> 的 ClusterRole 的权限信息，可以看到其中没有对 <code>verb=get, resource=nodes, subresource=metrics</code> 的授权，将其添加到授权中，重新查看 Prometheus 的 Targets 中 <code>kubernetes-kubelet</code> 的状态，请求正常。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl edit clusterrole prometheus</span></span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRole</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus</span><br><span class="line">rules:</span><br><span class="line">- apiGroups:</span><br><span class="line">  - &quot;&quot;</span><br><span class="line">  resources:</span><br><span class="line">  - nodes</span><br><span class="line">  - nodes/proxy</span><br><span class="line">  - nodes/metrics</span><br><span class="line">  - services</span><br><span class="line">  - endpoints</span><br><span class="line">  - pods</span><br><span class="line">  verbs:</span><br><span class="line">  - get</span><br><span class="line">  - list</span><br><span class="line">  - watch</span><br><span class="line">- apiGroups:</span><br><span class="line">  - extensions</span><br><span class="line">  resources:</span><br><span class="line">  - ingresses</span><br><span class="line">  verbs:</span><br><span class="line">  - get</span><br><span class="line">  - list</span><br><span class="line">  - watch</span><br><span class="line">- nonResourceURLs:</span><br><span class="line">  - /metrics</span><br><span class="line">  verbs:</span><br><span class="line">  - get</span><br></pre></td></tr></table></figure>
<img src="https://i.csms.tech/img_158.png"></li>
</ol>
<h3 id="配置-Prometheus-从-cAdvisor-读取监控数据"><a href="#配置-Prometheus-从-cAdvisor-读取监控数据" class="headerlink" title="配置 Prometheus 从 cAdvisor 读取监控数据"></a>配置 Prometheus 从 cAdvisor 读取监控数据</h3><p>各节点的 kubelet 组件中除了包含自身的监控指标信息以外，kubelet 组件还内置了对 cAdvisor 的支持。cAdvisor 能够获取当前节点上运行的所有容器的资源使用情况，通过访问 kubelet 的 <code>/metrics/cadvisor</code> 地址可以获取到 cadvisor 的监控指标，因此和获取 kubelet 监控指标类似，这里同样通过 node 模式自动发现所有的 kubelet 信息，并通过适当的 <code>relabel</code> 过程，修改监控采集任务的配置</p>
<figure class="highlight shell"><figcaption><span>/etc/prometheus/prometheus.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">global:</span><br><span class="line">  scrape_interval: 5s</span><br><span class="line">  evaluation_interval: 5s</span><br><span class="line"></span><br><span class="line">scrape_configs:</span><br><span class="line">  - job_name: &#x27;prometheus&#x27;</span><br><span class="line">    static_configs:</span><br><span class="line">    - targets: [&#x27;localhost:9090&#x27;]</span><br><span class="line">    </span><br><span class="line">  - job_name: &#x27;kubernetes-nodes&#x27;</span><br><span class="line">    tls_config:</span><br><span class="line">      ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt</span><br><span class="line">    bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token</span><br><span class="line">    kubernetes_sd_configs:</span><br><span class="line">    - role: node</span><br><span class="line">    relabel_configs:</span><br><span class="line">    - source_labels: [__address__]</span><br><span class="line">      regex: &#x27;(.*):10250&#x27;</span><br><span class="line">      replacement: &#x27;$&#123;1&#125;:9100&#x27;</span><br><span class="line">      target_label: __address__</span><br><span class="line">      action: replace</span><br><span class="line">    - action: labelmap</span><br><span class="line">      regex: __meta_kubernetes_node_label_(.+)</span><br><span class="line"></span><br><span class="line">  - job_name: &#x27;kubernetes-kubelet&#x27;</span><br><span class="line">    kubernetes_sd_configs:</span><br><span class="line">    - role: node</span><br><span class="line">    scheme: https</span><br><span class="line">    tls_config:</span><br><span class="line">      ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt</span><br><span class="line">      insecure_skip_verify: true</span><br><span class="line">    bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token</span><br><span class="line">    relabel_configs:</span><br><span class="line">    - action: labelmap</span><br><span class="line">      regex: __meta_kubernetes_node_label_(.+)</span><br><span class="line">      </span><br><span class="line">  - job_name: &#x27;kubernetes-cadvisor&#x27;</span><br><span class="line">    scheme: https</span><br><span class="line">    tls_config:</span><br><span class="line">      ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt</span><br><span class="line">      insecure_skip_verify: true</span><br><span class="line">    kubernetes_sd_configs:</span><br><span class="line">    - role: node</span><br><span class="line">    bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token</span><br><span class="line">    relabel_configs:</span><br><span class="line">    - source_labels: [__meta_kubernetes_node_name]</span><br><span class="line">      regex: (.+)</span><br><span class="line">      target_label: __metrics_path__</span><br><span class="line">      replacement: metrics/cadvisor</span><br><span class="line">    - action: labelmap</span><br><span class="line">      regex: __meta_kubernetes_node_label_(.+)</span><br></pre></td></tr></table></figure>
<p>以上配置生效后，查看 Prometheus 的 Targets 信息，正常会看到 cAdvisor 的 Target</p>
<p><img src="https://i.csms.tech/img_159.png"></p>
<h3 id="配置-Prometheus-抓取-Kubernetes-集群资源状态指标"><a href="#配置-Prometheus-抓取-Kubernetes-集群资源状态指标" class="headerlink" title="配置 Prometheus 抓取 Kubernetes 集群资源状态指标"></a>配置 Prometheus 抓取 Kubernetes 集群资源状态指标</h3><p>要监控 Kubernetes 集群资源状态的相关指标，需要在 Kubernetes 中 <a href="https://csms.tech/202209121102/#部署-kube-state-metrics-组件">部署 <code>kube-state-metrics</code> 组件</a>。</p>
<p>在 Prometheus 配置文件中，添加一个新的监控目标以获取 <code>kube-state-metrics</code> 抓取的指标</p>
<figure class="highlight shell"><figcaption><span>/etc/prometheus/prometheus.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">global:</span><br><span class="line">  scrape_interval: 5s</span><br><span class="line">  evaluation_interval: 5s</span><br><span class="line"></span><br><span class="line">scrape_configs:</span><br><span class="line">  - job_name: &#x27;prometheus&#x27;</span><br><span class="line">    static_configs:</span><br><span class="line">    - targets: [&#x27;localhost:9090&#x27;]</span><br><span class="line">    </span><br><span class="line">  - job_name: &#x27;kubernetes-nodes&#x27;</span><br><span class="line">    tls_config:</span><br><span class="line">      ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt</span><br><span class="line">    bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token</span><br><span class="line">    kubernetes_sd_configs:</span><br><span class="line">    - role: node</span><br><span class="line">    relabel_configs:</span><br><span class="line">    - source_labels: [__address__]</span><br><span class="line">      regex: &#x27;(.*):10250&#x27;</span><br><span class="line">      replacement: &#x27;$&#123;1&#125;:9100&#x27;</span><br><span class="line">      target_label: __address__</span><br><span class="line">      action: replace</span><br><span class="line">    - action: labelmap</span><br><span class="line">      regex: __meta_kubernetes_node_label_(.+)</span><br><span class="line"></span><br><span class="line">  - job_name: &#x27;kubernetes-kubelet&#x27;</span><br><span class="line">    kubernetes_sd_configs:</span><br><span class="line">    - role: node</span><br><span class="line">    scheme: https</span><br><span class="line">    tls_config:</span><br><span class="line">      ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt</span><br><span class="line">      insecure_skip_verify: true</span><br><span class="line">    bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token</span><br><span class="line">    relabel_configs:</span><br><span class="line">    - action: labelmap</span><br><span class="line">      regex: __meta_kubernetes_node_label_(.+)</span><br><span class="line">      </span><br><span class="line">  - job_name: &#x27;kubernetes-cadvisor&#x27;</span><br><span class="line">    scheme: https</span><br><span class="line">    tls_config:</span><br><span class="line">      ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt</span><br><span class="line">      insecure_skip_verify: true</span><br><span class="line">    kubernetes_sd_configs:</span><br><span class="line">    - role: node</span><br><span class="line">    bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token</span><br><span class="line">    relabel_configs:</span><br><span class="line">    - source_labels: [__meta_kubernetes_node_name]</span><br><span class="line">      regex: (.+)</span><br><span class="line">      target_label: __metrics_path__</span><br><span class="line">      replacement: metrics/cadvisor</span><br><span class="line">    - action: labelmap</span><br><span class="line">      regex: __meta_kubernetes_node_label_(.+)</span><br><span class="line">      </span><br><span class="line">  - job_name: &#x27;kube-state-metrics&#x27;</span><br><span class="line">    static_configs:</span><br><span class="line">    - targets: [&#x27;kube-state-metrics.kube-system.svc.cluster.local:8080&#x27;]  </span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<p>要查看 <code>kube-state-metrics</code> 抓取的指标，可以在集群内访问 <code>kube-state-metrics.kube-system.svc.cluster.local:8080/metrics</code> 查看</p>
<h3 id="配置-Prometheus-抓取-Ingress-Nginx-指标"><a href="#配置-Prometheus-抓取-Ingress-Nginx-指标" class="headerlink" title="配置 Prometheus 抓取 Ingress-Nginx 指标"></a>配置 Prometheus 抓取 Ingress-Nginx 指标</h3><ol>
<li><p>参考 <code>ingress-nginx</code> 官方提供的 Prometheus 自动发现 <code>ingress-nginx</code> 的配置 <sup id="fnref:9"><a href="#fn:9" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[ingress-nginx prometheus](https://github.com/kubernetes/ingress-nginx/blob/main/deploy/prometheus/prometheus.yaml)">[9]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">global:</span><br><span class="line">  scrape_interval: 10s</span><br><span class="line">scrape_configs:</span><br><span class="line">- job_name: &#x27;ingress-nginx-endpoints&#x27;</span><br><span class="line">  kubernetes_sd_configs:</span><br><span class="line">  - role: pod</span><br><span class="line">    namespaces:</span><br><span class="line">      names:</span><br><span class="line">      - ingress-nginx</span><br><span class="line">  relabel_configs:</span><br><span class="line">  - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]</span><br><span class="line">    action: keep</span><br><span class="line">    regex: true</span><br><span class="line">  - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scheme]</span><br><span class="line">    action: replace</span><br><span class="line">    target_label: __scheme__</span><br><span class="line">    regex: (https?)</span><br><span class="line">  - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path]</span><br><span class="line">    action: replace</span><br><span class="line">    target_label: __metrics_path__</span><br><span class="line">    regex: (.+)</span><br><span class="line">  - source_labels: [__address__, __meta_kubernetes_pod_annotation_prometheus_io_port]</span><br><span class="line">    action: replace</span><br><span class="line">    target_label: __address__</span><br><span class="line">    regex: ([^:]+)(?::\d+)?;(\d+)</span><br><span class="line">    replacement: $1:$2</span><br><span class="line">  - source_labels: [__meta_kubernetes_service_name]</span><br><span class="line">    regex: prometheus-server</span><br><span class="line">    action: drop</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置 <code>ingress-nginx</code> 的 Deployment，添加端口配置，本示例中 Ingress-Nginx 端口类型为 <code>hostNetwork: true</code>。如果 Ingress-Nginx 使用了 Service，需要配置 Service 暴露相关端口。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- containerPort: 10254</span><br><span class="line">  hostPort: 10254</span><br><span class="line">  name: prometheus</span><br><span class="line">  protocol: TCP</span><br></pre></td></tr></table></figure></li>
<li><p>配置 <code>ingress-nginx</code> 的 Deployment，添加 Pod 针对 Prometheus 监控的注释</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">spec:</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      annotations:</span><br><span class="line">        prometheus.io/scrape: &quot;true&quot;</span><br><span class="line">        prometheus.io/port: &quot;10254&quot;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>部署后，在 Prometheus UI 中检查 <code>nginx_ingress.*</code> 相关指标<br><img src="https://i.csms.tech/img_177.png"></p>
<h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><h2 id="failed-to-list-v1-Pod-pods-is-forbidden-User-quot-system-serviceaccount-prometheus-default-quot-cannot-list-resource-quot-pods-quot-in-API-group-quot-quot-at-the-cluster-scope”"><a href="#failed-to-list-v1-Pod-pods-is-forbidden-User-quot-system-serviceaccount-prometheus-default-quot-cannot-list-resource-quot-pods-quot-in-API-group-quot-quot-at-the-cluster-scope”" class="headerlink" title="failed to list *v1.Pod: pods is forbidden: User &quot;system:serviceaccount:prometheus:default&quot; cannot list resource &quot;pods&quot; in API group &quot;&quot; at the cluster scope”"></a>failed to list *v1.Pod: pods is forbidden: User &quot;system:serviceaccount:prometheus:default&quot; cannot list resource &quot;pods&quot; in API group &quot;&quot; at the cluster scope”</h2><p>部署 Prometheus 后，无法访问，检查 Pod 日志，显示错误： <code>failed to list *v1.Pod: pods is forbidden: User \&quot;system:serviceaccount:prometheus:default\&quot; cannot list resource \&quot;pods\&quot; in API group \&quot;\&quot; at the cluster scope&quot;</code> <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Configure Prometheus for service discovery](https://uzimihsr.github.io/post/2022-11-28-kubernetes-prometheus-kube-state-metrics-cadvisor/)
">[2]</span></a></sup></p>
<p>根据输出，应该是因为 Namespace <code>prometheus</code>  中的 <code>ServiceAccount</code> 账号 <code>default</code> 无相关权限导致，此权限是于 <a href="#%E5%88%9B%E5%BB%BA%E9%9B%86%E7%BE%A4%E8%A7%92%E8%89%B2">此处配置</a>，检查相关账号权限。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl describe clusterrole prometheus</span></span><br><span class="line">Name:         prometheus</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">PolicyRule:</span><br><span class="line">  Resources             Non-Resource URLs  Resource Names  Verbs</span><br><span class="line">  ---------             -----------------  --------------  -----</span><br><span class="line">  endpoints             []                 []              [get list watch]</span><br><span class="line">  nodes/proxy           []                 []              [get list watch]</span><br><span class="line">  nodes                 []                 []              [get list watch]</span><br><span class="line">  pods                  []                 []              [get list watch]</span><br><span class="line">  services              []                 []              [get list watch]</span><br><span class="line">  ingresses.extensions  []                 []              [get list watch]</span><br><span class="line">                        [/metrics]         []              [get]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl describe clusterrolebinding prometheus</span></span><br><span class="line">Name:         prometheus</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">Role:</span><br><span class="line">  Kind:  ClusterRole</span><br><span class="line">  Name:  prometheus</span><br><span class="line">Subjects:</span><br><span class="line">  Kind            Name     Namespace</span><br><span class="line">  ----            ----     ---------</span><br><span class="line">  ServiceAccount  default  prometheus</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>正常配置的 RBAC 账号输出如上，如果权限显示异常，需要重新检查 <a href="#%E5%88%9B%E5%BB%BA%E9%9B%86%E7%BE%A4%E8%A7%92%E8%89%B2">此处配置</a> 是否正常，如文件格式是否正确。本示例中是因为 yaml 文件格式导致 <code>clusterrolebinding</code> 绑定异常，输出结果如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl describe clusterrolebinding prometheus</span></span><br><span class="line">Name:         prometheus</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">Role:</span><br><span class="line">  Kind:  ClusterRole</span><br><span class="line">  Name:  prometheus</span><br><span class="line">Subjects:</span><br><span class="line">  Kind            Name     Namespace</span><br><span class="line">  ----            ----     ---------</span><br></pre></td></tr></table></figure>
<p>更正文件格式后，重新 <code>kubectl apply</code> ，Prometheus Server 部署正常。</p>
<h2 id="server-returned-HTTP-status-400-Bad-Request"><a href="#server-returned-HTTP-status-400-Bad-Request" class="headerlink" title="server returned HTTP status 400 Bad Request"></a>server returned HTTP status 400 Bad Request</h2><p>Prometheus 配置服务自动发现监控 Kubernetes 的 Node 后，Node 状态显示为 <code>DOWN</code>，Error 为 <code>server returned HTTP status 400 Bad Request</code><br><img src="https://i.csms.tech/img_152.png"><br>这个是因为 prometheus 去发现 Node 模式的服务的时候，访问的端口默认是10250。而默认是需要认证的 https 协议才有权访问的，但实际上我们并不是希望让去访问 10250 端口的 <code>/metrics</code> 接口，而是 <code>node-exporter</code> 绑定到节点的 9100 端口，所以我们应该将这里的 10250 替换成 9100。 <sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[服务发现](https://www.qikqiak.com/k8strain/monitor/prometheus/#_8)
">[4]</span></a></sup></p>
<h2 id="opening-storage-failed-lock-DB-directory-resource-temporarily-unavailable"><a href="#opening-storage-failed-lock-DB-directory-resource-temporarily-unavailable" class="headerlink" title="opening storage failed: lock DB directory: resource temporarily unavailable"></a>opening storage failed: lock DB directory: resource temporarily unavailable</h2><p>Prometheus Server 无法启动，查看 Pod 日志，显示以下错误</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl logs prometheus-deployment-6967df46c6-znj2k -n prometheus</span></span><br><span class="line">ts=2023-05-27T09:22:14.967Z caller=main.go:1155 level=error err=&quot;opening storage failed: lock DB directory: resource temporarily unavailable&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>解决方法</strong> ： 删除 Prometheus Server 数据目录下的 <code>lock</code> 文件，重新启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">01H1CXS2BWTCBWA08HK9EFQ0FJ  01H1DBGBZP5SF2ENGTQV1CRVNM  01H1DS7Y4HQ9NPRDXEPYPM9BD0  01H1E6Z9Z1KTWCSDW75H3JW6Q7  lock            wal</span><br><span class="line">01H1D4MMQMSZHMQ31NN976SXEX  01H1DJC6WRMKJTGSTFQX262D75  01H1E03HZG28CZKB9YM0ZQPJ57  chunks_head                 queries.active</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> -rf lock</span></span><br></pre></td></tr></table></figure>

<h2 id="cAdvisor-获取-Pod-指标元数据异常"><a href="#cAdvisor-获取-Pod-指标元数据异常" class="headerlink" title="cAdvisor 获取 Pod 指标元数据异常"></a>cAdvisor 获取 Pod 指标元数据异常</h2><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Centos 7</li>
<li>Kubernetes 1.24</li>
<li>Prometheus 2.44.0</li>
<li>Docker Engine - Community 20.10.9</li>
<li>containerd containerd.io 1.6.9</li>
</ul>
<p>在 Prometheus UI 中查询指标 <code>container_network_transmit_bytes_total</code>，输出中没有 <code>container</code>、<code>name</code>、<code>pod</code> 等指标，甚至未输出 Pod 的网卡流量的指标。<br><img src="https://i.csms.tech/img_176.png"></p>
<p><code>container_network_transmit_bytes_total</code> 指标是 Kubelet 从 cAdvisor 中读取到的，为了排查问题出现的地方，尝试直接访问 Kubelet 获取此指标的数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -k -H <span class="string">&quot;Authorization: Bearer `cat /var/run/secrets/kubernetes.io/serviceaccount/token`&quot;</span> https://172.31.26.116</span></span><br><span class="line">:10250/metrics/cadvisor | grep container_network_transmit_bytes_total</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">TYPE container_network_transmit_bytes_total counter</span></span><br><span class="line">container_network_transmit_bytes_total&#123;container=&quot;&quot;,id=&quot;/&quot;,image=&quot;&quot;,interface=&quot;cni0&quot;,name=&quot;&quot;,namespace=&quot;&quot;,pod=&quot;&quot;&#125; 7.29571749e+09 1686126675185</span><br><span class="line">container_network_transmit_bytes_total&#123;container=&quot;&quot;,id=&quot;/&quot;,image=&quot;&quot;,interface=&quot;eth0&quot;,name=&quot;&quot;,namespace=&quot;&quot;,pod=&quot;&quot;&#125; 1.639010015553e+12 1686126675185</span><br><span class="line">container_network_transmit_bytes_total&#123;container=&quot;&quot;,id=&quot;/&quot;,image=&quot;&quot;,interface=&quot;flannel.1&quot;,name=&quot;&quot;,namespace=&quot;&quot;,pod=&quot;&quot;&#125; 7.967725528e+09 1686126675185</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从结果可以看到，Kubelet 就未获取到相关指标及标签。Kubelet 是从 cAdvisor 获取到的容器的 Lables。如果是 Docker，主要是读取容器的 Inspect 信息获取标签（<code>Config.Labels</code>），检查容器的 Inspect 信息，发现是存在完整的 Lables 信息 <sup id="fnref:8"><a href="#fn:8" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[cAdvisor获取Pod指标元数据异常](https://juejin.cn/post/7208349474841198650)
">[8]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker inspect 6b2b9d1b3a62</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: &quot;6b2b9d1b3a62a9d070656841aaeb1bb0c43a83025295d69ec8d47618c717290b&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2023-06-02T09:42:23.197361826Z&quot;,</span><br><span class="line">        &quot;Path&quot;: &quot;/coredns&quot;,</span><br><span class="line">        </span><br><span class="line">        &quot;Image&quot;: &quot;sha256:a4ca41631cc7ac19ce1be3ebf0314ac5f47af7c711f17066006db82ee3b75b03&quot;,</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        &quot;Config&quot;: &#123;</span><br><span class="line">            &quot;Hostname&quot;: &quot;coredns-6d4b75cb6d-fzxmc&quot;,</span><br><span class="line">            </span><br><span class="line">            &quot;ExposedPorts&quot;: &#123;</span><br><span class="line">                &quot;53/tcp&quot;: &#123;&#125;,</span><br><span class="line">                &quot;53/udp&quot;: &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;Tty&quot;: false,</span><br><span class="line">            &quot;OpenStdin&quot;: false,</span><br><span class="line">            &quot;StdinOnce&quot;: false,</span><br><span class="line">            </span><br><span class="line">            &quot;Image&quot;: &quot;sha256:a4ca41631cc7ac19ce1be3ebf0314ac5f47af7c711f17066006db82ee3b75b03&quot;,</span><br><span class="line">            </span><br><span class="line">            &quot;Labels&quot;: &#123;</span><br><span class="line">                &quot;annotation.io.kubernetes.container.hash&quot;: &quot;6208af3e&quot;,</span><br><span class="line">                &quot;annotation.io.kubernetes.container.ports&quot;: &quot;[&#123;\&quot;name\&quot;:\&quot;dns\&quot;,\&quot;containerPort\&quot;:53,\&quot;protocol\&quot;:\&quot;UDP\&quot;&#125;,&#123;\&quot;name\&quot;:\&quot;dns-tcp\&quot;,\&quot;containerPort\&quot;:53,\&quot;protocol\&quot;:\&quot;TCP\&quot;&#125;,&#123;\&quot;name\&quot;:\&quot;metrics\&quot;,\&quot;containerPort\&quot;:9153,\&quot;protocol\&quot;:\&quot;TCP\&quot;&#125;]&quot;,</span><br><span class="line">                &quot;annotation.io.kubernetes.container.restartCount&quot;: &quot;11&quot;,</span><br><span class="line">                &quot;annotation.io.kubernetes.container.terminationMessagePath&quot;: &quot;/dev/termination-log&quot;,</span><br><span class="line">                &quot;annotation.io.kubernetes.container.terminationMessagePolicy&quot;: &quot;File&quot;,</span><br><span class="line">                &quot;annotation.io.kubernetes.pod.terminationGracePeriod&quot;: &quot;30&quot;,</span><br><span class="line">                &quot;io.kubernetes.container.logpath&quot;: &quot;/var/log/pods/kube-system_coredns-6d4b75cb6d-fzxmc_d46b52b3-e38d-4f57-938e-a454aa70c846/coredns/11.log&quot;,</span><br><span class="line">                &quot;io.kubernetes.container.name&quot;: &quot;coredns&quot;,</span><br><span class="line">                &quot;io.kubernetes.docker.type&quot;: &quot;container&quot;,</span><br><span class="line">                &quot;io.kubernetes.pod.name&quot;: &quot;coredns-6d4b75cb6d-fzxmc&quot;,</span><br><span class="line">                &quot;io.kubernetes.pod.namespace&quot;: &quot;kube-system&quot;,</span><br><span class="line">                &quot;io.kubernetes.pod.uid&quot;: &quot;d46b52b3-e38d-4f57-938e-a454aa70c846&quot;,</span><br><span class="line">                &quot;io.kubernetes.sandbox.id&quot;: &quot;1ce33bdb40f6498ce7bd9f61802b3b51e9e13aaf50184130a40578ef7562b5ca&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>从以上分析可以确定，问题应该是出在 cAdvisor 未获取到 Docker 容器中的 Labels 信息。</p>
<p>问题原因一直未找到，尝试 <a href="https://csms.tech/202209121102/#修改-kubelet-使用的-CRI-为-containerd">将 Kubelet 使用的 CRI 由 Docker 更改为 Containerd</a>，更改后，再次在 Prometheus UI 中查看 <code>container_network_transmit_bytes_total</code>，发现改 Containerd 作为 CRI 的 Kubelet 节点采集的指标标签中已经包含了 <code>Pod</code>、<code>namespace</code>、<code>image</code> 等标签</p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://zhangquan.me/2022/09/04/shi-yong-prometheus-jian-kong-kubernetes-ji-qun-jie-dian/">使用 Prometheus 监控 Kubernetes 集群节点</a></p>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://zhuanlan.zhihu.com/p/456205833">如何部署 Prometheus 监控K8S</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://uzimihsr.github.io/post/2022-11-28-kubernetes-prometheus-kube-state-metrics-cadvisor/">Configure Prometheus for service discovery</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://yunlzheng.gitbook.io/prometheus-book/part-iii-prometheus-shi-zhan/readmd/service-discovery-with-kubernetes#fu-wu-fa-xian">Kubernetes 服务发现</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.qikqiak.com/k8strain/monitor/prometheus/#_8">服务发现</a><a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/kubelet-authn-authz/#kubelet-authorization">Kubelet 鉴权</a><a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="http://www.mydlq.club/article/123/">Kubernetes 部署告警工具 AlertManager</a><a href="#fnref:6" rev="footnote"> ↩</a></span></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/alert/alert-manager-config">Alertmanager 配置概述</a><a href="#fnref:7" rev="footnote"> ↩</a></span></li><li id="fn:8"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">8.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://juejin.cn/post/7208349474841198650">cAdvisor获取Pod指标元数据异常</a><a href="#fnref:8" rev="footnote"> ↩</a></span></li><li id="fn:9"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">9.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://github.com/kubernetes/ingress-nginx/blob/main/deploy/prometheus/prometheus.yaml">ingress-nginx prometheus</a><a href="#fnref:9" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>Prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes Pod 调度</title>
    <url>/202305221527/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos 7</li>
<li>Kubernetes 1.24</li>
</ul>
<h1 id="污点和容忍度"><a href="#污点和容忍度" class="headerlink" title="污点和容忍度"></a>污点和容忍度</h1><p>默认情况下，集群中的 master 节点被设置成了污点，以确保只有控制平面的 Pod 才能调度部署到主节点上。</p>
<h2 id="显示节点的污点信息"><a href="#显示节点的污点信息" class="headerlink" title="显示节点的污点信息"></a>显示节点的污点信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl describe node k8s-master1</span></span><br><span class="line">Name:               k8s-master1</span><br><span class="line">Roles:              control-plane</span><br><span class="line">Labels:             beta.kubernetes.io/arch=amd64</span><br><span class="line">                    beta.kubernetes.io/os=linux</span><br><span class="line">                    kubernetes.io/arch=amd64</span><br><span class="line">                    kubernetes.io/hostname=k8s-master1</span><br><span class="line">                    kubernetes.io/os=linux</span><br><span class="line">                    node-role.kubernetes.io/control-plane=</span><br><span class="line">                    node.kubernetes.io/exclude-from-external-load-balancers=</span><br><span class="line">Annotations:        flannel.alpha.coreos.com/backend-data: &#123;&quot;VNI&quot;:1,&quot;VtepMAC&quot;:&quot;de:75:a4:67:58:1f&quot;&#125;</span><br><span class="line">                    flannel.alpha.coreos.com/backend-type: vxlan</span><br><span class="line">                    flannel.alpha.coreos.com/kube-subnet-manager: true</span><br><span class="line">                    flannel.alpha.coreos.com/public-ip: 172.31.26.116</span><br><span class="line">                    kubeadm.alpha.kubernetes.io/cri-socket: unix:///var/run/cri-dockerd.sock</span><br><span class="line">                    management.cattle.io/pod-limits: &#123;&quot;cpu&quot;:&quot;100m&quot;,&quot;memory&quot;:&quot;390Mi&quot;&#125;</span><br><span class="line">                    management.cattle.io/pod-requests: &#123;&quot;cpu&quot;:&quot;950m&quot;,&quot;memory&quot;:&quot;290Mi&quot;,&quot;pods&quot;:&quot;8&quot;&#125;</span><br><span class="line">                    node.alpha.kubernetes.io/ttl: 0</span><br><span class="line">                    volumes.kubernetes.io/controller-managed-attach-detach: true</span><br><span class="line">CreationTimestamp:  Tue, 06 Dec 2022 17:50:49 +0800</span><br><span class="line">Taints:             node-role.kubernetes.io/control-plane:NoSchedule</span><br><span class="line">                    node-role.kubernetes.io/master:NoSchedule</span><br></pre></td></tr></table></figure>
<p>Master 节点包含 2 个污点 </p>
<ul>
<li><code>node-role.kubernetes.io/control-plane:NoSchedule</code></li>
<li><code>node-role.kubernetes.io/master:NoSchedule</code></li>
</ul>
<p>这 2 个污点将阻止 Pod 调度到这个节点上面，除非有 Pod 能够容忍这个污点(Taints)，通常能容忍这个污点的都是控制平面的 Pod。</p>
<h2 id="查看-Pod-的容忍度"><a href="#查看-Pod-的容忍度" class="headerlink" title="查看 Pod 的容忍度"></a>查看 Pod 的容忍度</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl describe pod -n kube-system kube-proxy-2cslw</span></span><br><span class="line">...</span><br><span class="line">Tolerations:                 op=Exists</span><br><span class="line">                             node.kubernetes.io/disk-pressure:NoSchedule op=Exists</span><br><span class="line">                             node.kubernetes.io/memory-pressure:NoSchedule op=Exists</span><br><span class="line">                             node.kubernetes.io/network-unavailable:NoSchedule op=Exists</span><br><span class="line">                             node.kubernetes.io/not-ready:NoExecute op=Exists</span><br><span class="line">                             node.kubernetes.io/pid-pressure:NoSchedule op=Exists</span><br><span class="line">                             node.kubernetes.io/unreachable:NoExecute op=Exists</span><br><span class="line">                             node.kubernetes.io/unschedulable:NoSchedule op=Exists</span><br><span class="line">Events:                      &lt;none&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes Service 详解</title>
    <url>/202305030923/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Kubernetes 的 Service 代表的是 Kubernetes 后端服务的入口，它主要包含服务的访问 IP（虚拟 IP）和端口，工作在 L4.</p>
<p>Service 只存储服务的入口信息（IP:PORT），不存储后端 Pod 信息，Service 是通过 <a href="https://csms.tech/202209241108/#标签和选择算符"><code>Label Selector</code></a> 选择与之匹配的后端 Pod。当被 Service 选择的后端 Pod 运行且能正常向外提供服务时，Kubernetes 的 <code>Endpoint Controller</code> 会生成一个新的 Endpoint 对象，指向此 Pod 的 IP:PORT。Service 接收到访问请求，会将请求转发到对应的 Endpoint。同时，Service 的访问 IP 和 Endpoint&#x2F;Pod 的 IP 都会在 Kubernetes 的 DNS 服务里面进行注册以记录域名和 IP 的对应关系，因此用户可以在集群中通过域名的方式访问 Service 和 Pod。</p>
<p>用户创建 Service 后，Kubernetes 会从集群的可用服务 IP 池中为 Service 分配一个稳定的集群内访问 IP，称为 <strong>Cluster IP</strong>。Kubernetes 还会通过注册 DNS 条目为 <strong>Cluster IP</strong> 分配 <strong>域名</strong>（主机名）。<strong>Cluster IP</strong> 和 <strong>域名</strong> 在集群内是独一无二的，并且在服务的整个生命周期中保持不变，直到将 Service 从集群中删除，Kubernetes 才会释放 <strong>Cluster IP</strong> 和 <strong>域名</strong> 。通过此方法，Service 作为代理，向客户端提供了稳定不变的访问后端服务的入口。</p>
<p>Service 除了作为 <strong>代理</strong> 功能，同时也提供了 <strong>负载均衡</strong> 和 <strong>高可用</strong>。当后端的 Pod 有多个时，默认会通过 <strong>轮询</strong> 将请求流量均匀分布到多个 Pod 上，当某个 Pod 不可用是，Service 不会将请求调度到问题节点。</p>
<p>Kubernetes 使用节点上运行的 <code>kube-proxy</code> 组件管理各 Service 和后端 Pod 的连接。<code>kube-proxy</code> 是一个基于出战流量的 <strong>负载均衡控制器</strong>，它监控 Kubernetes API Service 并持续将 Service IP （ClusterIP）映射到运行状况良好的后端 Pod，具体实现是通过主机上的 <code>iptables/IPVS</code> 的规则。访问 Service 的 IP 会被这些（路由）规则直接 DNAT 到后端 Pod 的 IP。</p>
<p><a href="https://csms.tech/202209241108/#Service">Service 配置语法参考</a></p>
<h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos 7 3.10.0-1160</li>
<li>Kubernetes v1.24.7</li>
</ul>
<h1 id="kube-proxy-iptables-模式下的规则解析"><a href="#kube-proxy-iptables-模式下的规则解析" class="headerlink" title="kube-proxy iptables 模式下的规则解析"></a>kube-proxy iptables 模式下的规则解析</h1><p>kube-proxy 默认使用 <code>iptables</code> 模式实现 Service 的代理转发和负载均衡。<a href="https://csms.tech/202209131536/#获取节点上的-kube-proxy-代理模式">检查 <code>kube-proxy</code> 使用的代理模式</a></p>
<p>本示例使用相关信息如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get services</span> </span><br><span class="line">NAME             TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)     AGE</span><br><span class="line">api-service      ClusterIP   10.106.126.96    &lt;none&gt;        10302/TCP   145d</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get endpoints api-service</span></span><br><span class="line">NAME          ENDPOINTS                               AGE</span><br><span class="line">api-service   10.244.3.138:10302,10.244.4.120:10302   145d</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>针对 <code>api-service</code>，后端的 Pod 就绪后，生成了 ENDPOINTS，kube-proxy 会为该服务创建以下 iptables 规则</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-A PREROUTING -m comment --comment &quot;kubernetes service portals&quot; -j KUBE-SERVICES</span><br><span class="line"></span><br><span class="line">-A KUBE-SERVICES -d 10.106.126.96/32 -p tcp -m comment --comment &quot;default/api-service:api-pord cluster IP&quot; -m tcp --dport 10302 -j KUBE-SVC-DVTQLPR6DVOLBZS4</span><br><span class="line"></span><br><span class="line">-A KUBE-SVC-DVTQLPR6DVOLBZS4 ! -s 10.244.0.0/16 -d 10.106.126.96/32 -p tcp -m comment --comment &quot;default/api-service:api-pord cluster IP&quot; -m tcp --dport 10302 -j KUBE-MARK-MASQ</span><br><span class="line">-A KUBE-SVC-DVTQLPR6DVOLBZS4 -m comment --comment &quot;default/api-service:api-pord -&gt; 10.244.3.138:10302&quot; -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-JXBL7O23XHVFQV2I</span><br><span class="line">-A KUBE-SVC-DVTQLPR6DVOLBZS4 -m comment --comment &quot;default/api-service:api-pord -&gt; 10.244.4.120:10302&quot; -j KUBE-SEP-BBPDSOPRICLINLPY</span><br><span class="line"></span><br><span class="line">-A KUBE-SEP-JXBL7O23XHVFQV2I -s 10.244.3.138/32 -m comment --comment &quot;default/api-service:api-pord&quot; -j KUBE-MARK-MASQ</span><br><span class="line">-A KUBE-SEP-JXBL7O23XHVFQV2I -p tcp -m comment --comment &quot;default/api-service:api-pord&quot; -m tcp -j DNAT --to-destination 10.244.3.138:10302</span><br><span class="line"></span><br><span class="line">-A KUBE-SEP-BBPDSOPRICLINLPY -s 10.244.4.120/32 -m comment --comment &quot;default/api-service:api-pord&quot; -j KUBE-MARK-MASQ</span><br><span class="line">-A KUBE-SEP-BBPDSOPRICLINLPY -p tcp -m comment --comment &quot;default/api-service:api-pord&quot; -m tcp -j DNAT --to-destination 10.244.4.120:10302</span><br><span class="line"></span><br><span class="line">-A POSTROUTING -m comment --comment &quot;flanneld masq&quot; -j FLANNEL-POSTRTG</span><br><span class="line">-A POSTROUTING -m comment --comment &quot;kubernetes postrouting rules&quot; -j KUBE-POSTROUTING-A FLANNEL-POSTRTG -m mark --mark 0x4000/0x4000 -m comment --comment &quot;flanneld masq&quot; -j RETURN</span><br><span class="line">-A FLANNEL-POSTRTG -s 10.244.0.0/16 -d 10.244.0.0/16 -m comment --comment &quot;flanneld masq&quot; -j RETURN</span><br><span class="line">-A FLANNEL-POSTRTG -s 10.244.0.0/16 ! -d 224.0.0.0/4 -m comment --comment &quot;flanneld masq&quot; -j MASQUERADE</span><br><span class="line">-A FLANNEL-POSTRTG ! -s 10.244.0.0/16 -d 10.244.3.0/24 -m comment --comment &quot;flanneld masq&quot; -j RETURN</span><br><span class="line">-A FLANNEL-POSTRTG ! -s 10.244.0.0/16 -d 10.244.0.0/16 -m comment --comment &quot;flanneld masq&quot; -j MASQUERADE</span><br><span class="line"></span><br><span class="line">-A KUBE-POSTROUTING -m mark ! --mark 0x4000/0x4000 -j RETURN</span><br><span class="line">-A KUBE-POSTROUTING -j MARK --set-xmark 0x4000/0x0</span><br><span class="line">-A KUBE-POSTROUTING -m comment --comment &quot;kubernetes service traffic requiring SNAT&quot; -j MASQUERADE</span><br></pre></td></tr></table></figure>
<p>具体工作流程如下：</p>
<ol>
<li>所有进入 <code>PREROUTING</code> 链的流量会被跳转到 <code>KUBE-SERVICES</code> 自定义链</li>
<li>本示例中请求 <code>api-service</code> 的访问数据包（目的地址为 <code>10.106.126.96:10302</code>）在 <code>PREROUTING</code> 链中被 <code>-d 10.106.126.96/32 -p tcp -m comment --comment &quot;default/api-service:api-pord cluster IP&quot; -m tcp --dport 10302</code> 匹配到，根据规则跳转到自定义链 <code>KUBE-SVC-DVTQLPR6DVOLBZS4</code></li>
<li>在自定义链 <code>KUBE-SVC-DVTQLPR6DVOLBZS4</code> 中，实现了负载均衡，一半的流量会被跳转到链 <code>KUBE-SEP-JXBL7O23XHVFQV2I</code>，另一半的流量会被跳转到 <code>KUBE-SEP-BBPDSOPRICLINLPY</code></li>
<li>在自定义链 <code>KUBE-SEP-JXBL7O23XHVFQV2I</code> 和 <code>KUBE-SEP-BBPDSOPRICLINLPY</code> 中，流量分别被 DNAT 分配到了后端的 Pod（就绪的 Endpoints）。</li>
<li>Pod 处理完数据请求，向客户端返回请求结果时，在 <code>POSTROUTING</code> 链上要对数据包做 SNAT 处理，以确保客户端接收到的数据包的源地址是其发送请求时的目标地址。</li>
</ol>
<p>通过以上 kube-proxy 管理的规则，Service 实现了对后端 Pod 的服务代理及负载均衡功能。</p>
<p>综上所述，iptables 模式最主要的链是 <code>KUBE-SERVICES</code> 、<code>KUBE-SVC-*</code>、<code>KUBE-SEP-*</code></p>
<ul>
<li><code>KUBE-SERVICES</code> - 访问集群服务的数据包入口，它会根据匹配到的目标 IP:PORT 将数据包分发到相应的链 <code>KUBE-SVC-*</code></li>
<li><code>KUBE-SVC-*</code> - 相当于一个负载均衡器，它会将数据包平均分配到 <code>KUBE-SEP-*</code> 链。每个 <code>KUBE-SVC-*</code> 链后面的 <code>KUBE-SEP-*</code> 链的数量和 Service 后端就绪的 Pod 数量一致。</li>
<li><code>KUBE-SEP-*</code> - 通过 DNAT 将数据包的目的地址（IP:PORT）修改为后端就绪的 Pod 的 IP:PORT，从而将流量转发到相应的 Pod</li>
</ul>
<p><code>kube-proxy</code> 的 iptables 模式因为使用 DNAT 转发数据包，存在一定的性能损耗，另外，当集群中的 Service 数量上万时，节点上的 iptables rules 会非常庞大，对管理是个不小的负担，性能也会大打折扣。</p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes 安装配置</title>
    <url>/202209121102/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="https://kubernetes.io/zh-cn/docs/setup/production-environment/">Kubernetes 官网文档</a></p>
<h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos 7 5.4.212-1</li>
<li>Docker 20.10.18</li>
<li>containerd.io-1.6.8</li>
<li>kubectl-1.24.7</li>
<li>kubeadm-1.24.7</li>
<li>kubelet-1.24.7</li>
</ul>
<h1 id="kubernetes-环境安装前配置"><a href="#kubernetes-环境安装前配置" class="headerlink" title="kubernetes 环境安装前配置"></a>kubernetes 环境安装前配置</h1><h2 id="升级内核版本"><a href="#升级内核版本" class="headerlink" title="升级内核版本"></a>升级内核版本</h2><p>Centos 7 默认的内核版本 3.10 在运行 kubernetes 时存在不稳定性，建议升级内核版本到新版本</p>
<a href="/202209140931/" title="Centos 7 升级内核">Centos 7 升级内核</a>

<h2 id="关闭-SELinux"><a href="#关闭-SELinux" class="headerlink" title="关闭 SELinux"></a>关闭 SELinux</h2><p>kubernetes 目前未实现对 SELinux 的支持，因此必须要关闭 SELinux</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo setenforce 0</span><br><span class="line">sudo sed -i &#x27;s/^SELINUX=enforcing$/SELINUX=disabled/&#x27; /etc/selinux/config</span><br></pre></td></tr></table></figure>

<h2 id="集群中所有计算机之间具有完全的网络连接"><a href="#集群中所有计算机之间具有完全的网络连接" class="headerlink" title="集群中所有计算机之间具有完全的网络连接"></a>集群中所有计算机之间具有完全的网络连接</h2><p>配置集群所有节点的防火墙，确保所有集群节点之间具有完全的网络连接。</p>
<ul>
<li>放通节点之间的通信</li>
<li>确保防火墙允许 <code>FORWARD</code> 链的流量<figure class="highlight shell"><figcaption><span>/etc/sysconfig/iptables</span></figcaption><table><tr><td class="code"><pre><span class="line">*filter</span><br><span class="line">:INPUT DROP [0:0]</span><br><span class="line">:FORWARD ACCEPT [0:0]</span><br><span class="line">:OUTPUT ACCEPT [4:368]</span><br><span class="line"></span><br><span class="line">-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">-A INPUT -i lo -j ACCEPT</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kubernetes nodes</span></span><br><span class="line">-A INPUT -m comment --comment &quot;kubernetes nodes&quot; -s 172.31.5.58 -j ACCEPT</span><br><span class="line">-A INPUT -m comment --comment &quot;kubernetes nodes&quot; -s 172.31.5.68 -j ACCEPT</span><br><span class="line">-A INPUT -m comment --comment &quot;kubernetes nodes&quot; -s 172.31.0.230 -j ACCEPT</span><br><span class="line"></span><br><span class="line">-A INPUT -p tcp -m multiport --dports 80,443 -j ACCEPT -m comment --comment &quot;k8s ingress http,https&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">-A INPUT -p icmp -m icmp --icmp-type 8 -j ACCEPT</span><br><span class="line">-A INPUT -p icmp -m icmp --icmp-type 0 -j ACCEPT</span><br><span class="line">-A INPUT -j REJECT --reject-with icmp-host-prohibited</span><br><span class="line">COMMIT</span><br></pre></td></tr></table></figure></li>
</ul>
<span id="more"></span>

<p>集群通信 ( iptables ) 矩阵说明： <sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[端口和协议](https://v1-25.docs.kubernetes.io/zh-cn/docs/reference/networking/ports-and-protocols/)">[6]</span></a></sup></p>
<table>
<thead>
<tr>
<th>Protocol</th>
<th>iptables table</th>
<th>ipables chain</th>
<th>Port Range</th>
<th>Purpose</th>
<th>Used by</th>
</tr>
</thead>
<tbody><tr>
<td>UDP</td>
<td>filter</td>
<td>INPUT</td>
<td>8472</td>
<td>flannel</td>
<td>network</td>
</tr>
<tr>
<td>TCP</td>
<td>filter</td>
<td>INPUT</td>
<td>6443</td>
<td>Kubernetes API server</td>
<td>ALL node</td>
</tr>
<tr>
<td>TCP</td>
<td>filter</td>
<td>INPUT</td>
<td>2379-2380</td>
<td>etcd server client API</td>
<td>kube-apiserver,etcd</td>
</tr>
<tr>
<td>TCP</td>
<td>filter</td>
<td>INPUT</td>
<td>10250</td>
<td>kubelet API</td>
<td>Control plane, Self ,kubectl exec</td>
</tr>
<tr>
<td>TCP</td>
<td>filter</td>
<td>INPUT</td>
<td>10251</td>
<td>kube-scheduler</td>
<td>self</td>
</tr>
<tr>
<td>TCP</td>
<td>filter</td>
<td>INPUT</td>
<td>10252</td>
<td>kube-controller-manager</td>
<td>self</td>
</tr>
<tr>
<td>TCP</td>
<td>filter</td>
<td>INPUT</td>
<td>30000-32767</td>
<td>NodePortService</td>
<td>All</td>
</tr>
</tbody></table>
<ul>
<li>不同节点之间的 <code>Pod</code> 通信需要经过 <code>flannel</code> 的 <code>8472/udp</code> </li>
<li><code>nodePort</code> 类型的 <code>service</code> ，默认可用的 <code>nodePort</code> 端口范围为 <code>30000-32767</code>，根据实际情况配置</li>
</ul>
<p>若对网络安全要求较为严格，可在 master 节点使用以下防火墙规则，本示例中 CNI 对接的网络插件为 flannel，若使用其他网络插件，则根据插件要求放通对应端口。</p>
<p>本示例中 <code>192.168.142.8 - 10</code> 为 master 节点，<code>192.168.142.11 - 12</code> 为 worker 节点</p>
<figure class="highlight shell"><figcaption><span>/etc/sysconfig/iptables</span></figcaption><table><tr><td class="code"><pre><span class="line">*filter</span><br><span class="line">:INPUT DROP [0:0]</span><br><span class="line">:FORWARD ACCEPT [0:0]</span><br><span class="line">:OUTPUT ACCEPT [0:0]</span><br><span class="line">-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">-A INPUT -p icmp -j ACCEPT</span><br><span class="line">-A INPUT -i lo -j ACCEPT</span><br><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kubernetes master</span></span><br><span class="line">-A INPUT -s 192.168.142.8 -p tcp -m multiport --dports 6443,2379:2380,10250,10259,10257 -j ACCEPT -m comment --comment &quot;kubernetes master&quot;</span><br><span class="line"></span><br><span class="line">-A INPUT -s 192.168.142.9 -p tcp -m multiport --dports 6443,2379:2380,10250,10259,10257 -j ACCEPT -m comment --comment &quot;kubernetes master&quot;</span><br><span class="line"></span><br><span class="line">-A INPUT -s 192.168.142.10 -p tcp -m multiport --dports 6443,2379:2380,10250,10259,10257 -j ACCEPT -m comment --comment &quot;kubernetes master&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-A INPUT -s 192.168.142.11 -p tcp -m multiport --dports 6443,2379:2380,10250 -j ACCEPT -m comment --comment &quot;kubernetes master for k8s node&quot;</span><br><span class="line">-A INPUT -s 192.168.142.12 -p tcp -m multiport --dports 6443,2379:2380,10250 -j ACCEPT -m comment --comment &quot;kubernetes master for k8s node&quot;</span><br><span class="line"></span><br><span class="line">-A INPUT -s 192.168.142.8 -p udp --dport 8472 -j ACCEPT -m comment --comment &quot;flannel for kubernetes master&quot;</span><br><span class="line">-A INPUT -s 192.168.142.9 -p udp --dport 8472 -j ACCEPT -m comment --comment &quot;flannel for kubernetes master&quot;</span><br><span class="line">-A INPUT -s 192.168.142.10 -p udp --dport 8472 -j ACCEPT -m comment --comment &quot;flannel for kubernetes master&quot;</span><br><span class="line">-A INPUT -s 192.168.142.11 -p udp --dport 8472 -j ACCEPT -m comment --comment &quot;flannel for kubernetes node&quot;</span><br><span class="line">-A INPUT -s 192.168.142.12 -p udp --dport 8472 -j ACCEPT -m comment --comment &quot;flannel for kubernetes node&quot;</span><br><span class="line"></span><br><span class="line">COMMIT</span><br></pre></td></tr></table></figure>
<p>在 node 节点使用以下防火墙规则</p>
<figure class="highlight shell"><figcaption><span>/etc/sysconfig/iptables</span></figcaption><table><tr><td class="code"><pre><span class="line">*filter</span><br><span class="line">:INPUT DROP [0:0]</span><br><span class="line">:FORWARD ACCEPT [0:0]</span><br><span class="line">:OUTPUT ACCEPT [0:0]</span><br><span class="line">-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">-A INPUT -p icmp -j ACCEPT</span><br><span class="line">-A INPUT -i lo -j ACCEPT</span><br><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kubernetes node</span></span><br><span class="line">-A INPUT -s 192.168.142.8 -p tcp -m multiport --dports 10250 -j ACCEPT -m comment --comment &quot;kubernetes node for master&quot;</span><br><span class="line">-A INPUT -s 192.168.142.9 -p tcp -m multiport --dports 10250 -j ACCEPT -m comment --comment &quot;kubernetes node for master&quot;</span><br><span class="line">-A INPUT -s 192.168.142.10 -p tcp -m multiport --dports 10250 -j ACCEPT -m comment --comment &quot;kubernetes node for master&quot;</span><br><span class="line"></span><br><span class="line">-A INPUT -s 192.168.142.8 -p udp --dport 8472 -j ACCEPT -m comment --comment &quot;flannel for kubernetes master&quot;</span><br><span class="line">-A INPUT -s 192.168.142.9 -p udp --dport 8472 -j ACCEPT -m comment --comment &quot;flannel for kubernetes master&quot;</span><br><span class="line">-A INPUT -s 192.168.142.10 -p udp --dport 8472 -j ACCEPT -m comment --comment &quot;flannel for kubernetes master&quot;</span><br><span class="line">-A INPUT -s 192.168.142.11 -p udp --dport 8472 -j ACCEPT -m comment --comment &quot;flannel for kubernetes node&quot;</span><br><span class="line">-A INPUT -s 192.168.142.12 -p udp --dport 8472 -j ACCEPT -m comment --comment &quot;flannel for kubernetes node&quot;</span><br><span class="line"></span><br><span class="line">COMMIT</span><br></pre></td></tr></table></figure>

<h2 id="禁止swap分区"><a href="#禁止swap分区" class="headerlink" title="禁止swap分区"></a>禁止swap分区</h2><p>以下命令临时关闭 swap，要永久关闭 swap，修改配置文件 <code>/etc/fstab</code>，删除或注释其中 <code>swap</code> 相关的行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">swapoff -a</span><br></pre></td></tr></table></figure>

<h2 id="配置主机名"><a href="#配置主机名" class="headerlink" title="配置主机名"></a>配置主机名</h2><p>节点之中不可以有重复的主机名、MAC 地址或 product_uuid</p>
<p>配置集群中的 3 台主机名分别为 <code>kubernetes1</code>，<code>kubernetes2</code>，<code>kubernetes3</code>，本示例中 <code>kubernetes1</code> 作为 master </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hostnamectl set-hostname kubernetes1</span><br></pre></td></tr></table></figure>

<p>添加主机名和 ip 解析到 <code>/etc/hosts</code> 文件</p>
<figure class="highlight shell"><figcaption><span>/etc/hosts</span></figcaption><table><tr><td class="code"><pre><span class="line">172.31.10.19 kubernetes1</span><br><span class="line">172.31.9.241 kubernetes2</span><br><span class="line">172.31.14.115 kubernetes3</span><br></pre></td></tr></table></figure>

<h2 id="为-kube-proxy-开启-ipvs"><a href="#为-kube-proxy-开启-ipvs" class="headerlink" title="为 kube-proxy 开启 ipvs"></a>为 kube-proxy 开启 ipvs</h2><p><a href="https://blog.fleeto.us/post/iptables-or-ipvs/">kube-proxy 模式对比：iptables 还是 IPVS</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1890887">kube-proxy中使用ipvs与iptables的比较</a></p>
<p>此配置为<strong>可选操作</strong>，在不启用 ipvs 模式的情况下，kube-proxy 会使用 iptables 模式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &gt; /etc/sysconfig/modules/ipvs.modules &lt;&lt;EOF</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">modprobe -- ip_vs</span><br><span class="line">modprobe -- ip_vs_rr</span><br><span class="line">modprobe -- ip_vs_wrr</span><br><span class="line">modprobe -- ip_vs_sh</span><br><span class="line">modprobe -- nf_conntrack_ipv4</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">chmod 755 /etc/sysconfig/modules/ipvs.modules &amp;&amp; bash /etc/sysconfig/modules/ipvs.modules </span><br></pre></td></tr></table></figure>

<h2 id="转发-IPv4-并让-iptables-看到桥接流量"><a href="#转发-IPv4-并让-iptables-看到桥接流量" class="headerlink" title="转发 IPv4 并让 iptables 看到桥接流量"></a>转发 IPv4 并让 iptables 看到桥接流量</h2><p>以下操作需要在 kubernetes 集群中的所有节点操作  </p>
<p>通过运行 <code>lsmod | grep br_netfilter</code> 来验证 <code>br_netfilter</code> 模块是否已加载。Kubernetes 通过 <code>bridge-netfilter</code> 配置使 iptables 规则可以应用在 Linux Bridge 上，对 Linux 内核进行宿主机和容器之间的数据包的地址转换是必须的，否则 Pod 进行外部服务网络请求时会出现目标主机不可达或者连接拒绝等错误（host unreachable 或者 connection refused）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">lsmod | grep br_netfilter</span></span><br><span class="line">br_netfilter           22256  0 </span><br><span class="line">bridge                151336  1 br_netfilter</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>若要显式加载此模块，请运行以下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo modprobe overlay</span><br><span class="line">sudo modprobe br_netfilter</span><br></pre></td></tr></table></figure>


<p>为了让 Linux 节点的 iptables 能够正确查看桥接流量，请确认 <code>sysctl</code> 配置中的 <code>net.bridge.bridge-nf-call-iptables</code> 设置为 1</p>
<p>为配置永久生效，可以添加以下配置，<code>/etc/modules-load.d/k8s.conf</code> 中追加要加载的模块</p>
<figure class="highlight shell"><figcaption><span>/etc/modules-load.d/k8s.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">overlay</span><br><span class="line">br_netfilter</span><br></pre></td></tr></table></figure>

<p><code>/etc/sysctl.d/k8s.conf</code> 中追加内核参数</p>
<figure class="highlight shell"><figcaption><span>/etc/sysctl.d/k8s.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">net.bridge.bridge-nf-call-iptables  = 1</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.ipv4.ip_forward                 = 1</span><br></pre></td></tr></table></figure>

<p>执行以下命令重新载入 sysctl 参数而无需重启系统</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo sysctl --system</span><br></pre></td></tr></table></figure>

<!-- more -->

<h2 id="安装-Docker-Engine"><a href="#安装-Docker-Engine" class="headerlink" title="安装 Docker Engine"></a>安装 Docker Engine</h2><p>以下操作需要在 kubernetes 集群中的所有节点操作<br>参考以下链接，在每个节点上安装 Docker Engine<br><a href="https://docs.docker.com/engine/install/centos/">Centos 安装 Docker Engine 官网参考文档</a></p>
<a href="/202208041317/" title="docker 安装及常用命令介绍">docker 安装及常用命令介绍</a>

<h2 id="安装-cri-dockerd"><a href="#安装-cri-dockerd" class="headerlink" title="安装 cri-dockerd"></a>安装 cri-dockerd</h2><p>Docker Engine 没有实现 CRI，因此 Kubernetes 无法直接使用 Docker Engine，需要先安装 cri-dockerd，以让 Kubernetes 可以通过 Kubernetes 的 CRI 操作 Docker。</p>
<p>以下操作需要在 kubernetes 集群中的所有节点操作 </p>
<p>按照源代码仓库中的说明安装 <a href="https://github.com/Mirantis/cri-dockerd">cri-dockerd</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/Mirantis/cri-dockerd.git</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Run these commands as root</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##Install GO###</span></span></span><br><span class="line">wget https://storage.googleapis.com/golang/getgo/installer_linux</span><br><span class="line">chmod +x ./installer_linux</span><br><span class="line">./installer_linux</span><br><span class="line">source ~/.bash_profile</span><br><span class="line"></span><br><span class="line">cd cri-dockerd</span><br><span class="line">mkdir bin</span><br><span class="line">go build -o bin/cri-dockerd</span><br><span class="line">mkdir -p /usr/local/bin</span><br><span class="line">install -o root -g root -m 0755 bin/cri-dockerd /usr/local/bin/cri-dockerd</span><br><span class="line">cp -a packaging/systemd/* /etc/systemd/system</span><br><span class="line">sed -i -e &#x27;s,/usr/bin/cri-dockerd,/usr/local/bin/cri-dockerd,&#x27; /etc/systemd/system/cri-docker.service</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 使用 iptables 替换 firewalld</span></span></span><br><span class="line">sed -i -e &#x27;s,firewalld.service,iptables.service,&#x27; /etc/systemd/system/cri-docker.service</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable --now cri-docker.service</span><br><span class="line">systemctl enable --now cri-docker.socket</span><br></pre></td></tr></table></figure>

<p>对于 <code>cri-dockerd</code>，默认情况下，CRI 套接字是 <code>/run/cri-dockerd.sock</code></p>
<h1 id="Kubernetes-安装配置"><a href="#Kubernetes-安装配置" class="headerlink" title="Kubernetes 安装配置"></a>Kubernetes 安装配置</h1><h2 id="安装-kubeadm、kubelet-和-kubectl"><a href="#安装-kubeadm、kubelet-和-kubectl" class="headerlink" title="安装 kubeadm、kubelet 和 kubectl"></a>安装 kubeadm、kubelet 和 kubectl</h2><p>需要在每台机器上安装以下的软件包：</p>
<ul>
<li><p><code>kubeadm</code> ： 用来初始化集群的指令。</p>
</li>
<li><p><code>kubelet</code> ： 在集群中的每个节点上用来启动 Pod 和容器等。</p>
</li>
<li><p><code>kubectl</code> ： 用来与集群通信的命令行工具。</p>
</li>
</ul>
<p>添加 <code>yum</code> 源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF | sudo tee /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-\$basearch</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg</span><br><span class="line">exclude=kubelet kubeadm kubectl</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<p>安装软件包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install -y kubelet-1.24.7 kubeadm-1.24.7 kubectl-1.24.7 --disableexcludes=kubernetes</span><br></pre></td></tr></table></figure>
<p>启动服务并配置开机启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable --now kubelet</span><br></pre></td></tr></table></figure>
<p>kubelet 现在每隔几秒就会重启，因为它陷入了一个等待 <code>kubeadm</code> 指令的死循环。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl status kubelet</span></span><br><span class="line">● kubelet.service - kubelet: The Kubernetes Node Agent</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/kubelet.service; enabled; vendor preset: disabled)</span><br><span class="line">  Drop-In: /usr/lib/systemd/system/kubelet.service.d</span><br><span class="line">           └─10-kubeadm.conf</span><br><span class="line">   Active: activating (auto-restart) (Result: exit-code) since Mon 2022-09-12 14:35:58 CST; 7s ago</span><br><span class="line">     Docs: https://kubernetes.io/docs/</span><br><span class="line">  Process: 2056 ExecStart=/usr/bin/kubelet $KUBELET_KUBECONFIG_ARGS $KUBELET_CONFIG_ARGS $KUBELET_KUBEADM_ARGS $KUBELET_EXTRA_ARGS (code=exited, status=1/FAILURE)</span><br><span class="line"> Main PID: 2056 (code=exited, status=1/FAILURE)</span><br><span class="line"></span><br><span class="line">Sep 12 14:35:58 ip-172-31-14-115.us-west-1.compute.internal systemd[1]: Unit kubelet.service entered failed state.</span><br><span class="line">Sep 12 14:35:58 ip-172-31-14-115.us-west-1.compute.internal systemd[1]: kubelet.service failed.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="初始化控制平面节点"><a href="#初始化控制平面节点" class="headerlink" title="初始化控制平面节点"></a>初始化控制平面节点</h2><h3 id="创建单控制平面集群"><a href="#创建单控制平面集群" class="headerlink" title="创建单控制平面集群"></a>创建单控制平面集群</h3><p>控制平面节点是运行控制平面组件的机器， 包括 etcd （集群数据库） 和 API Server （命令行工具 kubectl 与之通信）。</p>
<ol>
<li><p>初始化控制平面节点</p>
<p> 要初始化控制平面节点，请在 master 节点上（<code>kubernetes1</code>）运行以下命令，<a href="(https://csms.tech%3C!--swig%EF%BF%BC103--%3E#%E5%88%9B%E5%BB%BA%E9%9B%86%E7%BE%A4)">命令参数说明</a>：</p>
 <figure class="highlight shell"><figcaption><span>kubernetes1</span></figcaption><table><tr><td class="code"><pre><span class="line">kubeadm init --pod-network-cidr=10.244.0.0/16 --cri-socket=unix:///var/run/cri-dockerd.sock</span><br></pre></td></tr></table></figure>
<ul>
<li><code>--pod-network-cidr=10.244.0.0/16</code> 指定 pod 使用的网络段，后面配置网络（CNI）时配置的网段要和此处一致</li>
<li><code>--cri-socket=unix:///var/run/cri-dockerd.sock</code> 指定使用的 CRI 为 Docker</li>
</ul>
<p> 输出结果如下：<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[init] Using Kubernetes version: v1.25.0</span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">[preflight] Pulling images required for setting up a Kubernetes cluster</span><br><span class="line">[preflight] This might take a minute or two, depending on the speed of your internet connection</span><br><span class="line">[preflight] You can also perform this action in beforehand using &#x27;kubeadm config images pull&#x27;</span><br><span class="line">[certs] Using certificateDir folder &quot;/etc/kubernetes/pki&quot;</span><br><span class="line">[certs] Generating &quot;ca&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;apiserver&quot; certificate and key</span><br><span class="line">[certs] apiserver serving cert is signed for DNS names [kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local kubernetes1] and IPs [10.96.0.1 172.31.10.19]</span><br><span class="line">[certs] Generating &quot;apiserver-kubelet-client&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;front-proxy-ca&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;front-proxy-client&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;etcd/ca&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;etcd/server&quot; certificate and key</span><br><span class="line">[certs] etcd/server serving cert is signed for DNS names [localhost kubernetes1] and IPs [172.31.10.19 127.0.0.1 ::1]</span><br><span class="line">[certs] Generating &quot;etcd/peer&quot; certificate and key</span><br><span class="line">[certs] etcd/peer serving cert is signed for DNS names [localhost kubernetes1] and IPs [172.31.10.19 127.0.0.1 ::1]</span><br><span class="line">[certs] Generating &quot;etcd/healthcheck-client&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;apiserver-etcd-client&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;sa&quot; key and public key</span><br><span class="line">[kubeconfig] Using kubeconfig folder &quot;/etc/kubernetes&quot;</span><br><span class="line">[kubeconfig] Writing &quot;admin.conf&quot; kubeconfig file</span><br><span class="line">[kubeconfig] Writing &quot;kubelet.conf&quot; kubeconfig file</span><br><span class="line">[kubeconfig] Writing &quot;controller-manager.conf&quot; kubeconfig file</span><br><span class="line">[kubeconfig] Writing &quot;scheduler.conf&quot; kubeconfig file</span><br><span class="line">[kubelet-start] Writing kubelet environment file with flags to file &quot;/var/lib/kubelet/kubeadm-flags.env&quot;</span><br><span class="line">[kubelet-start] Writing kubelet configuration to file &quot;/var/lib/kubelet/config.yaml&quot;</span><br><span class="line">[kubelet-start] Starting the kubelet</span><br><span class="line">[control-plane] Using manifest folder &quot;/etc/kubernetes/manifests&quot;</span><br><span class="line">[control-plane] Creating static Pod manifest for &quot;kube-apiserver&quot;</span><br><span class="line">[control-plane] Creating static Pod manifest for &quot;kube-controller-manager&quot;</span><br><span class="line">[control-plane] Creating static Pod manifest for &quot;kube-scheduler&quot;</span><br><span class="line">[etcd] Creating static Pod manifest for local etcd in &quot;/etc/kubernetes/manifests&quot;</span><br><span class="line">[wait-control-plane] Waiting for the kubelet to boot up the control plane as static Pods from directory &quot;/etc/kubernetes/manifests&quot;. This can take up to 4m0s</span><br><span class="line">[apiclient] All control plane components are healthy after 17.003297 seconds</span><br><span class="line">[upload-config] Storing the configuration used in ConfigMap &quot;kubeadm-config&quot; in the &quot;kube-system&quot; Namespace</span><br><span class="line">[kubelet] Creating a ConfigMap &quot;kubelet-config&quot; in namespace kube-system with the configuration for the kubelets in the cluster</span><br><span class="line">[upload-certs] Skipping phase. Please see --upload-certs</span><br><span class="line">[mark-control-plane] Marking the node kubernetes1 as control-plane by adding the labels: [node-role.kubernetes.io/control-plane node.kubernetes.io/exclude-from-external-load-balancers]</span><br><span class="line">[mark-control-plane] Marking the node kubernetes1 as control-plane by adding the taints [node-role.kubernetes.io/control-plane:NoSchedule]</span><br><span class="line">[bootstrap-token] Using token: 8ca35s.butdpihinkdczvqb</span><br><span class="line">[bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles</span><br><span class="line">[bootstrap-token] Configured RBAC rules to allow Node Bootstrap tokens to get nodes</span><br><span class="line">[bootstrap-token] Configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials</span><br><span class="line">[bootstrap-token] Configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token</span><br><span class="line">[bootstrap-token] Configured RBAC rules to allow certificate rotation for all node client certificates in the cluster</span><br><span class="line">[bootstrap-token] Creating the &quot;cluster-info&quot; ConfigMap in the &quot;kube-public&quot; namespace</span><br><span class="line">[kubelet-finalize] Updating &quot;/etc/kubernetes/kubelet.conf&quot; to point to a rotatable kubelet client certificate and key</span><br><span class="line">[addons] Applied essential addon: CoreDNS</span><br><span class="line">[addons] Applied essential addon: kube-proxy</span><br><span class="line"></span><br><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p $HOME/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line">Alternatively, if you are the root user, you can run:</span><br><span class="line"></span><br><span class="line">  export KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">  beadm join 172.31.10.19:6443 --token 8ca35s.butdpihinkdczvqb \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:b2793f9a6bea44a64640f99042f11c4ff6e4fef99fa2407241e1a0e8ea652149 </span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p> 根据 <code>kubeadm init</code> 输出提示，配置 <code>kubectl</code> 需要的环境变量，root 用户执行以下命令<br> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export KUBECONFIG=/etc/kubernetes/admin.conf</span><br></pre></td></tr></table></figure><br> 为永久生效，可将其添加到 <code>~/.bash_profile</code></p>
<p> 此时，执行以下命令查看集群节点信息<br> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods -A</span></span><br><span class="line">NAMESPACE     NAME                                      READY   STATUS    RESTARTS   AGE</span><br><span class="line">kube-system   coredns-565d847f94-dc8tl                  0/1     Pending   0          5m42s</span><br><span class="line">kube-system   coredns-565d847f94-zqctg                  0/1     Pending   0          5m42s</span><br><span class="line">kube-system   etcd-kubernetes1                      1/1     Running   0          5m54s</span><br><span class="line">kube-system   kube-apiserver-kubernetes1            1/1     Running   0          5m53s</span><br><span class="line">kube-system   kube-controller-manager-kubernetes1   1/1     Running   0          5m54s</span><br><span class="line">kube-system   kube-proxy-6kwdx                          1/1     Running   0          5m43s</span><br><span class="line">kube-system   kube-scheduler-kubernetes1            1/1     Running   0          5m54s</span><br><span class="line"></span><br></pre></td></tr></table></figure><br> 其中，<code>coredns</code> 的 pod 处于 <code>Pending</code> 状态，是因为网络还没配置。</p>
<p> 因为 CRI 使用 docker，此时使用以下命令，可以查看到启动的所有容器<br> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker ps -a</span></span><br><span class="line">CONTAINER ID   IMAGE                  COMMAND                  CREATED         STATUS         PORTS     NAMES</span><br><span class="line">741a6d32b2cd   58a9a0c6d96f           &quot;/usr/local/bin/kube…&quot;   5 minutes ago   Up 5 minutes             k8s_kube-proxy_kube-proxy-6kwdx_kube-system_93101b10-7ee5-437c-a234-3e31edc7cfa9_0</span><br><span class="line">31509b3f06cc   k8s.gcr.io/pause:3.6   &quot;/pause&quot;                 5 minutes ago   Up 5 minutes             k8s_POD_kube-proxy-6kwdx_kube-system_93101b10-7ee5-437c-a234-3e31edc7cfa9_0</span><br><span class="line">fb3ec15950b6   bef2cf311509           &quot;kube-scheduler --au…&quot;   6 minutes ago   Up 6 minutes             k8s_kube-scheduler_kube-scheduler-kubernetes1_kube-system_c455960b65afeadd009ff9ba9e7ab7b0_0</span><br><span class="line">333188677c01   4d2edfd10d3e           &quot;kube-apiserver --ad…&quot;   6 minutes ago   Up 6 minutes             k8s_kube-apiserver_kube-apiserver-kubernetes1_kube-system_11596873d958a699a1b923df2333eaad_0</span><br><span class="line">4bdbf8689bbb   1a54c86c03a6           &quot;kube-controller-man…&quot;   6 minutes ago   Up 6 minutes             k8s_kube-controller-manager_kube-controller-manager-kubernetes1_kube-system_23ce2f60ac97b06bde25c1662e88e409_0</span><br><span class="line">a399d3484c17   a8a176a5d5d6           &quot;etcd --advertise-cl…&quot;   6 minutes ago   Up 6 minutes             k8s_etcd_etcd-kubernetes1_kube-system_84da44e552601c02573afe1dc1e3b0a2_0</span><br><span class="line">28aae0e41a7d   k8s.gcr.io/pause:3.6   &quot;/pause&quot;                 6 minutes ago   Up 6 minutes             k8s_POD_kube-apiserver-kubernetes1_kube-system_11596873d958a699a1b923df2333eaad_0</span><br><span class="line">3f4f378ed731   k8s.gcr.io/pause:3.6   &quot;/pause&quot;                 6 minutes ago   Up 6 minutes             k8s_POD_kube-scheduler-kubernetes1_kube-system_c455960b65afeadd009ff9ba9e7ab7b0_0</span><br><span class="line">eaa6d312a174   k8s.gcr.io/pause:3.6   &quot;/pause&quot;                 6 minutes ago   Up 6 minutes             k8s_POD_etcd-kubernetes1_kube-system_84da44e552601c02573afe1dc1e3b0a2_0</span><br><span class="line">707e84291ac2   k8s.gcr.io/pause:3.6   &quot;/pause&quot;                 6 minutes ago   Up 6 minutes             k8s_POD_kube-controller-manager-kubernetes1_kube-system_23ce2f60ac97b06bde25c1662e88e409_0</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
</li>
<li><p><a href="#%E5%AE%89%E8%A3%85-kube-flannel">安装 kube-flannel</a></p>
<p> 在进行下一步之前，必须选择并部署合适的网络插件。 否则集群不会正常运行。</p>
</li>
<li><p>将节点加入集群</p>
<p> 在 work 节点上执行以下命令加入集群</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm join 172.31.10.19:6443 --token 8ca35s.butdpihinkdczvqb --discovery-token-ca-cert-hash sha256:b2793f9a6bea44a64640f99042f11c4ff6 \ </span><br><span class="line">        --cri-socket=unix:///var/run/cri-dockerd.sock</span><br></pre></td></tr></table></figure>
<p> 加入集群成功后，在 master 上查看所有节点</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get nodes</span></span><br><span class="line">NAME              STATUS     ROLES           AGE   VERSION</span><br><span class="line">kubernetes1   Ready      control-plane   36m   v1.25.0</span><br><span class="line">kubernetes2   NotReady   &lt;none&gt;          21s   v1.25.0</span><br><span class="line">kubernetes3   NotReady   &lt;none&gt;          18s   v1.25.0</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="创建高可用控制平面的集群"><a href="#创建高可用控制平面的集群" class="headerlink" title="创建高可用控制平面的集群"></a>创建高可用控制平面的集群</h3><p>创建 <a href="https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/ha-topology/#stacked-etcd-topology"><code>堆叠（Stacked）etcd 拓扑</code></a> 的高可用控制平面集群</p>
<p><code>堆叠（Stacked）etcd 拓扑</code> 主要有以下特点：</p>
<ul>
<li><code>etcd</code> 分布式数据存储集群堆叠在 <code>kubeadm</code> 管理的控制平面节点上，作为控制平面的一个组件运行。</li>
<li>每个控制平面节点运行 <code>etcd</code>、 <code>kube-apiserver</code>、<code>kube-scheduler</code> 和 <code>kube-controller-manager</code> 实例。 <code>kube-apiserver</code> 使用负载均衡器暴露给工作节点。</li>
<li>每个控制平面节点创建一个本地 <code>etcd</code> 成员（member），这个 <code>etcd</code> 成员只与该节点的 <code>kube-apiserver</code> 通信。 这同样适用于本地 <code>kube-controller-manager</code> 和 <code>kube-scheduler</code> 实例。</li>
<li>堆叠集群存在耦合失败的风险。如果一个节点发生故障，则 <code>etcd</code> 成员和控制平面实例都将丢失， 并且冗余会受到影响。你可以通过添加更多控制平面节点来降低此风险。</li>
</ul>
<p><code>堆叠（Stacked）etcd 拓扑</code><br><img src="https://i.csms.tech/img_77.png"></p>
<p>为 kube-apiserver 创建负载均衡器，该负载均衡器将流量分配给目标列表中所有运行状况良好的控制平面节点。 API 服务器的健康检查是在 kube-apiserver 的监听端口（默认值 :6443） 上进行的一个 TCP 检查。 <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[为 kube-apiserver 创建负载均衡器](https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/high-availability/#%E4%B8%BA-kube-apiserver-%E5%88%9B%E5%BB%BA%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8)">[2]</span></a></sup></p>
<p>此处假设 kube-apiserver 的负载均衡地址为 <code>kube-apiserver.my.com:6443</code>。</p>
<ol>
<li><p>初始化控制平面：</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm init --pod-network-cidr=10.244.0.0/16 --cri-socket=unix:///var/run/cri-dockerd.sock \</span><br><span class="line">             --control-plane-endpoint &quot;kube-apiserver.my.com:6443&quot; \</span><br><span class="line">             --upload-certs</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>--upload-certs</code> 标志用来将在所有控制平面实例之间的共享证书上传到集群。</p>
<p> 根据 <code>kubeadm init</code> 输出提示，配置 <code>kubectl</code> 需要的环境变量，root 用户执行以下命令</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export KUBECONFIG=/etc/kubernetes/admin.conf</span><br></pre></td></tr></table></figure>
<p> 为永久生效，可将其添加到 <code>~/.bash_profile</code></p>
</li>
<li><p><a href="#%E5%AE%89%E8%A3%85-kube-flannel">安装 kube-flannel</a></p>
<p> 在进行下一步之前，必须选择并部署合适的网络插件。 否则集群不会正常运行。</p>
<p> 输入以下内容，并查看控制平面组件的 Pod 启动：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl get pod -n kube-system -w</span><br></pre></td></tr></table></figure></li>
<li><p>其余控制平面节点上的操作</p>
<p> 执行先前由第一个节点上的 <code>kubeadm init</code> 输出提供给你的 <code>join</code> 命令。 在 CRI 是 <code>cri-dockerd</code> 的场景下，要添加 <code>--cri-socket=unix:///var/run/cri-dockerd.sock</code>。它看起来应该像这样：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubeadm join 192.168.0.200:6443 --token 9vr73a.a8uxyaju799qwdjv \</span><br><span class="line">             --discovery-token-ca-cert-hash sha256:7c2e69131a36ae2a042a339b33381c6d0d43887e2de83720eff5359e26aec866 \</span><br><span class="line">             --control-plane \</span><br><span class="line">             --certificate-key f8902e114ef118304e561c3ecd4d0b543adc226b7a07f675f56564185ffe0c07 \</span><br><span class="line">             --cri-socket=unix:///var/run/cri-dockerd.sock</span><br></pre></td></tr></table></figure>
</li>
<li><p>工作节点上的操作</p>
<p> 在工作节点上执行以下命令，添加工作节点到集群中。在 CRI 是 <code>cri-dockerd</code> 的场景下，要添加 <code>--cri-socket=unix:///var/run/cri-dockerd.sock</code>。它看起来应该像这样：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubeadm join kube-apiserver.uat.148962587001:6443 \</span><br><span class="line">        --token 0nf24o.fb98ll5qkhpcxd70 \</span><br><span class="line">        --discovery-token-ca-cert-hash sha256:a5d589a3476777df757e38334b035a93811d94e75131e3d9cc1d7efad22fc793 \</span><br><span class="line">        --cri-socket=unix:///var/run/cri-dockerd.sock</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="安装-kube-flannel"><a href="#安装-kube-flannel" class="headerlink" title="安装 kube-flannel"></a>安装 kube-flannel</h3><p>Kubernetes 安装时已经安装了网络相关驱动，位于 <code>/opt/cni/bin/flannel</code>，此时只需要根据相关配置文件生成 <code>kube-flannel</code> 的 pod 即可</p>
<p>请在 master 节点上（<code>kubernetes1</code>）运行以下命令创建 <code>kube-flannel</code> 相关 POD</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl apply -f https://github.com/flannel-io/flannel/releases/latest/download/kube-flannel.yml</span></span><br><span class="line"></span><br><span class="line">namespace/kube-flannel created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/flannel created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/flannel created</span><br><span class="line">serviceaccount/flannel created</span><br><span class="line">configmap/kube-flannel-cfg created</span><br><span class="line">daemonset.apps/kube-flannel-ds created</span><br></pre></td></tr></table></figure>
<p>使用默认的 <code>kube-flannel.yml</code>，默认的 Network 为 <code>10.244.0.0/16</code>，要变更默认网段，更改 <code>kube-flannel.yml</code> 中的以下内容即可：</p>
<figure class="highlight shell"><figcaption><span>kube-flannel.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">net-conf.json: |</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;Network&quot;: &quot;10.244.0.0/16&quot;,</span><br><span class="line">    &quot;Backend&quot;: &#123;</span><br><span class="line">      &quot;Type&quot;: &quot;vxlan&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>此处的网段配置需要和 <a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2%E8%8A%82%E7%82%B9">初始化集群时定义的 pod 网段</a> 保持一致</p>
<p>创建完成 <code>kube-flannel</code> 后，再次查看集群中的 pod 信息，可以看到 <code>coredns</code> 已经处于运行状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods -A</span></span><br><span class="line">NAMESPACE      NAME                                      READY   STATUS    RESTARTS   AGE</span><br><span class="line">kube-flannel   kube-flannel-ds-rg969                     1/1     Running   0          20s</span><br><span class="line">kube-system    coredns-565d847f94-dc8tl                  0/1     Running   0          22m</span><br><span class="line">kube-system    coredns-565d847f94-zqctg                  0/1     Running   0          22m</span><br><span class="line">kube-system    etcd-kubernetes1                      1/1     Running   0          22m</span><br><span class="line">kube-system    kube-apiserver-kubernetes1            1/1     Running   0          22m</span><br><span class="line">kube-system    kube-controller-manager-kubernetes1   1/1     Running   0          22m</span><br><span class="line">kube-system    kube-proxy-6kwdx                          1/1     Running   0          22m</span><br><span class="line">kube-system    kube-scheduler-kubernetes1            1/1     Running   0          22m</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="安装-dashboard"><a href="#安装-dashboard" class="headerlink" title="安装 dashboard"></a>安装 dashboard</h1><p><a href="https://github.com/kubernetes/dashboard">kubernetes-dashboard 项目地址</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/kubernetes/dashboard/v2.6.1/aio/deploy/recommended.yaml</span><br></pre></td></tr></table></figure>

<p>修改 <code>recommended.yaml</code> 以下内容</p>
<figure class="highlight shell"><figcaption><span>recommended.yaml</span></figcaption><table><tr><td class="code"><pre><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line">  name: kubernetes-dashboard</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line">spec:</span><br><span class="line">  type: NodePort     </span><br><span class="line">  ports:</span><br><span class="line">    - port: 443</span><br><span class="line">      targetPort: 8443</span><br><span class="line">      nodePort: 30443</span><br><span class="line">  selector:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以上修改主要是新加以下 2 行，配置对外的端口，可用范围为 30000-32767：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">type: NodePort </span><br><span class="line">    nodePort: 30443</span><br></pre></td></tr></table></figure>
<p>以下 2 处新增配置 <code>nodeName: kubernetes1</code>，其中 <code>kubernetes1</code> 为 master 节点名称，可以通过 <code>kubectl get nodes</code> 查看</p>
<figure class="highlight shell"><figcaption><span>recommended.yaml</span></figcaption><table><tr><td class="code"><pre><span class="line">spec:</span><br><span class="line">  securityContext:</span><br><span class="line">    seccompProfile:</span><br><span class="line">      type: RuntimeDefault</span><br><span class="line">  nodeName: kubernetes1</span><br><span class="line">  containers:</span><br><span class="line">    - name: kubernetes-dashboard</span><br><span class="line">      image: kubernetesui/dashboard:v2.6.1</span><br><span class="line">      imagePullPolicy: Always</span><br><span class="line">      ports:</span><br><span class="line">        - containerPort: 8443</span><br><span class="line">          protocol: TCP</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上 2 处修改主要是配置 <code>kubernetes-dashboard</code> 运行在 master 节点上，否则可能运行在其他节点上，会因为网络问题导致 <code>kubernetes-dashboard</code> 无法正常启动，查看日志会报以下错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl logs -n kubernetes-dashboard kubernetes-dashboard-66c887f759-5rbbb</span></span><br><span class="line">2022/09/14 06:59:17 Starting overwatch</span><br><span class="line">2022/09/14 06:59:17 Using namespace: kubernetes-dashboard</span><br><span class="line">2022/09/14 06:59:17 Using in-cluster config to connect to apiserver</span><br><span class="line">2022/09/14 06:59:17 Using secret token for csrf signing</span><br><span class="line">2022/09/14 06:59:17 Initializing csrf token from kubernetes-dashboard-csrf secret</span><br><span class="line">panic: Get &quot;https://10.96.0.1:443/api/v1/namespaces/kubernetes-dashboard/secrets/kubernetes-dashboard-csrf&quot;: dial tcp 10.96.0.1:443: connect: no route to host</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>关键日志 ： <code>panic: Get &quot;https://10.96.0.1:443/api/v1/namespaces/kubernetes-dashboard/secrets/kubernetes-dashboard-csrf&quot;: dial tcp 10.96.0.1:443: connect: no route to host </code></p>
<p>以上报错也有可能是因为防火墙未放通各个 <code>service</code> 的 <code>CLUSTER-IP</code> 网段导致，可以在防火墙中放通相应网段</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get services -A</span></span><br><span class="line">NAMESPACE              NAME                        TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)                  AGE</span><br><span class="line">default                kubernetes                  ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP                  3h9m</span><br><span class="line">kube-system            kube-dns                    ClusterIP   10.96.0.10      &lt;none&gt;        53/UDP,53/TCP,9153/TCP   3h9m</span><br><span class="line">kubernetes-dashboard   dashboard-metrics-scraper   ClusterIP   10.107.39.231   &lt;none&gt;        8000/TCP                 88m</span><br><span class="line">kubernetes-dashboard   kubernetes-dashboard        NodePort    10.101.165.61   &lt;none&gt;        443:30443/TCP            88m</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>iptables</code> 中放通对应网段</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -I INPUT 6 -s 10.0.0.0/8 -j ACCEPT</span><br></pre></td></tr></table></figure>

<p>使用修改后的配置文件 <code>recommended.yaml</code> 启动 <code>kubernetes-dashboard</code> pod</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl apply -f recommended.yaml</span></span><br><span class="line"></span><br><span class="line">namespace/kubernetes-dashboard created</span><br><span class="line">serviceaccount/kubernetes-dashboard created</span><br><span class="line">service/kubernetes-dashboard created</span><br><span class="line">secret/kubernetes-dashboard-certs created</span><br><span class="line">secret/kubernetes-dashboard-csrf created</span><br><span class="line">secret/kubernetes-dashboard-key-holder created</span><br><span class="line">configmap/kubernetes-dashboard-settings created</span><br><span class="line">role.rbac.authorization.k8s.io/kubernetes-dashboard created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/kubernetes-dashboard created</span><br><span class="line">rolebinding.rbac.authorization.k8s.io/kubernetes-dashboard created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/kubernetes-dashboard created</span><br><span class="line">deployment.apps/kubernetes-dashboard created</span><br><span class="line">service/dashboard-metrics-scraper created</span><br><span class="line">deployment.apps/dashboard-metrics-scraper created</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看 pod</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods -A</span></span><br><span class="line">NAMESPACE              NAME                                         READY   STATUS    RESTARTS      AGE</span><br><span class="line">kube-flannel           kube-flannel-ds-bdms5                        1/1     Running   1 (17h ago)   19h</span><br><span class="line">kube-flannel           kube-flannel-ds-kq7gz                        1/1     Running   1             19h</span><br><span class="line">kube-flannel           kube-flannel-ds-rg969                        1/1     Running   2 (17h ago)   19h</span><br><span class="line">kube-system            coredns-565d847f94-dc8tl                     1/1     Running   2 (17h ago)   20h</span><br><span class="line">kube-system            coredns-565d847f94-zqctg                     1/1     Running   2 (17h ago)   20h</span><br><span class="line">kube-system            etcd-kubernetes1                         1/1     Running   2 (17h ago)   20h</span><br><span class="line">kube-system            kube-apiserver-kubernetes1               1/1     Running   2 (17h ago)   20h</span><br><span class="line">kube-system            kube-controller-manager-kubernetes1      1/1     Running   2 (17h ago)   20h</span><br><span class="line">kube-system            kube-proxy-6kwdx                             1/1     Running   2 (17h ago)   20h</span><br><span class="line">kube-system            kube-proxy-7lk7c                             1/1     Running   1 (17h ago)   19h</span><br><span class="line">kube-system            kube-proxy-rjr76                             1/1     Running   1 (17h ago)   19h</span><br><span class="line">kube-system            kube-scheduler-kubernetes1               1/1     Running   3 (17h ago)   20h</span><br><span class="line">kubernetes-dashboard   dashboard-metrics-scraper-746f6b45bf-ndvbr   1/1     Running   0             40s</span><br><span class="line">kubernetes-dashboard   kubernetes-dashboard-64f444d4f9-2mjdb        1/1     Running   0             40s</span><br></pre></td></tr></table></figure>

<p><code>kubernetes-dashboard</code> 运行正常后，在防火墙放通 <code>kubernetes-dashboard</code> 对外的端口（30443）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -I INPUT 6 -p tcp --dport 30443  -j ACCEPT</span><br></pre></td></tr></table></figure>

<p>浏览器通过访问 master 节点的公网 ip 地址和端口（<a href="https://ip:30443）">https://ip:30443）</a> ，可以打开 <code>kubernetes-dashboard</code> web 界面<br><img src="https://i.csms.tech/img_56.png"></p>
<p>此时要验证 Token。需要首先创建管理员用户，创建以下配置文件，文件命名为 <code>kubernetes-dashboard-adminuser.yaml</code>，<a href="https://github.com/kubernetes/dashboard/blob/master/docs/user/access-control/creating-sample-user.md">参考文档</a></p>
<figure class="highlight shell"><figcaption><span>kubernetes-dashboard-adminuser.yaml</span></figcaption><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: admin</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: admin</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: cluster-admin</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: admin</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上配置创建了一个 <code>admin</code> 用户（用户名字随便起），赋予 <code>ClusterRoleBinding</code> 角色权限，关联到 <code>clusert-admin</code>（名称是固定的不能修改）。</p>
<p>根据此配置创建账号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl apply -f kubernetes-dashboard-adminuser.yaml</span></span><br><span class="line">serviceaccount/admin created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/admin created</span><br></pre></td></tr></table></figure>

<p>获取 <code>Bearer Token</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl -n kubernetes-dashboard create token admin</span></span><br><span class="line">eyJhbGciOiJSUzI1NiIsImtpZCI6InUxMDNNUmZmU3BFenZYTEZjNjk2LUR0S1Q..</span><br></pre></td></tr></table></figure>
<p>将生成的 <code>Token</code> 输入浏览器进行验证，验证成功后可以登入 Dashboard<br><img src="https://i.csms.tech/img_57.png"></p>
<p>默认的 token 有效期很短，要修改 token 的有限时间，可以在登陆 Dashboard 后，编辑 <code>kubernetes-dashboard</code> 的 <code>Deployment</code><br><img src="https://i.csms.tech/img_58.png"></p>
<p>在 <code>spec:template:spec:containers:args</code> 下新增 <code>- &#39;--token-ttl=2592000&#39;</code><br><img src="https://i.csms.tech/img_59.png"></p>
<h1 id="安装-Kubernetes-Metrics-Server"><a href="#安装-Kubernetes-Metrics-Server" class="headerlink" title="安装 Kubernetes Metrics Server"></a>安装 Kubernetes Metrics Server</h1><p>安装 <code>Kubernetes Metrics Server</code> 可以支持使用 <code>kubectl top</code> 命令来查看集群使用的资源情况。 <sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Kubernetes Metrics Server](https://github.com/kubernetes-sigs/metrics-server)">[5]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml</span><br><span class="line">mv components.yaml kubernetes-mitrics-server.yaml</span><br><span class="line">kubectl apply -f kubernetes-mitrics-server.yaml</span><br></pre></td></tr></table></figure>
<p>部署后为了解决证书问题，可以临时配置不使用安全证书进行通信，修改 <code>metrics-server</code> 的 <code>Deployment</code>，在 <code>metrics-server</code> 启动时添加参数 <code>--kubelet-insecure-tls</code></p>
<figure class="highlight shell"><figcaption><span>kubernetes-mitrics-server.yaml</span></figcaption><table><tr><td class="code"><pre><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - args:</span><br><span class="line">    - --cert-dir=/tmp</span><br><span class="line">    - --secure-port=4443</span><br><span class="line">    - --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname</span><br><span class="line">    - --kubelet-use-node-status-port</span><br><span class="line">    - --metric-resolution=15s</span><br><span class="line">    - --kubelet-insecure-tls</span><br></pre></td></tr></table></figure>

<h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><h2 id="Found-multiple-CRI-endpoints-on-the-host"><a href="#Found-multiple-CRI-endpoints-on-the-host" class="headerlink" title="Found multiple CRI endpoints on the host"></a>Found multiple CRI endpoints on the host</h2><p><strong>错误场景</strong> ： 执行以下命令将节点加入集群时报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubeadm <span class="built_in">join</span> 172.31.10.19:6443 --token 8ca35s.butdpihinkdczvqb --discovery-token-ca-cert-hash sha256:b2793f9a6bea44a64640f99042</span></span><br><span class="line"></span><br><span class="line">Found multiple CRI endpoints on the host. Please define which one do you wish to use by setting the &#x27;criSocket&#x27; field in the kubeadm configuration file: unix:///var/run/containerd/containerd.sock, unix:///var/run/cri-dockerd.sock</span><br><span class="line">To see the stack trace of this error execute with --v=5 or higher</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>报错原因</strong> ： 在没有明确指定 Kubernetes 要使用的 CRI 情况下，会自动扫描主机上面安装的 CRI，如果出现多个可用的 CRI，会报错并提示确定使用哪个 CRI。</p>
<p><strong>解决方法</strong> ： 使用如下命令，指定要使用的 CRI</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm join 172.31.10.19:6443 --token 8ca35s.butdpihinkdczvqb --discovery-token-ca-cert-hash sha256:b2793f9a6bea44a64640f99042f11c4ff6 \ </span><br><span class="line">        --cri-socket=unix:///var/run/cri-dockerd.sock</span><br></pre></td></tr></table></figure>

<h2 id="kube-flannel-状态为-CrashLoopBackOff"><a href="#kube-flannel-状态为-CrashLoopBackOff" class="headerlink" title="kube-flannel 状态为 CrashLoopBackOff"></a>kube-flannel 状态为 CrashLoopBackOff</h2><p><strong>错误场景</strong> ：<br><code>kube-flannel</code> 一直重启，状态为 <code>CrashLoopBackOff</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods --all-namespaces</span></span><br><span class="line">NAMESPACE      NAME                                      READY   STATUS              RESTARTS         AGE</span><br><span class="line">kube-flannel   kube-flannel-ds-7q2hp                     0/1     CrashLoopBackOff    40 (3m39s ago)   3h4m</span><br><span class="line">kube-flannel   kube-flannel-ds-k8wd6                     0/1     CrashLoopBackOff    35 (53s ago)     76m</span><br><span class="line">kube-flannel   kube-flannel-ds-x6ck2                     0/1     CrashLoopBackOff    18 (106s ago)    69m</span><br><span class="line">kube-system    coredns-565d847f94-b4sgn                  0/1     ContainerCreating   0                3h40m</span><br><span class="line">kube-system    coredns-565d847f94-ml6k5                  0/1     ContainerCreating   0                3h40m</span><br><span class="line">kube-system    etcd-kubernetes1                      1/1     Running             0                3h40m</span><br><span class="line">kube-system    kube-apiserver-kubernetes1            1/1     Running             0                3h40m</span><br><span class="line">kube-system    kube-controller-manager-kubernetes1   1/1     Running             0                3h40m</span><br><span class="line">kube-system    kube-proxy-9vwxl                          1/1     Running             0                76m</span><br><span class="line">kube-system    kube-proxy-qxsc7                          1/1     Running             0                69m</span><br><span class="line">kube-system    kube-proxy-v5msf                          1/1     Running             0                3h40m</span><br><span class="line">kube-system    kube-scheduler-kubernetes1            1/1     Running             0                3h40m</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>排查步骤</strong> ：<br>查看日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl logs kube-flannel-ds-7q2hp -n kube-flannel</span></span><br><span class="line">Defaulted container &quot;kube-flannel&quot; out of: kube-flannel, install-cni-plugin (init), install-cni (init)</span><br><span class="line">I0913 06:42:19.799473       1 main.go:207] CLI flags config: &#123;etcdEndpoints:http://127.0.0.1:4001,http://127.0.0.1:2379 etcdPrefix:/coreos.com/network etcdKeyfile: etcdCertfile: etcdCAFile: etcdUsername: etcdPassword: version:false kubeSubnetMgr:true kubeApiUrl: kubeAnnotationPrefix:flannel.alpha.coreos.com kubeConfigFile: iface:[] ifaceRegex:[] ipMasq:true ifaceCanReach: subnetFile:/run/flannel/subnet.env publicIP: publicIPv6: subnetLeaseRenewMargin:60 healthzIP:0.0.0.0 healthzPort:0 iptablesResyncSeconds:5 iptablesForwardRules:true netConfPath:/etc/kube-flannel/net-conf.json setNodeNetworkUnavailable:true&#125;</span><br><span class="line">W0913 06:42:19.799563       1 client_config.go:614] Neither --kubeconfig nor --master was specified.  Using the inClusterConfig.  This might not work.</span><br><span class="line">I0913 06:42:19.903750       1 kube.go:120] Waiting 10m0s for node controller to sync</span><br><span class="line">I0913 06:42:19.903882       1 kube.go:401] Starting kube subnet manager</span><br><span class="line">I0913 06:42:20.903967       1 kube.go:127] Node controller sync successful</span><br><span class="line">I0913 06:42:20.903995       1 main.go:227] Created subnet manager: Kubernetes Subnet Manager - kubernetes1</span><br><span class="line">I0913 06:42:20.904004       1 main.go:230] Installing signal handlers</span><br><span class="line">I0913 06:42:20.904152       1 main.go:467] Found network config - Backend type: vxlan</span><br><span class="line">I0913 06:42:20.904195       1 match.go:206] Determining IP address of default interface</span><br><span class="line">I0913 06:42:20.904542       1 match.go:259] Using interface with name eth0 and address 172.31.10.19</span><br><span class="line">I0913 06:42:20.904570       1 match.go:281] Defaulting external address to interface address (172.31.10.19)</span><br><span class="line">I0913 06:42:20.904651       1 vxlan.go:138] VXLAN config: VNI=1 Port=0 GBP=false Learning=false DirectRouting=false</span><br><span class="line">E0913 06:42:20.904962       1 main.go:330] Error registering network: failed to acquire lease: node &quot;kubernetes1&quot; pod cidr not assigned</span><br><span class="line">I0913 06:42:20.905100       1 main.go:447] Stopping shutdownHandler...</span><br><span class="line">W0913 06:42:20.905251       1 reflector.go:436] github.com/flannel-io/flannel/subnet/kube/kube.go:402: watch of *v1.Node ended with: an error on the server (&quot;unable to decode an event from the watch stream: context canceled&quot;) has prevented the request from succeeding</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>关键日志： <code>Error registering network: failed to acquire lease: node &quot;kubernetes1&quot; pod cidr not assigned</code></p>
<p><strong>问题原因</strong> ： worker 节点的 flannel 组件无法正常获取 podCIDR 的定义</p>
<p><strong>解决方法</strong> ： 编辑控制节点上的配置文件 <code>/etc/kubernetes/manifests/kube-controller-manager.yaml</code>，在 <code>- command</code> 下添加以下内容：</p>
<figure class="highlight shell"><figcaption><span>/etc/kubernetes/manifests/kube-controller-manager.yaml</span></figcaption><table><tr><td class="code"><pre><span class="line">- --allocate-node-cidrs=true</span><br><span class="line">- --cluster-cidr=10.244.0.0/16</span><br></pre></td></tr></table></figure>
<p>如果内容已存在的话，更改 cidr 的网段和 <a href="#%E5%AE%89%E8%A3%85-kube-flannel"><code>kube-flannel.yml</code> 中的 cidr</a> 一致</p>
<p>更改配置后，重启所有节点的 <code>kubelet</code> 服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart kubelet</span><br></pre></td></tr></table></figure>
<p>重新查看所有 pod 状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods -A</span></span><br><span class="line">NAMESPACE      NAME                                      READY   STATUS    RESTARTS         AGE</span><br><span class="line">kube-flannel   kube-flannel-ds-7q2hp                     1/1     Running   62 (2m20s ago)   4h43m</span><br><span class="line">kube-flannel   kube-flannel-ds-k8wd6                     1/1     Running   55 (4m33s ago)   175m</span><br><span class="line">kube-flannel   kube-flannel-ds-x6ck2                     1/1     Running   38 (2m43s ago)   168m</span><br><span class="line">kube-system    coredns-565d847f94-b4sgn                  0/1     Running   0                5h19m</span><br><span class="line">kube-system    coredns-565d847f94-ml6k5                  0/1     Running   0                5h19m</span><br><span class="line">kube-system    etcd-kubernetes1                      1/1     Running   0                5h19m</span><br><span class="line">kube-system    kube-apiserver-kubernetes1            1/1     Running   0                5h19m</span><br><span class="line">kube-system    kube-controller-manager-kubernetes1   1/1     Running   0                2m39s</span><br><span class="line">kube-system    kube-proxy-9vwxl                          1/1     Running   0                175m</span><br><span class="line">kube-system    kube-proxy-qxsc7                          1/1     Running   0                168m</span><br><span class="line">kube-system    kube-proxy-v5msf                          1/1     Running   0                5h19m</span><br><span class="line">kube-system    kube-scheduler-kubernetes1            1/1     Running   0                5h19m</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="master-节点状态为-NotReady"><a href="#master-节点状态为-NotReady" class="headerlink" title="master 节点状态为 NotReady"></a>master 节点状态为 NotReady</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get nodes</span></span><br><span class="line">NAME              STATUS     ROLES                  AGE    VERSION</span><br><span class="line">k8s-work1         Ready      &lt;none&gt;                 99m    v1.21.2</span><br><span class="line">k8s-master        NotReady   control-plane,master   102m   v1.21.2</span><br><span class="line">k8s-work2         Ready      &lt;none&gt;                 99m    v1.21.2</span><br></pre></td></tr></table></figure>

<p>查看节点详细信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl describe node k8s-master</span></span><br><span class="line"></span><br><span class="line">Conditions:</span><br><span class="line">  Type             Status    LastHeartbeatTime                 LastTransitionTime                Reason              Message</span><br><span class="line">  ----             ------    -----------------                 ------------------                ------              -------</span><br><span class="line">  MemoryPressure   Unknown   Tue, 11 Oct 2022 14:54:19 +0800   Tue, 11 Oct 2022 14:57:46 +0800   NodeStatusUnknown   Kubelet stopped posting node status.</span><br><span class="line">  DiskPressure     Unknown   Tue, 11 Oct 2022 14:54:19 +0800   Tue, 11 Oct 2022 14:57:46 +0800   NodeStatusUnknown   Kubelet stopped posting node status.</span><br><span class="line">  PIDPressure      Unknown   Tue, 11 Oct 2022 14:54:19 +0800   Tue, 11 Oct 2022 14:57:46 +0800   NodeStatusUnknown   Kubelet stopped posting node status.</span><br><span class="line">  Ready            Unknown   Tue, 11 Oct 2022 14:54:19 +0800   Tue, 11 Oct 2022 14:57:46 +0800   NodeStatusUnknown   Kubelet stopped posting node status.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看 <code>Pod</code> 状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods -A</span></span><br><span class="line">NAMESPACE      NAME                                 READY   STATUS    RESTARTS   AGE</span><br><span class="line">kube-flannel   kube-flannel-ds-84s24                0/1     Pending   0          22m</span><br><span class="line">kube-flannel   kube-flannel-ds-qzd9g                1/1     Running   1          22m</span><br><span class="line">kube-flannel   kube-flannel-ds-sbtrr                1/1     Running   1          22m</span><br><span class="line">kube-system    coredns-558bd4d5db-8mbl5             1/1     Running   1          105m</span><br><span class="line">kube-system    coredns-558bd4d5db-gzrrx             1/1     Running   1          105m</span><br><span class="line">kube-system    etcd-k8s-master             1/1     Running   0          105m</span><br><span class="line">kube-system    kube-apiserver-k8s-master            1/1     Running   0          105m</span><br><span class="line">kube-system    kube-proxy-747cx                     1/1     Running   1          103m</span><br><span class="line">kube-system    kube-proxy-8bs8l                     1/1     Running   1          103m</span><br><span class="line">kube-system    kube-proxy-mvqjq                     1/1     Running   0          105m</span><br><span class="line">kube-system    kube-scheduler-k8s-master            1/1     Running   0          105m</span><br></pre></td></tr></table></figure>
<p>结果显示 <code>kube-flannel</code> 位于 master 上的 <code>Pod</code> 状态异常。</p>
<p>查看 <code>kubelet</code> 日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">journalctl -f -u kubelet</span></span><br><span class="line"> E1011 16:28:53.898132     796 kubelet_node_status.go:93] &quot;Unable to register node with API server&quot; err=&quot;nodes \&quot;k8s-admin\&quot; is forbidden: node \&quot;k8s-master\&quot; is not allowed to modify node \&quot;k8s-admin\&quot;&quot; node=&quot;k8s-admin&quot;</span><br><span class="line"> E1011 16:28:53.900459     796 kubelet.go:2291] &quot;Error getting node&quot; err=&quot;node \&quot;k8s-admin\&quot; not found&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看主机名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hostname status</span></span><br><span class="line"></span><br><span class="line">   Static hostname: k8s-master</span><br><span class="line">Transient hostname: k8s-admin</span><br><span class="line">         Icon name: computer-vm</span><br><span class="line">           Chassis: vm</span><br><span class="line">        Machine ID: b1527a5456aab241a74a8a3dc31395c0</span><br><span class="line">           Boot ID: f8428003692349298cf2bb9efae8a664</span><br><span class="line">    Virtualization: kvm</span><br><span class="line">  Operating System: CentOS Linux 7 (Core)</span><br><span class="line">       CPE OS Name: cpe:/o:centos:centos:7</span><br><span class="line">            Kernel: Linux 3.10.0-1160.76.1.el7.x86_64</span><br><span class="line">      Architecture: x86-64</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>根据 <code>kubelet</code> 日志，Kubenetes 节点名称和主机名不一致。修改节点主机名。</p>
<h2 id="集群之外的服务器使用-kubectl-报错"><a href="#集群之外的服务器使用-kubectl-报错" class="headerlink" title="集群之外的服务器使用 kubectl 报错"></a>集群之外的服务器使用 kubectl 报错</h2><p><strong>问题场景</strong>：</p>
<p>将集群的管理配置文件 (<code>/etc/kubernetes/admin.conf</code>) 拷贝到集群之外的服务器，并命名为指定文件 <code>~/.kube/config</code>，修改 <code>~/.kube/config</code> 中 <code>server</code> 的 IP 为 Kubernetes API Server 的实际 IP，使用 <code>kubectl</code> 命令时，报错 <code>Unable to connect to the server: x509: certificate is valid for 10.96.0.1, 10.150.0.21, not </code>。</p>
<p><strong>问题原因</strong>：</p>
<p>报错表示，当使用安全端口 6443 访问 Kubernetes API Server 时，默认证书中的 DNS 包含了 API Server 服务的 CLUSTER-IP 和 服务器的 IP ，如果是云主机，则为云服务器的私有 IP，不包含其公网 IP，如果使用公网 IP 访问 6443 端口，会报此错误</p>
<p>通过以下命令，可以看到默认的 API Server 的 HTTPS 证书中包含的 DNS</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /etc/kubernetes/pki</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">openssl x509 -noout -text -<span class="keyword">in</span> apiserver.crt</span></span><br><span class="line">...</span><br><span class="line">    DNS:k8s-master, DNS:kubernetes, DNS:kubernetes.default, DNS:kubernetes.default.svc, DNS:kubernetes.default.svc.cluster.local, IP Address:10.96.0.1, IP Address:10.150.0.21</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>解决方法</strong>：</p>
<ul>
<li><p>使用 <code>kubectl</code> 的命令行选项 <code>--insecure-skip-tls-verify</code> 可跳过证书验证。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get nodes</span></span><br><span class="line">Unable to connect to the server: x509: certificate is valid for 10.96.0.1, 10.150.0.21, not 34.150.1.1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get nodes --insecure-skip-tls-verify</span></span><br><span class="line"></span><br><span class="line">NAME         STATUS   ROLES                  AGE    VERSION</span><br><span class="line">k8s-master   Ready    control-plane,master   6d5h   v1.21.2</span><br><span class="line">k8s-work1    Ready    &lt;none&gt;                 6d5h   v1.21.2</span><br><span class="line">k8s-work2    Ready    &lt;none&gt;                 6d5h   v1.21.2</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>修改 <code>~/.kube/config</code> 中 <code>server</code> 地址为证书中包含的 DNS 名称，如 <code>k8s-master</code>，并确保域名本地可解析</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep server .kube/config</span></span><br><span class="line">  server: https://k8s-master:6443</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get nodes</span></span><br><span class="line">  NAME         STATUS   ROLES                  AGE    VERSION</span><br><span class="line">  k8s-master   Ready    control-plane,master   6d6h   v1.21.2</span><br><span class="line">  k8s-work1    Ready    &lt;none&gt;                 6d6h   v1.21.2</span><br><span class="line">  k8s-work2    Ready    &lt;none&gt;                 6d6h   v1.21.2</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新生成 API Server 证书</p>
<ol>
<li><p>备份当前证书</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /etc/kubernetes/pki</span><br><span class="line">mkdir /data/k8s/backup/pki</span><br><span class="line">mv apiserver.* /data/k8s/backup/pki/</span><br></pre></td></tr></table></figure></li>
<li><p>生成新的 API Server 证书</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"> $ </span><span class="language-bash">kubeadm init phase certs apiserver \</span></span><br><span class="line"><span class="language-bash">         --apiserver-advertise-address  10.150.0.21 \</span></span><br><span class="line"><span class="language-bash">         --apiserver-cert-extra-sans  10.96.0.1 \</span></span><br><span class="line"><span class="language-bash">         --apiserver-cert-extra-sans 34.150.1.1</span></span><br><span class="line">     </span><br><span class="line">[certs] Generating &quot;apiserver&quot; certificate and key</span><br><span class="line">[certs] apiserver serving cert is signed for DNS names [k8s-master kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.96.0.1 10.150.0.21 34.150.1.1]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>10.150.0.21</code> - 为云主机的私有（内网） IP 地址，同时也是 <code>--apiserver-advertise-address</code>，必须要有</li>
<li><code>10.96.0.1</code> - 为 Kubernetes 集群中 API Server 对应的 Service 的 ClusterIP，必须要有</li>
<li><code>34.150.1.1</code> - 为云主机的公网（弹性） IP，是本次要添加的 IP</li>
</ul>
<p>如果还有其他 IP，可以参照格式 <code>--apiserver-cert-extra-sans 34.150.1.1</code> 添加。</p>
<p> 命令执行成功后，会生成新的证书。<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ls apiserver*</span><br><span class="line">   apiserver.crt              apiserver-etcd-client.key  apiserver-kubelet-client.crt</span><br><span class="line">   apiserver-etcd-client.crt  apiserver.key              apiserver-kubelet-client.key</span><br></pre></td></tr></table></figure></p>
</li>
<li><p>重启 kubelet 服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart kubelet</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证</p>
<p> 在远端服务器执行以下命令验证效果 </p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ rm -rf .kube/cache/</span><br><span class="line">     </span><br><span class="line">$ grep server .kube/config </span><br><span class="line">  server: https://34.150.1.1:6443</span><br><span class="line">     </span><br><span class="line">$ kubectl get nodes</span><br><span class="line">   NAME                  STATUS   ROLES                  AGE    VERSION</span><br><span class="line">   k8s-master   Ready    control-plane,master   6d6h   v1.21.2</span><br><span class="line">   k8s-work1    Ready    &lt;none&gt;                 6d6h   v1.21.2</span><br><span class="line">   k8s-work2    Ready    &lt;none&gt;                 6d6h   v1.21.2</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h2 id="kubelet-启动失败"><a href="#kubelet-启动失败" class="headerlink" title="kubelet 启动失败"></a>kubelet 启动失败</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">journalctl -u kubelet</span></span><br><span class="line">&quot;command failed&quot; err=&quot;failed to run Kubelet: running with swap on is not supported, please disable swap! or set --fail-swap-on flag to false. /proc/swas contained: [Filename\t\t\t\tType\t\tSize\tUsed\tPriority /dev/dm-1</span><br></pre></td></tr></table></figure>
<p>根据 kubelet 服务日志，导致失败的原因为系统启用了 swap，关闭 swap，重新启动正常</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">free -h</span></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           1.9G        306M        120M        8.7M        1.5G        1.4G</span><br><span class="line">Swap:          3.9G        2.0M        3.9G</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">swapoff -a</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">free -h</span></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           1.9G        350M         71M        9.0M        1.5G        1.4G</span><br><span class="line">Swap:            0B          0B          0B</span><br></pre></td></tr></table></figure>

<h1 id="其他常用配置"><a href="#其他常用配置" class="headerlink" title="其他常用配置"></a>其他常用配置</h1><h2 id="新增节点"><a href="#新增节点" class="headerlink" title="新增节点"></a>新增节点</h2><p>要为集群新增 worker 节点，参考以下步骤</p>
<ol>
<li>加入前准备工作<br><a href="#kubernetes-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%89%8D%E9%85%8D%E7%BD%AE">参考安装步骤，配置新节点</a></li>
<li>在集群的 master 节点执行以下命令，获取加入集群的命令<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubeadm token create --print-join-command</span></span><br><span class="line">kubeadm join cluster:6443 --token cuxvrexi24aejb --discovery-token-ca-cert-hash sha256:9e5b71bc392</span><br></pre></td></tr></table></figure></li>
<li>在新节点上执行加入集群的命令 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm join cluster:6443 --token cuxvrexi24aejb --discovery-token-ca-cert-hash sha256:9e5b71bc392</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="将-CRI-由-containerd-变更为-Docker"><a href="#将-CRI-由-containerd-变更为-Docker" class="headerlink" title="将 CRI 由 containerd 变更为 Docker"></a>将 CRI 由 <code>containerd</code> 变更为 <code>Docker</code></h2><p>编辑 <code>/var/lib/kubelet/kubeadm-flags.env</code> 文件，在该文件中可以添加 <code>kubelet</code> 启动参数，将 <code>--container-runtime-endpoint</code> 标志，设置为 <code>unix:///var/run/cri-dockerd.sock</code> <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[配置 kubelet 使用 cri-dockerd](https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/migrating-from-dockershim/migrate-dockershim-dockerd/#configure-the-kubelet-to-use-cri-dockerd)">[1]</span></a></sup></p>
<figure class="highlight shell"><figcaption><span>/var/lib/kubelet/kubeadm-flags.env</span></figcaption><table><tr><td class="code"><pre><span class="line">KUBELET_KUBEADM_ARGS=&quot;--container-runtime=remote --container-runtime-endpoint=unix:///var/run/cri-dockerd.sock --pod-infra-container-image=registry.k8s.io/pause:3.8&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>kubeadm</code> 工具将节点上的套接字存储为控制面上 <code>Node</code> 对象的注解。 要为每个被影响的节点更改此套接字：</p>
<ol>
<li>编辑 Node 对象的 YAML 表示：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">KUBECONFIG=/path/to/admin.conf kubectl edit no &lt;NODE_NAME&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><code>/path/to/admin.conf</code> ：指向 <code>kubectl</code> 配置文件 <code>admin.conf</code> 的路径；</li>
<li><code>&lt;NODE_NAME&gt;</code> ：你要修改的节点的名称。</li>
</ul>
<ol start="2">
<li>将 <code>kubeadm.alpha.kubernetes.io/cri-socket</code> 标志更改为 <code>unix:///var/run/cri-dockerd.sock</code>；</li>
</ol>
<p>配置完成后，重启 kubelet</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart kubelet </span><br></pre></td></tr></table></figure>

<p>查看 node 使用的 CRI</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get nodes -o wide</span></span><br><span class="line">NAME              STATUS   ROLES           AGE    VERSION   INTERNAL-IP    EXTERNAL-IP   OS-IMAGE                KERNEL-VERSION                CONTAINER-RUNTIME</span><br><span class="line">kubernetes1   Ready    control-plane   7d2h   v1.25.0   172.31.5.58    &lt;none&gt;        CentOS Linux 7 (Core)   5.4.212-1.el7.elrepo.x86_64   docker://20.10.18</span><br><span class="line">kubernetes2   Ready    &lt;none&gt;          7d1h   v1.25.0   172.31.5.68    &lt;none&gt;        CentOS Linux 7 (Core)   5.4.212-1.el7.elrepo.x86_64   docker://20.10.18</span><br><span class="line">kubernetes3   Ready    &lt;none&gt;          7d1h   v1.25.0   172.31.0.230   &lt;none&gt;        CentOS Linux 7 (Core)   5.4.212-1.el7.elrepo.x86_64   docker://20.10.18</span><br></pre></td></tr></table></figure>

<h2 id="修改-kubelet-使用的-CRI-为-containerd"><a href="#修改-kubelet-使用的-CRI-为-containerd" class="headerlink" title="修改 kubelet 使用的 CRI 为 containerd"></a>修改 kubelet 使用的 CRI 为 containerd</h2><p>修改之前，<code>kubelet</code> 使用的 CRI 为 <code>cri-docker</code>。修改步骤如下</p>
<ol>
<li><p>停止 <code>kubelet</code>、<code>docker</code>、<code>cri-docker</code> 服务</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop kubelet</span><br><span class="line">systemctl stop docker</span><br><span class="line">systemctl stop docker.socket</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>修改 kubelet 配置及节点配置。</p>
<p>编辑 kubelet 配置文件 <code>/var/lib/kubelet/kubeadm-flags.env</code> 修改 <code>--container-runtime-endpoint</code> 为 <code>containerd</code> 的 socket 地址</p>
 <figure class="highlight shell"><figcaption><span>/var/lib/kubelet/kubeadm-flags.env</span></figcaption><table><tr><td class="code"><pre><span class="line">--container-runtime-endpoint=unix:///run/containerd/containerd.sock</span><br></pre></td></tr></table></figure>
<p>编辑节点配置，修改以下配置 <code>kubeadm.alpha.kubernetes.io/cri-socket: unix:///run/containerd/containerd.sock</code> <sup id="fnref:9"><a href="#fn:9" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[配置 kubelet 使用 containerd 作为其容器运行时](https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/migrating-from-dockershim/change-runtime-containerd/#%E9%85%8D%E7%BD%AE-kubelet-%E4%BD%BF%E7%94%A8-containerd-%E4%BD%9C%E4%B8%BA%E5%85%B6%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6)">[9]</span></a></sup></p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl edit node master2</span></span><br><span class="line">kubeadm.alpha.kubernetes.io/cri-socket: unix:///run/containerd/containerd.sock</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动服务</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload &amp;&amp; systemctl restart containerd  &amp;&amp; systemctl restart kubelet</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果启动 <code>kubelet</code> 失败，报错误： <code>Error: failed to run Kubelet: failed to create kubelet: get remote runtime typed version failed: rpc error: code = Unimplemented desc = unknown service runtime.v1alpha2.RuntimeService</code>，删除 <code>containerd</code> 的默认配置文件 <code>/etc/containerd/config.toml</code> 后，重新启动 <sup id="fnref:10"><a href="#fn:10" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Kubeadm unknown service runtime.v1alpha2.RuntimeService](https://github.com/containerd/containerd/issues/4581)">[10]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -rf /etc/containerd/config.toml</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
<h2 id="修改-Service-可使用的-nodePort-端口范围"><a href="#修改-Service-可使用的-nodePort-端口范围" class="headerlink" title="修改 Service 可使用的 nodePort 端口范围"></a>修改 Service 可使用的 nodePort 端口范围</h2><p>默认情况下，<code>Service</code> 中可使用的 <code>nodePort</code> 端口的默认范围为 <code>30000-32767</code>，要修改此配置，参考以下步骤。</p>
<p>Master 节点上编辑 kube-apiserver 的 <code>Pod</code> 配置文件 <code>/etc/kubernetes/manifests/kube-apiserver.yaml</code>，在 <code>.spec.containers.command</code> 下添加以下内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">- --service-node-port-range=1-65535</span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_60.png"></p>
<p><code>apiserver</code> 是以静态 <code>Pod</code> 的形式运行，<code>/etc/kubernetes/manifests</code> 目录下是所有静态 <code>Pod</code> 文件的定义，<code>kubelet</code> 会监控该目录下文件的变动，只要发生变化，<code>Pod</code> 就会重建，响应相应的改动。所以我们修改 <code>/etc/kubernetes/manifests/kube-apiserver.yaml</code> 文件，添加 <code>nodePort</code> 范围参数后会自动生效，无需进行其他操作</p>
<p><strong>高可用场景下，所有 Master 节点上都要修改，否则可能遇到部分时候依然报错： <code>nodePort: Invalid value: 65500: provided port is not in the valid range. The range of valid ports is 30000-32767</code></strong></p>
<h2 id="开启-corndns-日志记录"><a href="#开启-corndns-日志记录" class="headerlink" title="开启 corndns 日志记录"></a>开启 corndns 日志记录</h2><p>默认的 coredns 配置没有开启日志插件，这导致 kubernetes 集群中一些 dns 解析超时问题难以定位。要打开 coredns 的日志功能，可以通过以下命令开启日志功能</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl edit configmap -n kube-system  coredns</span><br></pre></td></tr></table></figure>
<p>添加以下配置：<br><img src="https://i.csms.tech/img_66.png"></p>
<p>接下来我们再使用命令查看日志，就可以看到 dns 解析的记录，无需重启 coredns</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl logs -f -n kube-system coredns-558bd4d5db-z6mst</span></span><br><span class="line">...</span><br><span class="line">[INFO] 10.244.2.23:39830 - 37988 &quot;A IN raw.githubusercontent.com.google.internal. udp 59 false 512&quot; NXDOMAIN qr,aa,rd,ra 164 0.000065843s</span><br><span class="line">[INFO] 10.244.2.23:56581 - 52144 &quot;A IN raw.githubusercontent.com. udp 43 false 512&quot; NOERROR qr,aa,rd,ra 207 0.000133489s</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="升级-cri-dockerd"><a href="#升级-cri-dockerd" class="headerlink" title="升级 cri-dockerd"></a>升级 cri-dockerd</h2><p>如果需要升级 <code>cri-dockerd</code> 版本，可以执行以下操作，如果之前的安装目录还在，则直接 <code>git pull</code> 更新代码，否则 clone 代码 <sup id="fnref:11"><a href="#fn:11" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[cri-dockerd 安装链接](https://github.com/Mirantis/cri-dockerd)">[11]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd cri-dockerd</span><br><span class="line">git pull</span><br><span class="line">make cri-dockerd</span><br><span class="line"></span><br><span class="line">install -o root -g root -m 0755 cri-dockerd /usr/local/bin/cri-dockerd</span><br><span class="line"></span><br><span class="line">install packaging/systemd/* /etc/systemd/system</span><br><span class="line">sed -i -e &#x27;s,/usr/bin/cri-dockerd,/usr/local/bin/cri-dockerd,&#x27; /etc/systemd/system/cri-docker.service</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 iptables 替换 firewalld</span></span><br><span class="line">sed -i -e &#x27;s,firewalld.service,iptables.service,&#x27; /etc/systemd/system/cri-docker.service</span><br><span class="line"></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable cri-docker.service --now</span><br><span class="line">systemctl enable --now cri-docker.socket</span><br></pre></td></tr></table></figure>

<h2 id="添加-Harbor-私有镜像仓库的认证信息"><a href="#添加-Harbor-私有镜像仓库的认证信息" class="headerlink" title="添加 Harbor 私有镜像仓库的认证信息"></a>添加 Harbor 私有镜像仓库的认证信息</h2><p>在命令行上提供凭证来创建 Secret <sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[在命令行上提供凭证来创建 Secret](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/pull-image-private-registry/#create-a-secret-by-providing-credentials-on-the-command-line)">[3]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create secret docker-registry $&#123;secretname&#125; \</span><br><span class="line">  --namespace default</span><br><span class="line">  --docker-server=https://index.docker.io/v1/ \</span><br><span class="line">  --docker-username=&lt;你的用户名&gt; \</span><br><span class="line">  --docker-password=&lt;你的密码&gt; \</span><br><span class="line">  --docker-email=&lt;你的邮箱地址&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>&lt;your-registry-server&gt;</code> 是你的私有 Docker 仓库全限定域名（FQDN）。 DockerHub 使用 <code>https://index.docker.io/v1/</code>。</li>
<li><code>&lt;your-name&gt;</code> 是你的 Docker 用户名。</li>
<li><code>&lt;your-pword&gt;</code> 是你的 Docker 密码。</li>
<li><code>&lt;your-email&gt;</code> 是你的 Docker 邮箱。</li>
</ul>
<p>这样你就成功地将集群中的 Docker 凭证设置为名为 <code>$&#123;secretname&#125;</code> 的 Secret。</p>
<p>Secret 属于 namespace 级别的资源，不能跨 namespace 使用。</p>
<p>检查创建的 Secret</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get secret <span class="variable">$&#123;secretname&#125;</span> --output=yaml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">data:</span><br><span class="line">  .dockerconfigjson: eyJhdXRocfX19</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: &quot;2022-11-04T08:55:51Z&quot;</span><br><span class="line">  name: $&#123;secretname&#125;</span><br><span class="line">  namespace: default</span><br><span class="line">  resourceVersion: &quot;1679647&quot;</span><br><span class="line">  uid: a780ac6d-9525-4620-a171-b818021cc6ca</span><br><span class="line">type: kubernetes.io/dockerconfigjson</span><br></pre></td></tr></table></figure>

<p><code>.dockerconfigjson</code> 字段的值是 Docker 凭证的 base64 表示。要了解 <code>dockerconfigjson</code> 字段中的内容，请将 Secret 数据转换为可读格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get secret <span class="variable">$&#123;secretname&#125;</span> --output=<span class="string">&quot;jsonpath=&#123;.data.\.dockerconfigjson&#125;&quot;</span> | <span class="built_in">base64</span> --decode</span></span><br><span class="line">&#123;&quot;auths&quot;:&#123;&quot;https://harbor1.my.com&quot;:&#123;&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;password&quot;,&quot;email&quot;:&quot;docker@q.com&quot;,&quot;auth&quot;:&quot;YWRdsUQ==&quot;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置-Pod-拉取镜像的认证信息"><a href="#配置-Pod-拉取镜像的认证信息" class="headerlink" title="配置 Pod 拉取镜像的认证信息"></a>配置 Pod 拉取镜像的认证信息</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get secret -n frtg</span></span><br><span class="line">NAME                   TYPE                             DATA   AGE</span><br><span class="line">harbor1.1dergegh.com   kubernetes.io/dockerconfigjson   1      157d</span><br></pre></td></tr></table></figure>

<p>在 namespace 中配置了镜像仓库的 Secret 后，可以使用以下方法配置 Pod 拉取镜像时的认证信息</p>
<ol>
<li><p>在 Pod 的配置中使用 <code>imagePullSecrets</code> 指令，此种方式需要在每个 Pod 的配置中添加</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: $&#123;NAME&#125;</span><br><span class="line">  namespace: $&#123;NAMESPACE&#125;</span><br><span class="line">spec:</span><br><span class="line">  restartPolicy: Always</span><br><span class="line">  containers:</span><br><span class="line">  - name: $&#123;NAME&#125;</span><br><span class="line">    image: nginx:1.14.2</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 80</span><br><span class="line">      name: http-web</span><br><span class="line">      </span><br><span class="line">  imagePullSecrets:</span><br><span class="line">  - name: $&#123;secret_name&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>通过 ServiceAccount 配置</p>
<p> 每个 namespace 都有个默认的 <a href="/202305161451/" title="ServiceAccount">ServiceAccount</a>，namespace 中的所有 Pod 默认情况下都会关联到此 ServiceAccount，ServiceAccount 的配置中包含了 <code>Image pull secrets</code>，在 ServiceAccount 中添加的镜像拉取密钥，会自动添加到所有使用这个 ServiceAccount 的 Pod 中。因此，向 ServiceAccount 中添加镜像拉取密钥可以不必对每个 Pod 都单独进行镜像拉取密钥的配置。 <sup id="fnref:8"><a href="#fn:8" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[为服务账号添加 ImagePullSecrets](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account)">[8]</span></a></sup></p>
<p> 执行命令 <code>kubectl edit serviceaccount default</code> 编辑默认的 ServiceAccount，删掉包含 <code>resourceVersion</code> 主键的行，添加包含 <code>imagePullSecrets:</code> 的行并保存文件</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: &quot;2022-12-06T09:51:03Z&quot;</span><br><span class="line">  name: default</span><br><span class="line">  namespace: default</span><br><span class="line">  uid: b219bafc-e2f9-48bb-a9e4-6e0bfb4ab536</span><br><span class="line">imagePullSecrets:</span><br><span class="line">  - name: harbor1.1dergegh.com</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Pod-添加-hosts"><a href="#Pod-添加-hosts" class="headerlink" title="Pod 添加 hosts"></a>Pod 添加 hosts</h2><p>有时需要在启动 Pod 时为其 <code>/etc/hosts</code> 中添加解析，以覆盖对主机名的解析，此时可以通过 <code>PodSpec</code> 的 <code>HostAliases</code> 字段来 <strong>添加这些自定义条目</strong> <sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[使用 HostAliases 向 Pod /etc/hosts 文件添加条目](https://kubernetes.io/zh-cn/docs/tasks/network/customize-hosts-file-for-pods/)">[4]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: hostaliases-pod</span><br><span class="line">spec:</span><br><span class="line">  restartPolicy: Never</span><br><span class="line">  hostAliases:</span><br><span class="line">  - ip: &quot;127.0.0.1&quot;</span><br><span class="line">    hostnames:</span><br><span class="line">    - &quot;foo.local&quot;</span><br><span class="line">    - &quot;bar.local&quot;</span><br><span class="line">  - ip: &quot;10.1.2.3&quot;</span><br><span class="line">    hostnames:</span><br><span class="line">    - &quot;foo.remote&quot;</span><br><span class="line">    - &quot;bar.remote&quot;</span><br><span class="line">  containers:</span><br><span class="line">  - name: cat-hosts</span><br><span class="line">    image: busybox:1.28</span><br><span class="line">    command:</span><br><span class="line">    - cat</span><br><span class="line">    args:</span><br><span class="line">    - &quot;/etc/hosts&quot;</span><br></pre></td></tr></table></figure>

<h2 id="配置-Pod-中的时区和时间"><a href="#配置-Pod-中的时区和时间" class="headerlink" title="配置 Pod 中的时区和时间"></a>配置 Pod 中的时区和时间</h2><p><a href="https://www.cnblogs.com/ssgeek/p/15192028.html">关于 OS 中的时间及时区的说明</a></p>
<p>通常情况下，我们的环境中，宿主机都是配置为 CST 时间（东八区），而使用的基础镜像中的默认时间都是 UTC 时间，而不是本地时间，通常需要确保系统中所有的时间格式一致，需将容器中的时间也修改为 CST 时间。</p>
<p>为此可使用以下方法中的一种来实现</p>
<ul>
<li><p>在 Dockerfile 中添加时区</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Set timezone</span><br><span class="line">RUN ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \</span><br><span class="line">           &amp;&amp; echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone</span><br></pre></td></tr></table></figure></li>
<li><p>将时区文件挂载到 Pod 中</p>
<p>  在定义 Pod 上层控制器的时候，添加一个用于挂载时区的卷，挂载宿主机的时区文件</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  ...</span><br><span class="line">containers:</span><br><span class="line">- name: xxx</span><br><span class="line">  ...</span><br><span class="line">  volumeMounts:</span><br><span class="line">    - name: timezone</span><br><span class="line">      mountPath: /etc/localtime</span><br><span class="line">volumes:</span><br><span class="line">  - name: timezone</span><br><span class="line">    hostPath:</span><br><span class="line">      path: /usr/share/zoneinfo/Asia/Shanghai</span><br></pre></td></tr></table></figure></li>
<li><p>通过环境变量定义时区</p>
<p>  在定义pod上层控制器的时候，添加一个用于指定时区的环境变量</p>
<p>  <code>TZ</code> 环境变量用于设置时区。它由各种时间函数用于计算相对于全球标准时间 UTC（以前称为格林威治标准时间 GMT）的时间。格式由操作系统指定</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  ...</span><br><span class="line">containers:</span><br><span class="line">- name: xxx</span><br><span class="line">  ...</span><br><span class="line">  env:</span><br><span class="line">  - name: TZ</span><br><span class="line">    value: Asia/Shanghai</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="配置节点允许启动的最大-Pod-数"><a href="#配置节点允许启动的最大-Pod-数" class="headerlink" title="配置节点允许启动的最大 Pod 数"></a>配置节点允许启动的最大 Pod 数</h2><p>在 K8S 集群中，默认每个 Worker 节点最大可创建 110 个 Pod，实际可以根据节点资源情况调整范围。</p>
<p>在 Woker 节点上，可创建的最大的 Pod 数量是作为 Kubelet 的启动参数出现的，因此修改 Kubelet 服务的配置文件增加 <code>--max-pod</code> 参数即可。</p>
<p>修改 <code>kubelet</code> 服务的启动文件 <code>/usr/lib/systemd/system/kubelet.service.d/10-kubeadm.conf</code>，添加以下环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Environment=&quot;KUBELET_NODE_MAX_PODS=--max-pods=200&quot;</span><br></pre></td></tr></table></figure>
<p>将新加的环境变量追加到 <code>/usr/bin/kubelet</code> 中</p>
<figure class="highlight shell"><figcaption><span>/usr/lib/systemd/system/kubelet.service.d/10-kubeadm.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"> Note: This dropin only works with kubeadm and kubelet v1.11+</span><br><span class="line">[Service]</span><br><span class="line">Environment=&quot;KUBELET_KUBECONFIG_ARGS=--bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf --kubeconfig=/etc/kubernetes/kubelet.conf&quot;</span><br><span class="line">Environment=&quot;KUBELET_CONFIG_ARGS=--config=/var/lib/kubelet/config.yaml&quot;</span><br><span class="line">Environment=&quot;KUBELET_EVICT_NODEFS_THRESHOLD_ARGS=--eviction-hard=nodefs.available&lt;5%&quot;</span><br><span class="line">Environment=&quot;KUBELET_NODE_MAX_PODS=--max-pods=200&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This is a file that <span class="string">&quot;kubeadm init&quot;</span> and <span class="string">&quot;kubeadm join&quot;</span> generates at runtime, populating the KUBELET_KUBEADM_ARGS variable dynamically</span></span><br><span class="line">EnvironmentFile=-/var/lib/kubelet/kubeadm-flags.env</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This is a file that the user can use <span class="keyword">for</span> overrides of the kubelet args as a last resort. Preferably, the user should use</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">the .NodeRegistration.KubeletExtraArgs object <span class="keyword">in</span> the configuration files instead. KUBELET_EXTRA_ARGS should be sourced from this file.</span></span><br><span class="line">EnvironmentFile=-/etc/sysconfig/kubelet</span><br><span class="line">ExecStart=</span><br><span class="line">ExecStart=/usr/bin/kubelet $KUBELET_KUBECONFIG_ARGS $KUBELET_CONFIG_ARGS $KUBELET_KUBEADM_ARGS $KUBELET_EXTRA_ARGS $KUBELET_EVICT_NODEFS_THRESHOLD_ARGS $KUBELET_NODE_MAX_PODS</span><br></pre></td></tr></table></figure>

<h2 id="重置集群"><a href="#重置集群" class="headerlink" title="重置集群"></a>重置集群</h2><p>要重置集群配置，可以参考以下步骤 <sup id="fnref:7"><a href="#fn:7" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[清理](https://v1-25.docs.kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#tear-down)
">[7]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubeadm reset --cri-socket=unix:///var/run/cri-dockerd.sock</span></span><br><span class="line">[reset] Reading configuration from the cluster...</span><br><span class="line">[reset] FYI: You can look at this config file with &#x27;kubectl -n kube-system get cm kubeadm-config -o yaml&#x27;</span><br><span class="line">W0428 15:31:57.928077   38272 reset.go:103] [reset] Unable to fetch the kubeadm-config ConfigMap from cluster: failed to get config map: configmaps &quot;kubeadm-config&quot; not found</span><br><span class="line">W0428 15:31:57.928210   38272 preflight.go:55] [reset] WARNING: Changes made to this host by &#x27;kubeadm init&#x27; or &#x27;kubeadm join&#x27; will be reverted.</span><br><span class="line">[reset] Are you sure you want to proceed? [y/N]: y</span><br><span class="line">W0428 15:32:05.851830   38272 removeetcdmember.go:85] [reset] No kubeadm config, using etcd pod spec to get data directory</span><br><span class="line">[reset] Stopping the kubelet service</span><br><span class="line">[reset] Unmounting mounted directories in &quot;/var/lib/kubelet&quot;</span><br><span class="line">[reset] Deleting contents of directories: [/etc/kubernetes/manifests /etc/kubernetes/pki]</span><br><span class="line">[reset] Deleting files: [/etc/kubernetes/admin.conf /etc/kubernetes/kubelet.conf /etc/kubernetes/bootstrap-kubelet.conf /etc/kubernetes/controller-manager.conf /etc/kubernetes/scheduler.conf]</span><br><span class="line">[reset] Deleting contents of stateful directories: [/var/lib/etcd /var/lib/kubelet]</span><br><span class="line"></span><br><span class="line">The reset process does not clean CNI configuration. To do so, you must remove /etc/cni/net.d</span><br><span class="line"></span><br><span class="line">The reset process does not reset or clean up iptables rules or IPVS tables.</span><br><span class="line">If you wish to reset iptables, you must do so manually by using the &quot;iptables&quot; command.</span><br><span class="line"></span><br><span class="line">If your cluster was setup to utilize IPVS, run ipvsadm --clear (or similar)</span><br><span class="line">to reset your system&#x27;s IPVS tables.</span><br><span class="line"></span><br><span class="line">The reset process does not clean your kubeconfig files and you must remove them manually.</span><br><span class="line">Please, check the contents of the $HOME/.kube/config file.</span><br></pre></td></tr></table></figure>

<h2 id="部署-kube-state-metrics-组件"><a href="#部署-kube-state-metrics-组件" class="headerlink" title="部署 kube-state-metrics 组件"></a>部署 kube-state-metrics 组件</h2><p><code>kube-state-metrics</code> 是一个用于导出 Kubernetes 集群的资源状态指标的开源项目，通过监听 API Server 生成有关资源对象(如 <code>Deployment</code>、<code>Node</code>、<code>Pod</code>)的状态指标，需要注意的是 <code>kube-state-metrics</code> 只是简单的提供一个 <code>metrics</code> 数据，并不会存储这些指标数据，所以我们可以使用 Prometheus 来抓取这些数据然后存储，主要关注的是业务相关的一些元数据，比如 <code>Deployment</code>、<code>Pod</code>、<code>RepliSet</code> 的状态等指标。</p>
<p><a href="https://github.com/kubernetes/kube-state-metrics/releases">下载链接</a> 下载对应版本的部署文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget https://github.com/kubernetes/kube-state-metrics/archive/refs/tags/v2.6.0.tar.gz</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -xf v2.6.0.tar.gz</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> kube-state-metrics-2.6.0/examples/standard/</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl apply -f cluster-role.yaml</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl apply -f cluster-role-binding.yaml</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl apply -f service-account.yaml</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl apply -f deployment.yaml</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl apply -f service.yaml</span></span><br></pre></td></tr></table></figure>
<p>参考以上步骤部署后，会生成 <code>kube-state-metrics</code> 所需要的资源：<code>ClusterRole</code>、<code>ClusterRoleBinding</code>、<code>ServiceAccount</code>、<code>Deployment</code>、<code>Service</code></p>
<p>部署成功后，查看生成的 <code>Service</code>，会看到是一个 <a href="https://csms.tech/202209241108/#无头服务（Headless-Services）">Headless 的服务</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get services -n kube-system</span></span><br><span class="line">NAME                 TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)                  AGE</span><br><span class="line">kube-dns             ClusterIP   10.96.0.10     &lt;none&gt;        53/UDP,53/TCP,9153/TCP   180d</span><br><span class="line">kube-state-metrics   ClusterIP   None           &lt;none&gt;        8080/TCP,8081/TCP        16m</span><br><span class="line">metrics-server       ClusterIP   10.99.58.171   &lt;none&gt;        443/TCP                  10d</span><br></pre></td></tr></table></figure>

<p>登陆一个 Pod，尝试在 Pod 中访问 <code>kube-state-metrics</code> 提供 Metrics 的 url （<code>kube-state-metrics.kube-system.svc.cluster.local:8080/metrics</code>）。对应的 Service 的 FQDN 为 <code>kube-state-metrics.kube-system.svc.cluster.local</code>，查看其解析，根据 <code>Headless Service</code> 的原理，会解析成 <code>kube-state-metrics</code> 的 Pod 的 IP。正常情况下会获取到 <code>kube-state-metrics</code> 监控的指标数据。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ping kube-state-metrics.kube-system.svc.cluster.local</span></span><br><span class="line">PING kube-state-metrics.kube-system.svc.cluster.local (10.244.4.178) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10-244-4-178.kube-state-metrics.kube-system.svc.cluster.local (10.244.4.178): icmp_seq=1 ttl=62 time=0.160 ms</span><br><span class="line">64 bytes from 10-244-4-178.kube-state-metrics.kube-system.svc.cluster.local (10.244.4.178): icmp_seq=2 ttl=62 time=0.146 ms</span><br><span class="line">64 bytes from 10-244-4-178.kube-state-metrics.kube-system.svc.cluster.local (10.244.4.178): icmp_seq=3 ttl=62 time=0.143 ms</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl kube-state-metrics.kube-system.svc.cluster.local:8080/metrics</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">TYPE kube_certificatesigningrequest_annotations gauge</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">HELP kube_certificatesigningrequest_labels Kubernetes labels converted to Prometheus labels.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">TYPE kube_certificatesigningrequest_labels gauge</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">HELP kube_certificatesigningrequest_created Unix creation timestamp</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">TYPE kube_certificatesigningrequest_created gauge</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">HELP kube_certificatesigningrequest_condition The number of each certificatesigningrequest condition</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">TYPE kube_certificatesigningrequest_condition gauge</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">HELP kube_certificatesigningrequest_cert_length Length of the issued cert</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">TYPE kube_certificatesigningrequest_cert_length gauge</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">HELP kube_configmap_annotations Kubernetes annotations converted to Prometheus labels.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">TYPE kube_configmap_annotations gauge</span></span><br><span class="line">kube_configmap_annotations&#123;namespace=&quot;cattle-impersonation-system&quot;,configmap=&quot;kube-root-ca.crt&quot;&#125; 1</span><br><span class="line">kube_configmap_annotations&#123;namespace=&quot;fleet-local&quot;,configmap=&quot;kube-root-ca.crt&quot;&#125; 1</span><br><span class="line">kube_configmap_annotations&#123;namespace=&quot;telegram-stream&quot;,configmap=&quot;kube-root-ca.crt&quot;&#125; 1</span><br><span class="line">kube_configmap_annotations&#123;namespace=&quot;cattle-system&quot;,configmap=&quot;admincreated&quot;&#125; 1</span><br><span class="line">kube_configmap_annotations&#123;namespace=&quot;cattle-fleet-system&quot;,configmap=&quot;gitjob&quot;&#125; 1</span><br><span class="line">kube_configmap_annotations&#123;namespace=&quot;cattle-system&quot;,configmap=&quot;forcesystemnamespaceassignment&quot;&#125; 1</span><br><span class="line">kube_configmap_annotations&#123;namespace=&quot;kube-flannel&quot;,configmap=&quot;kube-flannel-cfg&quot;&#125; 1</span><br><span class="line">kube_configmap_annotations&#123;namespace=&quot;p-76mvn&quot;,configmap=&quot;kube-root-ca.crt&quot;&#125; 1</span><br><span class="line">kube_configmap_annotations&#123;namespace=&quot;p-gqxm4&quot;,configmap=&quot;kube-root-ca.crt&quot;&#125; 1</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://kubernetes.io/zh-cn/docs/setup/production-environment/">Kubernetes 官网文档</a><br><a href="https://github.com/Mirantis/cri-dockerd">cri-dockerd 安装链接</a><br><a href="https://juejin.cn/post/6844904148001882120">Centos7 集群部署k8s 版本v1.17.4及Dashboard </a><br><a href="https://github.com/kubernetes/dashboard/tree/master/docs">kubernetes-dashboard 配置官网说明</a><br><a href="https://kubernetes.io/zh-cn/docs/tasks/access-application-cluster/web-ui-dashboard/">部署和访问 Kubernetes 仪表板（Dashboard）</a></p>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/migrating-from-dockershim/migrate-dockershim-dockerd/#configure-the-kubelet-to-use-cri-dockerd">配置 kubelet 使用 cri-dockerd</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/high-availability/#%E4%B8%BA-kube-apiserver-%E5%88%9B%E5%BB%BA%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8">为 kube-apiserver 创建负载均衡器</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/pull-image-private-registry/#create-a-secret-by-providing-credentials-on-the-command-line">在命令行上提供凭证来创建 Secret</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/tasks/network/customize-hosts-file-for-pods/">使用 HostAliases 向 Pod /etc/hosts 文件添加条目</a><a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://github.com/kubernetes-sigs/metrics-server">Kubernetes Metrics Server</a><a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://v1-25.docs.kubernetes.io/zh-cn/docs/reference/networking/ports-and-protocols/">端口和协议</a><a href="#fnref:6" rev="footnote"> ↩</a></span></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://v1-25.docs.kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#tear-down">清理</a><a href="#fnref:7" rev="footnote"> ↩</a></span></li><li id="fn:8"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">8.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account">为服务账号添加 ImagePullSecrets</a><a href="#fnref:8" rev="footnote"> ↩</a></span></li><li id="fn:9"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">9.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/migrating-from-dockershim/change-runtime-containerd/#%E9%85%8D%E7%BD%AE-kubelet-%E4%BD%BF%E7%94%A8-containerd-%E4%BD%9C%E4%B8%BA%E5%85%B6%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6">配置 kubelet 使用 containerd 作为其容器运行时</a><a href="#fnref:9" rev="footnote"> ↩</a></span></li><li id="fn:10"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">10.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://github.com/containerd/containerd/issues/4581">Kubeadm unknown service runtime.v1alpha2.RuntimeService</a><a href="#fnref:10" rev="footnote"> ↩</a></span></li><li id="fn:11"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">11.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://github.com/Mirantis/cri-dockerd">cri-dockerd 安装链接</a><a href="#fnref:11" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes Pod</title>
    <url>/202304271425/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Pod 是由一个或多个容器构成的集合，被 Kubernetes 作为一个整体进行部署和调度，是 Kubernetes 调度的最小单元。同一个 Pod 内的容器共享 <a href="/202304031317/" title="network namespace">network namespace</a>、<a href="/202304191340/" title="UTS nanespace">UTS nanespace</a></p>
<h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos7</li>
<li>Kubernetes v1.24.7</li>
</ul>
<h1 id="Pod-创建过程"><a href="#Pod-创建过程" class="headerlink" title="Pod 创建过程"></a>Pod 创建过程</h1><p>当用户在 Kubernetes 中创建了一个 Pod 后，CRI 和 CNI 协同创建 Pod 所属容器，并为 Pod 中的容器初始化网络协议栈的具体过程如下<br><img src="https://i.csms.tech/img_139.png"></p>
<ol>
<li><p>用户在 Kubernetes 中创建了一个 Pod 后，Kubelet 接收到创建新 Pod 的任务，首先调用 CRI 创建 Pod 内的容器</p>
</li>
<li><p>Pod 中第一个被创建的容器是 <code>pause</code> 容器。<code>pause</code> 容器中运行着一个功能非常简单的 C 程序，具体逻辑是把自己永远阻塞，没有实际的业务逻辑，主要功能是用来占用一个  <a href="/202304031317/" title="network namespace">network namespace</a>。</p>
<p> 创建 <code>pause</code> 容器，使用 <a href="https://csms.tech/202208301536/#None-模式">docker none 网络模式</a>，创建出来的容器除了 lo 回环网卡外没有其他网络设备。</p>
</li>
<li><p>Pod 内的其他用户容器通过加入 <code>pause</code> 容器已占用的 network namespace 的方式共享同一个 network namespace。对应于 docker 的 <a href="https://csms.tech/202208301536/#Container-模式">Container 模式</a></p>
<p> 其他用户容器都使用 <code>pause</code> 容器的主机名，但并不使用同一个 UTS namespace。</p>
</li>
<li><p>CNI 负责 Pod 中容器的网络初始化工作。主要为 Pod 内的 <code>pause</code> 容器添加 <code>eth0</code> 网卡、分配 IP、配置网关等。</p>
</li>
</ol>
<h1 id="pause-容器"><a href="#pause-容器" class="headerlink" title="pause 容器"></a>pause 容器</h1><p><code>pause</code> 容器是 Pod 中被创建的第一个容器，Pod 中的其他容器通过使用 <code>pause</code> 容器的 network namespace 共享网络协议栈和主机名。它是 Pod 中其他容器的父容器。</p>
<blockquote>
<p>1.8 以后版本默认不启用 PID namespace 共享。每个容器拥有独立的 PID namespace。</p>
</blockquote>
<p>以下步骤通过 docker 演示 Pod 容器创建的整个过程。首先，创建 <code>pause</code> 容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name=test-pause \</span><br><span class="line">	--hostname=test-pause \</span><br><span class="line">	--network=none \</span><br><span class="line">	--workdir=/ \</span><br><span class="line">	--log-opt max-size=100m \</span><br><span class="line">	--runtime=runc \</span><br><span class="line">	--detach=true \</span><br><span class="line">	k8s.gcr.io/pause:3.4.1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后在 Pod 中运行其他容器，本示例启动 2 个应用容器，一个 nginx 容器，里面启动了 nginx 服务，一个自定义的容器，里面包含常用工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run --name=pod_nginx_test \</span></span><br><span class="line"><span class="language-bash">             --network=container:0eec8dd9d164 \</span></span><br><span class="line"><span class="language-bash">             --restart=no --log-opt max-size=100m \</span></span><br><span class="line"><span class="language-bash">             --runtime=runc --detach=<span class="literal">true</span> \</span></span><br><span class="line"><span class="language-bash">             nginx</span></span><br><span class="line">             </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run --name=pod_centos_test \</span></span><br><span class="line"><span class="language-bash">             --network=container:0eec8dd9d164 \</span></span><br><span class="line"><span class="language-bash">             --restart=no --log-opt max-size=100m \</span></span><br><span class="line"><span class="language-bash">             --runtime=runc --detach=<span class="literal">true</span> \</span></span><br><span class="line"><span class="language-bash">             centos7:my ping 127.1</span>             </span><br><span class="line">             </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker ps -a</span></span><br><span class="line">CONTAINER ID   IMAGE                    COMMAND                  CREATED          STATUS          PORTS     NAMES</span><br><span class="line">54d57add44d2   centos7:my               &quot;ping 127.1&quot;             3 seconds ago    Up 2 seconds              pod_centos_test</span><br><span class="line">cd0c661774e2   nginx                    &quot;/docker-entrypoint.…&quot;   2 minutes ago    Up 2 minutes              pod_nginx_test</span><br><span class="line">0eec8dd9d164   k8s.gcr.io/pause:3.4.1   &quot;/pause&quot;                 10 minutes ago   Up 10 minutes             test-pause             </span><br></pre></td></tr></table></figure>
<p>进入 <code>pod_centos_test</code> 容器，查看网络、端口、主机名信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hostname</span></span><br><span class="line">test-pause</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">s -elf</span></span><br><span class="line">F S UID         PID   PPID  C PRI  NI ADDR SZ WCHAN  STIME TTY          TIME CMD</span><br><span class="line">4 S root          1      0  0  80   0 -  6218 skb_wa 17:01 ?        00:00:00 ping 127.1</span><br><span class="line">4 S root          7      0  0  80   0 -  2959 do_wai 17:02 pts/0    00:00:00 bash</span><br><span class="line">0 R root         30      7  0  80   0 - 12935 -      17:08 pts/0    00:00:00 ps -elf</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">netstat -anutp</span></span><br><span class="line">Active Internet connections (servers and established)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      -                   </span><br><span class="line">tcp6       0      0 :::80                   :::*                    LISTEN      - </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip add</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">       </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl  localhost:80</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">html &#123; color-scheme: light dark; &#125;</span><br><span class="line">body &#123; width: 35em; margin: 0 auto;</span><br><span class="line">font-family: Tahoma, Verdana, Arial, sans-serif; &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;If you see this page, the nginx web server is successfully installed and</span><br><span class="line">working. Further configuration is required.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;For online documentation and support please refer to</span><br><span class="line">&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;</span><br><span class="line">Commercial support is available at</span><br><span class="line">&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;       </span><br></pre></td></tr></table></figure>
<ul>
<li>Pod 中的容器主机名相同，都使用 <code>pause</code> 容器的主机名，但实际并未共享 UTS namespace。<blockquote>
<p>可以通过找到对应 docker 容器的进程 PID，找到对应进程的 namespace 信息对比确认</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps -elf | grep ping</span></span><br><span class="line">4 S root      35333  35311  0  80   0 -  6218 skb_wa 01:01 ?        00:00:00 ping 127.1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l /proc/35333/ns/</span></span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr  8 01:13 cgroup -&gt; cgroup:[4026531835]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr  8 01:02 ipc -&gt; ipc:[4026532664]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr  8 01:02 mnt -&gt; mnt:[4026532662]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr  8 01:02 net -&gt; net:[4026532588]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr  8 01:02 pid -&gt; pid:[4026532665]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr  8 01:13 pid_for_children -&gt; pid:[4026532665]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr  8 01:13 user -&gt; user:[4026531837]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr  8 01:02 uts -&gt; uts:[4026532663]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps -elf | grep nginx</span></span><br><span class="line">4 S root      34909  34887  0  80   0 -  2233 sigsus 00:59 ?        00:00:00 nginx: master process nginx -g daemon off;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l /proc/34909/ns/</span></span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr  8 01:14 cgroup -&gt; cgroup:[4026531835]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr  8 01:00 ipc -&gt; ipc:[4026532660]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr  8 01:00 mnt -&gt; mnt:[4026532658]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr  8 01:00 net -&gt; net:[4026532588]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr  8 01:00 pid -&gt; pid:[4026532661]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr  8 01:14 pid_for_children -&gt; pid:[4026532661]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr  8 01:14 user -&gt; user:[4026531837]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr  8 01:00 uts -&gt; uts:[4026532659]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps -elf | grep pause</span></span><br><span class="line">4 S root      34239  34221  0  80   0 -   241 ia32_s 00:51 ?        00:00:00 /pause</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l /proc/34239/ns/</span></span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr  8 01:15 cgroup -&gt; cgroup:[4026531835]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr  8 00:51 ipc -&gt; ipc:[4026532585]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr  8 00:51 mnt -&gt; mnt:[4026532583]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr  8 00:51 net -&gt; net:[4026532588]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr  8 00:51 pid -&gt; pid:[4026532586]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr  8 01:15 pid_for_children -&gt; pid:[4026532586]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr  8 01:15 user -&gt; user:[4026531837]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr  8 00:51 uts -&gt; uts:[4026532584]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以上观察可以看到，Pod 中的容器共享了 network namespace，未共享 UTS namespace。Kubernetes 中 Pod 中的容器同理。</p>
</blockquote>
</li>
<li>Pod 中容器的 PID namespace 进行了隔离，各个容器的 PID 进行了隔离，PID namespace 不同。</li>
<li>Pod 中的容器共享了 network namespace，具有相同的网络信息（网卡、IP、端口资源）</li>
<li>Pod 中的容器直接可以通过 <code>localhost</code> 互相访问</li>
</ul>
<span id="more"></span>

<h1 id="Pod-和-Kubernetes-API-服务交互"><a href="#Pod-和-Kubernetes-API-服务交互" class="headerlink" title="Pod 和 Kubernetes API 服务交互"></a>Pod 和 Kubernetes API 服务交互</h1><p><a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/downward-api/"><code>downwardAPI</code></a> 提供了一种简单的方式，可以将 Pod 的 Metadata 和状态数据通过<strong>环境变量</strong>或者 <strong>Volume</strong> 传递（挂载）到 Pod 中，允许内部进程使用。但这种方式仅仅可以暴露一个 Pod 自身的 Metadata ，而且只能暴露一部分数据，某些情况下，应用可能需要知道其他 Pod 的信息，甚至集群中其他资源的信息，这种情况下，<code>downwardAPI</code> 的方式就无能为力了。</p>
<p>Pod 启动时，系统会主动将部分信息以环境变量的形式注入到每个 Pod 中，比如自定义的 Service 的部分信息，Kubernetes API Service 的信息等，可以登陆 Pod，检查系统环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">printenv</span> | grep <span class="string">&quot;SERVICE&quot;</span></span></span><br><span class="line">KUBERNETES_SERVICE_PORT_HTTPS=443</span><br><span class="line">TEST_API_SERVICE_PORT=tcp://10.106.126.96:10302</span><br><span class="line">KUBERNETES_SERVICE_PORT=443</span><br><span class="line">TEST_API_SERVICE_PORT_10302_TCP_PORT=10302</span><br><span class="line">TEST_API_SERVICE_PORT_10302_TCP_PROTO=tcp</span><br><span class="line">TEST_API_SERVICE_SERVICE_HOST=10.106.126.96</span><br><span class="line">TEST_API_SERVICE_SERVICE_PORT=10302</span><br><span class="line">TEST_API_SERVICE_PORT_10302_TCP=tcp://10.106.126.96:10302</span><br><span class="line">TEST_API_SERVICE_SERVICE_PORT_TEST_API_PORD=10302</span><br><span class="line">TEST_API_SERVICE_PORT_10302_TCP_ADDR=10.106.126.96</span><br><span class="line">KUBERNETES_SERVICE_HOST=10.96.0.1</span><br></pre></td></tr></table></figure>
<p>以上示例中的 Pod ，在启动时，系统主动注入了相同 namespace 中的 Service 的信息，包括 Service IP 地址、端口等信息，以及 Kubernetes API Service 的 IP 及端口信息。</p>
<blockquote>
<p>Pod 中要使用 Service 的环境变量，要确保 Service 在 Pod 启动之前被创建，否则 Pod 中不存在相关环境变量。</p>
</blockquote>
<p>Pod 启动时，系统除了主动注入环境变量，还通过创建 <code>projected</code> 的 Volume 的方式给每个 Pod 挂载了以下信息</p>
<ul>
<li>所属 namespace 的默认 ServiceAccount 的 token（<code>serviceAccountToken</code>）</li>
<li>集群的 CA 证书（<code>configMap</code>）</li>
<li>Pod 的所属 namespace 信息（<code>downwardAPI</code>）</li>
</ul>
<p>可以通过以下命令验证上述信息。其中的 Volume <code>kube-api-access-8ch7r</code> 为系统自动生成并挂载到了 Pod 中的容器的 <code>/var/run/secrets/kubernetes.io/serviceaccount</code> 目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl edit pod -n ops ops-centos7-bfc4d75b5-kjcfs</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: ops-centos7</span><br><span class="line">  name: ops-centos7-bfc4d75b5-kjcfs</span><br><span class="line">  namespace: ops</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - command:</span><br><span class="line">    - ping</span><br><span class="line">    - 127.0.0.1</span><br><span class="line">    image: centos:centos7.9.2009</span><br><span class="line">    name: ops-centos7</span><br><span class="line">	</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - mountPath: /var/run/secrets/kubernetes.io/serviceaccount</span><br><span class="line">      name: kube-api-access-8ch7r</span><br><span class="line">      readOnly: true</span><br><span class="line"></span><br><span class="line">  volumes:</span><br><span class="line">  - name: kube-api-access-8ch7r</span><br><span class="line">    projected:</span><br><span class="line">      defaultMode: 420</span><br><span class="line">      sources:</span><br><span class="line">      - serviceAccountToken:</span><br><span class="line">          expirationSeconds: 3607</span><br><span class="line">          path: token</span><br><span class="line">      - configMap:</span><br><span class="line">          items:</span><br><span class="line">          - key: ca.crt</span><br><span class="line">            path: ca.crt</span><br><span class="line">          name: kube-root-ca.crt</span><br><span class="line">      - downwardAPI:</span><br><span class="line">          items:</span><br><span class="line">          - fieldRef:</span><br><span class="line">              apiVersion: v1</span><br><span class="line">              fieldPath: metadata.namespace</span><br><span class="line">            path: namespace</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>卷 <code>kube-api-access-8ch7r</code> 主要包含 3 部分内容</p>
<ul>
<li><code>serviceAccountToken</code> 每个 namespace 都有个默认的 ServiceAccount，在没有为 Pod 配置 ServiceAccount 的情况下，系统会自动将默认的 ServiceAccount 挂载到 Pod 中的每个容器，作为运行在 Pod 中的进程和 API Server 交互时认证授权的身份（主体）。<a href="/202305161451/" title="ServiceAccount 使用说明参考">ServiceAccount 使用说明参考</a></li>
<li><code>configMap</code> - 以 <code>configMap</code> 的方式为 Pod 中的容器挂载了集群的 CA 证书</li>
<li><code>downwardAPI</code> - 以 <code>downwardAPI</code> 的方式，让 Pod 中的容器可以获取到 Pod 所在的 namespace 信息。</li>
</ul>
<p>以上内容被挂载到了容器的 <code>/var/run/secrets/kubernetes.io/serviceaccount</code> 目录中，可以在容器中检查此目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> /var/run/secrets/kubernetes.io/serviceaccount/</span></span><br><span class="line">ca.crt  namespace  token</span><br></pre></td></tr></table></figure>



<h2 id="在-Pod-中通过-curl-命令请求-Kubernetes-API"><a href="#在-Pod-中通过-curl-命令请求-Kubernetes-API" class="headerlink" title="在 Pod 中通过 curl 命令请求 Kubernetes API"></a>在 Pod 中通过 curl 命令请求 Kubernetes API</h2><p>默认情况下，Kubernetes API Service 的 Service 名称为 <code>kubernetes</code>，因此在集群内部，可以通过 FQDN <code>kubernetes.default.svc.cluster.local</code> 访问 Kubernetes API Service</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get services</span></span><br><span class="line">NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">kubernetes   ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP   156d</span><br></pre></td></tr></table></figure>

<p>在 Pod 中尝试访问 Kubernetes API Service，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl https://kubernetes.default.svc.cluster.local</span></span><br><span class="line">curl: (60) SSL certificate problem: unable to get local issuer certificate</span><br><span class="line">More details here: https://curl.haxx.se/docs/sslcerts.html</span><br><span class="line"></span><br><span class="line">curl failed to verify the legitimacy of the server and therefore could not</span><br><span class="line">establish a secure connection to it. To learn more about this situation and</span><br><span class="line">how to fix it, please visit the web page mentioned above.</span><br></pre></td></tr></table></figure>
<p>以上报错，是因为通过 https 访问 Kubernetes API Service，但是无法验证证书。最简单的规避此问题的方法是使用 <code>curl</code> 命令的 <code>-k, --insecure</code> 选项忽略验证证书，但这是存在安全隐患的，不建议在生产环境使用。</p>
<p>Pod 启动时，系统已经将集群的 CA 证书注入到了每个容器，因此可以使用 CA 证书来验证服务器证书。执行以下命令，使用 CA 证书重新访问 Kubernetes API Service</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt https://kubernetes.default.svc.cluster.local</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;kind&quot;: &quot;Status&quot;,</span><br><span class="line">  &quot;apiVersion&quot;: &quot;v1&quot;,</span><br><span class="line">  &quot;metadata&quot;: &#123;&#125;,</span><br><span class="line">  &quot;status&quot;: &quot;Failure&quot;,</span><br><span class="line">  &quot;message&quot;: &quot;forbidden: User \&quot;system:anonymous\&quot; cannot get path \&quot;/\&quot;&quot;,</span><br><span class="line">  &quot;reason&quot;: &quot;Forbidden&quot;,</span><br><span class="line">  &quot;details&quot;: &#123;&#125;,</span><br><span class="line">  &quot;code&quot;: 403</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，使用 CA 证书后，HTTPS 连接成功，Kubernetes API 返回了响应。以上 Kubernetes API 输出中，表面此次请求使用的是匿名用户，不具有 API 服务器的授权，因此拒绝访问。</p>
<blockquote>
<p>默认情况下，Pod 使用的是 namespace 中的默认的 ServiceAccount token，默认不具有任何权限。</p>
</blockquote>
<p><a href="https://csms.tech/202305161451/#RBAC-配置示例">参考 RBAC 配置认证鉴权使 Pod 的容器可以和 Kubernetes API Server 通信</a></p>
<h1 id="Pod-计算资源限制"><a href="#Pod-计算资源限制" class="headerlink" title="Pod 计算资源限制"></a>Pod 计算资源限制</h1><p>创建 Pod 时，可以指定<strong>容器</strong>对 CPU 和 Memory 的资源请求量（<code>requests</code>）和资源限制量（’limits&#96;），他们不是针对 Pod，而是针对 Pod 中的容器。Pod 对资源的请求量和限制量是它所包含的所有容器的请求量和限制量之和。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: $&#123;NAME&#125;</span><br><span class="line">  namespace: $&#123;NAMESPACE&#125;</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: $&#123;NAME&#125;</span><br><span class="line">    image: nginx:1.14.2</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 80</span><br><span class="line">      name: http-web</span><br><span class="line">      </span><br><span class="line">    resources:</span><br><span class="line">      requests:</span><br><span class="line">        cpu: 200m</span><br><span class="line">        memory: 10Mi</span><br><span class="line">      limits:</span><br><span class="line">        cpu: 200m</span><br><span class="line">        memory: 10Mi</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果为容器的资源申请指定了 <code>limits</code>，但未指定 <code>requests</code>，并且没有应用准入时机制为该资源设置默认请求， 然后 Kubernetes 将复制你所指定的限制值，将其用作资源的请求值。</p>
</blockquote>
<h2 id="资源类型"><a href="#资源类型" class="headerlink" title="资源类型"></a>资源类型</h2><p>CPU 和 内存 都是 资源类型。每种资源类型具有其基本单位。 CPU 表达的是计算处理能力，其单位是 Kubernetes CPU。内存的单位是字节。<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[资源类型](https://kubernetes.io/zh-cn/docs/concepts/configuration/manage-resources-containers/#resource-types)
">[2]</span></a></sup></p>
<h3 id="CPU-资源单位"><a href="#CPU-资源单位" class="headerlink" title="CPU 资源单位"></a>CPU 资源单位</h3><p>CPU 资源的限制和请求以 “cpu” 为单位。 在 Kubernetes 中，一个 CPU 等于 1 个物理 CPU 核 或者 1 个虚拟核， 取决于节点是一台物理主机还是运行在某物理主机上的虚拟机。</p>
<blockquote>
<p>1 CPU &#x3D; 1000m 的 CPU 资源</p>
</blockquote>
<h3 id="Memory-资源单位"><a href="#Memory-资源单位" class="headerlink" title="Memory 资源单位"></a>Memory 资源单位</h3><p>memory 的限制和请求以字节为单位。 你可以使用普通的整数，或者带有以下 数量后缀 的定点数字来表示内存：E、P、T、G、M、k。 你也可以使用对应的 2 的幂数：Ei、Pi、Ti、Gi、Mi、Ki。</p>
<h2 id="查看节点资源总量"><a href="#查看节点资源总量" class="headerlink" title="查看节点资源总量"></a>查看节点资源总量</h2><p>通过以下命令输出，可以看到节点的资源总量和可分配资源量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get nodes</span></span><br><span class="line">...</span><br><span class="line">Capacity:</span><br><span class="line">  cpu:                16</span><br><span class="line">  ephemeral-storage:  524276716Ki</span><br><span class="line">  hugepages-1Gi:      0</span><br><span class="line">  hugepages-2Mi:      0</span><br><span class="line">  memory:             32068748Ki</span><br><span class="line">  pods:               110</span><br><span class="line">Allocatable:</span><br><span class="line">  cpu:                16</span><br><span class="line">  ephemeral-storage:  483173420666</span><br><span class="line">  hugepages-1Gi:      0</span><br><span class="line">  hugepages-2Mi:      0</span><br><span class="line">  memory:             31966348Ki</span><br><span class="line">  pods:               110</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/workload-resources/pod-v1/#%E8%B5%84%E6%BA%90">resources</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/concepts/configuration/manage-resources-containers/#resource-types">资源类型</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes 权限控制</title>
    <url>/202305161451/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos 7</li>
<li>Kubernetes 1.24</li>
</ul>
<h1 id="ServiceAccount"><a href="#ServiceAccount" class="headerlink" title="ServiceAccount"></a>ServiceAccount</h1><p>ServiceAccount 就像 Pod、Secret、ConfigMap 等一样，都是资源，属于 namespace 级别，作用在单独的命名空间。默认情况，每个 namespace 都有一个默认的 ServiceAccount。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get serviceaccount</span></span><br><span class="line">NAME      SECRETS   AGE</span><br><span class="line">default   0         160d</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl describe serviceaccount default</span></span><br><span class="line">Name:                default</span><br><span class="line">Namespace:           default</span><br><span class="line">Labels:              &lt;none&gt;</span><br><span class="line">Annotations:         &lt;none&gt;</span><br><span class="line">Image pull secrets:  &lt;none&gt;</span><br><span class="line">Mountable secrets:   &lt;none&gt;</span><br><span class="line">Tokens:              &lt;none&gt;</span><br><span class="line">Events:              &lt;none&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>namespace 中的每个 Pod 都和一个 ServiceAccount 关联，它代表了运行在 Pod 中的应用程序的身份证明。<strong>Pod 中的每个容器都会挂载此 ServiceAccount token</strong></p>
<p>在 Pod 的 manifest 定义文件中，可以通过指定账户名称的方式将一个 ServiceAccount 关联到 Pod。如果不显示指定 ServiceAccount 的账户名称，Pod 会使用 namespace 中默认的 ServiceAccount。可以将不同的 ServiceAccount 关联给不同的 Pod 来控制每个 Pod 可以访问的资源。</p>
<p>当 API 服务接收到一个带有认证 token 的请求时， API 会用这个 token 来验证发送请求的客户端所关联的 ServiceAccount 是否允许执行请求的操作。</p>
<h2 id="查看-ServiceAccount"><a href="#查看-ServiceAccount" class="headerlink" title="查看 ServiceAccount"></a>查看 ServiceAccount</h2><p>以 rancher 相关的 ServiceAccount 为例，查看 ServiceAccount 信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get serviceaccount -n cattle-system</span></span><br><span class="line">NAME                      SECRETS   AGE</span><br><span class="line">default                   0         160d</span><br><span class="line">git-webhook-api-service   0         160d</span><br><span class="line">rancher                   0         160d</span><br><span class="line">rancher-webhook           0         160d</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl describe sa default -n cattle-system</span></span><br><span class="line">Name:                default</span><br><span class="line">Namespace:           cattle-system</span><br><span class="line">Labels:              &lt;none&gt;</span><br><span class="line">Annotations:         &lt;none&gt;</span><br><span class="line">Image pull secrets:  &lt;none&gt;</span><br><span class="line">Mountable secrets:   &lt;none&gt;</span><br><span class="line">Tokens:              &lt;none&gt;</span><br><span class="line">Events:              &lt;none&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以下输出名为 <code>rancher</code> 的 ServiceAccount 信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl describe sa rancher -n cattle-system</span></span><br><span class="line">Name:                rancher</span><br><span class="line">Namespace:           cattle-system</span><br><span class="line">Labels:              app=rancher</span><br><span class="line">                     app.kubernetes.io/managed-by=Helm</span><br><span class="line">                     chart=rancher-2.7.0</span><br><span class="line">                     heritage=Helm</span><br><span class="line">                     release=rancher</span><br><span class="line">Annotations:         meta.helm.sh/release-name: rancher</span><br><span class="line">                     meta.helm.sh/release-namespace: cattle-system</span><br><span class="line">Image pull secrets:  &lt;none&gt;</span><br><span class="line">Mountable secrets:   &lt;none&gt;</span><br><span class="line">Tokens:              rancher-token</span><br><span class="line">Events:              &lt;none&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>ServiceAccount 主要包含了密钥（token）信息，客户端 (Pod)请求 API Service 时使用的 token 文件（如 <code>/var/run/secrets/kubernetes.io/serviceaccount/token</code>）持有 ServiceAccount 的 token 。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl describe secret rancher-token -n cattle-system</span></span><br><span class="line">Name:         rancher-token</span><br><span class="line">Namespace:    cattle-system</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  field.cattle.io/projectId: local:p-76mvn</span><br><span class="line">              kubernetes.io/service-account.name: rancher</span><br><span class="line">              kubernetes.io/service-account.uid: 1e80ce10-2ba3-4bc3-81d9-ccc72001431b</span><br><span class="line"></span><br><span class="line">Type:  kubernetes.io/service-account-token</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line">====</span><br><span class="line">ca.crt:     1099 bytes</span><br><span class="line">namespace:  13 bytes</span><br><span class="line">token:      eyJhbGciOiJSUzI1NiIsImtpZCI6Ik51eFpuNU9MUlp2Qkxm</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="https://csms.tech/202209121102/#配置-Pod-拉取镜像的认证信息">通过 ServiceAccount 配置镜像拉取密钥</a></p>
</blockquote>
<p>在新建了 ServiceAccount 之后，若要将它赋值给 Pod，通过在 Pod 定义中的 <code>spec.serviceAccountName</code> 字段上配置 ServiceAccount 名称来分配。<strong>Pod 的 ServiceAccount 必须在 Pod 创建时进行配置，后续不能被修改</strong></p>
<h1 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h1><p>从 Kubernetes 1.8.0 开始，RBAC（基于角色的权限控制）授权插件升级为 GA（通用可用性），并在大多数集群上默认开启（比如通过 <code>kubeadm</code> 部署的集群）。<a href="https://csms.tech/202304271425/#在-Pod-中通过-curl-命令请求-Kubernetes-API">RBAC 会阻止未授权的用户查看和修改集群状态，默认的 ServiceAccount 不允许查看集群状态</a>。</p>
<p>RBAC 授权规则是通过四种资源对象来进行配置的，他们可以分为 2 个组 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[使用 RBAC 鉴权](https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/rbac/#restrictions-on-role-creation-or-update)
">[1]</span></a></sup></p>
<ul>
<li><code>Role</code>、<code>ClusterRole</code> -  一组代表相关权限的规则，他们指定了在资源上可以执行哪些操作（动词）</li>
<li><code>RoleBinding</code>、<code>ClusterRoleBinding</code> - 将角色中定义的权限赋予一个或者一组用户。它包含若干主体（用户、组或者 ServiceAccount）的列表和对这些主体所获得的角色的引用。</li>
</ul>
<blockquote>
<p><code>Role</code> 和 <code>RoleBinding</code> 属于 namespace 范围的资源，必须在 namespace 中配置</p>
<p><code>ClusterRole</code> 和 <code>ClusterRoleBinding</code> 是集群作用域的资源</p>
<p><strong>一个 RoleBinding 可以引用某 ClusterRole 并将该 ClusterRole 绑定到 RoleBinding 所在的名字空间。但是，RoleBinding 不能授予主体集群级别的资源的访问权限，即使它引用了一个 ClusterRoleBinding</strong></p>
<hr>
</blockquote>
<span id="more"></span>
<h2 id="Role"><a href="#Role" class="headerlink" title="Role"></a>Role</h2><p><a href="https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/rbac/#role-example">下面是一个位于 <code>default</code> 名字空间的 <code>Role</code> 的示例，可用来授予对 Pod 的读访问权限 </a> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: Role</span><br><span class="line">metadata:</span><br><span class="line">  namespace: default</span><br><span class="line">  name: pod-reader</span><br><span class="line">rules:</span><br><span class="line">- apiGroups: [&quot;&quot;] # &quot;&quot; 标明 core API 组</span><br><span class="line">  resources: [&quot;pods&quot;]</span><br><span class="line">  verbs: [&quot;get&quot;, &quot;watch&quot;, &quot;list&quot;]</span><br></pre></td></tr></table></figure>

<h2 id="RoleBinding"><a href="#RoleBinding" class="headerlink" title="RoleBinding"></a>RoleBinding</h2><p><a href="https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/rbac/#rolebinding-example">下面的例子中的 <code>RoleBinding</code> 将 <code>pod-reader</code> 这个 <code>Role</code> 授予在 <code>default</code> 名字空间中的用户 <code>jane</code>。 这样，用户 <code>jane</code> 就具有了读取 <code>default</code> 名字空间中所有 Pod 的权限</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此角色绑定允许 <span class="string">&quot;jane&quot;</span> 读取 <span class="string">&quot;default&quot;</span> 名字空间中的 Pod</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">你需要在该命名空间中有一个名为 “pod-reader” 的 Role</span></span><br><span class="line">kind: RoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: read-pods</span><br><span class="line">  namespace: default</span><br><span class="line">subjects:</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">你可以指定不止一个“subject（主体）”</span></span><br><span class="line">- kind: User</span><br><span class="line">  name: jane # &quot;name&quot; 是区分大小写的</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">roleRef:</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">&quot;roleRef&quot;</span> 指定与某 Role 或 ClusterRole 的绑定关系</span></span><br><span class="line">  kind: Role        # 此字段必须是 Role 或 ClusterRole</span><br><span class="line">  name: pod-reader  # 此字段必须与你要绑定的 Role 或 ClusterRole 的名称匹配</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br></pre></td></tr></table></figure>

<h2 id="RBAC-配置示例"><a href="#RBAC-配置示例" class="headerlink" title="RBAC 配置示例"></a>RBAC 配置示例</h2><p>以下示例演示通过给 namespace 中默认的 ServiceAccount 配置查看 Service 的权限，学习 RBAC 的使用。</p>
<p>本示例中的 namespace 为 <code>ops</code>，示例 Pod 为 <code>ops-centos7-bfc4d75b5-kjcfs</code>，配置信息如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl edit pod -n ops  ops-centos7-bfc4d75b5-kjcfs</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: ops-centos7</span><br><span class="line">  name: ops-centos7-bfc4d75b5-kjcfs</span><br><span class="line">  namespace: ops</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - command:</span><br><span class="line">    - ping</span><br><span class="line">    - 127.0.0.1</span><br><span class="line">    image: centos:centos7.9.2009</span><br><span class="line">	name: ops-centos7</span><br><span class="line">	</span><br><span class="line">	volumeMounts:</span><br><span class="line">    - mountPath: /var/run/secrets/kubernetes.io/serviceaccount</span><br><span class="line">      name: kube-api-access-8ch7r</span><br><span class="line">      readOnly: true</span><br><span class="line"></span><br><span class="line">  volumes:</span><br><span class="line">  - name: kube-api-access-8ch7r</span><br><span class="line">    projected:</span><br><span class="line">      defaultMode: 420</span><br><span class="line">      sources:</span><br><span class="line">      - serviceAccountToken:</span><br><span class="line">          expirationSeconds: 3607</span><br><span class="line">          path: token</span><br><span class="line">      - configMap:</span><br><span class="line">          items:</span><br><span class="line">          - key: ca.crt</span><br><span class="line">            path: ca.crt</span><br><span class="line">          name: kube-root-ca.crt</span><br><span class="line">      - downwardAPI:</span><br><span class="line">          items:</span><br><span class="line">          - fieldRef:</span><br><span class="line">              apiVersion: v1</span><br><span class="line">              fieldPath: metadata.namespace</span><br><span class="line">            path: namespace</span><br></pre></td></tr></table></figure>

<p>登陆到 Pod 中的容器，请求 Kubernetes API Server。默认的 token 没有查询集群信息的权限。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt https://kubernetes.default.svc.cluster.local</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;kind&quot;: &quot;Status&quot;,</span><br><span class="line">  &quot;apiVersion&quot;: &quot;v1&quot;,</span><br><span class="line">  &quot;metadata&quot;: &#123;&#125;,</span><br><span class="line">  &quot;status&quot;: &quot;Failure&quot;,</span><br><span class="line">  &quot;message&quot;: &quot;forbidden: User \&quot;system:anonymous\&quot; cannot get path \&quot;/\&quot;&quot;,</span><br><span class="line">  &quot;reason&quot;: &quot;Forbidden&quot;,</span><br><span class="line">  &quot;details&quot;: &#123;&#125;,</span><br><span class="line">  &quot;code&quot;: 403</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt https://kubernetes.default.sv.cluster.local/api/v1/namespaces/ops/services</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;kind&quot;: &quot;Status&quot;,</span><br><span class="line">  &quot;apiVersion&quot;: &quot;v1&quot;,</span><br><span class="line">  &quot;metadata&quot;: &#123;&#125;,</span><br><span class="line">  &quot;status&quot;: &quot;Failure&quot;,</span><br><span class="line">  &quot;message&quot;: &quot;services is forbidden: User \&quot;system:anonymous\&quot; cannot list resource \&quot;services\&quot; in API group \&quot;\&quot; in the namespace \&quot;ops\&quot;&quot;,</span><br><span class="line">  &quot;reason&quot;: &quot;Forbidden&quot;,</span><br><span class="line">  &quot;details&quot;: &#123;</span><br><span class="line">    &quot;kind&quot;: &quot;services&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;code&quot;: 403</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上请求中，因为没有提供访问的凭据，认证系统会将请求者的身份标记为 <code>system:anonymous</code>，鉴权系统检查此用户是否有权限请求相应资源，没有权限则返回 403。</p>
<p>使用 Pod 中默认挂载的 token 进行请求，认证系统会识别请求者的身份为对应的 ServiceAccount（默认的 <code>default</code>），鉴权系统检查权限，返回 <code>Unauthorized</code> 表示请求未授权。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \</span></span><br><span class="line"><span class="language-bash">       -H <span class="string">&quot;Authorization: Bearer `cat /var/run/secrets/kubernetes.io/serviceaccount/token`&quot;</span> \</span></span><br><span class="line"><span class="language-bash">       https://kubernetes.default.svc.cluster.local</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;kind&quot;: &quot;Status&quot;,</span><br><span class="line">  &quot;apiVersion&quot;: &quot;v1&quot;,</span><br><span class="line">  &quot;metadata&quot;: &#123;&#125;,</span><br><span class="line">  &quot;status&quot;: &quot;Failure&quot;,</span><br><span class="line">  &quot;message&quot;: &quot;Unauthorized&quot;,</span><br><span class="line">  &quot;reason&quot;: &quot;Unauthorized&quot;,</span><br><span class="line">  &quot;code&quot;: 401</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建-Role"><a href="#创建-Role" class="headerlink" title="创建 Role"></a>创建 Role</h3><p>创建以下配置的 <code>Role</code>，名称为 <code>services-read</code>，<code>Role</code> 属于 namespace 资源，因此必须指定 namespace <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[API Role](https://v1-24.docs.kubernetes.io/zh-cn/docs/reference/kubernetes-api/authorization-resources/role-v1/)">[2]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: Role</span><br><span class="line">metadata:</span><br><span class="line">  namespace: ops</span><br><span class="line">  name: services-read</span><br><span class="line">rules:</span><br><span class="line">- apiGroups: [&quot;&quot;]</span><br><span class="line">  resources: [&quot;services&quot;]</span><br><span class="line">  verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;]</span><br></pre></td></tr></table></figure>

<h3 id="创建-RoleBinding"><a href="#创建-RoleBinding" class="headerlink" title="创建 RoleBinding"></a>创建 RoleBinding</h3><p><code>Role</code> 配置了允许的操作（动作），未指定可以执行动作的主体（用户，组，ServiceAccount），必须将 <code>Role</code> 绑定到一个主体，通过创建 <code>RoleBinding</code>，来实现将 <code>Role</code> 绑定到主体</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: RoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  namespace: ops</span><br><span class="line">  name: services-read</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: Role</span><br><span class="line">  name: services-read</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: default</span><br><span class="line">  namespace: ops</span><br></pre></td></tr></table></figure>
<p>通过以上配置，namespace 中默认的 ServiceAccount <code>default</code> 的 token 拥有了 <code>services-read</code> 这个 <code>Role</code> 的权限，而默认情况下 <code>default</code> 这个 ServiceAccount 的 token 被挂载到了 Pod 的容器中，可用于容器中的进程和 Kubernetes API Server 通信的身份认证。</p>
<p>通过以下命令访问 Kubernetes API Server，已经可以获取到 <code>ops</code> namespace 中的 <code>Service</code> 资源。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt -H <span class="string">&quot;Authorization: Bearer `cat /var/run/secrets/kubernetes.io/serviceaccount/token`&quot;</span> https://kubernetes.default.svc.cluster.local/api/v1/namespaces/ops/services</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;kind&quot;: &quot;ServiceList&quot;,</span><br><span class="line">  &quot;apiVersion&quot;: &quot;v1&quot;,</span><br><span class="line">  &quot;metadata&quot;: &#123;</span><br><span class="line">    &quot;resourceVersion&quot;: &quot;86457226&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;items&quot;: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改 <code>Role</code> 为以下配置，使默认的 ServiceAccount <code>default</code> 可以查看 namespace 中的所有资源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: Role</span><br><span class="line">metadata:</span><br><span class="line">  namespace: ops</span><br><span class="line">  name: services-read</span><br><span class="line">rules:</span><br><span class="line">- apiGroups: [&quot;&quot;]</span><br><span class="line">  resources: [&quot;*&quot;]</span><br><span class="line">  verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;]</span><br></pre></td></tr></table></figure>
<p>获取 Pods 资源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \</span></span><br><span class="line"><span class="language-bash">       -H <span class="string">&quot;Authorization: Bearer `cat /var/run/secrets/kubernetes.io/serviceaccount/token`&quot;</span> \</span></span><br><span class="line"><span class="language-bash">       https://kubernetes.default.svc.cluster.local/api/v1/namespaces/ops/pods</span>    </span><br><span class="line">&#123;</span><br><span class="line">  &quot;kind&quot;: &quot;PodList&quot;,</span><br><span class="line">  &quot;apiVersion&quot;: &quot;v1&quot;,</span><br><span class="line">  &quot;metadata&quot;: &#123;</span><br><span class="line">    &quot;resourceVersion&quot;: &quot;86457516&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;items&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;metadata&quot;: &#123;</span><br><span class="line">        &quot;name&quot;: &quot;ops-centos7-bfc4d75b5-bc8xm&quot;,</span><br><span class="line">        &quot;generateName&quot;: &quot;ops-centos7-bfc4d75b5-&quot;,</span><br><span class="line">        &quot;namespace&quot;: &quot;ops&quot;,</span><br><span class="line">        &quot;uid&quot;: &quot;b35919d7-a227-4fe5-abd7-c7f426d97ab8&quot;,</span><br><span class="line">        &quot;resourceVersion&quot;: &quot;86425875&quot;,</span><br><span class="line">        &quot;creationTimestamp&quot;: &quot;2023-05-18T03:20:24Z&quot;,</span><br><span class="line">        &quot;labels&quot;: &#123;</span><br><span class="line">          &quot;app&quot;: &quot;ops-centos7&quot;,</span><br><span class="line">          &quot;pod-template-hash&quot;: &quot;bfc4d75b5&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ownerReferences&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;apiVersion&quot;: &quot;apps/v1&quot;,</span><br><span class="line">            &quot;kind&quot;: &quot;ReplicaSet&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;ops-centos7-bfc4d75b5&quot;,</span><br><span class="line">            &quot;uid&quot;: &quot;1d7a428d-8004-493b-b04c-2c4f996acf0c&quot;,</span><br><span class="line">            &quot;controller&quot;: true,</span><br><span class="line">            &quot;blockOwnerDeletion&quot;: true</span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;managedFields&quot;: [</span><br><span class="line">          ...</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;spec&quot;: &#123;</span><br><span class="line">        &quot;volumes&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;name&quot;: &quot;kube-api-access-vsh5j&quot;,</span><br><span class="line">            &quot;projected&quot;: &#123;</span><br><span class="line">              &quot;sources&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                  &quot;serviceAccountToken&quot;: &#123;</span><br><span class="line">                    &quot;expirationSeconds&quot;: 3607,</span><br><span class="line">                    &quot;path&quot;: &quot;token&quot;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                  &quot;configMap&quot;: &#123;</span><br><span class="line">                    &quot;name&quot;: &quot;kube-root-ca.crt&quot;,</span><br><span class="line">                    &quot;items&quot;: [</span><br><span class="line">                      &#123;</span><br><span class="line">                        &quot;key&quot;: &quot;ca.crt&quot;,</span><br><span class="line">                        &quot;path&quot;: &quot;ca.crt&quot;</span><br><span class="line">                      &#125;</span><br><span class="line">                    ]</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                  &quot;downwardAPI&quot;: &#123;</span><br><span class="line">                    &quot;items&quot;: [</span><br><span class="line">                      &#123;</span><br><span class="line">                        &quot;path&quot;: &quot;namespace&quot;,</span><br><span class="line">                        &quot;fieldRef&quot;: &#123;</span><br><span class="line">                          &quot;apiVersion&quot;: &quot;v1&quot;,</span><br><span class="line">                          &quot;fieldPath&quot;: &quot;metadata.namespace&quot;</span><br><span class="line">                        &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                    ]</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              ],</span><br><span class="line">              &quot;defaultMode&quot;: 420</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;containers&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;name&quot;: &quot;ops-centos7&quot;,</span><br><span class="line">            &quot;image&quot;: &quot;centos:centos7.9.2009&quot;,</span><br><span class="line">            &quot;command&quot;: [</span><br><span class="line">              &quot;ping&quot;,</span><br><span class="line">              &quot;127.0.0.1&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;resources&quot;: &#123;&#125;,</span><br><span class="line">            &quot;volumeMounts&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;name&quot;: &quot;kube-api-access-vsh5j&quot;,</span><br><span class="line">                &quot;readOnly&quot;: true,</span><br><span class="line">                &quot;mountPath&quot;: &quot;/var/run/secrets/kubernetes.io/serviceaccount&quot;</span><br><span class="line">              &#125;</span><br><span class="line">            ],</span><br><span class="line">            &quot;terminationMessagePath&quot;: &quot;/dev/termination-log&quot;,</span><br><span class="line">            &quot;terminationMessagePolicy&quot;: &quot;File&quot;,</span><br><span class="line">            &quot;imagePullPolicy&quot;: &quot;IfNotPresent&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;restartPolicy&quot;: &quot;Always&quot;,</span><br><span class="line">        &quot;terminationGracePeriodSeconds&quot;: 30,</span><br><span class="line">        &quot;dnsPolicy&quot;: &quot;ClusterFirst&quot;,</span><br><span class="line">        &quot;serviceAccountName&quot;: &quot;default&quot;,</span><br><span class="line">        &quot;serviceAccount&quot;: &quot;default&quot;,</span><br><span class="line">        &quot;nodeName&quot;: &quot;fm-k8s-c1-worker2&quot;,</span><br><span class="line">        &quot;securityContext&quot;: &#123;&#125;,</span><br><span class="line">        &quot;schedulerName&quot;: &quot;default-scheduler&quot;,</span><br><span class="line">        &quot;tolerations&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;key&quot;: &quot;node.kubernetes.io/not-ready&quot;,</span><br><span class="line">            &quot;operator&quot;: &quot;Exists&quot;,</span><br><span class="line">            &quot;effect&quot;: &quot;NoExecute&quot;,</span><br><span class="line">            &quot;tolerationSeconds&quot;: 300</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;key&quot;: &quot;node.kubernetes.io/unreachable&quot;,</span><br><span class="line">            &quot;operator&quot;: &quot;Exists&quot;,</span><br><span class="line">            &quot;effect&quot;: &quot;NoExecute&quot;,</span><br><span class="line">            &quot;tolerationSeconds&quot;: 300</span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;priority&quot;: 0,</span><br><span class="line">        &quot;enableServiceLinks&quot;: true,</span><br><span class="line">        &quot;preemptionPolicy&quot;: &quot;PreemptLowerPriority&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;status&quot;: &#123;</span><br><span class="line">        &quot;phase&quot;: &quot;Running&quot;,</span><br><span class="line">        &quot;conditions&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;type&quot;: &quot;Initialized&quot;,</span><br><span class="line">            &quot;status&quot;: &quot;True&quot;,</span><br><span class="line">            &quot;lastProbeTime&quot;: null,</span><br><span class="line">            &quot;lastTransitionTime&quot;: &quot;2023-05-18T03:20:24Z&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;type&quot;: &quot;Ready&quot;,</span><br><span class="line">            &quot;status&quot;: &quot;True&quot;,</span><br><span class="line">            &quot;lastProbeTime&quot;: null,</span><br><span class="line">            &quot;lastTransitionTime&quot;: &quot;2023-05-18T03:20:25Z&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;type&quot;: &quot;ContainersReady&quot;,</span><br><span class="line">            &quot;status&quot;: &quot;True&quot;,</span><br><span class="line">            &quot;lastProbeTime&quot;: null,</span><br><span class="line">            &quot;lastTransitionTime&quot;: &quot;2023-05-18T03:20:25Z&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;type&quot;: &quot;PodScheduled&quot;,</span><br><span class="line">            &quot;status&quot;: &quot;True&quot;,</span><br><span class="line">            &quot;lastProbeTime&quot;: null,</span><br><span class="line">            &quot;lastTransitionTime&quot;: &quot;2023-05-18T03:20:24Z&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;hostIP&quot;: &quot;172.31.22.159&quot;,</span><br><span class="line">        &quot;podIP&quot;: &quot;10.244.3.159&quot;,</span><br><span class="line">        &quot;podIPs&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;ip&quot;: &quot;10.244.3.159&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;startTime&quot;: &quot;2023-05-18T03:20:24Z&quot;,</span><br><span class="line">        &quot;containerStatuses&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;name&quot;: &quot;ops-centos7&quot;,</span><br><span class="line">            &quot;state&quot;: &#123;</span><br><span class="line">              &quot;running&quot;: &#123;</span><br><span class="line">                &quot;startedAt&quot;: &quot;2023-05-18T03:20:25Z&quot;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;lastState&quot;: &#123;&#125;,</span><br><span class="line">            &quot;ready&quot;: true,</span><br><span class="line">            &quot;restartCount&quot;: 0,</span><br><span class="line">            &quot;image&quot;: &quot;centos:centos7.9.2009&quot;,</span><br><span class="line">            &quot;imageID&quot;: &quot;docker-pullable://centos@sha256:be65f488b7764ad3638f236b7b515b3678369a5124c47b8d32916d6487418ea4&quot;,</span><br><span class="line">            &quot;containerID&quot;: &quot;docker://4e689d3e4f48ad0a7b6829a155421d8425fb023a46aec1b71e6277dbfd557fb6&quot;,</span><br><span class="line">            &quot;started&quot;: true</span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;qosClass&quot;: &quot;BestEffort&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/rbac/#restrictions-on-role-creation-or-update">使用 RBAC 鉴权</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://v1-24.docs.kubernetes.io/zh-cn/docs/reference/kubernetes-api/authorization-resources/role-v1/">API Role</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>lftp 使用</title>
    <url>/202306080936/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos 7</li>
</ul>
<h1 id="lftp-安装"><a href="#lftp-安装" class="headerlink" title="lftp 安装"></a>lftp 安装</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y lftp</span><br></pre></td></tr></table></figure>

<h1 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h1><p>查看帮助信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">lftp -h</span></span><br><span class="line">Usage: lftp [OPTS] &lt;site&gt;</span><br><span class="line">`lftp&#x27; is the first command executed by lftp after rc files</span><br><span class="line"> -f &lt;file&gt;           execute commands from the file and exit</span><br><span class="line"> -c &lt;cmd&gt;            execute the commands and exit</span><br><span class="line"> --help              print this help and exit</span><br><span class="line"> --version           print lftp version and exit</span><br><span class="line">Other options are the same as in `open&#x27; command</span><br><span class="line"> -e &lt;cmd&gt;            execute the command just after selecting</span><br><span class="line"> -u &lt;user&gt;[,&lt;pass&gt;]  use the user/password for authentication</span><br><span class="line"> -p &lt;port&gt;           use the port for connection</span><br><span class="line"> &lt;site&gt;              host name, URL or bookmark name</span><br></pre></td></tr></table></figure>

<h2 id="登陆-FTP"><a href="#登陆-FTP" class="headerlink" title="登陆 FTP"></a>登陆 FTP</h2><p>命令格式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lftp $&#123;USER&#125;:$&#123;PASSWORD&#125;@$&#123;FTPIP&#125;:$&#123;FTPPORT&#125;</span><br></pre></td></tr></table></figure>

<h2 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h2><p>在一条 shell 命令中执行登陆、上传、退出操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lftp -u $&#123;USER&#125;,$&#123;PASSWORD&#125; -p $&#123;FTPPORT&#125; $&#123;FTPIP&#125; -e &quot;put /1.mp4 &amp;&amp; exit&quot;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 常用命令总结</title>
    <url>/202305311658/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos 7</li>
</ul>
<h1 id="分割文件"><a href="#分割文件" class="headerlink" title="分割文件"></a>分割文件</h1><p>文件太大，需要分割时，可以使用以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">split -b 100M -d test.file</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>-b, --bytes=SIZE</code></td>
<td>按照指定大小分割文件</td>
<td></td>
</tr>
<tr>
<td><code>-d, --numeric-suffixes</code></td>
<td>指定分割后的文件后缀为数字</td>
<td></td>
</tr>
<tr>
<td><code>-a, --suffix-length=N</code></td>
<td>分割后的文件后缀的长度</td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">split</span> -b 100M -d test.file</span></span><br><span class="line">x00  x03  x06  x09  x12  x15  x18  x21  x24  x27  x30  x33               </span><br><span class="line">x01  x04  x07  x10  x13  x16  x19  x22  x25  x28  x31  test.file</span><br><span class="line">x02  x05  x08  x11  x14  x17  x20  x23  x26  x29  x32  </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 常用文件说明</title>
    <url>/202208180923/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Centos 7</li>
</ul>
<h3 id="常用文件说明"><a href="#常用文件说明" class="headerlink" title="常用文件说明"></a>常用文件说明</h3><table>
<thead>
<tr>
<th>文件路径</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;etc&#x2F;motd</td>
<td>登录成功后的欢迎信息，ssh 登录和 console 登录成功后都会显示</td>
<td></td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;issue</td>
<td>在登录系统输入用户名之前显示的信息，远程 ssh 连接的时候并不会显示此信息</td>
<td><a href="#x2F-etc-x2F-issue">说明示例</a></td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;services</td>
<td>记录网络服务名和它们对应使用的端口号及协议</td>
<td></td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;protocols</td>
<td>该文件是网络协议定义文件，里面记录了 <code>TCP/IP</code> 协议族的所有协议类型。文件中的每一行对应一个协议类型，它有3个字段，分别表示 <code>协议名称</code>、<code>协议号</code> 和 <code>协议别名</code></td>
<td></td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;vimrc<br/>~&#x2F;.vimrc</td>
<td><code>vim</code> 启动时会读取 <code>/etc/vimrc</code>（全局配置） 和 <code>~/.vimrc</code> （用户配置）</td>
<td><a href="/202208181117/" title="vim">vim</a></td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;passwd<br/>&#x2F;etc&#x2F;shadow<br/>&#x2F;etc&#x2F;group</td>
<td>用户数据库，其中记录了 <code>用户名</code>，<code>id</code>，<code>用户家目录</code>，<code>shell</code> 等<br/>用户密码文件<br/>组信息</td>
<td></td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;fstab</td>
<td>系统启动时需要自动挂载的文件系统列表</td>
<td></td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;mtab</td>
<td>当前系统已挂载的文件系统，并由 <code>mount</code> 命令自动更新。当需要当前挂载的文件系统的列表时使用(例如df命令)</td>
<td></td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;shells</td>
<td>系统可使用的 <code>shell</code></td>
<td></td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;filesystems</td>
<td>系统可使用的 <code>文件系统</code></td>
<td></td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;hostname</td>
<td>存放这主机名</td>
<td></td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;hosts</td>
<td>主机名查询静态表，域名和 ip 本地静态表</td>
<td></td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;nsswitch.conf</td>
<td>它规定通过哪些途径以及按照什么顺序以及通过这些途径来查找特定类型的信息，还可以指定某个方法奏效或失效时系统将采取什么动作</td>
<td><code>hosts:      files dns myhostname</code><br/>此配置设定：在查找域名解析的时候，先查找本地 <code>/etc/hosts</code>，再发送给 DNS 服务器查询</td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;rsyslog.conf</td>
<td><code>rsyslog</code> 服务的配置文件，用来托管其他服务的日志</td>
<td><a href="/202208191014/" title="linux rsyslog 服务">linux rsyslog 服务</a></td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;logrotate.conf</td>
<td>linux 日志切割工具</td>
<td><a href="/202208191317/" title="linux logrotate 服务">linux logrotate 服务</a></td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;rsyncd.conf</td>
<td><code>rsync</code> 服务的配置文件</td>
<td><a href="/36f703dc/" title="rsyncd 服务">rsyncd 服务</a></td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;sysctl.conf<br/>&#x2F;etc&#x2F;sysctl.d&#x2F;</td>
<td>内核的运行参数配置文件，<code>sysctl</code> 命令对内核参数的修改仅在当前生效，重启系统后参数丢失，如果希望参数永久生效可以修改此配置文件</td>
<td><a href="/202302131009/" title="Linux 常用内核参数说明">Linux 常用内核参数说明</a></td>
</tr>
</tbody></table>
<span id="more"></span>
<h3 id="说明示例"><a href="#说明示例" class="headerlink" title="说明示例"></a>说明示例</h3><h4 id="x2F-etc-x2F-issue"><a href="#x2F-etc-x2F-issue" class="headerlink" title="&#x2F;etc&#x2F;issue"></a>&#x2F;etc&#x2F;issue</h4><p><img src="https://i.csms.tech/img_40.png"></p>
<p>文件内容可使用的各个变量说明如下</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>\d</td>
<td>显示当前日期</td>
</tr>
<tr>
<td>\l</td>
<td>显示虚拟控制台号</td>
</tr>
<tr>
<td>\m</td>
<td>显示机器类型，即 CPU 架构，如 i386 或 x86_64 等（相当于 uname -m）</td>
</tr>
<tr>
<td>\n</td>
<td>显示主机的网络名（相当于 uname -n）</td>
</tr>
<tr>
<td>\o</td>
<td>显示域名</td>
</tr>
<tr>
<td>\r</td>
<td>显示 Kernel 内核版本号（相当于 uname -r）</td>
</tr>
<tr>
<td>\t</td>
<td>显示当前时间</td>
</tr>
<tr>
<td>\s</td>
<td>显示当前操作系统名称</td>
</tr>
<tr>
<td>\u</td>
<td>显示当前登录用户的编号</td>
</tr>
<tr>
<td>\U</td>
<td>显示当前登录用户的编号和用户</td>
</tr>
<tr>
<td>\v</td>
<td>显示当前操作系统的版本日期</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 压缩解压缩</title>
    <url>/202209301257/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h2><h3 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">file test.gz</span> </span><br><span class="line">test.gz: gzip compressed data, from FAT filesystem (MS-DOS, OS/2, NT)</span><br><span class="line"></span><br><span class="line">gzip -d test.gz </span><br></pre></td></tr></table></figure>

<h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gzip test.txt</span><br></pre></td></tr></table></figure>

<p>压缩后默认生成压缩文件 <code>test.txt.gz</code></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>cp 命令用法</title>
    <url>/202210281406/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>常用选项</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>-R, -r, --recursive</code></td>
<td>递归拷贝</td>
<td></td>
</tr>
<tr>
<td><code>-p, --preserve</code></td>
<td>拷贝时保留文件信息（default: mode,ownership,timestamps）</td>
<td></td>
</tr>
</tbody></table>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="拷贝时包含隐藏文件一起"><a href="#拷贝时包含隐藏文件一起" class="headerlink" title="拷贝时包含隐藏文件一起"></a>拷贝时包含隐藏文件一起</h3><p><code>cp -rf dir1/* dir2/</code> </p>
<p>使用此格式拷贝时，假如 <code>dir1</code> 下面包含隐藏文件，拷贝时隐藏文件不会被拷贝过去</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree -a</span></span><br><span class="line">.</span><br><span class="line">├── dir1</span><br><span class="line">│    ├── test1</span><br><span class="line">│    └── .test2</span><br><span class="line">└── dir2</span><br><span class="line"></span><br><span class="line">2 directories, 2 files</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如上所示的目录结构，执行命令 <code>cp -rf dir1/* dir2/</code>，观察目录结构:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree -a</span></span><br><span class="line">.</span><br><span class="line">├── dir1</span><br><span class="line">│    ├── test1</span><br><span class="line">│    └── .test2</span><br><span class="line">└── dir2</span><br><span class="line">    └── test1</span><br><span class="line"></span><br><span class="line">2 directories, 3 files</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>看见，<code>dir/.test</code> 未被拷贝，如果拷贝时希望同时保护隐藏文件，可以使用 <code>.</code> 代替 <code>*</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree -a</span></span><br><span class="line">.</span><br><span class="line">├── dir1</span><br><span class="line">│    ├── test1</span><br><span class="line">│    └── .test2</span><br><span class="line">└── dir2</span><br><span class="line"></span><br><span class="line">2 directories, 2 files</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> -rf dir1/. dir2/</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree -a</span></span><br><span class="line">.</span><br><span class="line">├── dir1</span><br><span class="line">│    ├── test1</span><br><span class="line">│    └── .test2</span><br><span class="line">└── dir2</span><br><span class="line">    ├── test1</span><br><span class="line">    └── .test2</span><br><span class="line"></span><br><span class="line">2 directories, 4 files</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 系统崩溃问题分析</title>
    <url>/202304191031/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos7 5.4.221-1.el7</li>
<li>Docker Engine - Community 20.10.9</li>
</ul>
<p>本文档中的日志分析主要依赖于 <code>journald</code> 服务记录的日志，因此首先需要对 <a href="/202211211437/" title="&#96;journald&#96; 服务记录的日志进行持久化配置">&#96;journald&#96; 服务记录的日志进行持久化配置</a></p>
<h1 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h1><h2 id="k8s-worker-节点经常死机-奔溃"><a href="#k8s-worker-节点经常死机-奔溃" class="headerlink" title="k8s worker 节点经常死机(奔溃)"></a>k8s worker 节点经常死机(奔溃)</h2><h3 id="环境信息-1"><a href="#环境信息-1" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Centos7 5.4.221-1.el7</li>
<li>Docker Engine - Community 20.10.9 </li>
<li>Kubernetes v1.24.7</li>
</ul>
<p>k8s 节点经常出现无响应(死机)，重启才能恢复正常。重启恢复后，检查系统 <code>messages</code> 日志。</p>
<figure class="highlight shell"><figcaption><span>/var/log/messages</span></figcaption><table><tr><td class="code"><pre><span class="line">Feb 10 12:21:40 k8s-work1 kernel: INFO: task dockerd:1443 blocked for more than 368 seconds.</span><br><span class="line">Feb 10 12:21:40 k8s-work1 kernel:      Tainted: G            E     5.4.221-1.el7.elrepo.x86_64 #1</span><br><span class="line">Feb 10 12:21:40 k8s-work1 kernel: &quot;echo 0 &gt; /proc/sys/kernel/hung_task_timeout_secs&quot; disables this message.</span><br><span class="line">Feb 10 12:21:40 k8s-work1 kernel: dockerd         D    0  1443      1 0x00004080</span><br><span class="line">Feb 10 12:21:40 k8s-work1 kernel: Call Trace:</span><br><span class="line">Feb 10 12:21:40 k8s-work1 kernel: __schedule+0x2d2/0x730</span><br><span class="line">Feb 10 12:21:40 k8s-work1 kernel: schedule+0x42/0xb0</span><br><span class="line">Feb 10 12:21:40 k8s-work1 kernel: wb_wait_for_completion+0x56/0x90</span><br><span class="line">Feb 10 12:21:40 k8s-work1 kernel: ? finish_wait+0x80/0x80</span><br><span class="line">Feb 10 12:21:40 k8s-work1 kernel: sync_inodes_sb+0xd4/0x2c0</span><br><span class="line">Feb 10 12:21:40 k8s-work1 kernel: ? __filemap_fdatawrite_range+0xf1/0x110</span><br><span class="line">Feb 10 12:21:40 k8s-work1 kernel: sync_filesystem+0x5f/0xa0</span><br><span class="line">Feb 10 12:21:40 k8s-work1 kernel: ovl_sync_fs+0x39/0x60 [overlay]</span><br><span class="line">Feb 10 12:21:40 k8s-work1 kernel: sync_filesystem+0x79/0xa0</span><br><span class="line">Feb 10 12:21:40 k8s-work1 kernel: generic_shutdown_super+0x27/0x110</span><br><span class="line">Feb 10 12:21:40 k8s-work1 kernel: kill_anon_super+0x18/0x30</span><br><span class="line">Feb 10 12:21:40 k8s-work1 kernel: deactivate_locked_super+0x3b/0x80</span><br><span class="line">Feb 10 12:21:40 k8s-work1 kernel: deactivate_super+0x3e/0x50</span><br><span class="line">Feb 10 12:21:40 k8s-work1 kernel: cleanup_mnt+0x109/0x160</span><br><span class="line">Feb 10 12:21:40 k8s-work1 kernel: __cleanup_mnt+0x12/0x20</span><br><span class="line">Feb 10 12:21:40 k8s-work1 kernel: task_work_run+0x8f/0xb0</span><br><span class="line">Feb 10 12:21:40 k8s-work1 kernel: exit_to_usermode_loop+0x10c/0x130</span><br><span class="line">Feb 10 12:21:40 k8s-work1 kernel: do_syscall_64+0x170/0x1b0</span><br><span class="line">Feb 10 12:21:40 k8s-work1 kernel: entry_SYSCALL_64_after_hwframe+0x5c/0xc1</span><br><span class="line">Feb 10 12:21:40 k8s-work1 kernel: RIP: 0033:0x55cf9a53e13b</span><br><span class="line">Feb 10 12:21:40 k8s-work1 kernel: Code: Bad RIP value.</span><br><span class="line">Feb 10 12:21:40 k8s-work1 kernel: RSP: 002b:000000c252fea778 EFLAGS: 00000212 ORIG_RAX: 00000000000000a6</span><br><span class="line">Feb 10 12:21:40 k8s-work1 kernel: RAX: 0000000000000000 RBX: 000000c000070800 RCX: 000055cf9a53e13b</span><br><span class="line">Feb 10 12:21:40 k8s-work1 kernel: RDX: 0000000000000000 RSI: 0000000000000002 RDI: 000000c2d000c3f0</span><br><span class="line">Feb 10 12:21:40 k8s-work1 kernel: RBP: 000000c252fea7d0 R08: 0000000000000000 R09: 0000000000000000</span><br><span class="line">Feb 10 12:21:40 k8s-work1 kernel: R10: 0000000000000000 R11: 0000000000000212 R12: 0000000000000000</span><br><span class="line">Feb 10 12:21:40 k8s-work1 kernel: R13: 0000000000000001 R14: 000000000000000a R15: ffffffffffffffff</span><br></pre></td></tr></table></figure>
<p>从日志中可看出，<code>dockerd</code> 进程处于 <a href="/202304181637/" title="&#96;D&#96; 状态">&#96;D&#96; 状态</a>，说明 <code>dockerd</code> 在等待 IO 操作，根据进程调用的栈信息，显示存在对 <code>overlay</code> 文件系统的同步操作，初步猜测，可能是因为 <code>overlay</code> 文件系统中的某些操作未能及时完成，导致了 <code>dockerd</code> 进程的阻塞。</p>
<p>继续检查日志，看到系统连接 NFS 服务超时，怀疑可能是因为 NFS 异常导致。</p>
<figure class="highlight shell"><figcaption><span>/var/log/messages</span></figcaption><table><tr><td class="code"><pre><span class="line">Feb 10 12:21:40 k8s-work1 kernel: nfs: server 172.31.88.9 not responding, timed out</span><br><span class="line">Feb 10 12:21:40 k8s-work1 kernel: nfs: server 172.31.88.9 not responding, still trying</span><br><span class="line">Feb 10 12:21:40 k8s-work1 kernel: nfs: server 172.31.88.9 not responding, timed out</span><br><span class="line">Feb 10 12:21:40 k8s-work1 kernel: nfs: server 172.31.88.9 not responding, still trying</span><br><span class="line">Feb 10 12:21:40 k8s-work1 kernel: nfs: server 172.31.88.9 not responding, timed out</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>curl 命令常见用法</title>
    <url>/202302201557/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos 7 3.10.0-1062</li>
</ul>
<h1 id="curl-命令示例"><a href="#curl-命令示例" class="headerlink" title="curl 命令示例"></a>curl 命令示例</h1><p>常见选项 </p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>-v</code></td>
<td>输出详细信息</td>
<td></td>
</tr>
<tr>
<td><code>-0</code></td>
<td>内容输出到指定文件或设备</td>
<td><code>curl -o /dev/null</code></td>
</tr>
<tr>
<td><code>-s</code></td>
<td>不输出任何信息（http 响应内容除外）</td>
<td></td>
</tr>
<tr>
<td><code>-w</code></td>
<td>自定义输出内容</td>
<td><code>curl -s -o /dev/null -w %&#123;http_code&#125; https://csms.tech</code></td>
</tr>
<tr>
<td><code>-I</code></td>
<td>只获取响应头部信息</td>
<td><code>curl -I https://csms.tech</code></td>
</tr>
<tr>
<td><code>--resolve yourdomain.com:443:source_ip</code></td>
<td>将 <code>domain:port</code> 解析为指定的 IP</td>
<td><a href="#SSL_ERROR_BAD_CERT_DOMAIN">使用方法参考</a><br/><code>curl -v -H &quot;Host: admin.test.com&quot; --resolve admin.test.com:443:52.52.2.9 https://admin.test.com</code></td>
</tr>
<tr>
<td><code>-H, --header</code></td>
<td>自定义 http 请求头部</td>
<td><code>-H &quot;Host: admin.test.com&quot;</code></td>
</tr>
</tbody></table>
<span id="more"></span>

<h2 id="输出响应状态码"><a href="#输出响应状态码" class="headerlink" title="输出响应状态码"></a>输出响应状态码</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -s -o /dev/null -w %&#123;http_code&#125; https://csms.tech</span><br></pre></td></tr></table></figure>

<h2 id="只获取响应头部"><a href="#只获取响应头部" class="headerlink" title="只获取响应头部"></a>只获取响应头部</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -I csms.tech</span><br></pre></td></tr></table></figure>

<h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><h2 id="SSL-ERROR-BAD-CERT-DOMAIN"><a href="#SSL-ERROR-BAD-CERT-DOMAIN" class="headerlink" title="SSL_ERROR_BAD_CERT_DOMAIN"></a>SSL_ERROR_BAD_CERT_DOMAIN</h2><h3 id="环境信息-1"><a href="#环境信息-1" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Centos7 5.4.225-1</li>
<li>curl 7.29.0</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ curl --version</span><br><span class="line">curl 7.29.0 (x86_64-redhat-linux-gnu) libcurl/7.29.0 NSS/3.53.1 zlib/1.2.7 libidn/1.28 libssh2/1.8.0</span><br><span class="line">Protocols: dict file ftp ftps gopher http https imap imaps ldap ldaps pop3 pop3s rtsp scp sftp smtp smtps telnet tftp </span><br><span class="line">Features: AsynchDNS GSS-Negotiate IDN IPv6 Largefile NTLM NTLM_WB SSL libz unix-sockets</span><br></pre></td></tr></table></figure>

<p>使用以下 <code>curl</code> 命令直接访问服务器来验证域名证书</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -v -H <span class="string">&quot;Host: admin.test.com&quot;</span> https://52.52.2.9</span></span><br><span class="line">* About to connect() to 52.52.2.9 port 443 (#0)</span><br><span class="line">*   Trying 52.52.2.9...</span><br><span class="line">* Connected to 52.52.2.9 (52.52.2.9) port 443 (#0)</span><br><span class="line">* Initializing NSS with certpath: sql:/etc/pki/nssdb</span><br><span class="line">*   CAfile: /etc/pki/tls/certs/ca-bundle.crt</span><br><span class="line">  CApath: none</span><br><span class="line">* Server certificate:</span><br><span class="line">* 	subject: CN=admin.test.com</span><br><span class="line">* 	start date: Mar 14 00:00:00 2023 GMT</span><br><span class="line">* 	expire date: Mar 13 23:59:59 2024 GMT</span><br><span class="line">* 	common name: admin.test.com</span><br><span class="line">* 	issuer: CN=Sectigo RSA Domain Validation Secure Server CA,O=Sectigo Limited,L=Salford,ST=Greater Manchester,C=GB</span><br><span class="line">* NSS error -12276 (SSL_ERROR_BAD_CERT_DOMAIN)</span><br><span class="line">* Unable to communicate securely with peer: requested domain name does not match the server&#x27;s certificate.</span><br><span class="line">* Closing connection 0</span><br><span class="line">curl: (51) Unable to communicate securely with peer: requested domain name does not match the server&#x27;s certificate.</span><br></pre></td></tr></table></figure>
<p>结果显示，请求的域名和服务器中的域名证书不匹配（<code>requested domain name does not match the server&#39;s certificate.</code>），通过浏览器直接访问域名(可以将域名和其对应 IP 写入系统 hosts 文件)，显示证书正常，使用 <code>openssl s_client</code> 命令验证证书，结果也显示正常</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> | openssl s_client -servername  admin.test.com -connect 52.52.2.9:443</span></span><br><span class="line">CONNECTED(00000003)</span><br><span class="line">depth=3 C = GB, ST = Greater Manchester, L = Salford, O = Comodo CA Limited, CN = AAA Certificate Services</span><br><span class="line">verify return:1</span><br><span class="line">depth=2 C = US, ST = New Jersey, L = Jersey City, O = The USERTRUST Network, CN = USERTrust RSA Certification Authority</span><br><span class="line">verify return:1</span><br><span class="line">depth=1 C = GB, ST = Greater Manchester, L = Salford, O = Sectigo Limited, CN = Sectigo RSA Domain Validation Secure Server CA</span><br><span class="line">verify return:1</span><br><span class="line">depth=0 CN = admin.test.com</span><br><span class="line">verify return:1</span><br><span class="line">---</span><br><span class="line">Certificate chain</span><br><span class="line"> 0 s:/CN=admin.test.com</span><br><span class="line">   i:/C=GB/ST=Greater Manchester/L=Salford/O=Sectigo Limited/CN=Sectigo RSA Domain Validation Secure Server CA</span><br><span class="line"> 1 s:/C=GB/ST=Greater Manchester/L=Salford/O=Sectigo Limited/CN=Sectigo RSA Domain Validation Secure Server CA</span><br><span class="line">   i:/C=US/ST=New Jersey/L=Jersey City/O=The USERTRUST Network/CN=USERTrust RSA Certification Authority</span><br><span class="line"> 2 s:/C=US/ST=New Jersey/L=Jersey City/O=The USERTRUST Network/CN=USERTrust RSA Certification Authority</span><br><span class="line">   i:/C=GB/ST=Greater Manchester/L=Salford/O=Comodo CA Limited/CN=AAA Certificate Services</span><br><span class="line">---</span><br><span class="line">Server certificate</span><br><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line">MIIGQTCCBSmgAwIBAgIRAMrTCHWnCEPDYFZcToXLKC8wDQYJKoZIhvcNAQELBQAw</span><br><span class="line">gY8xCzAJBgNVBAYTAkdCMRswGQYDVQQIExJHcmVhdGVyIE1hbmNoZXN0ZXIxEDAO</span><br><span class="line">BgNVBAcTB1NhbGZvcmQxGDAWBgNVBAoTD1NlY3RpZ28gTGltaXRlZDE3MDUGA1UE</span><br><span class="line">AxMuU2VjdGlnbyBSU0EgRG9tYWluIFZhbGlkYXRpb24gU2VjdXJlIFNlcnZlciBD</span><br><span class="line">...</span><br><span class="line">Srqh+IFfIKzcHX1eyPxluInUGxxHhVVPeLdzBGL2owLJ/u7YxMkmaiCaCZc9Tugt</span><br><span class="line">1aX61uQWmAUM1I4IhPCj1qKNWt94</span><br><span class="line">-----END CERTIFICATE-----</span><br><span class="line">subject=/CN=admin.test.com</span><br><span class="line">issuer=/C=GB/ST=Greater Manchester/L=Salford/O=Sectigo Limited/CN=Sectigo RSA Domain Validation Secure Server CA</span><br><span class="line">---</span><br><span class="line">No client certificate CA names sent</span><br><span class="line">Peer signing digest: SHA512</span><br><span class="line">Server Temp Key: ECDH, P-256, 256 bits</span><br><span class="line">---</span><br><span class="line">SSL handshake has read 5278 bytes and written 441 bytes</span><br><span class="line">---</span><br><span class="line">New, TLSv1/SSLv3, Cipher is ECDHE-RSA-AES256-GCM-SHA384</span><br><span class="line">Server public key is 2048 bit</span><br><span class="line">Secure Renegotiation IS supported</span><br><span class="line">Compression: NONE</span><br><span class="line">Expansion: NONE</span><br><span class="line">No ALPN negotiated</span><br><span class="line">SSL-Session:</span><br><span class="line">    Protocol  : TLSv1.2</span><br><span class="line">    Cipher    : ECDHE-RSA-AES256-GCM-SHA384</span><br><span class="line">    Session-ID: 40CFB3F53E5143F85E260CE777CEB6885A184401654EE71CB386FD5D3679D822</span><br><span class="line">    Session-ID-ctx: </span><br><span class="line">    Master-Key: 4FBB5C03A77D33AD14326C272F6D7A61528DA39763067EC27D21FFF13B16CDC71CEBCCF3E8443E5961AC7887F272D3CC</span><br><span class="line">    Key-Arg   : None</span><br><span class="line">    Krb5 Principal: None</span><br><span class="line">    PSK identity: None</span><br><span class="line">    PSK identity hint: None</span><br><span class="line">    TLS session ticket lifetime hint: 300 (seconds)</span><br><span class="line">    TLS session ticket:</span><br><span class="line">    0000 - c1 a5 66 e3 d5 68 a7 c5-02 29 03 60 12 7d 74 bf   ..f..h...).`.&#125;t.</span><br><span class="line">    0010 - fe 85 25 0f 76 8a 63 59-9c c7 f2 d4 15 5c 95 fb   ..%.v.cY.....\..</span><br><span class="line">    0020 - 37 5b 48 d2 74 45 e5 c5-8b af 09 8a 19 14 69 ea   7[H.tE........i.</span><br><span class="line">    0030 - cd 23 52 9b a9 e2 2c cb-0d ab 31 9e a9 b4 5f fd   .#R...,...1..._.</span><br><span class="line">    0040 - f9 ce bd b3 f8 68 0e 76-56 f8 76 a0 6b b2 85 93   .....h.vV.v.k...</span><br><span class="line">    0050 - 49 1e a6 61 16 17 73 b5-2c c9 69 53 a1 b3 b2 bf   I..a..s.,.iS....</span><br><span class="line">    0060 - 2c 74 7d 4d a5 c2 8d 00-1f 59 ce a5 c3 13 22 0a   ,t&#125;M.....Y....&quot;.</span><br><span class="line">    0070 - eb 85 33 33 a3 26 32 eb-38 1a 0c 16 c6 74 cb 16   ..33.&amp;2.8....t..</span><br><span class="line">    0080 - 34 2d 57 5c b7 3b 3b 68-22 23 4f 6f 52 d3 4f 3f   4-W\.;;h&quot;#OoR.O?</span><br><span class="line">    0090 - e9 6b 87 3b 2a da 2f 8f-4d 21 32 e2 c9 d4 3c 01   .k.;*./.M!2...&lt;.</span><br><span class="line">    00a0 - f7 96 36 1f 73 39 8c 80-b9 86 aa 01 b6 7b 57 40   ..6.s9.......&#123;W@</span><br><span class="line">    00b0 - 49 c1 ec 17 96 18 3c 65-2e 10 18 b5 3a 14 5d c9   I.....&lt;e....:.].</span><br><span class="line"></span><br><span class="line">    Start Time: 1683609320</span><br><span class="line">    Timeout   : 300 (sec)</span><br><span class="line">    Verify return code: 0 (ok)</span><br><span class="line">---</span><br><span class="line">DONE</span><br></pre></td></tr></table></figure>

<p>由以上判断可得出结论，域名配置的证书没问题，应该是 <code>curl</code> 的问题。正确命令如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -v -H <span class="string">&quot;Host: admin.test.com&quot;</span> --resolve admin.test.com:443:52.52.2.9 https://admin.test.com</span></span><br><span class="line">* Added admin.test.com:443:52.52.2.9 to DNS cache</span><br><span class="line">* About to connect() to admin.test.com port 443 (#0)</span><br><span class="line">*   Trying 52.52.2.9...</span><br><span class="line">* Connected to admin.test.com (52.52.2.9) port 443 (#0)</span><br><span class="line">* Initializing NSS with certpath: sql:/etc/pki/nssdb</span><br><span class="line">*   CAfile: /etc/pki/tls/certs/ca-bundle.crt</span><br><span class="line">  CApath: none</span><br><span class="line">* SSL connection using TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384</span><br><span class="line">* Server certificate:</span><br><span class="line">* 	subject: CN=admin.test.com</span><br><span class="line">* 	start date: Mar 14 00:00:00 2023 GMT</span><br><span class="line">* 	expire date: Mar 13 23:59:59 2024 GMT</span><br><span class="line">* 	common name: admin.test.com</span><br><span class="line">* 	issuer: CN=Sectigo RSA Domain Validation Secure Server CA,O=Sectigo Limited,L=Salford,ST=Greater Manchester,C=GB</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">GET / HTTP/1.1</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">User-Agent: curl/7.29.0</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Accept: */*</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Host: admin.test.com</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">&lt; HTTP/1.1 404 Not Found</span></span><br><span class="line">&lt; Server: nginx</span><br><span class="line">&lt; Content-Type: text/html; charset=UTF-8</span><br><span class="line">&lt; Transfer-Encoding: chunked</span><br><span class="line">&lt; Connection: keep-alive</span><br><span class="line">&lt; Vary: Accept-Encoding</span><br><span class="line">&lt; X-Powered-By: PHP/7.4.13</span><br><span class="line">&lt; Cache-Control: no-cache, private</span><br><span class="line">&lt; date: Tue, 09 May 2023 06:01:16 GMT</span><br><span class="line">&lt; </span><br><span class="line">* Connection #0 to host admin.test.com left intact</span><br></pre></td></tr></table></figure>

<h2 id="Bad-Request-chat-id-is-empty"><a href="#Bad-Request-chat-id-is-empty" class="headerlink" title="Bad Request: chat_id is empty"></a>Bad Request: chat_id is empty</h2><p>在执行以下命令向 telegram 发送消息时，返回了错误消息 : <code>&#123;&quot;ok&quot;:false,&quot;error_code&quot;:400,&quot;description&quot;:&quot;Bad Request: chat_id is empty&quot;&#125;</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -v https://api.telegram.org/bot568321111:AAHza111111111111Xcs2I/sendMessage?text=hello&amp;chat_id=-10018411111777</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">GET /bot568321111:AAHza111111111111Xcs2I/sendMessage?text=hello HTTP/1.1</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">User-Agent: curl/7.29.0</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Host: api.telegram.org</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Accept: */*</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">&lt; HTTP/1.1 400 Bad Request</span></span><br><span class="line">&lt; Server: nginx/1.18.0</span><br><span class="line">&lt; Date: Fri, 02 Jun 2023 02:17:27 GMT</span><br><span class="line">&lt; Content-Type: application/json</span><br><span class="line">&lt; Content-Length: 75</span><br><span class="line">&lt; Connection: keep-alive</span><br><span class="line">&lt; Strict-Transport-Security: max-age=31536000; includeSubDomains; preload</span><br><span class="line">&lt; Access-Control-Allow-Origin: *</span><br><span class="line">&lt; Access-Control-Expose-Headers: Content-Length,Content-Type,Date,Server,Connection</span><br><span class="line">&lt; </span><br><span class="line">* Connection #0 to host api.telegram.org left intact</span><br><span class="line">&#123;&quot;ok&quot;:false,&quot;error_code&quot;:400,&quot;description&quot;:&quot;Bad Request: chat_id is empty&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>根据 <code>curl</code> 打印的详细的请求和响应头部信息，可以看到发送的 url 存在问题，ulr 中的 <code>chat_id=-10018411111777</code> 实际并未被发送，url 变成了 <code>/bot5683237521:AAHzaGf0oRg8A3RiYeM_QOxwW8yUyEXcs2I/sendMessage?text=hello</code>。这可能是因为 <code>curl</code> 未正确处理 URL 导致，可以将 url 放置在 <code>&quot;&quot;</code> 中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -v <span class="string">&quot;https://api.telegram.org/bot568321111:AAHza111111111111Xcs2I/sendMessage?text=hello&amp;chat_id=-10018411111777&quot;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">GET /bot568321111:AAHza111111111111Xcs2I/sendMessage?text=hello&amp;chat_id=-10018411111777 HTTP/1.1</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">User-Agent: curl/7.29.0</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Host: api.telegram.org</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Accept: */*</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">&lt; HTTP/1.1 200 OK</span></span><br><span class="line">&lt; Server: nginx/1.18.0</span><br><span class="line">&lt; Date: Fri, 02 Jun 2023 02:29:54 GMT</span><br><span class="line">&lt; Content-Type: application/json</span><br><span class="line">&lt; Content-Length: 273</span><br><span class="line">&lt; Connection: keep-alive</span><br><span class="line">&lt; Strict-Transport-Security: max-age=31536000; includeSubDomains; preload</span><br><span class="line">&lt; Access-Control-Allow-Origin: *</span><br><span class="line">&lt; Access-Control-Allow-Methods: GET, POST, OPTIONS</span><br><span class="line">&lt; Access-Control-Expose-Headers: Content-Length,Content-Type,Date,Server,Connection</span><br><span class="line">&lt; </span><br><span class="line">* Connection #0 to host api.telegram.org left intact</span><br><span class="line">&#123;&quot;ok&quot;:true,&quot;result&quot;:&#123;&quot;message_id&quot;:5,&quot;sender_chat&quot;:&#123;&quot;id&quot;:-10018411111777,&quot;title&quot;:&quot;Alert Manager Test&quot;,&quot;username&quot;:&quot;ttydddrrr&quot;,&quot;type&quot;:&quot;channel&quot;&#125;,&quot;chat&quot;:&#123;&quot;id&quot;:-10018411111777,&quot;title&quot;:&quot;Alert Manager Test&quot;,&quot;username&quot;:&quot;ttydddrrr&quot;,&quot;type&quot;:&quot;channel&quot;&#125;,&quot;date&quot;:1685672994,&quot;text&quot;:&quot;hello&quot;&#125;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux find 命令</title>
    <url>/202208180949/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Centos 7</li>
</ul>
<h3 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h3><p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find   path   -option   [ -print ]   [ -exec   -ok   command ]   &#123;&#125; \;</span><br></pre></td></tr></table></figure>
<p>常用查找选项（<code>-option</code>）：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>-amin n<br/>-amin +n<br/>-amin -n</td>
<td>在过去 n 分钟内被读取过<br/>更改时间超过 n<br/>更改时间在 n 以内</td>
<td></td>
</tr>
<tr>
<td>-anewer file</td>
<td>比文件 file 更晚被读取过的文件</td>
<td></td>
</tr>
<tr>
<td>-atime n</td>
<td>在过去 n 天内被读取过的文件</td>
<td></td>
</tr>
<tr>
<td>-cmin n</td>
<td>在过去 n 分钟内被修改过</td>
<td></td>
</tr>
<tr>
<td>-cnewer file</td>
<td>比文件 file 更新的文件</td>
<td></td>
</tr>
<tr>
<td>-ctime n</td>
<td>在过去 n 天内创建的文件</td>
<td></td>
</tr>
<tr>
<td>-mtime n</td>
<td>在过去 n 天内修改过的文件</td>
<td></td>
</tr>
<tr>
<td>-empty</td>
<td>空的文件</td>
<td></td>
</tr>
<tr>
<td>-gid n<br/>-group name</td>
<td>gid 是 n<br/>group 名称是 name</td>
<td></td>
</tr>
<tr>
<td>-user u</td>
<td>根据用户名查找</td>
<td></td>
</tr>
<tr>
<td>-nouser</td>
<td>属主不存在</td>
<td></td>
</tr>
<tr>
<td>-ipath p<br/>-path p</td>
<td>路径名称符合 p 的文件，ipath 会忽略大小写</td>
<td></td>
</tr>
<tr>
<td>-name name<br/> -iname name</td>
<td>文件名称符合 name 的文件。iname 会忽略大小写</td>
<td></td>
</tr>
<tr>
<td>-size n <br/>-size +n<br/>-size -n</td>
<td>文件大小 是 n 单位，b 代表 512 位元组的区块，c 表示字元数，k 表示 kilo bytes，w 是二个位元组。<br/>文件大小大于 n<br/>文件大小小于 n</td>
<td></td>
</tr>
<tr>
<td>-type c</td>
<td>文件类型是 c 的文件，c 包括：<br/>d : 目录<br/>c : 字符设备<br/>b : 块设备<br/> p : 通道设备<br/>f : 文件<br/>l : 链接文件<br/>s : socker</td>
<td></td>
</tr>
<tr>
<td>-pid n</td>
<td>process id 是 n 的文件</td>
<td></td>
</tr>
<tr>
<td>-perm 0644</td>
<td>权限</td>
<td></td>
</tr>
<tr>
<td>-maxdepth<br/>-mindepth</td>
<td>查找深度</td>
<td></td>
</tr>
</tbody></table>
<span id="more"></span>

<p>常用运算符：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>()</code></td>
<td>将运算表达式组合起来</td>
<td></td>
</tr>
<tr>
<td><code>-and</code></td>
<td>与</td>
<td></td>
</tr>
<tr>
<td><code>-or</code></td>
<td>或</td>
<td></td>
</tr>
<tr>
<td><code>-not</code></td>
<td>取反</td>
<td></td>
</tr>
<tr>
<td><code>!</code></td>
<td>非</td>
<td><code>find . ! -type f -print</code><br/><code>find . -anewer FILE1 ! -anewer FILE2</code></td>
</tr>
</tbody></table>
<p>常用子命令：</p>
<table>
<thead>
<tr>
<th>子命令</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>-print &#123;&#125; \;</code></td>
<td>默认命令，输出查找到的目标到标准输出</td>
<td></td>
</tr>
<tr>
<td><code>-exec command &#123;&#125; \;</code></td>
<td>对查找到的目标执行命令</td>
<td></td>
</tr>
<tr>
<td><code>-ok   command &#123;&#125; \;</code></td>
<td>和 <code>-exec</code> 一样，不过执行前先询问是否执行</td>
<td></td>
</tr>
</tbody></table>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>查找读取时间比文件 <code>FILE1</code> 晚，但又比文件 <code>FILE2</code> 早的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">`find . -anewer FILE1 ! -anewer FILE2`</span><br></pre></td></tr></table></figure>

<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3>]]></content>
      <categories>
        <category>Linux</category>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>iptables 服务使用说明</title>
    <url>/202210241051/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>iptables 的底层实现是 <code>netfilter</code>，netfilter 的架构是在整个网络流程的若干位置放置一些钩子，并在每个钩子上挂载一些处理函数进行处理。</p>
<p>IP 层的 5 个钩子点的位置，对应就是 iptables 的 5 条内置链，分别是</p>
<ul>
<li><code>PREROUTING</code></li>
<li><code>FORWARD</code></li>
<li><code>INPUT</code></li>
<li><code>OUTPUT</code></li>
<li><code>POSTROUTING</code></li>
</ul>
<p><img src="https://i.csms.tech/img_133.png"><br>当网卡收到一个网络报文送达协议栈时，最先经过的 netfilter 钩子是 <code>PREROUTING</code>，此处常见的钩子函数是 <code>目的地址转换 (DNAT)</code>。无论 <code>PREROUTING</code> 是否存在钩子处理网络数据包，下一步内核都会通过查询本地路由表决定这个数据包的流向</p>
<ul>
<li>如果是发送给本地进程，则进入 <code>INPUT</code> 链传给本地进程</li>
<li>如果是发送给其他机器（或者其他 <code>network namespace</code>），则经过 netfilter 的 <code>FORWARD</code> 钩子传送出去，相当于将本地机器当作路由器</li>
</ul>
<p>所有马上要发送到网络协议栈之外的数据包，都会经过 <code>POSTROUTING</code> 钩子，这里常见的处理函数是 <code>源地址转换(SNAT)</code> 或者 <code>源地址伪装(Masquerade, 简称 Masq)</code></p>
<p>除了 5 条内置的链，iptables 还有 5 张表，这 5 张表主要是用来给 iptables 中的规则（rule）分类，系统中所有的 iptables 规则都被划分到不同的表集合中。5 张表分别为</p>
<ul>
<li><code>raw</code> - iptables 是有状态的，即 iptables 对数据包有连接追踪 (connection trackong) 机制，而 <code>raw</code> 可以用来去除这种追踪机制</li>
<li><code>mangle</code> - 用于修改数据包的 IP 头信息</li>
<li><code>nat</code> - 用于修改数据包的源或者目的地址</li>
<li><code>filter</code> - 用于控制到达某条链上面的数据包是继续放行、直接丢弃(drop)、或拒绝(reject)</li>
<li><code>security</code> - 用于在数据包上面应用 SELinux</li>
</ul>
<p>表是有优先级的，5 张表的优先级从高到低是: <code>raw</code>、<code>mangle</code>、<code>nat</code>、<code>filter</code>、<code>security</code>，iptables 不支持自定义表。不是每个链上都能挂表，iptables 表与链的对应关系如下图</p>
<table>
<thead>
<tr>
<th>-</th>
<th>PREROUTING</th>
<th>FORWARD</th>
<th>INPUT</th>
<th>OUTPUT</th>
<th>POSTROUTING</th>
</tr>
</thead>
<tbody><tr>
<td><code>raw</code></td>
<td>Y</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td><code>mangle</code></td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td><code>nat (SNAT)</code></td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td><code>nat (DNAT)</code></td>
<td>Y</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td><code>filter</code></td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td><code>security</code></td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
</tbody></table>
<p>iptables 表和链的工作流程图如下</p>
<p><img src="https://i.csms.tech/img_134.png"></p>
<h1 id="iptables-命令"><a href="#iptables-命令" class="headerlink" title="iptables 命令"></a>iptables 命令</h1><p>常用选项说明</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>-F ,--flush</code></td>
<td>清除所有规则，默认规则除外</td>
<td></td>
</tr>
<tr>
<td><code>-P ,--policy</code></td>
<td>设置默认规则</td>
<td></td>
</tr>
<tr>
<td><code>-t ,--table</code></td>
<td>指定要操作的表，默认为 <code>filter</code> 表</td>
<td><code>iptables -t nat -P INPUT ACCEPT</code></td>
</tr>
<tr>
<td><code>--list ,-L [chain [rulenum]]</code></td>
<td>列出（指定的链或所有链）的规则</td>
<td><code>iptables -t nat -L -v -n --line-numbers</code></td>
</tr>
<tr>
<td><code>--verbose	,-v</code></td>
<td>verbose mode</td>
<td></td>
</tr>
<tr>
<td><code>--numeric	,-n</code></td>
<td>不解析协议和端口号，以数字的形式显示</td>
<td></td>
</tr>
<tr>
<td><code>--line-numbers</code></td>
<td>显示规则的行号，可以根据行号对具体的规则进行操作</td>
<td></td>
</tr>
<tr>
<td><code>--jump	,-j</code></td>
<td>匹配的规则的处理 target</td>
<td><code>iptables -A INPUT  -j LOG</code></td>
</tr>
<tr>
<td><code>--append  ,-A chain</code></td>
<td>像指定的链中追加规则</td>
<td><code>-A INPUT -i lo -j ACCEPT</code></td>
</tr>
<tr>
<td><code>--insert  ,-I chain [rulenum]</code></td>
<td>向指定的链中指定的位置插入规则</td>
<td><code>iptables -I INPUT 10 -p tcp --dport 80 -j ACCEPT</code></td>
</tr>
<tr>
<td><code>--delete  ,-D chain rulenum</code></td>
<td>删除指定链中的指定位置的规则</td>
<td><code>iptables -D INPUT 10 </code></td>
</tr>
<tr>
<td><code>--replace ,-R chain rulenum</code></td>
<td>更新指定链中的指定位置的规则</td>
<td></td>
</tr>
<tr>
<td><code>-S, --list-rules [chain]</code></td>
<td>按照类似 <code>iptables-save</code> 的输出打印规则</td>
<td></td>
</tr>
</tbody></table>
<span id="more"></span>
<h2 id="删除指定规则"><a href="#删除指定规则" class="headerlink" title="删除指定规则"></a>删除指定规则</h2><p>查看规则及行号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iptables -L -v -n --line-number</span></span><br><span class="line">Chain INPUT (policy DROP 0 packets, 0 bytes)</span><br><span class="line">num   pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line">1       90  6516 ACCEPT     all  --  *      *       0.0.0.0/0            0.0.0.0/0            state RELATED,ESTABLISHED</span><br><span class="line">2        0     0 ACCEPT     all  --  lo     *       0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">3        0     0 ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            state NEW tcp multiport dports 10050,10051</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>删除指定行号的规则</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -D INPUT 7</span><br></pre></td></tr></table></figure>

<h2 id="记录-iptables-日志"><a href="#记录-iptables-日志" class="headerlink" title="记录 iptables 日志"></a>记录 iptables 日志</h2><p>可以通过以下 2 种方式之一查看 iptables 记录的日志</p>
<h3 id="rsyslog-服务记录日志"><a href="#rsyslog-服务记录日志" class="headerlink" title="rsyslog 服务记录日志"></a>rsyslog 服务记录日志</h3><ul>
<li><p>使用 <code>rsyslog</code> 服务记录日志</p>
<p>在 <code>rsyslog.conf</code> 中添加配置 <code>kern.*     /var/log/iptables.log</code></p>
<p>重启 <code>rsyslog</code> 服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart rsyslog.service</span><br></pre></td></tr></table></figure></li>
<li><p><code>journalctl -k</code> 命令查看</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">journalctl -f -k | grep iptables </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="配置-iptables-记录日志"><a href="#配置-iptables-记录日志" class="headerlink" title="配置 iptables 记录日志"></a>配置 iptables 记录日志</h3><p>iptables 配置日志选项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">记录所有通过防火墙的日志的方法</span></span><br><span class="line">iptables -A INPUT  -j LOG --log-prefix &quot;iptables&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只记录特定日志的方法</span></span><br><span class="line">iptables -A INPUT -s 192.168.10.0/24 -p tcp -j LOG --log-prefix &quot;iptables icmp warn&quot;</span><br></pre></td></tr></table></figure>
<p>iptables 中日志相关的选项：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>--log-prefix</code></td>
<td>记录的日志的内容前缀</td>
<td><code>-A INPUT  -j LOG --log-prefix &quot;iptables&quot;</code></td>
</tr>
<tr>
<td><code>--log-level</code></td>
<td>日志级别<br/>由高到低 <code>emerg</code>、<code>alert</code>、<code>crit</code>、<code>error</code>、<code>warning</code>、<code>notice</code>、<code>info</code>、<code>debug</code></td>
<td><code>-A INPUT -s 192.168.10.0/24 -j LOG --log-level 4</code></td>
</tr>
</tbody></table>
<p>使用 LOG 动作，可以将符合条件的报文的相关信息记录到日志中，但当前报文具体是被“接受”，还是被“拒绝”，都由后面的规则控制，换句话说，LOG 动作只负责记录匹配到的报文的相关信息，不负责对报文的其他处理，如果想要对报文进行进一步的处理，可以在之后设置具体规则，进行进一步的处理。</p>
<h2 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h2><p>以下示例实现，将目标端口为 80 的流量转发到目标端口 8080</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -s 192.168.10.0/24 -p tcp --dport 80 -i eth0 -j REDIRECT --to-port 8080</span><br></pre></td></tr></table></figure>

<h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><h3 id="DNAT"><a href="#DNAT" class="headerlink" title="DNAT"></a>DNAT</h3><p>DNAT 根据指定条件修改数据包的目标 ip 地址和目标端口，DNAT 的原理和端口转发的原理差不多，区别是端口转发不修改 ip 地址。需要注意的是，当转发的 ip 地址不是本机时，需要确保启用 <code>ip froward</code> 功能(<code>echo 1 &gt; /proc/sys/net/ipv4/ip_forward</code>)，即把 Linux 当做交换机使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -d 192.168.10.10 -p tcp --dport 80 -j DNAT --to-destination 192.168.10.20:8080</span><br></pre></td></tr></table></figure>

<h3 id="SNAT-和-Maskuerade"><a href="#SNAT-和-Maskuerade" class="headerlink" title="SNAT 和 Maskuerade"></a>SNAT 和 Maskuerade</h3><p>Maskuerade 本质上是 SNAT 的一种。SNAT 根据指定的条件修改数据包的源 IP 地址，SNAT 策略只能发生在 nat 表的 POSTROUTING 链</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -s 192.168.10.10 -j SNAT --to-source 192.168.10.20</span><br></pre></td></tr></table></figure>

<p>Maskuerade 是一种特殊的 SNAT，数据包从那个网卡发出，就使用该网卡的 IP 做 SNAT，具体使用哪个 IP 由内核决定</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -s 192.168.10.0/24 -j MASQUERADE</span><br></pre></td></tr></table></figure>


<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="ssh-无法连接"><a href="#ssh-无法连接" class="headerlink" title="ssh 无法连接"></a>ssh 无法连接</h2><p>iptables 配置文件内容如下，关闭防火墙后，ssh 可以从客户端 <code>192.168.1.2</code> 进行连接。重启防火墙后，则无法连接。说明问题是因为防火墙导致。</p>
<figure class="highlight shell"><figcaption><span>/etc/sysconfig/iptables</span></figcaption><table><tr><td class="code"><pre><span class="line">*filter</span><br><span class="line">:INPUT DROP [0:0]</span><br><span class="line">:FORWARD ACCEPT [0:0]</span><br><span class="line">:OUTPUT ACCEPT [4:368]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">允许本机访问外网</span></span><br><span class="line">-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">回环网卡配置</span></span><br><span class="line">-A INPUT -i lo -j ACCEPT</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sshd</span></span><br><span class="line">-A INPUT -m comment --comment &quot;ssh&quot; -p tcp -m state --state NEW -m tcp -s 192.168.1.2 --dport 22 -j ACCEPT</span><br><span class="line"></span><br><span class="line">-A INPUT -p icmp -m icmp --icmp-type 8 -j ACCEPT</span><br><span class="line">-A INPUT -p icmp -m icmp --icmp-type 0 -j ACCEPT</span><br><span class="line">-A INPUT -j REJECT --reject-with icmp-host-prohibited</span><br><span class="line">-A FORWARD -j REJECT --reject-with icmp-host-prohibited</span><br><span class="line">COMMIT</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>针对 sshd 的防火墙规则添加日志，配置文件修改如下 </p>
<figure class="highlight shell"><figcaption><span>/etc/sysconfig/iptables</span></figcaption><table><tr><td class="code"><pre><span class="line">*filter</span><br><span class="line">:INPUT DROP [0:0]</span><br><span class="line">:FORWARD ACCEPT [0:0]</span><br><span class="line">:OUTPUT ACCEPT [4:368]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">允许本机访问外网</span></span><br><span class="line">-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">回环网卡配置</span></span><br><span class="line">-A INPUT -i lo -j ACCEPT</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sshd</span></span><br><span class="line">-A INPUT -p tcp -s 192.168.1.2 --dport 22 -j LOG --log-prefix  &#x27;iptables-sshd&#x27;</span><br><span class="line">-A INPUT -m comment --comment &quot;ssh&quot; -p tcp -m state --state NEW -m tcp -s 192.168.1.2 --dport 22 -j ACCEPT</span><br><span class="line"></span><br><span class="line">-A INPUT -p icmp -m icmp --icmp-type 8 -j ACCEPT</span><br><span class="line">-A INPUT -p icmp -m icmp --icmp-type 0 -j ACCEPT</span><br><span class="line">-A INPUT -j REJECT --reject-with icmp-host-prohibited</span><br><span class="line">-A FORWARD -j REJECT --reject-with icmp-host-prohibited</span><br><span class="line">COMMIT</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>主要添加日志规则： <code>-A INPUT -p tcp -m state --state NEW -m tcp -s 192.168.1.2 --dport 22 -j LOG --log-prefix &#39;iptables-sshd&#39;</code> <a href="#%E8%AE%B0%E5%BD%95-iptables-%E6%97%A5%E5%BF%97">日志规则配置参考</a></p>
<p>ssh 连接失败后查看日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Feb 17 13:32:02 ip-172-31-2-4 kernel: iptables-sshdIN=eth0 OUT= MAC=02:d4:c1:a7:73:bb:02:69:00:94:63:ed:08:00 SRC=192.168.1.2 DST=172.31.2.4 LEN=60 TOS=0x00 PREC=0x00 TTL=42 ID=61621 DF PROTO=TCP SPT=53576 DPT=22 WINDOW=26883 RES=0x00 SYN URGP=0</span><br><span class="line">Feb 17 13:32:04 ip-172-31-2-4 kernel: iptables-sshdIN=eth0 OUT= MAC=02:d4:c1:a7:73:bb:02:69:00:94:63:ed:08:00 SRC=192.168.1.2 DST=172.31.2.4 LEN=60 TOS=0x00 PREC=0x00 TTL=42 ID=61622 DF PROTO=TCP SPT=53576 DPT=22 WINDOW=26883 RES=0x00 SYN URGP=0</span><br><span class="line">Feb 17 13:34:13 ip-172-31-2-4 kernel: iptables-sshdIN=eth0 OUT= MAC=02:d4:c1:a7:73:bb:02:69:00:94:63:ed:08:00 SRC=192.168.1.2 DST=172.31.2.4 LEN=60 TOS=0x00 PREC=0x00 TTL=42 ID=56660 DF PROTO=TCP SPT=53746 DPT=22 WINDOW=26883 RES=0x00 SYN URGP=0</span><br></pre></td></tr></table></figure>
<p>根据日志可知，规则 <code>INPUT -p tcp -s 192.168.1.2 --dport 22</code> 可以匹配到 ssh 的流量，说明 <code>filter</code> 表的 <code>INPUT</code> 链配置无误，根据 <code>-j ACCEPT</code>，<code>filter</code> 表的 <code>INPUT</code> 链会 ACCEPT 此连接请求。连接无法建立，应该是因为其他防火墙规则导致。</p>
<p>检查 <code>filter</code> 表之外的其他表的 <code>INPUT</code> 链，看是否存在拒绝的规则，发现 <code>NAT</code> 表中，<code>INPUT</code> 链的规则默认为 <code>DROP</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iptables -t nat -L -v -n --line-numbers</span></span><br><span class="line">Chain PREROUTING (policy ACCEPT 31 packets, 1742 bytes)</span><br><span class="line">num   pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line"></span><br><span class="line">Chain INPUT (policy DROP 6 packets, 360 bytes)</span><br><span class="line">num   pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT 5 packets, 367 bytes)</span><br><span class="line">num   pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line"></span><br><span class="line">Chain POSTROUTING (policy ACCEPT 5 packets, 367 bytes)</span><br><span class="line">num   pkts bytes target     prot opt in     out     source               destination  </span><br></pre></td></tr></table></figure>
<p>将其默认规则改为 <code>ACCEPT</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -t nat -P INPUT ACCEPT</span><br></pre></td></tr></table></figure>
<p>重新使用 ssh 登陆，连接正常。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title>linux logrotate 服务</title>
    <url>/202208191317/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Centos 7</li>
</ul>
<p><code>logrotate</code> 程序是一个日志文件管理工具。用于分割日志文件，压缩转存、删除旧的日志文件，并创建新的日志文件  </p>
<p><code>logrotate</code> 是基于 <code>crond</code> 来运行的，其脚本是 <code>/etc/cron.daily/logrotate</code>，日志轮转是系统自动完成的。<br>实际运行时，<code>logrotate</code> 会调用配置文件 <code>/etc/logrotate.conf</code>。<br><code>/etc/cron.daily/logrotate</code> 文件内容如下：</p>
<figure class="highlight shell"><figcaption><span>/etc/cron.daily/logrotate</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">/usr/sbin/logrotate -s /var/lib/logrotate/logrotate.status /etc/logrotate.conf</span><br><span class="line">EXITVALUE=$?</span><br><span class="line">if [ $EXITVALUE != 0 ]; then</span><br><span class="line">    /usr/bin/logger -t logrotate &quot;ALERT exited abnormally with [$EXITVALUE]&quot;</span><br><span class="line">fi</span><br><span class="line">exit 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以执行以下命令手动执行日志切割：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">logrotate -f /etc/logrotate.conf</span><br></pre></td></tr></table></figure>
<p>以下命令可以检测配置文件是否正确：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">logrotate -d /etc/logrotate.conf</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h3><p><code>logrotate</code> 的主配置文件默认为 <code>/etc/logrotate.conf</code>，默认配置如下：</p>
<figure class="highlight shell"><figcaption><span>/etc/logrotate.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认每一周执行一次 rotate 轮转工作</span></span><br><span class="line">weekly</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">保留多少个日志文件(轮转几次).默认保留四个.0 指没有备份</span></span><br><span class="line">rotate 4</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">自动创建新的日志文件，新的日志文件具有和原来的文件相同的权限；</span></span><br><span class="line">create</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这个参数很重要！就是切割后的日志文件以当前日期为格式结尾，如xxx.log-20131216这样,</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果注释掉,切割出来是按数字递增,即 xxx.log-1这种格式</span></span><br><span class="line">dateext</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">包含 /etc/logrotate.d 下的其他配置文件 ，用于隔离出各个服务的配置</span></span><br><span class="line">include /etc/logrotate.d</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">是否通过gzip压缩转储以后的日志文件，如xxx.log-20131216.gz ；如果不需要压缩，注释掉就行</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">compress</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">nocompress</span> </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">针对指定的文件做轮转切割</span></span><br><span class="line">/var/log/wtmp &#123;</span><br><span class="line">    # 每月轮转一次，取代全局默认值</span><br><span class="line">    monthly</span><br><span class="line">    </span><br><span class="line">    # 创建新文件，并指定权限，用户和组</span><br><span class="line">    create 0664 root utmp</span><br><span class="line">    </span><br><span class="line">    # 文件大小超过 1m 后才进行切割，到了 1 个月，文件大小小于 1m，不会进行切割</span><br><span class="line">	minsize 1M</span><br><span class="line">	</span><br><span class="line">    rotate 1</span><br><span class="line">&#125;</span><br><span class="line">/var/log/btmp &#123;</span><br><span class="line">    # 如果日志丢失，不报错继续滚动下一个日志</span><br><span class="line">    missingok</span><br><span class="line">    </span><br><span class="line">    monthly</span><br><span class="line">    create 0600 root utmp</span><br><span class="line">    rotate 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他常用选项说明如下：</p>
<figure class="highlight shell"><figcaption><span>/etc/logrotate.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定转储周期为每天</span></span><br><span class="line">daily </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">即使日志文件为空文件也做轮转，这个是 logrotate 的缺省选项。</span></span><br><span class="line">ifempty </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当日志文件为空时，不进行轮转</span></span><br><span class="line">notifempty </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当日志文件大于指定大小后就轮转，支持的单位： k，K，m，M</span></span><br><span class="line">size 5M</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用于还在打开中的日志文件，把当前日志备份并截断；</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">是先拷贝再清空的方式，拷贝和清空之间有一个时间差，可能会丢失部分日志数据。</span></span><br><span class="line">copytruncate</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行 postrotate 脚本，作用是在所有日志都轮转后统一执行一次脚本。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果没有配置这个，那么每个日志轮转后都会执行一次脚本</span></span><br><span class="line">sharedscripts                      </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 logrotate 转储之后需要执行的指令，例如重新启动 (<span class="built_in">kill</span> -HUP) 某个服务！必须独立成行</span></span><br><span class="line">postrotate                         </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 logrotate 转储之前需要执行的指令，例如修改文件的属性等动作；必须独立成行</span></span><br><span class="line">prerotate      </span><br><span class="line">                    </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将轮转的日志保存到指定路径下，默认保存在日志文件同一目录下</span></span><br><span class="line">olddir /data/logs/</span><br></pre></td></tr></table></figure>

<h3 id="配置示例"><a href="#配置示例" class="headerlink" title="配置示例"></a>配置示例</h3><p><code>nginx</code> 日志切割配置文件示例，创建 <code>/etc/logrotate.d/nginx</code>:</p>
<figure class="highlight shell"><figcaption><span>/etc/logrotate.d/nginx</span></figcaption><table><tr><td class="code"><pre><span class="line">/logs/nginx/access/*.log</span><br><span class="line">/logs/bginx/error/*.log &#123;</span><br><span class="line">    daily</span><br><span class="line">    compress</span><br><span class="line">    rotate 7</span><br><span class="line">    missingok</span><br><span class="line">    notifempty</span><br><span class="line">    dateext</span><br><span class="line">    sharedscripts</span><br><span class="line">    postrotate</span><br><span class="line">        if [ -f /run/nginx.pid ]; then</span><br><span class="line">                    kill -USR1 `cat /run/nginx.pid`</span><br><span class="line">        fi</span><br><span class="line">    endscript</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用 <code>copytruncate</code> 方式切割 <code>nginx</code> 日志，此种方式不需要重启 <code>nginx</code> 服务<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[logrotate 原理介绍和配置详解](https://wsgzao.github.io/post/logrotate/)
">[1]</span></a></sup></p>
<figure class="highlight shell"><figcaption><span>/etc/logrotate.d/nginx</span></figcaption><table><tr><td class="code"><pre><span class="line">/logs/nginx/access/*.log</span><br><span class="line">/logs/bginx/error/*.log &#123;</span><br><span class="line">    copytruncate</span><br><span class="line">    daily</span><br><span class="line">    compress</span><br><span class="line">    rotate 7</span><br><span class="line">    missingok</span><br><span class="line">    notifempty</span><br><span class="line">    dateext</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://wsgzao.github.io/post/logrotate/">logrotate 原理介绍和配置详解</a></p>
<h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://wsgzao.github.io/post/logrotate/">logrotate 原理介绍和配置详解</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>logrotate</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux man 使用</title>
    <url>/202306091031/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos 7</li>
</ul>
<h1 id="为源码编译安装的软件安装-man-手册"><a href="#为源码编译安装的软件安装-man-手册" class="headerlink" title="为源码编译安装的软件安装 man 手册"></a>为源码编译安装的软件安装 man 手册</h1><p>使用源码编译安装的软件默认是没有 man 手册的，使用 man 命令会报以下错误</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">man fswatch</span></span><br><span class="line">No manual entry for fswatch</span><br></pre></td></tr></table></figure>

<p>要为源码编译安装的软件安装 man 手册，可以参考以下步骤，此处示例软件为 <code>fswatch</code>，软件编译安装到了 <code>/usr/local/fswatch-1.17.1/</code></p>
<ol>
<li><p>一般情况下，源码中会附带软件的使用文档，编译安装后，可能位于以下路径，<code>fswatch</code> 编译安装后的 man 手册位于 <code>/usr/local/fswatch-1.17.1/share/man/man7/fswatch.7</code></p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls /usr/local/fswatch-1.17.1/doc</span><br><span class="line">ls /usr/local/fswatch-1.17.1/share/doc</span><br><span class="line">ls /usr/local/fswatch-1.17.1/share/man/</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><code>man</code> 命令使用的文档默认来源于 <code>/usr/share/man/</code></p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> /usr/share/man/</span></span><br><span class="line">cs  de  fr  hu  it  ko     man1   man1x  man2x  man3p  man4   man5   man6   man7   man8   man9   mann  pl  pt_BR  ro  sk  tr  zh_CN</span><br><span class="line">da  es  hr  id  ja  man0p  man1p  man2   man3   man3x  man4x  man5x  man6x  man7x  man8x  man9x  nl    pt  pt_PT  ru  sv  zh  zh_TW</span><br></pre></td></tr></table></figure>
<p>要为编译安装软件的安装 <code>man</code> 帮助文档，首先将 <code>fswatch</code> 的帮助文档复制到 <code>man</code> 页面的目录</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp /usr/local/fswatch-1.17.1/share/man/man7/fswatch.7 /usr/share/man/man7/</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>更新 <code>man</code> 索引</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mandb</span><br><span class="line">1 man subdirectory contained newer manual pages.</span><br><span class="line">47 manual pages were added.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>安装成功后，可以正常使用 <code>man fswatch</code> 查看帮助文档。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 内存相关操作</title>
    <url>/202306021537/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos 7</li>
</ul>
<h1 id="内存压力测试工具"><a href="#内存压力测试工具" class="headerlink" title="内存压力测试工具"></a>内存压力测试工具</h1><h2 id="memtester"><a href="#memtester" class="headerlink" title="memtester"></a>memtester</h2><p>使用 docker 运行工具</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ docker run --rm -it dockerpinata/memtester:<span class="number">1</span> memtester</span><br><span class="line">memtester version <span class="number">4.3</span><span class="number">.0</span> (<span class="number">64</span>-bit)</span><br><span class="line">Copyright (C) <span class="number">2001</span>-<span class="number">2012</span> Charles Cazabon.</span><br><span class="line">Licensed under the GNU General Public License version <span class="number">2</span> (only).</span><br><span class="line"></span><br><span class="line">pagesize <span class="keyword">is</span> <span class="number">4096</span></span><br><span class="line">pagesizemask <span class="keyword">is</span> <span class="number">0xfffffffffffff000</span></span><br><span class="line">need memory argument, <span class="keyword">in</span> MB</span><br><span class="line"></span><br><span class="line">Usage: memtester [-p physaddrbase [-d device]] &lt;mem&gt;[B|K|M|G] [loops]</span><br></pre></td></tr></table></figure>

<h2 id="stress-工具"><a href="#stress-工具" class="headerlink" title="stress 工具"></a>stress 工具</h2><p><code>stress</code> 是一个用于模拟系统负载的工具，可以使用它来创建临时的内存负载。通过模拟负载，系统将使用更多的内存。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">yum install -y stress</span><br></pre></td></tr></table></figure>
<p>使用以下命令可以创建一个临时的内存负载</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stress --vm <span class="number">1</span> --vm-<span class="built_in">bytes</span> &lt;MEMORY_SIZE&gt;</span><br></pre></td></tr></table></figure>

<h2 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h2><p><code>dd</code> 命令可以用于创建大文件并占用磁盘空间，从而间接提升系统的内存使用率。您可以使用以下命令创建一个指定大小的临时文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/zero of=tempfile bs=1M count=&lt;MEMORY_SIZE&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 常见错误集锦</title>
    <url>/202306081314/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos 7</li>
</ul>
<h1 id="automake"><a href="#automake" class="headerlink" title="automake"></a>automake</h1><p>编译安装软件报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">error: require Automake 1.14, but have 1.13.4</span><br></pre></td></tr></table></figure>
<p>Automake 版本不匹配，需要安装 Automake 1.14</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rpm -qa | grep automake</span></span><br><span class="line">automake-1.13.4-3.el7.noarch</span><br></pre></td></tr></table></figure>

<p>以下步骤安装 <code>automake-1.14.1</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://ftp.gnu.org/gnu/automake/automake-1.14.1.tar.gz</span><br><span class="line">tar -xf automake-1.14.1.tar.gz</span><br><span class="line">cd automake-1.14.1</span><br><span class="line">./bootstrap.sh</span><br></pre></td></tr></table></figure>
<p>以上步骤执行完成后，会生成 <code>configure</code> 可执行文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>安装完成后，执行以下命令验证版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">automake --version</span></span><br><span class="line">automake (GNU automake) 1.14.1</span><br><span class="line">Copyright (C) 2013 Free Software Foundation, Inc.</span><br><span class="line">License GPLv2+: GNU GPL version 2 or later &lt;http://gnu.org/licenses/gpl-2.0.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line"></span><br><span class="line">Written by Tom Tromey &lt;tromey@redhat.com&gt;</span><br><span class="line">       and Alexandre Duret-Lutz &lt;adl@gnu.org&gt;.</span><br></pre></td></tr></table></figure>

<h1 id="makeinfo"><a href="#makeinfo" class="headerlink" title="makeinfo"></a>makeinfo</h1><p>编译安装软件报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">makeinfo: command not found</span><br></pre></td></tr></table></figure>
<p><code>makeinfo</code> 命令不存在，执行以下命令安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install texinfo</span><br></pre></td></tr></table></figure>

<h1 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h1><h2 id="A-compiler-with-support-for-C-11-language-features-is-required"><a href="#A-compiler-with-support-for-C-11-language-features-is-required" class="headerlink" title="A compiler with support for C++11 language features is required"></a>A compiler with support for C++11 language features is required</h2><p>编译安装软件时报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">configure: error: *** A compiler with support for C++11 language features is required.</span><br></pre></td></tr></table></figure>
<p>错误原因为 gcc 版本太低。查看当前 gcc 版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -v</span></span><br><span class="line">Using built-in specs.</span><br><span class="line">COLLECT_GCC=gcc</span><br><span class="line">COLLECT_LTO_WRAPPER=/usr/libexec/gcc/x86_64-redhat-linux/4.8.5/lto-wrapper</span><br><span class="line">Target: x86_64-redhat-linux</span><br><span class="line">Configured with: ../configure --prefix=/usr --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=http://bugzilla.redhat.com/bugzilla --enable-bootstrap --enable-shared --enable-threads=posix --enable-checking=release --with-system-zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-linker-build-id --with-linker-hash-style=gnu --enable-languages=c,c++,objc,obj-c++,java,fortran,ada,go,lto --enable-plugin --enable-initfini-array --disable-libgcj --with-isl=/builddir/build/BUILD/gcc-4.8.5-20150702/obj-x86_64-redhat-linux/isl-install --with-cloog=/builddir/build/BUILD/gcc-4.8.5-20150702/obj-x86_64-redhat-linux/cloog-install --enable-gnu-indirect-function --with-tune=generic --with-arch_32=x86-64 --build=x86_64-redhat-linux</span><br><span class="line">Thread model: posix</span><br><span class="line">gcc version 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC)</span><br></pre></td></tr></table></figure>

<h3 id="安装-gcc-8-3-0"><a href="#安装-gcc-8-3-0" class="headerlink" title="安装 gcc-8.3.0"></a>安装 gcc-8.3.0</h3><p>以下步骤演示安装 gcc-8.3.0 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[升级 GCC 支持C++11](https://www.cnblogs.com/gyfluck/p/10537383.html)
">[1]</span></a></sup></p>
<ol>
<li>下载安装包，<a href="http://ftp.gnu.org/gnu/gcc/">官方下载地址</a> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget ftp://ftp.irisa.fr/pub/mirrors/gcc.gnu.org/gcc/releases/gcc-8.3.0/gcc-8.3.0.tar.gz</span><br><span class="line">tar -xf gcc-8.3.0.tar.gz</span><br><span class="line">cd gcc-8.3.0</span><br></pre></td></tr></table></figure></li>
<li>编译安装。编译依赖 <code>GMP 4.2+</code>, <code>MPFR 2.4.0+</code> and <code>MPC 0.8.0+</code>，需要先按照顺序安装这 3 个依赖。依赖安装参考： <a href="#%E5%AE%89%E8%A3%85-GMP">安装 GMP</a>，<a href="#%E5%AE%89%E8%A3%85-MPFR">安装 MPFR</a>，<a href="%E5%AE%89%E8%A3%85-MPC">安装 MPC</a> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./configure --prefix=/usr/local/gcc-8.3.0 --disable-multilib</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make install</span></span><br></pre></td></tr></table></figure></li>
<li>安装完成后，需要更新系统标准库 查看当前系统使用的 gcc 库文件，可以看到版本为 <code>libstdc++.so.6.0.19</code> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> /usr/lib64/libstdc++.so.6</span></span><br><span class="line">libstdc++.so.6       libstdc++.so.6.0.19 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> /usr/lib64/libstdc++.so.6 -l</span></span><br><span class="line">lrwxrwxrwx 1 root root 19 May 30 08:05 /usr/lib64/libstdc++.so.6 -&gt; libstdc++.so.6.0.19</span><br></pre></td></tr></table></figure>
 执行以下操作，更新 <code>libstdc++.so.6</code> 到最新安装的版本 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> -rf /usr/lib64/libstdc++.so.6</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ln</span> -s /usr/local/gcc-8.3.0/lib64/libstdc++.so.6.0.25 /usr/lib64/libstdc++.so.6</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> /usr/lib64/libstdc++.so.6 -l</span></span><br><span class="line">lrwxrwxrwx 1 root root 46 Jun  9 09:31 /usr/lib64/libstdc++.so.6 -&gt; /usr/local/gcc-8.3.0/lib64/libstdc++.so.6.0.25</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="安装-GMP"><a href="#安装-GMP" class="headerlink" title="安装 GMP"></a>安装 GMP</h2><p><a href="ftp://gcc.gnu.org/pub/gcc/infrastructure/">安装包下载地址</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget ftp://gcc.gnu.org/pub/gcc/infrastructure/gmp-6.1.0.tar.bz2</span><br><span class="line">tar -jxvf gmp-6.1.0.tar.bz2</span><br><span class="line">cd gmp-6.1.0</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<h2 id="安装-MPFR"><a href="#安装-MPFR" class="headerlink" title="安装 MPFR"></a>安装 MPFR</h2><p><a href="ftp://gcc.gnu.org/pub/gcc/infrastructure/">安装包下载地址</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget ftp://gcc.gnu.org/pub/gcc/infrastructure/mpfr-3.1.4.tar.bz2</span><br><span class="line">tar -jxvf mpfr-3.1.4.tar.bz2</span><br><span class="line">cd mpfr-3.1.4</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<h2 id="安装-MPC"><a href="#安装-MPC" class="headerlink" title="安装 MPC"></a>安装 MPC</h2><p><a href="ftp://gcc.gnu.org/pub/gcc/infrastructure/">安装包下载地址</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget ftp://gcc.gnu.org/pub/gcc/infrastructure/mpc-1.0.3.tar.gz</span><br><span class="line">tar -zxvf mpc-1.0.3.tar.gz</span><br><span class="line">cd mpc-1.0.3</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="cannot-find-crtn-o"><a href="#cannot-find-crtn-o" class="headerlink" title="cannot find crtn.o"></a>cannot find crtn.o</h2><p>Centos7 编译软件时报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./configure --prefix=/usr/local/gcc-8.3.0</span></span><br><span class="line">cannot find crtn.o: No such file or directory</span><br></pre></td></tr></table></figure>
<p><strong>解决方法</strong> ： 编译时添加选项 <code>--disable-multilib</code> <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[cannot find crti.o](https://blog.csdn.net/weixin_39278265/article/details/118435463)">[2]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./configure --prefix=/usr/local/gcc-8.3.0 --disable-multilib</span></span><br></pre></td></tr></table></figure>

<h2 id="C-preprocessor-“-x2F-lib-x2F-cpp”-fails-sanity-check"><a href="#C-preprocessor-“-x2F-lib-x2F-cpp”-fails-sanity-check" class="headerlink" title="C++ preprocessor “&#x2F;lib&#x2F;cpp” fails sanity check"></a>C++ preprocessor “&#x2F;lib&#x2F;cpp” fails sanity check</h2><p>centos7 编译后，安装软件时报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">error: C++ preprocessor &quot;/lib/cpp&quot; fails sanity chec</span><br></pre></td></tr></table></figure>

<p>该报错原因为缺少必要的 C++ 库，执行以下命令安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y gcc-c++</span><br></pre></td></tr></table></figure>

<h2 id="编译安装软件前，执行-configure-时指定-C-编译器的路径"><a href="#编译安装软件前，执行-configure-时指定-C-编译器的路径" class="headerlink" title="编译安装软件前，执行 configure 时指定 C++ 编译器的路径"></a>编译安装软件前，执行 configure 时指定 C++ 编译器的路径</h2><p>在系统上安装了多个版本的 gcc 时，编译前执行 <code>./configure</code> 时可能会找到默认的 gcc，会不符合版本要求，可能会输出下面代码示例中的错误。<code>./configure</code> 时找到的是 <code>4.8.5</code> 的 GCC，配置此软件需要 <code>4.9</code>，系统上还安装了 <code>8.3.0</code> 版本的 gcc。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./configure --prefix=/usr/local/</span></span><br><span class="line">checking for C++ compiler vendor... gnu</span><br><span class="line">checking for C++ compiler version... 4.8.5</span><br><span class="line">configure: error: GCC v. 4.9 is required </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">/usr/local/gcc-8.3.0/bin/gcc --version</span></span><br><span class="line">gcc (GCC) 8.3.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为了解决此问题，可以在执行 <code>./configure</code> 时指定编译器的位置，分别可以使用环境变量 <code>CC=/path/to/gcc</code> 和 <code>CXX=/usr/local/gcc-8.3.0/bin/g++</code> 指定 C 和 C++ 编译器的具体路径。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure CXX=/usr/local/gcc-8.3.0/bin/g++ --prefix=/usr/local/</span><br><span class="line"></span><br><span class="line">./configure CC=/usr/local/gcc-8.3.0/bin/gcc --prefix=/usr/local/</span><br></pre></td></tr></table></figure>

<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.cnblogs.com/gyfluck/p/10537383.html">升级 GCC 支持C++11</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://blog.csdn.net/weixin_39278265/article/details/118435463">cannot find crti.o</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux namespace 简介</title>
    <url>/202304191340/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos 7 5.4.239-1</li>
</ul>
<p>Linux 的 namespace 的作用是 ”隔离内核资源“，目前主要实现了以下 namespace</p>
<ul>
<li><code>mount namespace</code> - 文件系统挂载点</li>
<li><code>UTS namespace</code> - 主机名</li>
<li><code>IPC namespace</code> - POSIX 进程间通信消息队列</li>
<li><code>PID namespace</code> - 进程 pid 数字空间</li>
<li><code>network namespace</code> - network</li>
<li><code>user namespace</code> - user ID 数字空间</li>
<li><code>cgroup</code> - 资源使用控制</li>
</ul>
<p>其中，除了 <code>network namespace</code>，其他 namespace 的操作需要使用 C 语言调用系统 API 实现。<code>network namespace</code> 的增删改查功能已经集成到了 Linux 的 <code>ip</code> 工具集的 <code>netns</code> 子命令中</p>
<p>Linux 里面的 namespace 给处在其中的进程造成 2 个错觉：</p>
<ol>
<li>它是系统里面唯一的进程</li>
<li>它独享系统的所有资源</li>
</ol>
<p>默认情况下，Linux 里面的所有进程处在和宿主机相同的 namespace ，即初始 namespace 里，默认享有全局系统资源。</p>
<p>想要查看某个进程都在哪些 namespace 中，可以找到进程 ID （PID），通过查看以下内容或者 namespace 信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps -elf | grep nginx</span></span><br><span class="line">4 S root     32679 32659  0  80   0 -  2248 sigsus Apr07 ?        00:00:00 nginx: master process nginx -g daemon off;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ll /proc/32679/ns/</span></span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr 19 13:51 cgroup -&gt; cgroup:[4026531835]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr 19 13:51 ipc -&gt; ipc:[4026534784]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr 19 13:51 mnt -&gt; mnt:[4026534583]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr 19 13:51 net -&gt; net:[4026534787]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr 19 13:51 pid -&gt; pid:[4026534878]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr 19 13:51 pid_for_children -&gt; pid:[4026534878]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr 19 13:51 user -&gt; user:[4026531837]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr 19 13:51 uts -&gt; uts:[4026534877]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过以上命令，可以看到 <code>nginx</code> 进程所属的 namespace，要查看系统初始 namespace ，可以查看 PID 为 1 的进程的 namespace 信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ll /proc/1/ns/</span></span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr 19 13:53 cgroup -&gt; cgroup:[4026531835]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr 19 13:53 ipc -&gt; ipc:[4026531839]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr 19 13:53 mnt -&gt; mnt:[4026531840]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr 19 13:53 net -&gt; net:[4026531992]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr 19 13:53 pid -&gt; pid:[4026531836]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr 19 13:53 pid_for_children -&gt; pid:[4026531836]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr 19 13:53 user -&gt; user:[4026531837]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr 19 13:53 uts -&gt; uts:[4026531838]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>链接文件的内容的格式为 ns 类型: [inode number]。这里的 <code>inode number</code> 则用来标识一个 namespace，我们也可以把它理解为 namespace 的 ID。如果两个进程的某个 namespace 文件指向同一个链接文件，说明其相关资源在同一个 namespace 中。 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[不能不知道的三个docker容器隔离核心技术：namespace、cgroups、rootfs](https://zhuanlan.zhihu.com/p/374503196)">[1]</span></a></sup></p>
</blockquote>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://zhuanlan.zhihu.com/p/374503196">不能不知道的三个docker容器隔离核心技术：namespace、cgroups、rootfs</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux macvlan 网卡虚拟化技术</title>
    <url>/202304251611/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Macvlan"><a href="#Macvlan" class="headerlink" title="Macvlan"></a>Macvlan</h1><p>Macvlan 本身是 linxu kernel 模块</p>
<p>Macvlan 接口是物理以太网接口的虚拟子接口，Macvlan 允许用户在一个物理网络接口上面配置多个虚拟的网络接口，每个 Macvlan 接口都有自己的区别与父接口的 MAC 地址，并且可以像普通的物理网络接口一样分配 IP 地址。使用 Macvlan 技术实现的效果是一块物理网卡可以绑定多个 IP 地址，并且每个 IP 地址有自己独立的 MAC 地址。</p>
<p>Macvlan 虚拟出来的虚拟网卡，在逻辑上和物理网卡是对等的。使用 Macvlan 的虚拟网卡要和父接口在同一个网段。</p>
<p>Macvlan 的最大优点是性能极好，相比其他方式，macvlan 不需要创建 Linux bridge，而是直接通过interface 连接到物理网络。</p>
<p>为保证父接口能接收多个不同 MAC 地址的网络包，需要开启网卡的 <a href="/202304041014/" title="混杂模式">混杂模式</a></p>
<h2 id="docker-中使用-Macvlan-虚拟网卡"><a href="#docker-中使用-Macvlan-虚拟网卡" class="headerlink" title="docker 中使用 Macvlan 虚拟网卡"></a>docker 中使用 Macvlan 虚拟网卡</h2><p>本示例演示 docker 环境中使用 macvlan。首先创建使用 macvlan 驱动的 network，Docker 中 macvlan 只支持 bridge 模式 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Docker跨主机通信之macvlan](http://dockeradv.baoshu.red/advanced_network/macvlan.html)">[1]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker network create -d macvlan --subnet=192.168.142.0/24 \</span></span><br><span class="line"><span class="language-bash">                                   --gateway=192.168.142.2 \</span></span><br><span class="line"><span class="language-bash">                                   -o parent=ens33 \</span></span><br><span class="line"><span class="language-bash">                                   macvlan1</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker network <span class="built_in">ls</span></span></span><br><span class="line">NETWORK ID     NAME       DRIVER    SCOPE</span><br><span class="line">69324d203c35   bridge     bridge    local</span><br><span class="line">f8943f720d73   host       host      local</span><br><span class="line">0aa95ac8c0f4   macvlan1   macvlan   local</span><br><span class="line">d400c40efdc5   none       null      local</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 docker 环境中，创建网络时，会自动将宿主机网卡设置为混杂模式，此时查看网卡信息，未显示混杂模式，但是查看 <code>dmesg</code> 日志，会看到网卡进入了混杂模式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ dmesg</span><br><span class="line">[93203.228311] device ens33 entered promiscuous mode</span><br></pre></td></tr></table></figure>
</blockquote>
<p>运行容器并连接到新建的 macvlan 网络 <code>macvlan1</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -itd --name test01 \</span><br><span class="line">                --ip=192.168.142.12 \</span><br><span class="line">                --network macvlan1 centos:centos7.9.2009</span><br></pre></td></tr></table></figure>
<p>使用命令 <code>docker exec -it test01 bash</code> 进入容器查看容器的 IP 地址信息，可以看到容器中的网卡类型为 <code>macvlan</code>，模式为 <code>bridge</code>，网关为 docker 网络 <code>macvlan1</code> 中配置的网关。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip -d add</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 promiscuity 0 numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535 </span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">4: eth0@if2: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default </span><br><span class="line">    link/ether 02:42:c0:a8:8e:0c brd ff:ff:ff:ff:ff:ff link-netnsid 0 promiscuity 0 </span><br><span class="line">    macvlan mode bridge numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535 </span><br><span class="line">    inet 192.168.142.12/24 brd 192.168.142.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">       </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">route -n</span></span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         192.168.142.2   0.0.0.0         UG    0      0        0 eth0</span><br><span class="line">192.168.142.0   0.0.0.0         255.255.255.0   U     0      0        0 eth0</span><br></pre></td></tr></table></figure>
<p>测试容器可以和宿主机网络一样访问外网。</p>
<p>此时检查宿主机网卡信息，系统上只有 <code>lo</code>，<code>ens33</code>，<code>docker0</code>，未出现其他网卡。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip -d <span class="built_in">link</span></span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 promiscuity 0 addrgenmode eui64 numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535 </span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 00:0c:29:90:51:eb brd ff:ff:ff:ff:ff:ff promiscuity 1 addrgenmode eui64 numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535 </span><br><span class="line">3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN mode DEFAULT group default </span><br><span class="line">    link/ether 02:42:e9:a6:76:56 brd ff:ff:ff:ff:ff:ff promiscuity 0 </span><br><span class="line">    bridge forward_delay 1500 hello_time 200 max_age 2000 ageing_time 30000 stp_state 0 priority 32768 vlan_filtering 0 vlan_protocol 802.1Q bridge_id 8000.2:42:e9:a6:76:56 designated_root 8000.2:42:e9:a6:76:56 root_port 0 root_path_cost 0 topology_change 0 topology_change_detected 0 hello_timer    0.00 tcn_timer    0.00 topology_change_timer    0.00 gc_timer  265.03 vlan_default_pvid 1 vlan_stats_enabled 0 group_fwd_mask 0 group_address 01:80:c2:00:00:00 mcast_snooping 1 mcast_router 1 mcast_query_use_ifaddr 0 mcast_querier 0 mcast_hash_elasticity 16 mcast_hash_max 4096 mcast_last_member_count 2 mcast_startup_query_count 2 mcast_last_member_interval 100 mcast_membership_interval 26000 mcast_querier_interval 25500 mcast_query_interval 12500 mcast_query_response_interval 1000 mcast_startup_query_interval 3125 mcast_stats_enabled 0 mcast_igmp_version 2 mcast_mld_version 1 nf_call_iptables 0 nf_call_ip6tables 0 nf_call_arptables 0 addrgenmode eui64 numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535</span><br></pre></td></tr></table></figure>

<p>在另一个 docker 节点上同样配置 docker 网络和容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker network create -d macvlan --subnet=192.168.142.0/24 \</span></span><br><span class="line"><span class="language-bash">                                   --gateway=192.168.142.2 \</span></span><br><span class="line"><span class="language-bash">                                   -o parent=ens33 \</span></span><br><span class="line"><span class="language-bash">                                   macvlan1</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -itd --name test01 \</span></span><br><span class="line"><span class="language-bash">                --ip=192.168.142.13 \</span></span><br><span class="line"><span class="language-bash">                --network macvlan1 centos:centos7.9.2009</span>                                   </span><br></pre></td></tr></table></figure>
<p>进入容器 <code>test01</code> ，访问到另一个节点上的容器的连通性</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ping 192.168.142.12</span></span><br><span class="line">PING 192.168.142.12 (192.168.142.12) 56(84) bytes of data.</span><br><span class="line">64 bytes from 192.168.142.12: icmp_seq=1 ttl=64 time=0.871 ms</span><br><span class="line">64 bytes from 192.168.142.12: icmp_seq=2 ttl=64 time=0.403 ms</span><br><span class="line">64 bytes from 192.168.142.12: icmp_seq=3 ttl=64 time=0.568 ms</span><br><span class="line">^C</span><br><span class="line">--- 192.168.142.12 ping statistics ---</span><br><span class="line">3 packets transmitted, 3 received, 0% packet loss, time 2047ms</span><br><span class="line">rtt min/avg/max/mdev = 0.403/0.614/0.871/0.193 ms</span><br></pre></td></tr></table></figure>
<p>进入容器 <code>test01</code> ，测试和宿主机 ip 的连通性，结果发现不通，原因为：在 macvlan 虚拟网络中，父接口（物理网卡）相当于一个交换机，对于其子 macvlan 网卡的数据包，只进行转发而不处理，于是造成了使用本机 macvlan 网卡的虚拟 IP 无法和本机物理网卡的 IP 通信。 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ping 192.168.142.10</span></span><br><span class="line">PING 192.168.142.10 (192.168.142.10) 56(84) bytes of data.</span><br><span class="line">From 192.168.142.13 icmp_seq=1 Destination Host Unreachable</span><br><span class="line">From 192.168.142.13 icmp_seq=2 Destination Host Unreachable</span><br><span class="line">From 192.168.142.13 icmp_seq=3 Destination Host Unreachable</span><br><span class="line">^C</span><br><span class="line">--- 192.168.142.10 ping statistics ---</span><br><span class="line">5 packets transmitted, 0 received, +3 errors, 100% packet loss, time 4073ms</span><br><span class="line">pipe 4</span><br></pre></td></tr></table></figure>

<span id="more"></span>
<h2 id="macvlan-网络存的缺点"><a href="#macvlan-网络存的缺点" class="headerlink" title="macvlan 网络存的缺点"></a>macvlan 网络存的缺点</h2><ul>
<li>macvlan 会独占主机的物理网卡，也就是说一个物理网卡只能创建一个 macvlan 网络</li>
<li>使用本机 macvlan 网卡的虚拟 IP 无法和本机物理网卡的 IP 通信</li>
<li>父接口异常，其他所有的虚拟子接口的网络都会异常</li>
</ul>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="http://dockeradv.baoshu.red/advanced_network/macvlan.html">Docker跨主机通信之macvlan</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Linux</category>
        <category>network</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 网络接口的混杂模式</title>
    <url>/202304041014/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Linux 网卡的混杂模式（Promiscuous mode），简称 Promisc mode，俗称 <code>监听模式</code>。在非混杂模式下，网卡只会接受目的 MAC 地址是它自己的单播帧，以及多播帧；在混杂模式下，网卡会接受经过它的所有帧。</p>
<p>查看网卡是否处于 <code>Promiscuous mode</code>，可以使用 <code>ifconfig</code> 或者 <code>netstat -i</code> 命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ifconfig ens33</span><br><span class="line">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.142.10  netmask 255.255.255.0  broadcast 192.168.142.255</span><br><span class="line">        inet6 fe80::20c:29ff:fee7:c027  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0c:29:e7:c0:27  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 194243  bytes 257521006 (245.5 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 92488  bytes 6051258 (5.7 MiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>
<p>当输出包含 <code>PROMISC</code> 时，表明该网络接口处于 <code>Promiscuous mode</code>，否则表明未处于 <code>Promiscuous mode</code>。要开启网卡的 <code>Promiscuous mode</code> ，可以使用以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ifconfig ens33 promisc</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ifconfig ens33</span></span><br><span class="line">ens33: flags=4419&lt;UP,BROADCAST,RUNNING,PROMISC,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.142.10  netmask 255.255.255.0  broadcast 192.168.142.255</span><br><span class="line">        inet6 fe80::20c:29ff:fee7:c027  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0c:29:e7:c0:27  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 194383  bytes 257531059 (245.6 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 92561  bytes 6058652 (5.7 MiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>
<p>以下命令使网卡退出 <code>Promiscuous mode</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ifconfig ens33 -promisc</span><br></pre></td></tr></table></figure>

<p>将网络设备加入 Linux bridge 后，网络设备会自动进入混杂模式，此种情况使用 <code>ifconfig</code> 或者 <code>netstat -i</code> 命令查看网卡，未显示 <code>PROMISC</code>，但是查看内核日志，显示网卡已进入混杂模式，并且无法退出，直到将 veth 从Linux bridge 中移除。网络设备移除网桥后，会自动退出混杂模式。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip <span class="built_in">link</span> add veth0 <span class="built_in">type</span> veth peer name veth1</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">brctl show</span></span><br><span class="line">bridge name	bridge id		STP enabled	interfaces</span><br><span class="line">br0		8000.000000000000	no		</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">brctl addif br0 veth0</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ifconfig veth0</span></span><br><span class="line">veth0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.10.1  netmask 255.255.255.0  broadcast 192.168.10.255</span><br><span class="line">        ether b6:b3:aa:ae:61:05  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">netstat -i</span></span><br><span class="line">Kernel Interface table</span><br><span class="line">Iface             MTU    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg</span><br><span class="line">br0              1500        0      0      0 0            34      0      0      0 BMU</span><br><span class="line">ens33            1500   195528      0      1 0         93168      0      0      0 BMPRU</span><br><span class="line">veth0            1500        0      0      0 0             0      0      0      0 BMU</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">dmesg | grep promisc</span></span><br><span class="line">[75099.376421] device veth2d80973 entered promiscuous mode</span><br><span class="line">[77630.104784] device ens33 entered promiscuous mode</span><br><span class="line">[77719.626596] device ens33 left promiscuous mode</span><br><span class="line">[77877.905587] device ens33 entered promiscuous mode</span><br><span class="line">[78153.928533] device veth0 entered promiscuous mode</span><br></pre></td></tr></table></figure>

<span id="more"></span>
]]></content>
      <categories>
        <category>Linux</category>
        <category>network</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 进程常见状态说明</title>
    <url>/202304181637/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><table>
<thead>
<tr>
<th>状态标识</th>
<th>状态名称</th>
<th>状态说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>R</code></td>
<td>task_running</td>
<td>进程处于运行或就绪状态</td>
<td></td>
</tr>
<tr>
<td><code>S</code></td>
<td>task_interruptible<br/> sleeping</td>
<td>可中断的睡眠状态</td>
<td></td>
</tr>
<tr>
<td><code>D</code></td>
<td>task_uninterruptible</td>
<td>不可中断的睡眠状态<br/>1. 它是一种睡眠状态，意味着处于此状态的进程不会消耗 CPU<br/>2. 睡眠的原因是等待某些资源（比如锁或者磁盘 IO），这也是非常多 D 状态的进程都处在处理 IO 操作的原因<br/>3. 是它不能被中断，这个要区别于 <code>硬件中断</code> 的中断，是指不希望在其获取到资源或者超时前被终止。因此他不会被信号唤醒，也就不会响应 <code>kill -9</code> 这类信号。这也是它跟 <code>S（可中断睡眠）</code>状态的区别</td>
<td></td>
</tr>
<tr>
<td><code>T</code></td>
<td>task_stopped <br/> task_traced<br/>Traced</td>
<td>暂停状态或跟踪状态</td>
<td></td>
</tr>
<tr>
<td><code>Z</code></td>
<td>task_dead <br/> exit_zombie<br/>zombie</td>
<td>退出状态，进程成为僵尸进程</td>
<td></td>
</tr>
<tr>
<td><code>X</code></td>
<td>task_dead <br/> exit_dead</td>
<td>退出状态，进程即将被销毁</td>
<td></td>
</tr>
<tr>
<td><code>I</code></td>
<td>idle</td>
<td>空闲状态</td>
<td></td>
</tr>
</tbody></table>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="http://lionheartwang.github.io/blog/2018/06/05/linuxjin-cheng-zhuang-tai-shuo-ming/">Linux进程状态说明</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux rsyslog 服务</title>
    <url>/202208191014/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Centos 7</li>
</ul>
<p>系统默认的日志托管服务，部分系统服务（如 <code>crond</code>, 邮件系统，安全审计等）会将日志发送给 <code>rsyslog</code> 服务来进行日志管理。</p>
<p><code>rsyslog</code> 服务是依赖其配置文件 <code>/etc/rsyslog.conf</code> 来确定哪个服务的什么等级的日志信息会被记录在哪个位置的。也就是说，日志服务的配置文件中主要定义了服务的名称、日志等级和日志记录位置。</p>
<span id="more"></span>

<h3 id="配置文件说明"><a href="#配置文件说明" class="headerlink" title="配置文件说明"></a>配置文件说明</h3><p>默认配置文件(<code>/etc/rsyslog.conf</code>)内容如下</p>
<figure class="highlight shell"><figcaption><span>/etc/rsyslog.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载指定模块</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">ModLoad imuxsock <span class="comment"># provides support for local system logging (e.g. via logger command)</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">ModLoad imjournal <span class="comment"># provides access to the systemd journal</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">放置 rsyslog 辅助文件的路径</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">WorkDirectory /var/lib/rsyslog</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">时间格式</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">ActionFileDefaultTemplate RSYSLOG_TraditionalFileFormat</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">包含其他配置</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">IncludeConfig /etc/rsyslog.d/*.conf</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">OmitLocalLogging on</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">IMJournalStateFile imjournal.state</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">日志记录规则</span></span><br><span class="line">*.info;mail.none;authpriv.none;cron.none                /var/log/messages</span><br><span class="line">authpriv.*                                              /var/log/secure</span><br><span class="line">mail.*                                                  -/var/log/maillog</span><br><span class="line">cron.*                                                  /var/log/cron</span><br><span class="line">*.emerg                                                 :omusrmsg:*</span><br><span class="line">uucp,news.crit                                          /var/log/spooler</span><br><span class="line">local7.*                                                /var/log/boot.log</span><br></pre></td></tr></table></figure>

<p>其中最为关键的部分是日志记录规则，其配置格式如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务名称 连接符号 日志等级               日志记录位置</span></span><br><span class="line">authpriv.*                                              /var/log/secure</span><br></pre></td></tr></table></figure>
<p>以上配置，指定认证相关服务 (<code>authpriv</code>) 的所有等级的日志，记录在 <code>/var/log/secure</code> 日志中</p>
<p>多个服务可以指定同一个<code>日志记录位置</code>，多个 <code>服务名称 连接符号 日志等级</code> 中间使用 <code>;</code> 分割  </p>
<figure class="highlight shell"><figcaption><span>/etc/rsyslog.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">*.info;mail.none;authpriv.none;cron.none                /var/log/messages</span><br></pre></td></tr></table></figure>
<p>多个服务也可以共用同一个 <code>日志等级</code>，格式如下，多个 <code>服务名称</code> 使用 <code>,</code> 分割</p>
<figure class="highlight shell"><figcaption><span>/etc/rsyslog.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">uucp,news.crit                                          /var/log/spooler</span><br></pre></td></tr></table></figure>

<p><code>rsyslog</code> 服务可识别的服务如下</p>
<table>
<thead>
<tr>
<th>服务</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>auth</td>
<td>安全和认证相关消息 (不推荐使用 <code>authpriv</code> 替代）</td>
</tr>
<tr>
<td>authpirv</td>
<td>安全和认证相关信息（私有的）</td>
</tr>
<tr>
<td>cron</td>
<td>系统定时任务 <code>cront</code> 和 <code>at</code> 产生的日志</td>
</tr>
<tr>
<td>daemon</td>
<td>和各个守护进程相关的日志</td>
</tr>
<tr>
<td>ftp</td>
<td>ftp守护进程产生的日志</td>
</tr>
<tr>
<td>kern</td>
<td>内核产生的日志（不是用户进程产生的）</td>
</tr>
<tr>
<td>local0-local7</td>
<td>为本地使用预留的服务</td>
</tr>
<tr>
<td>lpr</td>
<td>打印机产生的日志</td>
</tr>
<tr>
<td>mail</td>
<td>邮件收发信息</td>
</tr>
<tr>
<td>news</td>
<td>与新闻服务器相关的日志</td>
</tr>
<tr>
<td>syslog</td>
<td>有 <code>rsyslog</code> 服务产生的日志信息（虽然服务名称已经改为 <code>rsyslog</code> 服务，但是很多配置都还是沿用了 <code>syslogd</code> 的，这里并没有修改服务名）</td>
</tr>
<tr>
<td>user</td>
<td>用户等级类别的日志信息</td>
</tr>
<tr>
<td>uucp</td>
<td><code>uucp</code> 子系统的日志信息，<code>uucp</code> 是早期 Linux 系统进行数据传递的协议，后来也经常用在新闻组服务中。</td>
</tr>
</tbody></table>
<p><code>rsyslog</code> 服务配置中可使用的连接符号如下</p>
<table>
<thead>
<tr>
<th>连接符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>.</code></td>
<td>代表只要比后面的等级高的（包含该等级）日志都记录下来。比如： <code>cron.info</code> 代表 <code>crond</code> 服务产生的日志，只要日志等级大于等于 <code>info</code> 级别，就记录。</td>
</tr>
<tr>
<td><code>.=</code></td>
<td>代表只记录所需等级的日志，其他等级的都不记录。比如： <code>*.=emerg</code> 代表任何日志服务产生的日志，只要等级是 <code>emerg</code> 等级就记录。</td>
</tr>
<tr>
<td><code>.!</code></td>
<td>代表不等于，也就是除了该等级的日志外，其他等级的日志都记录。</td>
</tr>
</tbody></table>
<p><code>rsyslog</code> 服务配置中可使用的日志等级如下</p>
<table>
<thead>
<tr>
<th>日志等级</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>debug</td>
<td>一般的调试信息说明</td>
</tr>
<tr>
<td>info</td>
<td>基本的通知信息</td>
</tr>
<tr>
<td>notice</td>
<td>普通信息，但是有一定的重要性</td>
</tr>
<tr>
<td>warning</td>
<td>警告信息，但是还不会影响到服务或系统的运行</td>
</tr>
<tr>
<td>err</td>
<td>错误信息，一般达到 <code>err</code> 等级的信息以及可以影响到服务或系统的运行了</td>
</tr>
<tr>
<td>crit</td>
<td>临界状况信息，比 <code>err</code> 等级还要严重</td>
</tr>
<tr>
<td>alert</td>
<td>警告状态信息，比 <code>crit</code> 还要严重。必须立即采取行动</td>
</tr>
<tr>
<td>emerg</td>
<td>致命（毁灭）等级信息，系统已经无法使用了</td>
</tr>
<tr>
<td>*</td>
<td>代表所有等级的日志</td>
</tr>
<tr>
<td>none</td>
<td>忽略这个日志服务，该服务的所有日志都不再记录</td>
</tr>
</tbody></table>
<p>可用的 <code>日志记录位置</code> 如下</p>
<table>
<thead>
<tr>
<th>日志记录位置</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>/var/log/secure</code></td>
<td>日志文件的绝对路径</td>
<td><code>/var/log/secure</code></td>
</tr>
<tr>
<td><code>/dev/lp0</code></td>
<td>系统设备文件</td>
<td>如 <code>/dev/lp0</code> 代表第一台打印机，如果日志保存位置是打印机设备，当有日志时就会在打印机上打印。</td>
</tr>
<tr>
<td>远程主机</td>
<td>可以选择使用 <code>TCP</code> (<code>@@192.168.0.210：514</code>) 和 <code>UDP</code> (<code>@192.168.0.210：514</code>) 协议传输日志信息</td>
<td></td>
</tr>
</tbody></table>
<p><code>日志记录位置</code> 之前可以加以下符号：</p>
<ul>
<li><code>-</code>  ： 表示延迟写入</li>
</ul>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3>]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>rsyslog</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 系统状态查看</title>
    <url>/202301171137/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos 7 kernel 5.4.221</li>
</ul>
<h1 id="查看内存信息"><a href="#查看内存信息" class="headerlink" title="查看内存信息"></a>查看内存信息</h1><p>内存相关概念说明：</p>
<ul>
<li>VSS ,Virtual Set Size , VERT - 虚拟耗用内存（包含共享库占用的内存）</li>
<li>RSS , Resident Set Size , RES- 实际使用物理内存（包含共享库占用的内存）</li>
<li>PSS , Proportional Set Size - 实际使用的物理内存（比例分配共享库占用的内存）</li>
<li>USS , Unique Set Size - 进程独自占用的物理内存（不包含共享库占用的内存）</li>
</ul>
<h2 id="查看某个进程使用的内存量"><a href="#查看某个进程使用的内存量" class="headerlink" title="查看某个进程使用的内存量"></a>查看某个进程使用的内存量</h2><p>比如检查 docker 使用的内存量，首先通过 <code>ps</code> 命令查询到 <code>docker</code> 的 pid 信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps -elf | grep docker</span></span><br><span class="line">4 S root      1243     1  4  80   0 - 1067527 futex_ Jan03 ?      15:14:45 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock</span><br></pre></td></tr></table></figure>
<p>例如此处的 <code>docker</code> 进程的 pid 为 1243</p>
<ul>
<li><p>使用 <code>top</code> 命令动态查看 <code>docker</code> 使用的内存信息</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">top -p 1243</span></span><br><span class="line">top - 11:47:40 up 14 days,  2:09,  3 users,  load average: 0.65, 1.42, 1.70</span><br><span class="line">Tasks:   1 total,   0 running,   1 sleeping,   0 stopped,   0 zombie</span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">Cpu(s):  1.0 us,  0.6 sy,  0.0 ni, 98.3 <span class="built_in">id</span>,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span></span><br><span class="line">KiB Mem : 32068748 total,  2494500 free, 18536188 used, 11038060 buff/cache</span><br><span class="line">KiB Swap:        0 total,        0 free,        0 used.  9586340 avail Mem </span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                           </span><br><span class="line"> 1243 root      20   0 4270108   1.4g  53956 S   1.0  4.6 914:55.80 dockerd</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>ps aux</code> 命令查看内存使用量</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps aux | grep 1243</span></span><br><span class="line">root      1243  4.5  4.6 4270108 1486460 ?     Ssl  Jan03 914:57 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock</span><br></pre></td></tr></table></figure>

<p>  输出结果中</p>
<ul>
<li>第 3、4 列 (<code>4.5  4.6</code>) 分别表示 <code>cpu 使用率</code>、<code>内存使用率</code>。</li>
<li>第 5、6 列 (<code>4270108 1486460</code>) 分别表示 <code>虚拟内存使用量</code>、<code>物理内存使用量</code>，单位为 <code>k</code>。</li>
</ul>
</li>
<li><p>通过进程的 <code>status</code> 文件查看内存使用</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /proc/1243/status</span></span><br><span class="line">Name:	dockerd</span><br><span class="line">Umask:	0022</span><br><span class="line">State:	S (sleeping)</span><br><span class="line">Pid:	1243</span><br><span class="line">PPid:	1</span><br><span class="line">VmPeak:	 4270364 kB</span><br><span class="line">VmSize:	 4270108 kB</span><br><span class="line">VmLck:	       0 kB</span><br><span class="line">VmPin:	       0 kB</span><br><span class="line">VmHWM:	 1562204 kB</span><br><span class="line">VmRSS:	 1492340 kB</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>其中，<code>VmRSS</code> 为进程使用的物理内存</p>
</li>
<li><p>使用 <code>pmap</code> 命令查看进程使用的内存信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pmap -x 1243</span><br><span class="line">pmap -p 1243</span><br></pre></td></tr></table></figure>
<span id="more"></span></li>
</ul>
<h2 id="内存使用量统计"><a href="#内存使用量统计" class="headerlink" title="内存使用量统计"></a>内存使用量统计</h2><p>查看使用内存排名前十的进程：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps aux | sort -k4,4nr | head -n 10</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 常用内核参数说明</title>
    <url>/202302131009/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><code>sysctl</code> 命令被用于在内核运行时动态地修改内核的运行参数，可用的内核参数在目录 <code>/proc/sys</code> 中。</p>
<p><code>sysctl</code> 命令对内核参数的修改仅在当前生效，重启系统后参数丢失。如果希望参数永久生效可以修改配置文件 <code>/etc/sysctl.conf</code>。</p>
<h1 id="常用内核参数说明"><a href="#常用内核参数说明" class="headerlink" title="常用内核参数说明"></a>常用内核参数说明</h1><table>
<thead>
<tr>
<th>内核参数</th>
<th>取值范围</th>
<th>含义</th>
<th>使用说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>kernel.hung_task_timeout_secs = 120</code></td>
<td>int</td>
<td>设置系统检测到进程阻塞(如 <a href="/202304181637/" title="&#96;D&#96; 状态">&#96;D&#96; 状态</a>)后，等待进程结束的时常。<br/>如果进程未在规定时间内结束，系统认为该进程无响应，则自动杀死以避免系统奔溃</td>
<td></td>
</tr>
</tbody></table>
<h2 id="mem"><a href="#mem" class="headerlink" title="mem"></a>mem</h2><table>
<thead>
<tr>
<th>内核参数</th>
<th>取值范围</th>
<th>含义</th>
<th>使用说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>vm.min_free_kbytes = 2097152</code></td>
<td>单位 <code>KB</code></td>
<td>设置系统最小剩余内存，以避免缓存不释放导致的死机</td>
<td></td>
</tr>
<tr>
<td><code>vm.oom-kill = 0</code></td>
<td>0,1<br/>默认值为 1，开启</td>
<td>是否启用 OOM-killer。<br/>特定情况下，可能不希望核心执行 OOM killer 的工作,关闭 OOM killer。 例如，排错时<br/><code>echo 0 &gt; /proc/sys/vm/oom-kill</code> 临时关闭 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[OOM](http://33f.net/linux/linux-Out-of-Memory-Killer.html)">[1]</span></a></sup></td>
<td></td>
</tr>
<tr>
<td><code>vm.overcommit_memory = 0</code></td>
<td>0,1,2</td>
<td>内存分配策略<br/><code>/proc/sys/vm/overcommit_memory</code></td>
<td><a href="#vm-overcommit-memory">vm.overcommit_memory 详细说明</a></td>
</tr>
<tr>
<td><code>vm.overcommit_ratio = 50</code></td>
<td>int  <br/>default &#x3D; 50</td>
<td><code>vm.overcommit_memory = 2</code> 时才生效，配置允许 <code>overcommit</code> 的百分比</td>
<td><a href="#vm-overcommit-memory">vm.overcommit_memory 详细说明</a></td>
</tr>
<tr>
<td><code>vm.panic_on_oom = 0</code></td>
<td>0,1<br/>默认为 0 ，开启</td>
<td>表示当内存耗尽时，内核会触发 OOM killer 杀掉最耗内存的进程</td>
<td></td>
</tr>
<tr>
<td><code>vm.oom_kill_allocating_task = 0</code></td>
<td>0,1<br/>默认为 0 ，不启用</td>
<td>OOM-Killer 时，是否选择当前正在申请内存的进程进行 kill</td>
<td></td>
</tr>
</tbody></table>
<span id="more"></span>
<h3 id="vm-overcommit-memory"><a href="#vm-overcommit-memory" class="headerlink" title="vm.overcommit_memory"></a>vm.overcommit_memory</h3><p>Linux 对大部分申请内存的请求都回复 <code>yes</code>，以便能跑更多更大的程序。因为申请内存后，并不会马上使用内存。这种技术叫做 <code>Overcommit</code>。当 Linux 发现内存不足时，会发生 <code>OOM killer(OOM=out-of-memory)</code>。它会选择杀死一些进程(用户态进程，不是内核线程)，以便释放内存。</p>
<p>当 <code>oom-killer</code> 发生时，Linux 会选择杀死哪些进程？选择进程的函数是 <code>oom_badness</code> 函数(在 <code>mm/oom_kill.c</code> 中)，该函数会计算每个进程的点数(0~1000)。点数越高，这个进程越有可能被杀死。每个进程的点数跟 <code>oom_score_adj</code> 有关，而且 <code>oom_score_adj</code> 可以被设置(-1000最低，1000最高)。</p>
<p><code>overcommit</code> 内存分配策略，可选值：0、1、2</p>
<ul>
<li><p><code>0</code> -  表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程。</p>
</li>
<li><p><code>1</code> -  表示内核允许分配所有的物理内存，而不管当前的内存状态如何。</p>
</li>
<li><p><code>2</code> -  表示内核允许分配超过所有物理内存和交换空间总和的内存</p>
<p> 当系统分配的内存超过 <code>swap+N%*物理RAM</code> (N%由 <code>vm.overcommit_ratio</code> 决定)时，会拒绝 commit</p>
</li>
</ul>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="http://33f.net/linux/linux-Out-of-Memory-Killer.html">OOM</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux systemd-journald 服务说明</title>
    <url>/202211211437/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="systemd-journald-服务简介"><a href="#systemd-journald-服务简介" class="headerlink" title="systemd-journald 服务简介"></a>systemd-journald 服务简介</h1><p><code>systemd-journald</code> 服务是 <code>systemd init</code> 系统提供的收集系统日志的服务。它会根据从内核、用户进程、标准输入和系统服务错误收到的日志记录信息，维护结构化的索引日记，并以此方式来收集和储存日志记录数据。<code>systemd-journald</code> 服务默认处于启用状态。</p>
<p>默认情况下，日记在 <code>/run/log/journal/</code> 中储存日志数据。由于 <code>/run/</code> 目录具有易失本性，因此，在重引导时会丢失日志数据。要永久保存日志数据，<code>/var/log/journal/</code> 目录必须存在且具有正确的所有权和权限，如此，<code>systemd-journald</code> 服务便可在其中储存其数据。</p>
<p>要在终端中查看日志信息，可以使用命令 <code>journalctl</code></p>
<h1 id="systemd-journald-服务常用配置"><a href="#systemd-journald-服务常用配置" class="headerlink" title="systemd-journald 服务常用配置"></a>systemd-journald 服务常用配置</h1><h2 id="持久化日志存储"><a href="#持久化日志存储" class="headerlink" title="持久化日志存储"></a>持久化日志存储</h2><p>默认情况下，日志位于 <code>/run/log/journal/</code>，重启后日志会丢失，为了持久化日志，可按照以下 2 种方法之一配置</p>
<ul>
<li><p>方法 1</p>
<ol>
<li>以 <code>root</code> 身份打开 <code>/etc/systemd/journald.conf</code> 进行编辑 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/systemd/journald.conf</span><br></pre></td></tr></table></figure></li>
<li>将包含 <code>Storage=</code> 的行取消注释，并将它更改为 <code>Storage=persistent</code><figure class="highlight shell"><figcaption><span>/etc/systemd/journald.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">[Journal]</span><br><span class="line">Storage=persistent</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Compress=<span class="built_in">yes</span></span></span><br><span class="line">SystemMaxUse=50M</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure></li>
<li>重启动 <code>systemd-journald</code> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart systemd-journald</span><br></pre></td></tr></table></figure>
之后日志会持久化存储于 <code>/var/log/journal</code>。这些数据最多会占用 <code>/var/log/journal</code> 所在文件系统空间的 10%，要更改此限制，可以修改选项 <code>SystemMaxUse=50M</code></li>
</ol>
</li>
</ul>
<span id="more"></span>

<ul>
<li>方法 2<ol>
<li>创建目录 <code>/var/log/journal</code></li>
<li>重启日志服务 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemd-journald.service</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h1 id="journalctl-命令查看日志"><a href="#journalctl-命令查看日志" class="headerlink" title="journalctl 命令查看日志"></a>journalctl 命令查看日志</h1><p>不带任何选项时，<code>journalctl</code> 输出所有的日志。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">journalctl</span> </span><br><span class="line">-- Logs begin at Thu 2022-11-17 12:09:10 CST, end at Mon 2022-11-21 14:53:36 CST. --</span><br><span class="line">Nov 17 12:09:10 localhost systemd-journal[156]: Runtime journal is using 8.0M (max allowed 380.5M, trying to leave 570</span><br><span class="line">Nov 17 12:09:10 localhost kernel: Linux version 5.4.217-1.el7.elrepo.x86_64 (mockbuild@Build64R7) (gcc version 9.3.1 2</span><br><span class="line">Nov 17 12:09:10 localhost kernel: Command line: BOOT_IMAGE=/boot/vmlinuz-5.4.217-1.el7.elrepo.x86_64 root=UUID=44a6a61</span><br><span class="line">Nov 17 12:09:10 localhost kernel: x86/fpu: Supporting XSAVE feature 0x001: &#x27;x87 floating point registers&#x27;</span><br><span class="line">Nov 17 12:09:10 localhost kernel: x86/fpu: Supporting XSAVE feature 0x002: &#x27;SSE registers&#x27;</span><br><span class="line">Nov 17 12:09:10 localhost kernel: x86/fpu: Supporting XSAVE feature 0x004: &#x27;AVX registers&#x27;</span><br><span class="line">Nov 17 12:09:10 localhost kernel: x86/fpu: Supporting XSAVE feature 0x008: &#x27;MPX bounds registers&#x27;</span><br><span class="line">Nov 17 12:09:10 localhost kernel: x86/fpu: Supporting XSAVE feature 0x010: &#x27;MPX CSR&#x27;</span><br><span class="line">Nov 17 12:09:10 localhost kernel: x86/fpu: Supporting XSAVE feature 0x020: &#x27;AVX-512 opmask&#x27;</span><br><span class="line">Nov 17 12:09:10 localhost kernel: x86/fpu: Supporting XSAVE feature 0x040: &#x27;AVX-512 Hi256&#x27;</span><br><span class="line">Nov 17 12:09:10 localhost kernel: x86/fpu: Supporting XSAVE feature 0x080: &#x27;AVX-512 ZMM_Hi256&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>日常使用中，需要配合各种匹配策略类匹配具体的日志。我们可以通过 <code>FIELD=VALUE</code> 的格式来匹配具体的日志记录，通过 <code>man 7 systemd.journal-fields</code> 可以查看所有可用的 <code>match</code> 字段</p>
<h2 id="日志匹配"><a href="#日志匹配" class="headerlink" title="日志匹配"></a>日志匹配</h2><p>通过字段 <code>_SYSTEMD_UNIT=cron.service</code> 可以查看服务 <code>cron.service</code> 的日志，等同于选项 <code>-u cron.service</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">journalctl -u crond</span><br><span class="line">journalctl _SYSTEMD_UNIT=crond.service</span><br></pre></td></tr></table></figure>

<p>可以同时添加多个字段进行匹配，它们之间是与的关系，就是同时符合多个条件的记录才会被匹配，比如添加 <code>PRIORITY</code> 字段的匹配条件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">journalctl _SYSTEMD_UNIT=crond.service PRIORITY=6</span><br></pre></td></tr></table></figure>
<p>注意各个字段的取值，比如为 <code>PRIORITY</code> 设置 <code>debug</code>、<code>info</code> 是不工作的，必须设置为对应的数字。可以通过 <code>-F</code> 选项来查看某个字段的可选值：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">journalctl -F PRIORITY</span></span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对同一个字段使用多个字段匹配时，相当于 <strong>或</strong> 的关系，匹配的字段都会输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">journalctl _SYSTEMD_UNIT=cron.service _SYSTEMD_UNIT=prometheus.service</span><br></pre></td></tr></table></figure>
<p>此时 <code>cron.service</code> 和 <code>prometheus.service</code> 的日志都会输出。</p>
<p>使用 <code>+</code> 号可以对多个匹配字段执行 <strong>或</strong> 操作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">journalctl _SYSTEMD_UNIT=cron.service + _PID=28097</span><br></pre></td></tr></table></figure>
<p>上面的命令会输出 cron.service 的日志和进程 28097 的日志。</p>
<p>下面是一个更复杂的例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">journalctl _SYSTEMD_UNIT=avahi-daemon.service _PID=28097 + _SYSTEMD_UNIT=dbus.service</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>前面的两个条件是 <strong>与</strong> 的关系，最后一个条件与前面的两个条件是 <strong>或</strong> 的关系，也就是相当于用小括号把前面的两个条件括起来。</p>
<h2 id="查看指定时间段的日志"><a href="#查看指定时间段的日志" class="headerlink" title="查看指定时间段的日志"></a>查看指定时间段的日志</h2><p>利用 <code>--since</code> 与 <code>--until</code> 选项设定时间段，二者分别负责指定给定时间之后与之前的日志记录，时间格式可以使用多种，如：<code>YYYY-MM-DD HH:MM:SS</code>，格式中的某些组成部分未进行填写，系统会直接进行默认填充。例如，如果日期部分未填写，则会直接显示当前日期。如果时间部分未填写，则缺省使用 <code>00:00:00</code>(午夜)。秒字段亦可留空，默认值为 “00”</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">journalctl _SYSTEMD_UNIT=cron.service --since &quot;2018-03-27&quot; --until &quot;2018-03-27 01:00&quot;</span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.cnblogs.com/sparkdev/p/8795141.html">linux journalctl 命令 </a></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>tar 命令用法</title>
    <url>/202302231000/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>常用选项</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>-c</code></td>
<td>打包文件</td>
<td></td>
</tr>
<tr>
<td><code>-x</code></td>
<td>解包</td>
<td></td>
</tr>
<tr>
<td><code>-t</code></td>
<td>检测打包文件中的内容</td>
<td><code>tar -tf test.tar</code></td>
</tr>
<tr>
<td><code>-f</code></td>
<td>目标文件名称，要打包或解包的文件名</td>
<td><code>tar -cf test.tar test</code> <br/><code>tar -xf test.tar</code></td>
</tr>
<tr>
<td><code>--exclude</code></td>
<td>打包时排除文件<br/>打包的目录使用相对路径，排除的文件只能接相对路径<br/>打包的目录使用绝对路径，排除的文件接相对路径或绝对路径</td>
<td><code>tar -cf test.tar test --exclude=runtime/*</code></td>
</tr>
</tbody></table>
<span id="more"></span>

<h1 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h1><h2 id="排除指定文件或目录"><a href="#排除指定文件或目录" class="headerlink" title="排除指定文件或目录"></a>排除指定文件或目录</h2><ul>
<li><strong>打包的目录使用相对路径，排除的文件只能接相对路径</strong></li>
<li><strong>打包的目录使用绝对路径，排除的文件接相对路径或绝对路径</strong></li>
</ul>
<p><strong>建议打包的目录和排除的文件使用的使用路径时，保持一致，都是用绝对路径，或都是用相对路径</strong> <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[tar命令之--exclude参数 排除指定的文件或目录](https://cloud.tencent.com/developer/article/1360591)">[1]</span></a></sup></p>
<p>以下示例可正常执行排除操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -cf test.tar test --exclude=runtime/*</span><br><span class="line">tar -cf test.tar /home/www/test/ --exclude=/home/www/test/runtime/*</span><br><span class="line">tar -cf test.tar /home/www/test/ --exclude=runtime/*</span><br></pre></td></tr></table></figure>
<p>以下示例无法排除掉指定的文件或者目录，<strong>所有打包目录下面的文件都会被打包</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -cf test.tar test --exclude=/home/www/runtime/*</span><br></pre></td></tr></table></figure>

<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://cloud.tencent.com/developer/article/1360591">tar命令之--exclude参数 排除指定的文件或目录</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux tcp_wrappers 详解</title>
    <url>/202208171106/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Centos 7</li>
</ul>
<p><code>TCP_wrappers</code> 主要是工作在应用层的一个安全工具，使用访问控制列表（<code>ACL</code>）来防止主机名和主机地址的欺骗，用于过滤对 <code>类 Unix</code> 系统的网络访问。  </p>
<p>在一个安全的系统中，<code>Linux</code> 自身具有两层安全的防火墙。第一层是通过 IP&#x2F;Port 过滤机制的 <code>iptables</code> 来实现，第二层，也就是 <code>TCP_wrappers</code> 了，它主要是通过对系统中的某些服务进行开放与关闭，允许和禁止来有效保证系统安全运行。<br>可以简单理解为 <code>Linux</code> 系统访问控制的流程：  </p>
<blockquote>
<p>Client -&gt; iptables -&gt; TCP_wrappers -&gt; Server 的访问控制</p>
</blockquote>
<ul>
<li>iptables ：基于源 IP&#x2F;端口、目的 IP&#x2F;端口进行访问控制</li>
<li>TCP_wrappers：基于服务自身运行情况进行访问控制</li>
<li>Server：基于服务器本身行为包括文件、目录等权限进行访问控制</li>
</ul>
<span id="more"></span>

<h3 id="TCP-wrappers-的工作原理"><a href="#TCP-wrappers-的工作原理" class="headerlink" title="TCP_wrappers 的工作原理"></a>TCP_wrappers 的工作原理</h3><p><code>TCP_wrappers</code> 通过访问控制列表来提供保护机制，同时依赖 <code>/etc/hosts.allow</code> 和 <code>/etc/hosts.deny</code> 配置文件所设定的规则转交给相应的守护进程进行处理，同时记录请求过程。</p>
<p><code>TCP_wrappers</code> 在对报文做过滤操作的过程中，会链接到 <code>TCP_wrappers</code> 的函数库， <code>TCP_wrappers</code> 的主要功能是来自于 <code>libwrap.a</code> 这个静态库。</p>
<p>服务是否可以使用 <code>TCP_wrappers</code> 进行安全防护，取决于服务程序在编译时是否针对 <code>libwrap</code> 进行编译，如果库文件中有 <code>libwrap.so</code> 文件，就可以实现访问控制</p>
<p>可以通过下面的命令来确定要过滤的服务是否已经链接到了 <code>libwrap</code> 这个函数库中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ldd /usr/sbin/sshd | grep libwrap</span></span><br><span class="line">	libwrap.so.0 =&gt; /lib64/libwrap.so.0 (0x00007f283cdf1000)</span><br></pre></td></tr></table></figure>

<p>当客户端的 IP 通过了安全系统中第一层（iptables 防火墙），想要进一步访问服务器资源时，系统就会由 <code>TCP_wrappers</code> 来对请求进行分析处理，根据服务设定的规则来查看这个请求是否存在于 <code>/etc/hosts.allow</code> 列表中，如果存在就接受；如果不存在就继续对比 <code>/etc/hosts/deny</code> 列表，如果存在于 <code>hosts.deny</code> 中就拒绝 IP 请求，反之则接受请求。  </p>
<p><strong>判断规则的文件顺序必须严格按照先 <code>hosts.allow</code> 再 <code>hosts.deny</code> 的顺序进行判断。同时，<code>TCP_wrappers</code> 不会缓存 <code>hosts.allow</code> 和 <code>hosts.deny</code> 中的规则，所以针对 <code>hosts.allow</code> 和 <code>hosts.deny</code> 中规则的更改是立即生效的。</strong></p>
<h3 id="TCP-wrappers-的配置"><a href="#TCP-wrappers-的配置" class="headerlink" title="TCP_wrappers 的配置"></a>TCP_wrappers 的配置</h3><p><code>TCP_wrappers</code> 实现防火墙的功能主要是依靠 <code>/etc/hosts.allow</code> 和 <code>/etc/hosts.deny</code> 这两个文件的。<code>/etc/hosts.allow</code> 主要是定义允许访问，<code>/etc/hosts.deny</code> 用来定义拒绝访问。  </p>
<p>配置文件中的配置格式如下，格式说明可以参考 <code>man 5 hosts_options</code></p>
<figure class="highlight shell"><figcaption><span>/etc/hosts.allow</span></figcaption><table><tr><td class="code"><pre><span class="line">daemon_list[@host] : client_list : option : option ...</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>daemon_list</code> ： 服务名，例如：sshd、vsftpd、sendmail 等，多个服务之间使用逗号分割。</li>
<li><code>client_list</code> : IP 或 IP 段或主机名。（列表中存在多个服务或者主机的时候用 , 逗号分隔开）</li>
<li><code>option</code> : 包括对匹配规则的 <code>action</code>， 最主要的有 <code>allow</code> 或 <code>deny</code>（这个可以忽略不写）</li>
</ul>
<p>例如，配置限制 <code>192.168.0.0/16</code> 网段不能 <code>ssh</code> 到本机的 <code>sshd</code> 服务</p>
<figure class="highlight shell"><figcaption><span>/etc/hosts.deny</span></figcaption><table><tr><td class="code"><pre><span class="line">sshd:192.168.</span><br></pre></td></tr></table></figure>
<p>如上配置后，指定网段不能 <code>ssh</code> 到本机  </p>
<p>配置后有问题，可以查看日志文件 <code>/var/log/secure</code>，如配置有问题，日志中会记录相关日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /var/log/secure</span></span><br><span class="line">sshd[7699]: error: /etc/hosts.allow, line 12: bad option name: &quot;%d&quot;&quot;</span><br></pre></td></tr></table></figure>

<h4 id="配置文件中-daemon-list-常用格式"><a href="#配置文件中-daemon-list-常用格式" class="headerlink" title="配置文件中 daemon_list 常用格式"></a>配置文件中 daemon_list 常用格式</h4><table>
<thead>
<tr>
<th>格式</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>ALL</code></td>
<td>完全匹配，适配所有接受 <code>TCP_wrappers</code> 防护的服务</td>
<td></td>
</tr>
<tr>
<td><code>service1</code><br/><code>service1,service2</code><br/><code>service1@172.16.1.2</code></td>
<td>指定服务<br/>多个服务使用逗号分割<br/>针对本机的某个 ip 做限制</td>
<td><code>sshd,vsftpd:192.168.1.:allow</code></td>
</tr>
</tbody></table>
<h4 id="配置文件中-client-list-常用格式"><a href="#配置文件中-client-list-常用格式" class="headerlink" title="配置文件中 client_list 常用格式"></a>配置文件中 client_list 常用格式</h4><table>
<thead>
<tr>
<th>格式</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>ALL</code></td>
<td>完全匹配，适配所有客户端</td>
<td></td>
</tr>
<tr>
<td><code>.HOSTNAME</code></td>
<td>适配整个域</td>
<td><code>sshd:.csms.tech:allow</code>，允许 <a href="https://csms.tech/"><code>csms.tech</code></a> 内的所有主机访问</td>
</tr>
<tr>
<td><code>192.168.</code><br/><code>192.168.0.0/255.255.0.0</code><br/><code>192.168.0.0/16</code></td>
<td>适配整个网段，会匹配到 <code>192.168.0.0/16</code> 网段</td>
<td></td>
</tr>
<tr>
<td><code>172.16. EXCEPT 172.16.100.0/24</code></td>
<td>排除部分客户端</td>
<td><code>172.16. EXCEPT 172.16.100.0/24 EXCEPT 172.16.10.1</code></td>
</tr>
</tbody></table>
<h4 id="配置文件中-option-常用格式"><a href="#配置文件中-option-常用格式" class="headerlink" title="配置文件中 option 常用格式"></a>配置文件中 option 常用格式</h4><table>
<thead>
<tr>
<th>格式</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>allow</code></td>
<td>主要用在 <code>/etc/hosts.deny</code> 定义 <code>允许</code> 规则</td>
<td></td>
</tr>
<tr>
<td><code>deny</code></td>
<td>主要用在 <code>/etc/hosts.allow</code> 定义 <code>拒绝</code> 规则</td>
<td></td>
</tr>
<tr>
<td><code>spawn</code></td>
<td>启动一个外部程序(<code>shell</code>)完成指定的命令</td>
<td></td>
</tr>
<tr>
<td><code>twist</code></td>
<td>替换客户端的请求成我们指定的命令，会导致服务拒绝，即使写在 <code>/etc/hosts.allow</code></td>
<td></td>
</tr>
</tbody></table>
<h5 id="spawn-示例"><a href="#spawn-示例" class="headerlink" title="spawn 示例"></a>spawn 示例</h5><p>在 <code>/etc/hosts.allow</code> 中添加以下内容</p>
<figure class="highlight shell"><figcaption><span>/etc/hosts.allow</span></figcaption><table><tr><td class="code"><pre><span class="line">sshd: ALL :\</span><br><span class="line">         spawn echo $(date +%%F) login attempt from %c to %s,%d &gt;&gt;/var/log/sshd.log</span><br></pre></td></tr></table></figure>
<p>以上配置，会在客户端 ssh 登录时记录日志  </p>
<p>其中，可以变量包含以下</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>%a</code></td>
<td>客户端的 IP 地址</td>
</tr>
<tr>
<td><code>%A</code></td>
<td>服务端的 IP 地址</td>
</tr>
<tr>
<td><code>%d	</code></td>
<td>守护进程的名字</td>
</tr>
<tr>
<td><code>%h</code></td>
<td>客户端的主机名</td>
</tr>
<tr>
<td><code>%H</code></td>
<td>服务端的主机名</td>
</tr>
<tr>
<td><code>%p</code></td>
<td>守护进程的 pid</td>
</tr>
<tr>
<td><code>%u</code></td>
<td>客户端的用户名</td>
</tr>
</tbody></table>
<h5 id="twist-示例"><a href="#twist-示例" class="headerlink" title="twist 示例"></a>twist 示例</h5><p>在 <code>/etc/hosts.allow</code> 中添加以下内容</p>
<figure class="highlight shell"><figcaption><span>/etc/hosts.allow</span></figcaption><table><tr><td class="code"><pre><span class="line">vsftpd: 172.16.0.1 :twist /bin/echo “connection prohibited”</span><br></pre></td></tr></table></figure>

<p>以上配置会将客户端的请求替换成 <code>twist</code> 指定的命令，因此客户端无法使用指定的服务，即使配置在 <code>/etc/hosts.allow</code> 中</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://m-zhoujie2.gitbooks.io/-linux-devops-2/content/chapter3-5.html">TCP wrappers</a></p>
<p><a href="https://www.cnblogs.com/duzhaoqi/p/7607801.html">TCP_Wrappers</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>tcp_wrappers</tag>
      </tags>
  </entry>
  <entry>
    <title>tcpdump 抓包命令使用</title>
    <url>/202210241503/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="tcpdump-命令格式说明"><a href="#tcpdump-命令格式说明" class="headerlink" title="tcpdump 命令格式说明"></a>tcpdump 命令格式说明</h1><p><img src="https://i.csms.tech/img_67.png"></p>
<ul>
<li><code>option</code> - <a href="#%E5%B8%B8%E7%94%A8%E9%80%89%E9%A1%B9">可选选项（参数）</a> </li>
<li><code>proto</code> - 协议类过滤器：根据协议进行过滤，可识别的关键词有： <code>tcp</code>, <code>udp</code>, <code>icmp</code>, <code>ip</code>, <code>ip6</code>, <code>arp</code>, <code>rarp</code>,<code>ether</code>,<code>wlan</code>, <code>fddi</code>, <code>tr</code>, <code>decnet</code></li>
<li><code>direction</code> - 数据流向类过滤器：根据数据流向进行过滤，可识别的关键字有：<code>src</code>, <code>dst</code>，同时你可以使用逻辑运算符进行组合，比如 <code>src or dst</code></li>
<li><code>type</code> 类过滤器：可识别的关键词有：<code>host</code>, <code>net</code>, <code>port</code>, <code>portrange</code>，这些词后边需要再接参数。</li>
</ul>
<h2 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h2><table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>-i</code></td>
<td>目标网卡</td>
<td></td>
</tr>
<tr>
<td><code>-n</code> <br/><code>-nn</code></td>
<td>不对 IP&#x2F;DOMAIN 进行解析<br/> 不对 IP&#x2F;DOMAIN 及 PORT 进行解析</td>
<td></td>
</tr>
<tr>
<td><code>-w</code></td>
<td>将结果写入文件</td>
<td><code>tcpdump icmp -w icmp.pcap</code></td>
</tr>
</tbody></table>
<span id="more"></span>

<h1 id="tcpdump-命令输出内容说明"><a href="#tcpdump-命令输出内容说明" class="headerlink" title="tcpdump 命令输出内容说明"></a>tcpdump 命令输出内容说明</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">21:26:49.013621 IP 172.20.20.1.15605 &gt; 172.20.20.2.5920: Flags [P.], seq 49:97, ack 106048, win 4723, length 48</span><br></pre></td></tr></table></figure>
<ol>
<li>第一列：时分秒毫秒 21:26:49.013621</li>
<li>第二列：网络协议 IP</li>
<li>第三列：发送方的 ip 地址+端口号，其中 172.20.20.1 是 ip，而 15605 是端口号</li>
<li>第四列：箭头 &gt;， 表示数据流向</li>
<li>第五列：接收方的 ip 地址+端口号，其中 172.20.20.2 是 ip，而 5920 是端口号</li>
<li>第六列：冒号</li>
<li>第七列：数据包内容，包括 Flags 标识符，seq 号，ack 号，win 窗口，数据长度 length，其中 [P.] 表示 PUSH 标志位为 1，更多标识符见下面</li>
</ol>
<h2 id="Flags-标识符"><a href="#Flags-标识符" class="headerlink" title="Flags 标识符"></a>Flags 标识符</h2><p>使用 <code>tcpdump</code> 抓包后，会遇到的 TCP 报文 Flags，有以下几种：</p>
<ul>
<li>[S] : <code>SYN</code>（开始连接）</li>
<li>[P] : <code>PSH</code>（推送数据）</li>
<li>[F] : <code>FIN</code> （结束连接）</li>
<li>[R] : <code>RST</code>（重置连接）</li>
<li>[.] : 没有 Flag （意思是除上面四种类型外的其他情况，有可能是 <code>ACK</code> 也有可能是 <code>URG</code>）</li>
</ul>
<h1 id="常见用法示例"><a href="#常见用法示例" class="headerlink" title="常见用法示例"></a>常见用法示例</h1><h2 id="基于IP地址过滤：host"><a href="#基于IP地址过滤：host" class="headerlink" title="基于IP地址过滤：host"></a>基于IP地址过滤：host</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tcpdump host 192.168.10.100</span><br><span class="line"></span><br><span class="line">tcpdump -i eth0 src 192.168.10.100</span><br><span class="line"></span><br><span class="line">tcpdump -i eth0 dst 192.168.10.100</span><br></pre></td></tr></table></figure>

<h2 id="基于网段进行过滤：net"><a href="#基于网段进行过滤：net" class="headerlink" title="基于网段进行过滤：net"></a>基于网段进行过滤：net</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tcpdump net 192.168.10.0/24</span><br><span class="line"></span><br><span class="line">tcpdump src net 192.168</span><br><span class="line"></span><br><span class="line">tcpdump dst net 192.168</span><br></pre></td></tr></table></figure>

<h2 id="基于端口进行过滤：port"><a href="#基于端口进行过滤：port" class="headerlink" title="基于端口进行过滤：port"></a>基于端口进行过滤：port</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tcpdump src port 8088</span><br><span class="line"></span><br><span class="line">tcpdump dst port 8088</span><br><span class="line"></span><br><span class="line">tcpdump port 80 or port 8088</span><br><span class="line"></span><br><span class="line">tcpdump port 80 or 8088</span><br><span class="line"></span><br><span class="line">tcpdump portrange 8000-8080</span><br><span class="line"></span><br><span class="line">tcpdump src portrange 8000-8080</span><br><span class="line"></span><br><span class="line">tcpdump dst portrange 8000-8080</span><br></pre></td></tr></table></figure>

<h2 id="基于协议进行过滤：proto"><a href="#基于协议进行过滤：proto" class="headerlink" title="基于协议进行过滤：proto"></a>基于协议进行过滤：proto</h2><p>常见的网络协议有：tcp, udp, icmp, http, ip,ipv6 等</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tcpdump icmp</span><br></pre></td></tr></table></figure>
<p>protocol 可选值：ip, ip6, arp, rarp, atalk, aarp, decnet, sca, lat, mopdl, moprc, iso, stp, ipx, or netbeui</p>
<h2 id="组合过滤规则"><a href="#组合过滤规则" class="headerlink" title="组合过滤规则"></a>组合过滤规则</h2><p>支持的运算符：</p>
<ul>
<li><code>and</code> - 所有的条件都需要满足，也可以表示为 <code>&amp;&amp;</code></li>
<li><code>or</code> - 只要有一个条件满足就可以，也可以表示为 <code>||</code></li>
<li><code>not</code> - 取反，也可以使用 <code>!</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tcpdump src 10.5.2.3 and dst port 3389</span><br><span class="line"></span><br><span class="line">tcpdump &#x27;src 10.0.2.4 and (dst port 3389 or 22)&#x27;</span><br></pre></td></tr></table></figure>


<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.cnblogs.com/wongbingming/p/13212306.html">tcpdump 抓包指南</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>tcpdump</tag>
      </tags>
  </entry>
  <entry>
    <title>linux tun/tap 设备的工作原理</title>
    <url>/202304241633/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>从 Linux 文件系统的角度看，tun&#x2F;tap 设备是用户可以使用文件句柄操作的字符设备</p>
<p>从 Linux 网络虚拟化的角度看，tun&#x2F;tap 设备是虚拟网卡，一端连接内核网络协议栈，一端连接用户态的程序。</p>
<p>tun&#x2F;tap 设备主要的作用是可以将 TCP&#x2F;IP 协议栈处理好的数据包发送给任何一个使用 tun&#x2F;tap 设备驱动的程序，由用户态程序重新处理数据包后重新发送到 TCP&#x2F;IP 协议栈。</p>
<p>tun&#x2F;tap 设备的工作原理完全相同，主要区别在于：</p>
<ul>
<li>tun 设备的 &#x2F;dev&#x2F;tunX 文件收发的是 IP 包，因此只能工作在网络层（L3），无法与物理网卡做桥接，可以通过三层交换(如 ip_forward) 与物理网卡交互</li>
<li>tap 设备的 &#x2F;dev&#x2F;tapX 文件收发的是数据链路层报文，可以与物理网卡做桥接。</li>
</ul>
<h1 id="tun-x2F-tap-设备的工作原理"><a href="#tun-x2F-tap-设备的工作原理" class="headerlink" title="tun&#x2F;tap 设备的工作原理"></a>tun&#x2F;tap 设备的工作原理</h1><p><img src="https://i.csms.tech/img_135.png"></p>
<p>上图展示了物理设备上的数据是如何通过 Linux 内核网络协议栈发送到用户态程序的。</p>
<p>物理网卡的数据送达网络协议栈，进程通过 Socket 创建特殊套接字，从网络协议栈接收数据。</p>
<p>从网络协议栈的角度看，tun&#x2F;tap 设备这类虚拟网卡与物理网卡并无区别。对 tun&#x2F;tap 设备而言，他与物理网卡的不同表现在它的数据源不是物理链路，而是来自用户态。</p>
<p><img src="https://i.csms.tech/img_136.png"></p>
<p>普通的物理网卡通过网线收发数据包，而 tun&#x2F;tap 设备通过一个设备文件 （<code>/dev/tunX</code>，<code>/dev/tapX</code>）收发数据包，所有对这个文件的写操作会通过 tun&#x2F;tap 设备转换成一个网络数据包传送给内核的网络协议栈。当内核网络协议栈发送一个包给 tun&#x2F;tap 设备时，用户态的进程通过读取设备文件，就可以拿到报的内容。用户态的程序也可以通过写入这个设备文件向 tun&#x2F;tap 设备发送数据。</p>
<h1 id="VPN-原理简述"><a href="#VPN-原理简述" class="headerlink" title="VPN 原理简述"></a>VPN 原理简述</h1><p><img src="https://i.csms.tech/img_137.png"></p>
<p>如上图所示，整个数据包的流程包括</p>
<ol>
<li>App1 通过 Socket API 发送了一个数据包，假设这个数据包的目的 IP 地址是 192.168.1.3，和 tun0 位于同一个网段</li>
<li>数据包到达网络协议栈后，协议栈根据数据包的目的 IP 地址进行路由，匹配到数据包应该发送给 tun0 网卡，于是将数据包发送给 tun0 网卡</li>
<li>tun0 网卡收到数据包，将数据包写入 &#x2F;dev&#x2F;tun0，&#x2F;dev&#x2F;tun0 由 App2 打开，于是 App2 获得了数据包</li>
<li>App2 获得数据包后，通过报文封装，将原来的目的 IP 为 192.168.1.3 的报文封装在源 IP 为 eth0 的 IP，目的 IP 为 VPN 对端 IP 地址的报文中，构造出新的报文，并通过   Socket API 发送给内核网络协议栈</li>
<li>内核网络协议栈根据路由，发现数据包应该由 eth0 发送出去，于是将数据包发给 eth0，最终通过 eth0 将数据包发送到 VPN 的对端。</li>
</ol>
<p>综上所述，发到 192.168.1.0&#x2F;24 的数据包，首先通过监听在 tun0 设备上的 App2 （VPN 客户端）进行封包，再利用物理网卡 eth0 发送到远端网络的物理网卡上，从而实现 VPN。</p>
<p>VPN 网络报文真正从物理网卡出去需要经过 2 次内核网络协议栈，因此会有一定的性能损耗。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>network</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>LVM 逻辑卷管理</title>
    <url>/202208021256/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>LVM是 Logical Volume Manager(逻辑卷管理)的简写,LVM将一个或多个硬盘或分区在逻辑上集合，相当于一个大硬盘来使用，当硬盘的空间不够使用的时候，可以继续将其它的硬盘或分区加入其中，这样可以实现磁盘空间的动态管理，相对于普通的磁盘分区有很大的灵活性。与传统的磁盘与分区相比，LVM为计算机提供了更高层次的磁盘存储。它使系统管理员可以更方便的为应用与用户分配存储空间。  </p>
<blockquote>
<p><strong><code>/boot</code> 分区不可以在逻辑卷组上,否则bootloader会无法读取.</strong></p>
</blockquote>
<span id="more"></span>

<h3 id="LVM-原理简介"><a href="#LVM-原理简介" class="headerlink" title="LVM 原理简介"></a>LVM 原理简介</h3><p>单一硬盘系统的 LVM 基本原理如下图所示<br><img src="https://i.csms.tech/img_23.png"></p>
<p>多硬盘系统的 LVM 基本原理如下图所示<br><img src="https://i.csms.tech/img_24.png"><br><img src="https://i.csms.tech/img_25.png"></p>
<h4 id="基本概念说明"><a href="#基本概念说明" class="headerlink" title="基本概念说明"></a>基本概念说明</h4><h5 id="PV（Physical-Volume）-物理卷"><a href="#PV（Physical-Volume）-物理卷" class="headerlink" title="PV（Physical Volume）- 物理卷"></a>PV（Physical Volume）- 物理卷</h5><p>物理卷在逻辑卷管理中处于最底层，它可以是实际物理硬盘上的分区，也可以是整个物理硬盘，也可以是raid设备,是LVM的基本存储逻辑块，但和基本的物理存储介质(如分区、磁盘等)比较，却包含有与LVM相关的管理参数。  </p>
<p>PE（physical extent）：每一个物理卷被划分为称为PE(Physical Extents)的基本单元，具有唯一编号的PE是可以被LVM寻址的最小单元。PE的大小是在VG过程中配置的，默认为4MB。</p>
<h5 id="VG（Volumne-Group）-卷组"><a href="#VG（Volumne-Group）-卷组" class="headerlink" title="VG（Volumne Group）- 卷组"></a>VG（Volumne Group）- 卷组</h5><p>卷组建立在物理卷之上，一个卷组中至少要包括一个物理卷，在卷组建立之后可动态添加物理卷到卷组中。一个逻辑卷管理系统工程中可以只有一个卷组，也可以拥有多个卷组。  </p>
<h5 id="LV（Logical-Volume）-逻辑卷"><a href="#LV（Logical-Volume）-逻辑卷" class="headerlink" title="LV（Logical Volume）- 逻辑卷"></a>LV（Logical Volume）- 逻辑卷</h5><p>逻辑卷建立在卷组之上，卷组中的未分配空间可以用于建立新的逻辑卷，逻辑卷建立后可以动态地扩展和缩小空间。系统中的多个逻辑卷可以属于同一个卷组，也可以属于不同的多个卷组。</p>
<h3 id="LVM-基本操作"><a href="#LVM-基本操作" class="headerlink" title="LVM 基本操作"></a>LVM 基本操作</h3><h4 id="创建-PV-常用操作命令"><a href="#创建-PV-常用操作命令" class="headerlink" title="创建 PV 常用操作命令"></a>创建 PV 常用操作命令</h4><p>将空闲分区 <code>/dev/vdb1</code> 配置为可用的 PV（Physical Volume）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pvcreate /dev/vdb1</span><br></pre></td></tr></table></figure>
<p>将空闲磁盘 <code>/dev/vdd</code> 配置为可用的 PV（Physical Volume）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pvcreate /dev/vdd </span><br></pre></td></tr></table></figure>
<p>查看 PV 的信息，常用以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pvs</span><br><span class="line">pvscan</span><br><span class="line">pvdisplay</span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_26.png"><br><img src="https://i.csms.tech/img_27.png"></p>
<h4 id="创建-VG-常用操作命令"><a href="#创建-VG-常用操作命令" class="headerlink" title="创建 VG 常用操作命令"></a>创建 VG 常用操作命令</h4><p>使用已有的PV ，创建卷组（Volumne Group）名为 <code>VG1</code> 的 VG</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vgcreate VG1 /dev/vdb1 /dev/vdd</span><br></pre></td></tr></table></figure>

<p>查看 VG 的信息，常用以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vgs</span><br><span class="line">vgscan</span><br><span class="line">vgdisplay</span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_28.png"><br><img src="https://i.csms.tech/img_29.png"></p>
<h4 id="创建-LV-常用操作命令"><a href="#创建-LV-常用操作命令" class="headerlink" title="创建 LV 常用操作命令"></a>创建 LV 常用操作命令</h4><p>使用已有的卷组 VG1 ，创建逻辑卷（Logical Volume）名为 <code>data</code> 的 LV，并配置 <code>data</code> 逻辑卷的大小为1000m</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lvcreate -L 1000M -n data VG1</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>-L|--size</code>  指定逻辑卷的大小</p>
</blockquote>
<p>查看 LV 的信息，常用以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lvs</span><br><span class="line">lvscan</span><br><span class="line">lvdisplay</span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_30.png"><br><img src="https://i.csms.tech/img_31.png"></p>
<blockquote>
<p><strong>逻辑卷无法直接使用，必须格式化挂载之后才能使用</strong><br>逻辑卷的引用需要逻辑卷的设备文件, 逻辑卷的设备文件有两种书写形式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/dev/vg_name/lv_name</span><br><span class="line">/dev/mapper/vg_name-lv_name</span><br></pre></td></tr></table></figure>
<p>格式化 LV 并挂载，正确的挂载后，可正常使用新加的磁盘空间</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkfs.xfs /dev/VG1/data</span><br><span class="line">mount /dev/VG1/data /data</span><br></pre></td></tr></table></figure>
<p>为了防止系统重启后挂载失效，需要将挂载信息写入配置文件 <code>/etc/fstab</code></p>
<figure class="highlight shell"><figcaption><span>/etc/fstab</span></figcaption><table><tr><td class="code"><pre><span class="line">/dev/VG1/data /data xfs defaults 0 0</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="LVM-扩容操作"><a href="#LVM-扩容操作" class="headerlink" title="LVM 扩容操作"></a>LVM 扩容操作</h4><h5 id="VG-扩容"><a href="#VG-扩容" class="headerlink" title="VG 扩容"></a>VG 扩容</h5><p>使用已有的 PV ，或者 <a href="#%E5%88%9B%E5%BB%BA-PV-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4">新建 PV</a> 来扩容已有的 VG, 假设用来扩容的 PV 为 <code>/dev/vde</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vgextend VG1 /dev/vde</span><br></pre></td></tr></table></figure>

<h5 id="LV-扩容"><a href="#LV-扩容" class="headerlink" title="LV 扩容"></a>LV 扩容</h5><p>使用 VG 的空闲空间扩容 LV<br>指定要扩容的大小</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lvextend -L +100m /dev/VG1/data</span><br></pre></td></tr></table></figure>
<p>或者直接通过指定 PV 扩容 LV， 整个 PV 的空间被扩容到 LV， 前提是 PV 已被扩容到了 VG</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lvextend /dev/VG1/data /dev/vde</span><br></pre></td></tr></table></figure>
<p>其他扩容方式可查看命令帮助 <code>lvextend -h</code>  </p>
<p>扩容 LV 后需要重新调整分区文件系统大小</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">resize2fs /dev/VG1/data</span><br></pre></td></tr></table></figure>
<p><code>xfs</code> 文件系统需要使用以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xfs_growfs /dev/VG1/data</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>LVM</tag>
      </tags>
  </entry>
  <entry>
    <title>mongodb 配置</title>
    <url>/202303311747/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos 7 </li>
<li>mongodb 4.0.26</li>
</ul>
<h1 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h1><p><a href="https://www.mongodb.com/try/download/community">官方社区版下载页面</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://repo.mongodb.org/yum/redhat/7/mongodb-org/4.0/x86_64/RPMS/mongodb-org-shell-4.0.28-1.el7.x86_64.rpm</span><br><span class="line">wget https://repo.mongodb.org/yum/redhat/7/mongodb-org/4.0/x86_64/RPMS/mongodb-org-mongos-4.0.28-1.el7.x86_64.rpm</span><br><span class="line">wget https://repo.mongodb.org/yum/redhat/7/mongodb-org/4.0/x86_64/RPMS/mongodb-org-server-4.0.28-1.el7.x86_64.rpm</span><br><span class="line">wget https://repo.mongodb.org/yum/redhat/7/mongodb-org/4.0/x86_64/RPMS/mongodb-org-tools-4.0.28-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">yum localinstall mongodb-org-mongos-4.0.28-1.el7.x86_64.rpm mongodb-org-tools-4.0.28-1.el7.x86_64.rpm mongodb-org-server-4.0.28-1.el7.x86_64.rpm mongodb-org-shell-4.0.28-1.el7.x86_64.rpm</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql 常见错误</title>
    <url>/22072111/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息说明"><a href="#环境信息说明" class="headerlink" title="环境信息说明"></a>环境信息说明</h1><ul>
<li>mysql 5.7</li>
<li>Centos 7</li>
</ul>
<span id="more"></span>

<h1 id="错误集锦"><a href="#错误集锦" class="headerlink" title="错误集锦"></a>错误集锦</h1><h2 id="MySQL-主从不同步，尝试跳过执行错误的事务"><a href="#MySQL-主从不同步，尝试跳过执行错误的事务" class="headerlink" title="MySQL 主从不同步，尝试跳过执行错误的事务"></a>MySQL 主从不同步，尝试跳过执行错误的事务</h2><p>执行以下命令，可跳过对应的 slave 事务</p>
<figure class="highlight shell"><figcaption><span>slave</span></figcaption><table><tr><td class="code"><pre><span class="line">stop slave;</span><br><span class="line">SET GLOBAL SQL_SLAVE_SKIP_COUNTER = 1;</span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure>
<p>可以通过分析主库日志中的事务，来确定 <code>SQL_SLAVE_SKIP_COUNTER</code> 的合适值。<br>具体步骤如下：<br>在 slave 库中执行 <code>show slave status\G</code> ，确认以下两个参数:</p>
<ul>
<li><code>Relay_Master_Log_File</code></li>
<li><code>Exec_Master_Log_Pos</code></li>
</ul>
<p>或者以下2个参数：</p>
<ul>
<li><code>Master_Log_File</code></li>
<li><code>Read_Master_Log_Pos</code><br><img src="https://i.csms.tech/img_11.png"><blockquote>
<p>通过以上 2 个值，可以知道当前 slave 执行到了 master 对应的哪个 binlog 文件 ( <code>Relay_Master_Log_File</code>) 以及文件中的对应位置 (<code>Exec_Master_Log_Pos</code> )</p>
</blockquote>
</li>
</ul>
<p>根据上述两个参数的值，在 master 中可以查看当前阻碍从库复制的事务以及之后的事务。可以执行以下命令查看</p>
<figure class="highlight shell"><figcaption><span>master</span></figcaption><table><tr><td class="code"><pre><span class="line">SHOW BINLOG EVENTS in &#x27;mysql-bin.001015&#x27; from 366269088;</span><br></pre></td></tr></table></figure>
<p>这个可以查看到对应日志文件 <code>mysql-bin.001015</code> 中，事务 ID 为 <code>366269088</code> 之后的所有事务，</p>
<p>以下命令可以限制查询条数</p>
<figure class="highlight shell"><figcaption><span>master</span></figcaption><table><tr><td class="code"><pre><span class="line">SHOW BINLOG EVENTS in &#x27;mysql-bin.001015&#x27; from 366269088 limit 10;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="主从具有相同的-server-uuid"><a href="#主从具有相同的-server-uuid" class="headerlink" title="主从具有相同的 server-uuid"></a>主从具有相同的 server-uuid</h2><p><strong>报错信息</strong>：</p>
<blockquote>
<p>Fatal error: The slave I&#x2F;O thread stops because master and slave have equal MySQL server UUIDs; these UUIDs must be different for replication to work</p>
</blockquote>
<p><strong>问题原因</strong>： 主从数据目录(默认<code>/var/lib/mysql/</code>)都有一个 <code>auto.cnf</code> 文件，里面记录的 <code>server-uuid</code> 是相同的，在云主机 clone 的场景可能会出现此问题。</p>
<p><strong>解决方法</strong>： 修改 <code>auto.cnf</code> 文件中 <code>uuid</code> 的值，重启 Mysql 服务即可</p>
<p>查询 uuid 的方式，登录 mysql，执行以下命令查看</p>
<figure class="highlight shell"><figcaption><span>mysql</span></figcaption><table><tr><td class="code"><pre><span class="line">select uuid();</span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_12.png"></p>
<hr>
<h2 id="主从具有相同的-server-id"><a href="#主从具有相同的-server-id" class="headerlink" title="主从具有相同的 server-id"></a>主从具有相同的 server-id</h2><p><strong>报错信息</strong>：</p>
<blockquote>
<p>Fatal error: The slave I&#x2F;O thread stops because master and slave have equal MySQL server ids; </p>
</blockquote>
<p><strong>问题原因</strong>： 主从配置文件中配置了同样的 <code>server-id</code></p>
<p><strong>解决方法</strong>： 修改 <code>my.cnf</code>， 主从配置不同的<code>server-id</code></p>
<hr>
<h2 id="主从同步错误-1032"><a href="#主从同步错误-1032" class="headerlink" title="主从同步错误 1032"></a>主从同步错误 1032</h2><p><strong>报错信息</strong>：</p>
<blockquote>
<p>Could not execute Update_rows event on table ceshi.bbs_online; Can’t find record in ‘bbs_online’, Error_code: 1032; handler error HA_ERR_KEY_NOT_FOUND; the event’s master log mysql-bin.001423, end_log_pos 866646715</p>
</blockquote>
<p><strong>问题原因</strong>： 主从不同步，从数据库中记录被删除或者未同步到从库，主数据库中存在记录，主DB更新后，从无法同步</p>
<p><strong>解决方法1</strong>： 重新备份 master DB，恢复到 slave，重新 <a href="/94ee2c23/" title="恢复主从">恢复主从</a></p>
<p><strong>解决方法2</strong>： 找出丢失的数据在 slave 上插入。可以通过 <a href="#MySQL%E4%B8%BB%E4%BB%8E%E4%B8%8D%E5%90%8C%E6%AD%A5%EF%BC%8C%E5%B0%9D%E8%AF%95%E8%B7%B3%E8%BF%87%E6%89%A7%E8%A1%8C%E9%94%99%E8%AF%AF%E7%9A%84%E4%BA%8B%E5%8A%A1">分析出错的 binlog 找出丢失的记录</a></p>
<hr>
<h2 id="主从同步错误-1396"><a href="#主从同步错误-1396" class="headerlink" title="主从同步错误 1396"></a>主从同步错误 1396</h2><p><strong>报错信息</strong>：</p>
<blockquote>
<p>ERROR 1396 (HY000): Operation CREATE USER failed for ‘XXXX‘@’XXXX’</p>
</blockquote>
<p><strong>问题原因</strong>： slave 同步时，从数据库中已存在用户</p>
<p><strong>解决方法</strong>： slave 上删除已存在的用户</p>
<hr>
<h2 id="主从同步错误-1062"><a href="#主从同步错误-1062" class="headerlink" title="主从同步错误 1062"></a>主从同步错误 1062</h2><p><strong>报错信息</strong>：</p>
<blockquote>
<p>Last_SQL_Error: Could not execute Write_rows event on table *;<br>    Duplicate entry ‘2’ for key ‘PRIMARY’,<br>Error_code: 1062;<br>handler error HA_ERR_FOUND_DUPP_KEY; the event’s master log mysql-bin.000006, end_log_pos 924</p>
</blockquote>
<p><strong>问题原因</strong>： slave 上已有该记录，master 上又插入，可能存在主从数据不一致</p>
<p><strong>解决方法</strong>： 删除 slave 上重复的主键记录</p>
<hr>
<h2 id="主从同步错误-1042"><a href="#主从同步错误-1042" class="headerlink" title="主从同步错误 1042"></a>主从同步错误 1042</h2><p><strong>报错信息</strong>：</p>
<blockquote>
<p>error code 1042 (ER_BAD_HOST_ERROR): Can’t get hostname for your address</p>
</blockquote>
<p><strong>问题原因</strong>： 解析主机名失败</p>
<p><strong>解决方法</strong>： mysql 配置（<code>my.cnf</code>）中设置 <code>skip-name-resolve</code></p>
<p>使用以下命令解析 mysql 错误码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">perror 1042</span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_13.png"></p>
<hr>
<h2 id="导出导入数据错误-1290"><a href="#导出导入数据错误-1290" class="headerlink" title="导出导入数据错误 1290"></a>导出导入数据错误 1290</h2><p><strong>报错场景</strong>： 使用 <code>select/insert</code> 导出&#x2F;导入 时报错</p>
<p><strong>报错信息</strong>：</p>
<blockquote>
<p>ERROR 1290 (HY000): The MySQL server is running with the –secure-file-priv option so it cannot execute this statement</p>
</blockquote>
<p><strong>问题原因</strong>： <code>secure_file_priv</code> 参数用于限制 <code>LOAD DATA</code>, <code>SELECT …OUTFILE</code>, <code>LOAD_FILE()</code> 传到哪个指定目录。  </p>
<ul>
<li><code>secure_file_priv</code> 为 <code>NULL</code> 时，表示限制 mysqld 不允许导入或导出。</li>
<li><code>secure_file_priv</code> 为 <code>/tmp</code> 时，表示限制 mysqld 只能在 <code>/tmp</code> 目录中执行导入导出，其他目录不能执行。</li>
<li><code>secure_file_priv</code> 没有值时，表示不限制 mysqld 在任意目录的导入导出。</li>
</ul>
<p>可以通过以下命令，查看当前的配置  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> &quot;%secure_file_priv%&quot;;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.csms.tech/img_18.png"></p>
<p><strong>解决方法</strong>： 因为 <code>secure_file_priv</code> 参数是只读参数，不能使用 <code>set global</code> 命令修改。<br><img src="https://i.csms.tech/img_19.png"></p>
<p>需要修改配置文件，添加以下内容</p>
<figure class="highlight shell"><figcaption><span>my.cnf</span></figcaption><table><tr><td class="code"><pre><span class="line">secure_file_priv = &#x27;&#x27;</span><br></pre></td></tr></table></figure>

<p>修改配置后，重启 mysql 服务生效</p>
<h2 id="xtrbackup-备份时被阻塞，一直显示-log-scanned-up-to"><a href="#xtrbackup-备份时被阻塞，一直显示-log-scanned-up-to" class="headerlink" title="xtrbackup 备份时被阻塞，一直显示 log scanned up to"></a>xtrbackup 备份时被阻塞，一直显示 <code>log scanned up to</code></h2><p><strong>报错场景</strong>: xtrbackup 备份时间过长，一直输出 <code>log scanned up to</code><br><img src="https://i.csms.tech/img_20.png"></p>
<p><strong>可能原因</strong>： 备份在等待锁<br><img src="https://i.csms.tech/img_21.png"></p>
<p><strong>解决方法</strong>： 如果对业务无影响，可以重启 mysql 服务后重新备份，或者根据 ID kill 掉对应的线程</p>
<figure class="highlight shell"><figcaption><span>mysql</span></figcaption><table><tr><td class="code"><pre><span class="line">show processlist;</span><br><span class="line">kill ID;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Cannot-add-or-update-a-child-row-a-foreign-key-constraint-fails"><a href="#Cannot-add-or-update-a-child-row-a-foreign-key-constraint-fails" class="headerlink" title="Cannot add or update a child row: a foreign key constraint fails"></a>Cannot add or update a child row: a foreign key constraint fails</h2><p>修改表字段，添加外键时报错，sql 语句及报错信息如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ALTER TABLE `my_table1` ADD COLUMN `usage_id` BIGINT DEFAULT 1 NOT NULL , ADD CONSTRAINT `usage_id_43803979_fk_domains_c` FOREIGN KEY (`usage_id`) REFERENCES `domainusage`(`<span class="built_in">id</span>`);</span></span><br><span class="line"></span><br><span class="line">错误代码： 1452</span><br><span class="line">Cannot add or update a child row: a foreign key constraint fails (`test`.`#sql-648_bce`, CONSTRAINT `usage_id_43803979_fk_domains_c` FOREIGN KEY (`usage_id`) REFERENCES `domainusage` (`id`))</span><br></pre></td></tr></table></figure>
<p>这个错误通常发生在尝试添加外键约束时，存在不一致的数据。在这种情况下，它指示 <code>my_table1</code> 表中的 <code>usage_id</code> 列的默认值与 <code>domainusage</code> 表的外键约束不匹配。</p>
<p>可能的原因和解决方法包括：</p>
<ol>
<li><p><code>domainusage</code> 表中没有 id 为 1 的记录：如果你将 <code>my_table1</code> 表的 <code>usage_id</code> 列设置为引用 <code>domainusage</code> 表的 id 列作为外键约束，那么确保在 <code>domainusage</code> 表中存在一个 id 为 1 的记录。如果没有，请先添加一条记录，并确保它的 id 值为 1。</p>
</li>
<li><p><code>domainusage</code> 表的 id 为 1 的记录与 <code>my_table1</code> 表的数据不匹配：检查 <code>domainusage</code> 表中 id 为 1 的记录与 <code>my_table1</code> 表中的数据是否一致。确保 <code>my_table1</code> 表中的每一行都具有在 <code>domainusage</code> 表中存在的有效的 id 值。</p>
</li>
<li><p>数据库中已经存在不一致的数据：如果你已经尝试了上述步骤并且仍然遇到问题，可能是由于数据库中存在不一致的数据导致的。在这种情况下，你需要检查并修复 <code>my_table1</code> 表和 <code>domainusage</code> 表之间的数据一致性问题。可以通过更新或删除相关行来解决不一致的数据。</p>
</li>
</ol>
<p>本示例中遇到的问题为第 1 个原因导致，解决办法为： 先在表 <code>domainusage</code> 中添加 id 为 1 的数据，然后再更新表 <code>my_table1</code></p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql 常用 SQL</title>
    <url>/2207221611/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Mysql 5.7</li>
</ul>
<h1 id="常用-sql"><a href="#常用-sql" class="headerlink" title="常用 sql"></a>常用 sql</h1><h2 id="导出数据"><a href="#导出数据" class="headerlink" title="导出数据"></a>导出数据</h2><h3 id="导出到文件"><a href="#导出到文件" class="headerlink" title="导出到文件"></a>导出到文件</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> [<span class="keyword">TABLE</span>] </span><br><span class="line">    <span class="keyword">INTO</span> OUTFILE <span class="string">&#x27;[FILE]&#x27;</span> </span><br><span class="line">    FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;,&#x27;</span> </span><br><span class="line">    OPTIONALLY ENCLOSED <span class="keyword">BY</span> <span class="string">&#x27;&quot;&#x27;</span> </span><br><span class="line">    LINES TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\n&#x27;</span>；</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><code>into outfile ‘导出的目录和文件名’ </code>  </li>
<li><code>fields terminated by ‘字段间分隔符’ </code> </li>
<li><code>optionally enclosed by ‘字段包围符’  </code> </li>
<li><blockquote>
<blockquote>
<p><code>optionally enclosed by</code> 对数值型字段无效</p>
</blockquote>
</blockquote>
</li>
<li><code>lines terminated by ‘行间分隔符’ </code></li>
</ul>
<p>产生报错可参考 <a href="https://csms.tech/22072111/#导出导入数据错误-1290">Mysql 常见错误</a></p>
<h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><h3 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb(c1,c2) <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<span id="more"></span>
<h2 id="备份数据"><a href="#备份数据" class="headerlink" title="备份数据"></a>备份数据</h2><h3 id="mysqldump-常见用法"><a href="#mysqldump-常见用法" class="headerlink" title="mysqldump 常见用法"></a>mysqldump 常见用法</h3><a href="/94ee2c23/" title="MySQL 备份及主从恢复">MySQL 备份及主从恢复</a>
<h4 id="mysqldump-备份时排除某些表"><a href="#mysqldump-备份时排除某些表" class="headerlink" title="mysqldump 备份时排除某些表"></a>mysqldump 备份时排除某些表</h4><ul>
<li><code>--ignore-table=database.table</code> 导出时排除指定的表</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p database --ignore-table=database.table1 --ignore-table=database.table2 &gt; backup.sql</span><br></pre></td></tr></table></figure>

<h4 id="mysqldump-导出表结构"><a href="#mysqldump-导出表结构" class="headerlink" title="mysqldump 导出表结构"></a>mysqldump 导出表结构</h4><ul>
<li><code>-d</code> 选项，只导出表结构，不导出数据</li>
</ul>
<p>导出整个数据库表结构（不包含数据）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p -d DB &gt; db.sql</span><br></pre></td></tr></table></figure>

<p>导出单个数据表结构（不包含数据）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p -d DB TABLE &gt; table.sql</span><br></pre></td></tr></table></figure>

<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>为了创建一个新的触发器，可以使用 <code>CREATE TRIGGER</code> 语句。 下面说明了 <code>CREATE TRIGGER</code> 语句的语法： <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[MySQL触发器创建](https://www.yiibai.com/mysql/create-the-first-trigger-in-mysql.html)">[1]</span></a></sup></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> [trigger_name] [trigger_time] [trigger_event]</span><br><span class="line"> <span class="keyword">ON</span> [table_name]</span><br><span class="line"> <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"> <span class="keyword">BEGIN</span></span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><code>trigger_name</code> : 触发器名称, 一般遵循命名约定 <code>[trigger time]_[table name]_[trigger event]</code>，例如 <code>before_employees_update</code></li>
<li><code>trigger_time</code> : 触发激活时间，必须指定定义触发器的激活时间。如果要在更改之前处理操作，则使用 <code>BEFORE</code> 关键字，如果在更改后需要处理操作，则使用 <code>AFTER</code> 关键字</li>
<li><code>trigger_event</code> : 触发事件，可以是 <code>INSERT</code>，<code>UPDATE</code> 或 <code>DELETE</code>。此事件导致触发器被调用。 触发器只能由一个事件调用。要定义由多个事件调用的触发器，必须定义多个触发器，每个事件一个触发器。</li>
<li><code>table_name</code> : 触发器管理的表。触发器必须与特定表关联。没有表触发器将不存在，所以必须在 <code>ON</code> 关键字之后指定表名</li>
<li><code>BEGIN</code> … <code>END</code> : 将 SQL 语句放在 <code>BEGIN</code> 和 <code>END</code> 块之间。这是定义触发器逻辑的位置。</li>
</ul>
<p>以下示例定义一个触发器，在表中的字段被更改后，改回旧的之，实现禁止更改表的效果</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> `before_update_images` </span><br><span class="line">    BEFORE <span class="keyword">UPDATE</span> <span class="keyword">ON</span> `images` </span><br><span class="line">    <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">set</span> new.name<span class="operator">=</span>old.name;</span><br><span class="line">    <span class="keyword">set</span> new.url<span class="operator">=</span>old.url;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER;</span><br></pre></td></tr></table></figure>



<h1 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h1><h2 id="mysql-命令提示符下翻页查看输出"><a href="#mysql-命令提示符下翻页查看输出" class="headerlink" title="mysql 命令提示符下翻页查看输出"></a>mysql 命令提示符下翻页查看输出</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">pager less <span class="operator">-</span>S</span><br></pre></td></tr></table></figure>
<blockquote>
<p>之后的输出可以使用和less命令一样的参数</p>
</blockquote>
<h2 id="gegeral-log-开启"><a href="#gegeral-log-开启" class="headerlink" title="gegeral_log 开启"></a>gegeral_log 开启</h2><p>查询 <code>general_log</code> 配置，并启用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;%general%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+----------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name    <span class="operator">|</span> <span class="keyword">Value</span>                                              <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+----------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> general_log      <span class="operator">|</span> OFF                                                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> general_log_file <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>data<span class="operator">/</span>localhost.log                  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+----------------------------------------------------+</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> general_log_file<span class="operator">=</span><span class="string">&#x27;/tmp/mysql.log&#x27;</span>;</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> general_log<span class="operator">=</span><span class="keyword">on</span>;</span><br><span class="line">    </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;%general%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+----------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name    <span class="operator">|</span> <span class="keyword">Value</span>                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+----------------------+</span></span><br><span class="line"><span class="operator">|</span> general_log      <span class="operator">|</span> <span class="keyword">ON</span>                   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> general_log_file <span class="operator">|</span> <span class="operator">/</span>tmp<span class="operator">/</span>mysql.log       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+----------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> general_log<span class="operator">=</span>off;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;%general%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+----------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name    <span class="operator">|</span> <span class="keyword">Value</span>                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+----------------------+</span></span><br><span class="line"><span class="operator">|</span> general_log      <span class="operator">|</span> OFF                  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> general_log_file <span class="operator">|</span> <span class="operator">/</span>tmp<span class="operator">/</span>mysql.log       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+----------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 <code>general_log</code> 中可用通过搜索 <code>event id</code> 来查看登陆连接对数据库的所有 SQL 。</p>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.yiibai.com/mysql/create-the-first-trigger-in-mysql.html">MySQL触发器创建</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 常用配置说明</title>
    <url>/22721459/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>mysql 5.7</li>
</ul>
<p>默认配置文件路径: <code>/etc/my.cnf</code></p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##############通用配置##############</span><br><span class="line">user = mysql</span><br><span class="line">port = 3306</span><br><span class="line">default_storage_engine = InnoDB</span><br><span class="line">## 只读</span><br><span class="line">read_only=1  </span><br><span class="line">             </span><br><span class="line">## 跳过域名解析参数，禁止MySQL对外部连接进行DNS解析，使用这一选项可以消除MySQL进行DNS解析的时间。</span><br><span class="line">## 但需要注意，如果开启该选项，则所有远程主机连接授权都要使用IP地址方式，否则MySQL将无法正常处理连接请求！</span><br><span class="line">skip-name-resolve  </span><br><span class="line"></span><br><span class="line">## 跳过授权，重置密码时需要</span><br><span class="line">## 重置密码：update mysql.user set authentication_string=password(&#x27;Password@123&#x27;) where user=&#x27;root&#x27;;          </span><br><span class="line">skip-grant-tables   </span><br><span class="line">          </span><br><span class="line">datadir=/var/lib/mysql</span><br><span class="line">socket=/var/lib/mysql/mysql.sock</span><br><span class="line"></span><br><span class="line">## 解决日志中因wait-timeout的报错：</span><br><span class="line">## Aborted connection 40476 to db: &#x27;&#x27; user: &#x27;&#x27; host: &#x27;&#x27; (Got an error reading communication packets)</span><br><span class="line">log_warnings=1  </span><br><span class="line">                 </span><br><span class="line">### 连接错误超过此值，客户端无法连接，即拉黑</span><br><span class="line">max_connect_errors = 1000      </span><br><span class="line"></span><br><span class="line">###########主从配置选项###########</span><br><span class="line">server-id = 1</span><br><span class="line"># 主库要生成的二进制日志文件名称</span><br><span class="line">log-bin = mysql-bin    </span><br><span class="line">    </span><br><span class="line">## 从库中继日志名称</span><br><span class="line">relay-log = mysql-relay-bin    </span><br><span class="line"></span><br><span class="line">################</span><br><span class="line">## sync_binlog = 0    表示MySQL 不控制binlog的刷新，由文件系统自己控制它的缓存的刷新。</span><br><span class="line">## 这时候的性能是最好的，但是风险也是最大的。因为一旦系统Crash，在binlog_cache中的所有binlog信息都会被丢失。</span><br><span class="line">## sync_binlog&gt;0    表示每N个sync_binlog次事务提交，MySQL调用文件系统的刷新操作将缓存刷下去。</span><br><span class="line">## 最安全的就是sync_binlog=1了，表示每次事务提交，MySQL都会把binlog刷下去，是最安全但是性能损耗最大的设置。这样的话，在数据库所在的主机操作系统损坏或者突然掉电的情况下，系统才有可能丢失1个事务的数据。 </span><br><span class="line">## 但是binlog虽然是顺序IO，但是设置sync_binlog=1，多个事务同时提交，同样很大的影响MySQL和IO性能。</span><br><span class="line">## 对于高并发事务的系统来说，“sync_binlog”设置为0和设置为1的系统写入性能差距可能高达5倍甚至更多。</span><br><span class="line">## 只适用于主库的二进制日志，不适用中继日志</span><br><span class="line">################</span><br><span class="line">sync_binlog=0</span><br><span class="line"></span><br><span class="line">## 要同步的库.应该在从库上尽可能的使用replicate_wild_*，不建议在主库上使用</span><br><span class="line">binlog-do-db = rtzc_pnc_base       </span><br><span class="line"></span><br><span class="line"># 不同步的数据库,应该在从库上尽可能的使用replicate_wild_*</span><br><span class="line">binlog-ignore-db = mysql</span><br><span class="line"></span><br><span class="line">### 应该在从库上尽可能的使用replicate_wild_*              </span><br><span class="line">#replicate-wild-ignore-table=db.*               </span><br><span class="line">#replicate-wild-ignore-table=mysql.*</span><br><span class="line">#replicate-wild-ignore-table=information_schema.*</span><br><span class="line">#replicate-wild-ignore-table=performance_schema.*</span><br><span class="line">#replicate-wild-ignore-table=sys.*</span><br><span class="line">#replicate_wild_do_table=DB_NAME.%</span><br><span class="line">#replicate_ignore_db=test</span><br><span class="line"></span><br><span class="line">###复制实现模式/级别</span><br><span class="line">binlog_format=statement/row/mixed   </span><br><span class="line"></span><br><span class="line"># binlog日志大于此值是重新生成新的日志，默认(最大)1G，若使用大事务，日志可能会超过此值     </span><br><span class="line">max_binlog_size = 100M        </span><br><span class="line"></span><br><span class="line"># bilog日志保存天数，过期后清除</span><br><span class="line">expire_logs_days = 7   </span><br><span class="line"></span><br><span class="line"># 跳过某些同步错误号</span><br><span class="line">slave-skip-errors = 1032,1062  </span><br><span class="line"></span><br><span class="line">### 从库需要记录binlog，如级联从库场景，级联从库必须有此参数</span><br><span class="line">log-slave-updates=1          </span><br><span class="line"></span><br><span class="line"># 阻止slave自动启动复制</span><br><span class="line">skip_slave_start     </span><br><span class="line"></span><br><span class="line"># 从库发现和主库连接失败后，重连等待的时间，默认1小时       </span><br><span class="line">slave_net_timeout = 1        </span><br><span class="line"></span><br><span class="line"># 在从库上同步状态文件到磁盘，默认10000，表示在10000个事务执行完成后，将信息同步到磁盘</span><br><span class="line"># 打开后，可能会降低IO性能，设置为1最安全，但是IO性能最差；设置为0，由OS控制刷新</span><br><span class="line">sync_master_info | sync_relay_log | sync_relay_log_info  = 1      </span><br><span class="line"></span><br><span class="line"># SQL线程重放完一个中继日志后尽快将其删除</span><br><span class="line">relay_log_purge = 1         </span><br><span class="line"></span><br><span class="line"># 所有中继日志大小和的最大值。可防止主从延迟很大时，IO线程写relay log，导致磁盘空间不足。中继日志总和超过此值，IO线程会停止，等待SQL线程释放空间；</span><br><span class="line"># 风险是从库未从主库读取所有relaylog，这些日志可能在主库崩溃时丢失，磁盘空间足够的情况下，不推荐配置  </span><br><span class="line">relay_log_space_limit = 1G       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#########日志选项###########</span><br><span class="line">slow_query_log =1   </span><br><span class="line">long_query_time=2     </span><br><span class="line">slow_query_log_file=/var/lib/mysql/slow.log</span><br><span class="line"></span><br><span class="line">log-error=/var/log/mysqld.log</span><br><span class="line"></span><br><span class="line">##########编码选项######</span><br><span class="line">character-set-server = utf8</span><br><span class="line">collation-server=utf8_general_ci </span><br><span class="line"></span><br><span class="line">#############连接选项#############</span><br><span class="line"></span><br><span class="line"># 客户端的连接闲置的最大时间，默认8小时，设置非交互模式(jdbc)时的超时时间</span><br><span class="line">wait-timeout = 60      </span><br><span class="line"></span><br><span class="line"># 交互模式超时时间      </span><br><span class="line">interactive_timeout = 60    </span><br><span class="line"></span><br><span class="line"># 并发连接数,最终值由open_files_limit共同决定</span><br><span class="line">max_connections=65535    </span><br><span class="line"></span><br><span class="line"># 一个账号最大可发起多少并发连接                </span><br><span class="line">max_user_connections=65535            </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#############性能选项#############</span><br><span class="line"></span><br><span class="line"># 缓存的表个数，可以观察Opened_tables状态变量值，若很大(若经常需要创建/删除临时表，该计数器也会不停增长)，建议增加此配置值，由OS rlimit共同决定</span><br><span class="line">table_open_cache = 65535  </span><br><span class="line"></span><br><span class="line"># 缓存的线程个数，具体配置值可以观察Threads_created状态变量，如果此值较大，可加大thread_cache_size,建议此值保持足够大    </span><br><span class="line">thread_cache_size = 5000   </span><br><span class="line"></span><br><span class="line"># 查询缓存使用的内存大小，启动时，一次性分配</span><br><span class="line">query_cache_size = 1024M      </span><br><span class="line"></span><br><span class="line"># 查询需排序时分配内存，立即分配指定的全部内存，无论是否需要这么多</span><br><span class="line">sort_buffer_size = 10k            </span><br><span class="line"></span><br><span class="line"># 需要在服务启动程序(/usr/lib/systemd/system/mysqld.service)中配置：LimitNOFILE = 65535</span><br><span class="line">open_files_limit = 65535</span><br><span class="line">     </span><br><span class="line">max_allowed_packet = 200M</span><br><span class="line">innodb_open_files = 65535      </span><br><span class="line"></span><br><span class="line"># 默认值一般都太小，此值建议配置为os和其他应用消耗的内存除外的内存大小</span><br><span class="line"># 配置太大也会导致预热和关闭花费较多时间</span><br><span class="line">innodb_buffer_pool_size = 20G       </span><br><span class="line"></span><br><span class="line"># 事务日志的文件大小，太小，InnoDB必须做更多检查点，导致更多日志写，不利于IO。日志缓存满，事务提交或每秒，会刷新缓存到磁盘;</span><br><span class="line"># 可以观察show innodb status中log部分，Innodb_os_log_written查看写入了多少数据</span><br><span class="line">innodb_log_file_size = (32-128)M</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">innodb_flush_log_at_trx_commit = N</span><br><span class="line">########## innodb特有参数，事务日志用于在mysql崩溃后的恢复</span><br><span class="line"># N=0   每隔一秒，把事务日志缓存区的数据写到日志文件中，以及把日志文件的数据刷新到磁盘上；</span><br><span class="line"># 在这种情况下，MySQL性能最好，但如果 mysqld 进程崩溃，通常会导致最后 1s 的日志丢失。</span><br><span class="line"></span><br><span class="line"># N=1   每个事务提交时候，把事务日志从缓存区写到日志文件中，并且刷新日志文件的数据到磁盘上；每次事务提交时，log buffer 会被写入到日志文件并刷写到磁盘。 </span><br><span class="line"># 这也是默认值。这是最安全的配置，但由于每次事务都需要进行磁盘I/O，所以也最慢。</span><br><span class="line"></span><br><span class="line"># N=2    当取值为2 时，每次事务提交会写入日志文件，但并不会立即刷写到磁盘，日志文件会每秒刷写一次到磁盘。</span><br><span class="line"># 这时如果 mysqld 进程崩溃，由于日志已经写入到系统缓存，所以并不会丢失数据；在操作系统崩溃的情况下，通常会导致最后 1s 的日志丢失。</span><br><span class="line"># 对于一些数据一致性和完整性要求不高的应用，配置为 2 就足够了；如果为了最高性能，可以设置为 0。有些应用，如支付服务，对一致性和完整性要求很高，所以即使最慢，也最好设置为 1.</span><br><span class="line">##########</span><br><span class="line"></span><br><span class="line"># 限制一次性可以有多少线程进入内核，建议值：cpu数量* 磁盘数量* 2,进入内核的线程超过此值，新线程无法进入。</span><br><span class="line"># 为使线程高效进入内核，线程第一次休眠innodb_thread_sleep_delay(默认10000)微秒，然后重试，若依然不能进入内核，则放入一个等待线程队列，由OS内核处理。</span><br><span class="line"># 在高并发环境或大量小查询时，可减小此值。</span><br><span class="line">innodb_thread_concurrency = 64</span><br><span class="line"></span><br><span class="line"># 一旦线程进入内核，可以有指定数量的tickents，再次进入内核时，可不在做并发检查，按照查询授权，而非事务            </span><br><span class="line">innodb_concurrency_tickets = 10</span><br><span class="line"></span><br><span class="line"># 多少个线程可以在同一时间提交事务，太小会有线程冲突      </span><br><span class="line">innodb_commit_concurrency = 100   </span><br><span class="line"></span><br><span class="line"># 指定磁盘IO能力，默认为100，使用SSD或IO性能好的磁盘时，建议提高此值</span><br><span class="line">innodb_io_capacity = 1000     </span><br><span class="line"></span><br><span class="line"># 控制后台由多少线程负责IO操作，默认为4</span><br><span class="line">innodb_read_io_threads | innodb_write_io_threads = 10             </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 备份及主从恢复</title>
    <url>/94ee2c23/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos 7</li>
<li>Mysql 5.7</li>
<li>Percona-XtraBackup-2.4.4</li>
</ul>
<h1 id="恢复方法1：mysqldump-主库锁表备份恢复"><a href="#恢复方法1：mysqldump-主库锁表备份恢复" class="headerlink" title="恢复方法1：mysqldump 主库锁表备份恢复"></a>恢复方法1：mysqldump 主库锁表备份恢复</h1><p><strong>前提</strong> ： 接受主库锁表操作，备份恢复过程中主库无法写入数据</p>
<h2 id="从库停止slave进程"><a href="#从库停止slave进程" class="headerlink" title="从库停止slave进程"></a>从库停止slave进程</h2><p>登录 mysql 从库，执行以下命令，停止 slave 进程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">stop slave;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="主库锁表"><a href="#主库锁表" class="headerlink" title="主库锁表"></a>主库锁表</h2><p>登录 mysql 主库，执行以下命令，对主库进行锁表操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FLUSH TABLES WITH READ LOCK;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行锁表操作后，不要退出 mysql 命令行，否则会自动解锁。</p>
</blockquote>
<p>执行以下命令，查看主库锁表后的 binlog 位置信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SHOW MASTER STATUS\G</span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_3.png"></p>
<h2 id="备份主库数据库数据"><a href="#备份主库数据库数据" class="headerlink" title="备份主库数据库数据"></a>备份主库数据库数据</h2><p>执行以下命令备份数据库 db1</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p --master-data=2 --databases db1 &gt; db1.sql</span><br></pre></td></tr></table></figure>
<ul>
<li><code>--master-data=2</code>  将日志名和位置写入到备份结果并注释，可以从备份文件中搜索 <code>change master to</code>  查看 <code>binlog</code> 文件名和 <code>position</code></li>
</ul>
<p>主库备份完成后，可以解锁：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure>

<h2 id="从库恢复主库的备份数据"><a href="#从库恢复主库的备份数据" class="headerlink" title="从库恢复主库的备份数据"></a>从库恢复主库的备份数据</h2><p>将主库的备份数据拷贝到从库，使用备份数据覆盖恢复从库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p db1 &lt; db1.sql</span><br></pre></td></tr></table></figure>
<p>从库恢复备份完成后，和主库建立主从连接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">change master to master_host=&#x27;1.1.1.1&#x27;,master_user=&#x27;repl&#x27;,master_password=&#x27;pswd&#x27;,master_port=3306,master_log_file=&#x27;mysql-bin.000196&#x27;,master_log_pos=1037640668;</span><br><span class="line">start slave</span><br></pre></td></tr></table></figure>
<p>配置完成后，通过以下命令，查看主从状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">show slave status\G</span><br></pre></td></tr></table></figure>
<blockquote>
<p>主要关注以下项：<br>Slave_IO_Running: Yes<br>Slave_SQL_Running: Yes<br>Seconds_Behind_Master: 0  </p>
</blockquote>
<p><img src="https://i.csms.tech/img_5.png"></p>
<h1 id="恢复方法2：mysqldump-主库不锁表备份恢复"><a href="#恢复方法2：mysqldump-主库不锁表备份恢复" class="headerlink" title="恢复方法2：mysqldump 主库不锁表备份恢复"></a>恢复方法2：mysqldump 主库不锁表备份恢复</h1><h2 id="从库停止-slave-进程"><a href="#从库停止-slave-进程" class="headerlink" title="从库停止 slave 进程"></a>从库停止 slave 进程</h2><p>登录 mysql 从库，执行以下命令，停止 slave 进程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">stop slave;</span><br></pre></td></tr></table></figure>
<h2 id="备份主库数据库数据-1"><a href="#备份主库数据库数据-1" class="headerlink" title="备份主库数据库数据"></a>备份主库数据库数据</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p --master-data=2 --single-transaction -R --databases db01 &gt; db01.sql</span><br></pre></td></tr></table></figure>
<ul>
<li><code>--master-data=2</code> : 实现将日志名和位置写入到备份结果并注释,<code>db01.sql</code> 中会包含当前日志的文件名以及位置  </li>
<li><code>--routines, -R</code>：导出存储过程和函数</li>
</ul>
<h2 id="从库导入备份"><a href="#从库导入备份" class="headerlink" title="从库导入备份"></a>从库导入备份</h2><p>将主库的备份数据拷贝到从库，并进行恢复</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p db01 &lt; db01.sql</span><br></pre></td></tr></table></figure>
<h2 id="备份文件中查看binlog日志文件名和position"><a href="#备份文件中查看binlog日志文件名和position" class="headerlink" title="备份文件中查看binlog日志文件名和position"></a>备份文件中查看binlog日志文件名和position</h2><p>在备份文件(<code>db01.sql</code>)中搜索 <code>CHANGE MASTER TO </code>, 结果中可以获取到 <code>binlog</code> 日志文件名和 <code>position</code></p>
<h2 id="建立主从连接"><a href="#建立主从连接" class="headerlink" title="建立主从连接"></a>建立主从连接</h2><p>根据上一步获取到的 <code>binlog</code> 文件名和 &#96;position 信息，建立主从连接并启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">change master to master_host=&#x27;1.1.1.1&#x27;,master_user=&#x27;repl&#x27;,master_password=&#x27;pswd&#x27;,master_port=3306,master_log_file=&#x27;mysql-bin.000196&#x27;,master_log_pos=1037640668;</span><br><span class="line">start slave</span><br></pre></td></tr></table></figure>
<p>通过命令 <code>show slave status\G</code> 检查主从同步状态</p>
<h1 id="恢复方法3：-xbackup-整库备份恢复"><a href="#恢复方法3：-xbackup-整库备份恢复" class="headerlink" title="恢复方法3： xbackup 整库备份恢复"></a>恢复方法3： xbackup 整库备份恢复</h1><h2 id="xbackup安装"><a href="#xbackup安装" class="headerlink" title="xbackup安装"></a>xbackup安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y libaio-devel.x86_64 bzip2</span><br><span class="line">wget https://www.percona.com/downloads/XtraBackup/Percona-XtraBackup-2.4.4/binary/tarball/percona-xtrabackup-2.4.4-Linux-x86_64.tar.gz</span><br><span class="line">tar -zxf percona-xtrabackup-2.4.4-Linux-x86_64.tar.gz</span><br><span class="line">cp percona-xtrabackup-2.4.4-Linux-x86_64/bin/* /usr/bin</span><br></pre></td></tr></table></figure>

<h2 id="主库整库备份"><a href="#主库整库备份" class="headerlink" title="主库整库备份"></a>主库整库备份</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">innobackupex --defaults-file=/etc/my.cnf --user=root --password=PASSWD --port=3306 --socket=/var/lib/mysql/mysql.sock  [--databases  &quot;db1 db2 &quot;] $&#123;backup_data_dir&#125;</span><br></pre></td></tr></table></figure>

<h2 id="从库整库恢复"><a href="#从库整库恢复" class="headerlink" title="从库整库恢复"></a>从库整库恢复</h2><p>拷贝主库备份数据到从库,在从库上执行以下命令恢复数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd $&#123;backup_data_dir&#125;</span><br><span class="line"></span><br><span class="line">innobackupex --defaults-file=/etc/my.cnf --apply-log --use-memory=20000M $&#123;backup_data_dir&#125;</span><br><span class="line"></span><br><span class="line">cp -r $&#123;backup_data_dir&#125;/* $&#123;mysql_base_dir&#125;/data/</span><br></pre></td></tr></table></figure>

<h2 id="建立主从连接-1"><a href="#建立主从连接-1" class="headerlink" title="建立主从连接"></a>建立主从连接</h2><p>备份数据中的 <code>xtrabackup_binlog_info</code> 文件包含了从库建立主从连接时需要的 binlog 信息，根据此文件中的信息，在从库执行命令，建立主从连接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">change master to master_host=&#x27;1.1.1.1&#x27;,master_user=&#x27;repl&#x27;,master_password=&#x27;pswd&#x27;,master_port=3306,master_log_file=&#x27;mysql-bin.000196&#x27;,master_log_pos=1037640668;</span><br><span class="line">start slave</span><br></pre></td></tr></table></figure>
<p>通过命令 <code>show slave status\G</code> 检查主从同步状态</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql 多主一从即多源复制</title>
    <url>/2207210946/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Mysql 5.7 之后版本支持多主一从</li>
</ul>
<h3 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h3><h4 id="分别在Master-1和Master-2上导出需要同步的数据库"><a href="#分别在Master-1和Master-2上导出需要同步的数据库" class="headerlink" title="分别在Master_1和Master_2上导出需要同步的数据库"></a>分别在Master_1和Master_2上导出需要同步的数据库</h4><p>分别在Master_1和Master_2上执行以下命令，导出需要同步的数据库备份</p>
<figure class="highlight shell"><figcaption><span>Master_1</span></figcaption><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p123456 --master-data=2 --single-transaction --databases  --add-drop-database  db1  &gt; db1.sql</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><figcaption><span>Master_2</span></figcaption><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p123456 --master-data=2 --single-transaction --databases  --add-drop-database  db2  &gt; db2.sql</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>备份完成后，将备份数据拷贝到从库服务器上面</p>
<span id="more"></span>

<h4 id="在Master-1和Master-2上创建复制账号"><a href="#在Master-1和Master-2上创建复制账号" class="headerlink" title="在Master_1和Master_2上创建复制账号"></a>在Master_1和Master_2上创建复制账号</h4><blockquote>
<p>如果已有复制账号，跳过此步骤</p>
</blockquote>
<p>分别在Master_1和Master_2上执行以下命令，创建复制账号</p>
<figure class="highlight shell"><figcaption><span>Master_1 Master_2</span></figcaption><table><tr><td class="code"><pre><span class="line">grant replication slave on *.* to &#x27;repl&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27;;</span><br></pre></td></tr></table></figure>
<h4 id="更改slave配置以支持多主一从"><a href="#更改slave配置以支持多主一从" class="headerlink" title="更改slave配置以支持多主一从"></a>更改slave配置以支持多主一从</h4><p>mysql支持多主一从(多源复制)的关键配置。<br>要配置mysql支持多源复制，必须配置mysql存储同步信息的方式，主要有以下2种方式 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[存储同步信息的方式说明](https://dev.mysql.com/doc/refman/5.7/en/replication-multi-source-configuration.html)
">[1]</span></a></sup></p>
<ul>
<li>FILE  默认配置，此时同步信息存储在文件master.info和relay-log.info</li>
<li>TABLE  同步信息存储在mysql.slave_master_info和mysql.slave_relay_log_info</li>
</ul>
<p>更改mysql配置文件(默认&#x2F;etc&#x2F;my.cnf)，配置存储同步信息的方式</p>
<figure class="highlight shell"><figcaption><span>/etc/my.cnf</span></figcaption><table><tr><td class="code"><pre><span class="line">master_info_repository=TABLE</span><br><span class="line">relay_log_info_repository=TABLE</span><br></pre></td></tr></table></figure>
<p>更改配置后，重启mysql生效</p>
<h4 id="slave上恢复Master-1和Master-2的备份数据"><a href="#slave上恢复Master-1和Master-2的备份数据" class="headerlink" title="slave上恢复Master_1和Master_2的备份数据"></a>slave上恢复Master_1和Master_2的备份数据</h4><figure class="highlight shell"><figcaption><span>slave</span></figcaption><table><tr><td class="code"><pre><span class="line">mysql -uroot -p  &lt; db1.sql</span><br><span class="line">mysql -uroot -p  &lt; db2.sql</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为在 <code>mysqldump</code> 备份时，使用了选项 <code>--add-drop-database</code>，slave导入备份时，无需指定db</p>
</blockquote>
<h4 id="slave上配置多源复制"><a href="#slave上配置多源复制" class="headerlink" title="slave上配置多源复制"></a>slave上配置多源复制</h4><h5 id="找到配置主从需要的binlog位置和Pos位置"><a href="#找到配置主从需要的binlog位置和Pos位置" class="headerlink" title="找到配置主从需要的binlog位置和Pos位置"></a>找到配置主从需要的binlog位置和Pos位置</h5><p>分别在Master_1和Master_2的备份数据中，查找以下内容，找到需要的binlog位置和Pos位置</p>
<figure class="highlight shell"><figcaption><span>slave</span></figcaption><table><tr><td class="code"><pre><span class="line">cat db1.sql |grep &quot; CHANGE MASTER&quot;</span><br><span class="line">cat db2.sql |grep &quot; CHANGE MASTER&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这些信息是由  <code>mysqldump</code> 的选项 <code>--master-data=2</code>提供 <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[--master-data=2说明](https://dev.mysql.com/doc/mysql-replication-excerpt/5.7/en/replication-howto-mysqldump.html)">[2]</span></a></sup><br>结果中包含以下类似内容：<br>CHANGE MASTER TO MASTER_LOG_FILE&#x3D;’log-bin.000001’, MASTER_LOG_POS&#x3D;1539;</p>
</blockquote>
<h5 id="登录salve数据库配置多源复制"><a href="#登录salve数据库配置多源复制" class="headerlink" title="登录salve数据库配置多源复制"></a>登录salve数据库配置多源复制</h5><p>登录slave数据库，分别执行以下命令，创建到Master_1和Master_2的复制</p>
<figure class="highlight shell"><figcaption><span>slave</span></figcaption><table><tr><td class="code"><pre><span class="line">CHANGE MASTER TO MASTER_HOST=&#x27;Master_1&#x27;,MASTER_USER=&#x27;repl&#x27;, MASTER_PASSWORD=&#x27;123456&#x27;,MASTER_LOG_FILE=&#x27;log-bin.000001&#x27;,MASTER_LOG_POS=1539 FOR CHANNEL &#x27;Master_1&#x27;;</span><br><span class="line">CHANGE MASTER TO MASTER_HOST=&#x27;Master_2&#x27;,MASTER_USER=&#x27;repl&#x27;, MASTER_PASSWORD=&#x27;123456&#x27;,MASTER_LOG_FILE=&#x27;log-bin.000001&#x27;,MASTER_LOG_POS=1539 FOR CHANNEL &#x27;Master_2&#x27;; </span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<blockquote>
<p>不同的主从复制以最后的 <code>FOR CHANNEL</code> 来区分</p>
</blockquote>
<h5 id="启动主从复制"><a href="#启动主从复制" class="headerlink" title="启动主从复制"></a>启动主从复制</h5><p>在slave数据库中执行以下命令分别启动复制</p>
<figure class="highlight shell"><figcaption><span>slave</span></figcaption><table><tr><td class="code"><pre><span class="line">start slave for channel &quot;Master_1&quot;;</span><br><span class="line">start slave for channel &quot;Master_1&quot;;</span><br></pre></td></tr></table></figure>
<p>也可以通过 <code>start slave;</code> 启动所有的复制</p>
<p>可以通过以下命令查看启动复制后的状态</p>
<figure class="highlight shell"><figcaption><span>slave</span></figcaption><table><tr><td class="code"><pre><span class="line">SHOW SLAVE STATUS FOR CHANNEL &#x27;Master_1&#x27;\G</span><br><span class="line">SHOW SLAVE STATUS FOR CHANNEL &#x27;Master_2&#x27;\G</span><br><span class="line">SHOW SLAVE STATUS\G</span><br></pre></td></tr></table></figure>

<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://dev.mysql.com/doc/">Mysql 官网</a></p>
<h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://dev.mysql.com/doc/refman/5.7/en/replication-multi-source-configuration.html">存储同步信息的方式说明</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://dev.mysql.com/doc/mysql-replication-excerpt/5.7/en/replication-howto-mysqldump.html">--master-data=2说明</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql 主从复制相关原理简述</title>
    <url>/2207211114/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<h2 id="Mysql-主从同步基本原理"><a href="#Mysql-主从同步基本原理" class="headerlink" title="Mysql 主从同步基本原理"></a>Mysql 主从同步基本原理</h2></blockquote>
<p>复制的基本过程如下：  </p>
<ol>
<li><p>Slave上面的IO进程连接上Master，并请求从指定日志文件的指定位置（或者从最开始的日志）之后的日志内容；</p>
</li>
<li><p>Master接收到来自Slave的IO进程的请求后，通过负责复制的IO进程,根据请求信息,读取指定日志指定位置之后的日志信息，返回给Slave 的IO进程。返回信息中除了日志所包含的信息之外，还包括本次返回的信息已经到Master端的bin-log文件的名称以及bin-log的位置；</p>
</li>
<li><p>Slave的IO进程接收到信息后，将接收到的日志内容依次添加到Slave端的relay-log文件的最末端，并将读取到的Master端的 bin-log的文件名和位置记录到master-info文件中，以便在下一次读取的时候能够清楚的告诉Master“我需要从某个bin-log的哪个位置开始往后的日志内容，请发给我”；</p>
</li>
<li><p>Slave的Sql进程检测到relay-log中新增加了内容后，会马上解析relay-log的内容，获得在Master端真实执行的那些可执行的内容，并在自身执行。</p>
</li>
</ol>
<p>双主情况下，禁止同时写入，建议还是按照主从的方式工作，防止数据冲突。双主场景下，主要是切换主备方便。</p>
<span id="more"></span>

<blockquote>
<h2 id="Mysql-复制方式"><a href="#Mysql-复制方式" class="headerlink" title="Mysql 复制方式"></a>Mysql 复制方式</h2></blockquote>
<blockquote>
<h3 id="异步复制（Asynchronous-replication）"><a href="#异步复制（Asynchronous-replication）" class="headerlink" title="异步复制（Asynchronous replication）"></a>异步复制（Asynchronous replication）</h3></blockquote>
<p>MySQL默认的复制即是异步的，主库在执行完客户端提交的事务后会立即将结果返给给客户端，并不关心从库是否已经接收并处理，这样就会有一个问题，主如果crash掉了，此时主上已经提交的事务可能并没有传到从上，如果此时，强行将从提升为主，可能导致新主上的数据不完整。</p>
<blockquote>
<h3 id="全同步复制（Fully-synchronous-replication）"><a href="#全同步复制（Fully-synchronous-replication）" class="headerlink" title="全同步复制（Fully synchronous replication）"></a>全同步复制（Fully synchronous replication）</h3></blockquote>
<p>指当主库执行完一个事务，所有的从库都执行了该事务才返回给客户端。因为需要等待所有从库执行完该事务才能返回，所以全同步复制的性能必然会收到严重的影响。</p>
<blockquote>
<h3 id="半同步复制（Semisynchronous-replication）"><a href="#半同步复制（Semisynchronous-replication）" class="headerlink" title="半同步复制（Semisynchronous replication）"></a>半同步复制（Semisynchronous replication）</h3></blockquote>
<p>介于异步复制和全同步复制之间，主库在执行完客户端提交的事务后不是立刻返回给客户端，而是等待至少一个从库接收到并写到relay log中才返回给客户端。相对于异步复制，半同步复制提高了数据的安全性，同时它也造成了一定程度的延迟，这个延迟最少是一个TCP&#x2F;IP往返的时间。所以，半同步复制最好在低延时的网络中使用。半同步复制失败(配置超时时间)，自动转为异步复制  </p>
<h4 id="半同步复制配置步骤"><a href="#半同步复制配置步骤" class="headerlink" title="半同步复制配置步骤"></a>半同步复制配置步骤</h4><ol>
<li><p>加载使用的插件<br>主库执行以下命令</p>
<figure class="highlight shell"><figcaption><span>master</span></figcaption><table><tr><td class="code"><pre><span class="line">INSTALL PLUGIN rpl_semi_sync_master SONAME &#x27;semisync_master.so&#x27;;</span><br></pre></td></tr></table></figure>
<p>从库执行以下命令</p>
<figure class="highlight shell"><figcaption><span>slave</span></figcaption><table><tr><td class="code"><pre><span class="line">INSTALL PLUGIN rpl_semi_sync_slave SONAME &#x27;semisync_slave.so&#x27;;</span><br></pre></td></tr></table></figure>
<p>通过 <code>show plugins;</code> 可查看已加载的插件</p>
</li>
<li><p>启动半同步复制<br>主库执行以下命令</p>
<figure class="highlight shell"><figcaption><span>master</span></figcaption><table><tr><td class="code"><pre><span class="line">SET GLOBAL rpl_semi_sync_master_enabled = 1;</span><br></pre></td></tr></table></figure>
<p>从库执行以下命令</p>
<figure class="highlight shell"><figcaption><span>slave</span></figcaption><table><tr><td class="code"><pre><span class="line">SET GLOBAL rpl_semi_sync_slave_enabled = 1;</span><br></pre></td></tr></table></figure>
<p>执行以下命令重启从库上的IO线程</p>
<figure class="highlight shell"><figcaption><span>slave</span></figcaption><table><tr><td class="code"><pre><span class="line">STOP SLAVE IO_THREAD;</span><br><span class="line">START SLAVE IO_THREAD;</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查半同步复制插件是否在运行<br>主库执行以下命令</p>
<figure class="highlight shell"><figcaption><span>master</span></figcaption><table><tr><td class="code"><pre><span class="line">show status like &#x27;Rpl_semi_sync_master_status&#x27;;</span><br></pre></td></tr></table></figure>
<p>从库执行以下命令</p>
<figure class="highlight shell"><figcaption><span>slave</span></figcaption><table><tr><td class="code"><pre><span class="line">show status like &#x27;Rpl_semi_sync_slave_status&#x27;;</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<h2 id="Mysql-复制级别说明"><a href="#Mysql-复制级别说明" class="headerlink" title="Mysql 复制级别说明"></a>Mysql 复制级别说明</h2></blockquote>
<p>不同复制级别的设置会影响到Master端的bin-log记录成不同的形式。<br>配置方式:</p>
<figure class="highlight shell"><figcaption><span>/etc/my.cnf</span></figcaption><table><tr><td class="code"><pre><span class="line">binlog_format=&#x27;row&#x27;</span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="基于sql语句（Statement-level）"><a href="#基于sql语句（Statement-level）" class="headerlink" title="基于sql语句（Statement level）"></a>基于sql语句（Statement level）</h3></blockquote>
<p>每一条会修改数据的sql都会记录到 master的bin-log中。slave在复制的时候，sql进程会解析成和原来master端执行过的相同的sql来再次执行。</p>
<p><strong>优点</strong>：statement level下的优点首先就是解决了<a href="#%E5%9F%BA%E4%BA%8E%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95%EF%BC%88Row-level%EF%BC%89">row level</a>下的缺点，不需要记录每一行数据的变化，减少bin-log日志量，节约IO，提高性能。因为他只需要记录在Master上所执行的语句的细节，以及执行语句时候的上下文的信息。</p>
<p><strong>缺点</strong>：由于他是记录的执行语句，所以，为了让这些语句在slave端也能正确执行，那么他还必须记录每条语句在执行的时候的一些相关信息，也就是上下文信息，以保证所有语句在slave端被执行的时候能够得到和在master端执行时候相同的结果。<br>另外就是，由于Mysql现在发展比较快，很多的新功能不断的加入，使mysql的复制遇到了不小的挑战，复制的时候涉及到越复杂的内容，bug也就越容易出现。在statement level下，目前已经发现的就有不少情况会造成mysql的复制出现问题，主要是修改数据的时候使用了某些特定的函数或者功能的时候会出现，比如：sleep()函数在有些版本中就不能真确复制，在存储过程中使用了last_insert_id()函数，可能会使slave和master上得到不一致的id等等。<br>由于row level是基于每一行来记录的变化，所以不会出现类似的问题。</p>
<blockquote>
<h3 id="基于一条记录（Row-level）"><a href="#基于一条记录（Row-level）" class="headerlink" title="基于一条记录（Row level）"></a>基于一条记录（Row level）</h3></blockquote>
<p>日志中会记录成每一行数据被修改的形式，然后在slave端再对相同的数据进行修改</p>
<p><strong>优点</strong>： 在row level模式下，bin-log中可以不记录执行的sql语句的上下文相关的信息，仅仅只需要记录那一条记录被修改了，修改成什么样了。所以row level的日志内容会非常清楚的记录下每一行数据修改的细节，非常容易理解。而且不会出现某些特定情况下的存储过程，或function，以及 trigger的调用和触发无法被正确复制的问题。<br>任何情况都可以被复制，这对复制来说是最安全可靠的；和其他大多数数据库系统的复制技术一样；多数情况下，从服务器上的表如果有主键的话，复制就会快了很多,更少的锁</p>
<p><strong>缺点</strong>： row level下，所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容，比如有这样一条update语句：update product set owner_member_id &#x3D; ‘b’ where owner_member_id &#x3D; ‘a’，执行之后，日志中记录的不是这条update语句所对应的事件（mysql以事件的形式来记录bin-log日志），而是这条语句所更新的每一条记录的变化情况，这样就记录成很多条记录被更新的很多个事件。自然，bin-log日志的量就会很大。尤其是当执行alter table之类的语句的时候，产生的日志量是惊人的。因为Mysql对于alter table之类的表结构变更语句的处理方式是整个表的每一条记录都需要变动，实际上就是重建了整个表。那么该表的每一条记录都会被记录到日志中。</p>
<blockquote>
<h3 id="Mixed"><a href="#Mixed" class="headerlink" title="Mixed"></a>Mixed</h3></blockquote>
<p>在Mixed模式下，Mysql会根据执行的每一条具体的sql语句,来区分对待记录的日志形式，也就是在Statement和Row之间选择一种。新版本中的Statment level还是和以前一样，仅仅记录执行的语句。而新版本的Mysql中对row level模式也被做了优化，并不是所有的修改都会以row level来记录，像遇到表结构变更的时候就会以statement模式来记录，如果sql语句确实就是update或者delete等修改数据的语句，那么还是会记录所有行的变更。</p>
<blockquote>
<h3 id="GTID模式"><a href="#GTID模式" class="headerlink" title="GTID模式"></a>GTID模式</h3></blockquote>
<p>需要基于row模式，mysql-5.6.2支持,mysql5.6.10后完善</p>
<figure class="highlight shell"><figcaption><span>/etc/my.cnf</span></figcaption><table><tr><td class="code"><pre><span class="line">log_bin=on</span><br><span class="line">binlog_format=&#x27;row&#x27;</span><br><span class="line">gtid_mode=on</span><br><span class="line">enforce-gtid-consistency=on</span><br><span class="line">log-slave-updates=1</span><br></pre></td></tr></table></figure>
<p>限制：</p>
<ol>
<li>不支持非事务引擎(从库报错, stop slave; start slave ; 忽略)</li>
<li>不支持create table … select语句(主库直接报错)</li>
<li>不支持一个sql同时更新一个事务引擎和非事务引擎的表</li>
<li>在一个复制组中,必须要求统一开启gtid或是关闭gtid</li>
<li>开启gtid需要重启</li>
<li>开启gtid后,就不在使用原来传统的复制方式</li>
<li>对于create temporary table和drop temporary table语句不支持</li>
<li>不支持sql_slave_skip_counter</li>
</ol>
<blockquote>
<h2 id="MySQL（主从）配置相关参数"><a href="#MySQL（主从）配置相关参数" class="headerlink" title="MySQL（主从）配置相关参数"></a>MySQL（主从）配置相关参数</h2></blockquote>
<p>master相关配置  </p>
<figure class="highlight shell"><figcaption><span>master my.cnf</span></figcaption><table><tr><td class="code"><pre><span class="line">server-id = 1</span><br><span class="line">log-bin = mysql-bin    #要生成的二进制日志文件名称</span><br><span class="line">binlog_format=statement/row/mixed        ###复制实现模式/级别</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">binlog-do-db = rtzc_pnc_base       <span class="comment">##要同步的库.应该尽可能的在从库上使用replicate_wild_*，不建议在主库上使用</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">binlog-ignore-db = mysql   <span class="comment">#不同步的数据库,应该在从库上尽可能的使用replicate_wild_*</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#### 一般不再主服务器上过滤，虽然可以减少主的开销，但这样会导致二进制日志不完整</span></span></span><br><span class="line">sync_binlog=0</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#######</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">0      表示MySQL 不控制binlog的刷新，由文件系统自己控制它的缓存的刷新。这时候的性能是最好的，但是风险也是最大的。因为一旦系统Crash，在binlog_cache中的所有binlog信息都会被丢失。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sync_binlog&gt;0    表示每N个sync_binlog次事务提交，MySQL调用文件系统的刷新操作将缓存刷下去。最安全的就是sync_binlog=1了，表示每次事务提交，MySQL都会把binlog刷下去，是最安全但是性能损耗最大的设置。这样的话，在数据库所在的主机操作系统损坏或者突然掉电的情况下，系统才有可能丢失1个事务的数据。但是binlog虽然是顺序IO，但是设置sync_binlog=1，多个事务同时提交，同样很大的影响MySQL和IO性能。对于高并发事务的系统来说，“sync_binlog”设置为0和设置为1的系统写入性能差距可能高达5倍甚至更多。</span></span><br><span class="line"></span><br><span class="line">innodb_flush_log_at_trx_commit = 1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##########innodb特有参数</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">N=0     每隔一秒，把事务日志缓存区的数据写到日志文件中，以及把日志文件的数据刷新到磁盘上；在这种情况下，MySQL性能最好，但如果 mysqld 进程崩溃，通常会导致最后 1s 的日志丢失。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">N=1     每个事务提交时候，把事务日志从缓存区写到日志文件中，并且刷新日志文件的数据到磁盘上；每次事务提交时，<span class="built_in">log</span> buffer 会被写入到日志文件并刷写到磁盘。这也是默认值。这是最安全的配置，但由于每次事务都需要进行磁盘I/O，所以也最慢。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">N=2    当取值为 2 时，每次事务提交会写入日志文件，但并不会立即刷写到磁盘，日志文件会每秒刷写一次到磁盘。这时如果 mysqld 进程崩溃，由于日志已经写入到系统缓存，所以并不会丢失数据；在操作系统崩溃的情况下，通常会导致最后 1s 的日志丢失。 对于一些数据一致性和完整性要求不高的应用，配置为 2 就足够了；如果为了最高性能，可以设置为 0。有些应用，如支付服务，对一致性和完整性要求很高，所以即使最慢，也最好设置为 1.</span> </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">replicate-wild-ignore-table=db.*               <span class="comment">###应该在从库上尽可能的使用replicate_wild_</span></span></span><br><span class="line"></span><br><span class="line">max_binlog_size</span><br><span class="line">expire_logs_days = 7          ##日志保存天数</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>slave相关配置</p>
<figure class="highlight shell"><figcaption><span>my.cnf</span></figcaption><table><tr><td class="code"><pre><span class="line">server-id = 2</span><br><span class="line">relay-log = mysql-relay-bin</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">replicate-do-db = rtzc_pnc_base     <span class="comment">##应该在从库上尽可能的使用replicate_wild_*，并不会减少主往从复制数据占用带宽</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">replicate-do-table = db.table      <span class="comment">##表级过滤</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#replicate-ignore-table = db.table</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">replicate_ignore_db=<span class="built_in">test</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">replicate_wild_do_table=DB_NAME.%</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">replicate_wild_ignore_table=DB_NAME.%</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">slave-skip-errors = 1032,1062     <span class="comment">###跳过某些同步错误号</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">log-slave-updates=1          <span class="comment">###从库需要记录binlog，如级联从库场景，级联从库必须有此参数</span></span></span><br><span class="line">log-bin = mysql-bin</span><br><span class="line"></span><br><span class="line">expire_logs_days = 7</span><br><span class="line"></span><br><span class="line">read-only         ###从库Slave中使用read-only参数，确保从库数据不被非法更新。</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">innodb_read_only = 1         <span class="comment">###控制root用户，慎用</span></span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>yum 安装 Mysql 5.7</title>
    <url>/202211021345/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos 7 kernel 5.4</li>
<li>Mysql Server 5.7</li>
</ul>
<h1 id="Mysql-Server-安装步骤"><a href="#Mysql-Server-安装步骤" class="headerlink" title="Mysql Server 安装步骤"></a>Mysql Server 安装步骤</h1><h2 id="yum-方式安装"><a href="#yum-方式安装" class="headerlink" title="yum 方式安装"></a>yum 方式安装</h2><h3 id="安装-MySQL-5-7-的-yum-源"><a href="#安装-MySQL-5-7-的-yum-源" class="headerlink" title="安装  MySQL 5.7 的 yum 源"></a>安装  MySQL 5.7 的 yum 源</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum localinstall -y http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm</span><br></pre></td></tr></table></figure>
<p>如果因为源冲突，类似如下错误</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Processing Conflict: mysql80-community-release-el7-2.noarch conflicts mysql57-community-release</span><br></pre></td></tr></table></figure>

<p>可以卸载旧的 <code>yum</code> 源安装包，重新安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rpm -qa | grep mysql</span></span><br><span class="line">mysql80-community-release-el7-2.noarch</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum remove mysql80-community-release-el7-2</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum localinstall -y http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm</span></span><br></pre></td></tr></table></figure>

<p>检查 <code>yum</code> 源中的 <code>mysql-community-server</code> 信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum info mysql-community-server</span></span><br><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * base: download.cf.centos.org</span><br><span class="line"> * elrepo: reflector.westga.edu</span><br><span class="line"> * epel: coresite.mm.fcix.net</span><br><span class="line"> * extras: download.cf.centos.org</span><br><span class="line"> * updates: download.cf.centos.org</span><br><span class="line">Available Packages</span><br><span class="line">Name        : mysql-community-server</span><br><span class="line">Arch        : x86_64</span><br><span class="line">Version     : 5.7.40</span><br><span class="line">Release     : 1.el7</span><br><span class="line">Size        : 178 M</span><br><span class="line">Repo        : mysql57-community/x86_64</span><br><span class="line">Summary     : A very fast and reliable SQL database server</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<span id="more"></span>
<h3 id="安装-mysql-community-server"><a href="#安装-mysql-community-server" class="headerlink" title="安装 mysql-community-server"></a>安装 mysql-community-server</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y mysql-community-server</span><br></pre></td></tr></table></figure>

<h3 id="启动-mysql-server"><a href="#启动-mysql-server" class="headerlink" title="启动 mysql server"></a>启动 mysql server</h3><p>配置 mysql server 开机启动，同时启动服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable mysqld --now</span><br></pre></td></tr></table></figure>

<p>MySQL5.7 会为 root 用户随机生成一个临时密码，密码记录在日志 <code>/var/log/mysqld.log </code> 中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep &#x27;temporary password&#x27; /var/log/mysqld.log </span><br><span class="line">2022-11-02T06:09:54.520945Z 1 [Note] A temporary password is generated for root@localhost: ZQc6OCFidi:g</span><br></pre></td></tr></table></figure>

<p>使用临时密码登陆，修改密码，临时密码登陆后不能做任何操作，必须先更改密码</p>
<figure class="highlight shell"><figcaption><span>mysql</span></figcaption><table><tr><td class="code"><pre><span class="line">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;WadgyWwRdgDNEb+5Pw==&#x27;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>namesilo api 使用</title>
    <url>/202303031036/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="https://www.namesilo.com/api-reference">Namesilo api 官方文档</a></p>
<p>Python SDK 为 <a href="https://pypi.org/project/python-namesilo/">python-namesilo</a>，安装方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install python-namesilo</span><br></pre></td></tr></table></figure>

<h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Python 3.11.2</li>
<li>python-namesilo&#x3D;&#x3D;1.1.3</li>
</ul>
<h1 id="python-namesilo-常见用法示例"><a href="#python-namesilo-常见用法示例" class="headerlink" title="python-namesilo 常见用法示例"></a>python-namesilo 常见用法示例</h1><h2 id="获取账号中的所有域名"><a href="#获取账号中的所有域名" class="headerlink" title="获取账号中的所有域名"></a>获取账号中的所有域名</h2><p>使用 SDK 之前需要先登陆账号创建 API Token，详细使用方法可以查看帮助信息，获取所有域名使用方法 <code>list_domains</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> namesilo.core <span class="keyword">import</span> NameSilo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>key = <span class="string">&#x27;KKKKKKKKKKKKKKKKKK&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>client = NameSilo(token=key, sandbox=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">help</span>(client)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>client.list_domains()</span><br></pre></td></tr></table></figure>

<h2 id="获取指定域名的详细信息"><a href="#获取指定域名的详细信息" class="headerlink" title="获取指定域名的详细信息"></a>获取指定域名的详细信息</h2><p>获取指定域名的详细信息使用 <code>get_domain_info</code>，此方法返回一个 <code>DomainInfo</code> 对象，里面包括域名创建时间，过期时间，nameserver等信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>client.get_domain_info(<span class="string">&#x27;test.app&#x27;</span>)</span><br><span class="line">&lt;namesilo.common.models.DomainInfo <span class="built_in">object</span> at <span class="number">0x7f71a0530a50</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>(client.get_domain_info(<span class="string">&#x27;test.app&#x27;</span>))</span><br><span class="line">[<span class="string">&#x27;auto_renew&#x27;</span>, <span class="string">&#x27;contacts&#x27;</span>, <span class="string">&#x27;created&#x27;</span>, <span class="string">&#x27;expires&#x27;</span>, <span class="string">&#x27;locked&#x27;</span>, <span class="string">&#x27;name_servers&#x27;</span>, <span class="string">&#x27;private&#x27;</span>, <span class="string">&#x27;status&#x27;</span>, <span class="string">&#x27;traffic_type&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>云平台</category>
        <category>Namesilo</category>
      </categories>
      <tags>
        <tag>Namesilo</tag>
      </tags>
  </entry>
  <entry>
    <title>nfs 服务部署使用</title>
    <url>/202210251713/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>NFS（Network File System 的缩写），它的主要功能是：通过网络、让不同的机器、不同的 OS 可以共享彼此的文件</p>
<p>NFS 服务器可以允许 NFS 客户端将远端 NFS 服务器的共享目录挂载到自己的系统上，当作本地磁盘一样使用</p>
<h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos 7</li>
</ul>
<h1 id="服务安装"><a href="#服务安装" class="headerlink" title="服务安装"></a>服务安装</h1><h2 id="服务端安装"><a href="#服务端安装" class="headerlink" title="服务端安装"></a>服务端安装</h2><p>安装需要的软件包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install nfs-utils rpcbind</span><br></pre></td></tr></table></figure>

<p>创建数据目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /data/NFSDataHome</span><br><span class="line">chmod 666 /data/NFSDataHome</span><br></pre></td></tr></table></figure>

<p>修改配置文件 <code>/etc/exports</code>:</p>
<figure class="highlight shell"><figcaption><span>/etc/exports</span></figcaption><table><tr><td class="code"><pre><span class="line">/data/NFSDataHome 192.168.1.0/24(rw,sync,insecure,no_subtree_check,no_root_squash) </span><br><span class="line">/data/NFSDataHome *(ro)</span><br></pre></td></tr></table></figure>

<p>相关选项说明：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ro</td>
<td>只读访问</td>
</tr>
<tr>
<td>rw</td>
<td>读写访问</td>
</tr>
<tr>
<td>sync</td>
<td>所有数据在请求时写入共享</td>
</tr>
<tr>
<td>async</td>
<td>nfs 在写入数据前可以响应请求</td>
</tr>
<tr>
<td>secure</td>
<td>nfs 通过 1024 以下的安全 TCP&#x2F;IP 端口发送</td>
</tr>
<tr>
<td>insecure</td>
<td>nfs 通过 1024 以上的端口发送</td>
</tr>
<tr>
<td>wdelay</td>
<td>如果多个用户要写入 nfs 目录，则归组写入（默认）</td>
</tr>
<tr>
<td>no_wdelay</td>
<td>如果多个用户要写入 nfs 目录，则立即写入，当使用 async 时，无需此设置</td>
</tr>
<tr>
<td>hide</td>
<td>在 nfs 共享目录中不共享其子目录</td>
</tr>
<tr>
<td>no_hide</td>
<td>共享 nfs 目录的子目录</td>
</tr>
<tr>
<td>subtree_check</td>
<td>如果共享 &#x2F;usr&#x2F;bin 之类的子目录时，强制 nfs 检查父目录的权限（默认）</td>
</tr>
<tr>
<td>no_subtree_check</td>
<td>不检查父目录权限</td>
</tr>
<tr>
<td>all_squash</td>
<td>无论 NFS 客户端以哪种用户身份访问，均映射为 NFS 服务器的 nfsnobody 用户</td>
</tr>
<tr>
<td>no_all_squash</td>
<td>保留共享文件的 UID 和 GID（默认）</td>
</tr>
<tr>
<td>root_squash</td>
<td>当 NFS 客户端以 root 用户身份访问时，映射为 NFS 服务器的 nfsnobody 用户</td>
</tr>
<tr>
<td>no_root_squash</td>
<td>当 NFS 客户端以 root 身份访问时，映射为 NFS 服务器的 root 用户，也就是要为超级用户保留权限。这个选项会留下严重的安全隐患，一般不建议采用。</td>
</tr>
<tr>
<td>anonuid&#x3D;xxx</td>
<td>指定 nfs 服务器 &#x2F;etc&#x2F;passwd 文件中匿名用户的 UID</td>
</tr>
<tr>
<td>anongid&#x3D;xxx</td>
<td>指定 nfs 服务器 &#x2F;etc&#x2F;passwd 文件中匿名用户的 GID</td>
</tr>
</tbody></table>
<span id="more"></span>

<p>启动 <code>rpcbind</code> 服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable rpcbind.service --now</span><br></pre></td></tr></table></figure>
<p>启动 <code>nfs</code> 服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable nfs.service --now</span><br></pre></td></tr></table></figure>

<p>检查 expose 的资源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">showmount -e localhost</span></span><br><span class="line">Export list for localhost:</span><br><span class="line">/data/NFSDataHome *</span><br></pre></td></tr></table></figure>

<p>默认情况下，NFS server 启动时会随机启动多个端口并向 RPC 注册，有防火墙的场景下，不利于防火墙配置确切的端口。所以建议配置 NFS 使用固定的端口，配置方式如下</p>
<ol>
<li><p>编辑配置文件 <code>/etc/sysconfig/nfs</code>，添加以下内容</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RQUOTAD_PORT=30001</span><br><span class="line"></span><br><span class="line">LOCKD_TCPPORT=30002</span><br><span class="line"></span><br><span class="line">LOCKD_UDPPORT=30002</span><br><span class="line"></span><br><span class="line">MOUNTD_PORT=30003</span><br><span class="line"></span><br><span class="line">STATD_PORT=30004</span><br></pre></td></tr></table></figure></li>
<li><p>重启服务</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart rpcbind</span><br><span class="line">systemctl restart nfs</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>查看 NFS 使用的 RPC 端口</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ rpcinfo -p</span><br><span class="line">program vers proto   port  service</span><br><span class="line"> 100000    4   tcp    111  portmapper</span><br><span class="line"> 100000    3   tcp    111  portmapper</span><br><span class="line"> 100000    2   tcp    111  portmapper</span><br><span class="line"> 100000    4   udp    111  portmapper</span><br><span class="line"> 100000    3   udp    111  portmapper</span><br><span class="line"> 100000    2   udp    111  portmapper</span><br><span class="line"> 100005    1   udp  30003  mountd</span><br><span class="line"> 100005    1   tcp  30003  mountd</span><br><span class="line"> 100005    2   udp  30003  mountd</span><br><span class="line"> 100005    2   tcp  30003  mountd</span><br><span class="line"> 100005    3   udp  30003  mountd</span><br><span class="line"> 100005    3   tcp  30003  mountd</span><br><span class="line"> 100003    3   tcp   2049  nfs</span><br><span class="line"> 100003    4   tcp   2049  nfs</span><br><span class="line"> 100227    3   tcp   2049  nfs_acl</span><br><span class="line"> 100003    3   udp   2049  nfs</span><br><span class="line"> 100003    4   udp   2049  nfs</span><br><span class="line"> 100227    3   udp   2049  nfs_acl</span><br><span class="line"> 100021    1   udp  30002  nlockmgr</span><br><span class="line"> 100021    3   udp  30002  nlockmgr</span><br><span class="line"> 100021    4   udp  30002  nlockmgr</span><br><span class="line"> 100021    1   tcp  30002  nlockmgr</span><br><span class="line"> 100021    3   tcp  30002  nlockmgr</span><br><span class="line"> 100021    4   tcp  30002  nlockmgr</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>添加防火墙规则</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iptables -I INPUT 6 -p udp -m multiport --dports 111,2049,30001:30004 -j ACCEPT -m comment --comment &quot;nfs&quot;</span><br><span class="line">iptables -I INPUT 6 -p tcp -m multiport --dports 111,2049,30001:30004 -j ACCEPT -m comment --comment &quot;nfs&quot;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="客户端安装"><a href="#客户端安装" class="headerlink" title="客户端安装"></a>客户端安装</h2><h3 id="linux-客户端安装"><a href="#linux-客户端安装" class="headerlink" title="linux 客户端安装"></a>linux 客户端安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install nfs-utils</span><br></pre></td></tr></table></figure>

<p>测试 NFS 服务端 expose 的资源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">showmount -e <span class="variable">$&#123;NFS_SERVER_IP&#125;</span></span></span><br><span class="line">Export list for $&#123;NFS_SERVER_IP&#125;:</span><br><span class="line">/data/NFSDataHome *</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>客户端挂载</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount.nfs $&#123;NFS_SERVER_IP&#125;:/data/NFSDataHome /mnt/</span><br></pre></td></tr></table></figure>

<p>配置开机自动挂载，在 <code>/etc/fstab</code> 文件中添加以下内容</p>
<figure class="highlight shell"><figcaption><span>/etc/fstab</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;NFS_SERVER_IP&#125;:/data/NFSDataHome /mnt nfs defaults        0 0</span></span><br></pre></td></tr></table></figure>

<h3 id="Windows-客户端安装"><a href="#Windows-客户端安装" class="headerlink" title="Windows 客户端安装"></a>Windows 客户端安装</h3><ul>
<li>windows os： Win 10</li>
</ul>
<p>打开控制面板 -&gt; 程序 -&gt; 打开或关闭windows功能 -&gt; NFS客户端 ，启用 NFS。</p>
<p>cmd  执行以下命令挂载：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount IP:/nfsroot X:</span><br></pre></td></tr></table></figure>
<p>其中，<code>IP</code> 为 NFS 服务器得 IP，<code>/nfsroot</code> 为你挂载得 NFS 目录路径，执行成功后 NFS 路径会被挂载到 <code>X:</code> 盘</p>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="windows-挂载-NFS-后访问速度慢"><a href="#windows-挂载-NFS-后访问速度慢" class="headerlink" title="windows 挂载 NFS 后访问速度慢"></a>windows 挂载 NFS 后访问速度慢</h2><p>在 cmd 中通过命令 <code>mount</code> 查看挂载信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mount</span></span><br><span class="line"></span><br><span class="line">Local    Remote                                 Properties</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">x:       \\nfsserver\NFSDataHome                UID=-2, GID=-2</span><br><span class="line">                                                rsize=1048576, wsize=1048576</span><br><span class="line">                                                mount=soft, timeout=0.8</span><br><span class="line">                                                retry=1, locking=yes</span><br><span class="line">                                                fileaccess=755, lang=ANSI</span><br><span class="line">                                                casesensitive=no</span><br><span class="line">                                                sec=sys</span><br></pre></td></tr></table></figure>
<p>输出中可以看到读写大小（<code>rsize=1048576, wsize=1048576</code>，1M），NFS 服务默认的读写大小在配置文件 <code>/etc/nfsmount.conf</code>，默认大小为 8k</p>
<figure class="highlight shell"><figcaption><span>/etc/nfsmount.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Maximum Read Size (<span class="keyword">in</span> Bytes)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Rsize=8k</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Maximum Write Size (in Bytes)</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Wsize=8k</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将此配置修改为和 windows nfs 客户端的读写大小一样，重启 nfs 服务，window 重新挂载。</p>
<h2 id="Mysql-数据目录使用-NFS-文件系统"><a href="#Mysql-数据目录使用-NFS-文件系统" class="headerlink" title="Mysql 数据目录使用 NFS 文件系统"></a>Mysql 数据目录使用 NFS 文件系统</h2><blockquote>
<p>Mysql 数据目录使用 NFS 文件系统，只用来测试</p>
</blockquote>
<p>当 NFS 服务使用选项 <code>all_squash</code> 时，因为所有的客户端操作时，用户身份都会映射为 NFS 服务器上面的 <code>nfsnobody</code> 用户，Mysql 默认的用户 <code>mysql</code> 对此 NFS 目录权限受到限制，会导致初始化失败，报以下错误</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mysql_install_db --defaults-file=/etc/my.cnf -u mysql --basedir=/var/lib/mysql --datadir=/var/lib/mysql/data/</span></span><br><span class="line">2023-02-10 14:53:22 [WARNING] mysql_install_db is deprecated. Please consider switching to mysqld --initialize</span><br><span class="line">2023-02-10 14:53:22 [ERROR]   Failed to set file ownership for /var/lib/mysql/data/ to (999, 1002)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2023-02-10 14:53:59 [ERROR]   Child process: /bin/mysqldterminated prematurely with errno= 32</span><br></pre></td></tr></table></figure>

<p>针对此情况，可以修改 Mysql 服务运行的用户为 <code>nfsnobody</code>，并且此 <code>nfsnobody</code> 用户需要和 NFS 服务器上面的 <code>nfsnobody</code> 用户具有相同的 UID 和 GID</p>
<p>查看 NFS 服务器上面的 <code>nfsnobody</code> 的 ID 信息，默认为 <code>65534</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">id</span> nfsnobody</span></span><br><span class="line">uid=65534(nfsnobody) gid=65534(nfsnobody) groups=65534(nfsnobody)</span><br></pre></td></tr></table></figure>

<p>在 Mysql 服务器上面创建具有相同 UID 和 GID 的 <code>nfsnobody</code> 用户和组信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groupadd --gid 65534 nfsnobody</span><br><span class="line"></span><br><span class="line">useradd --uid 65534 --gid 65534 -M -s /sbin/nologin</span><br></pre></td></tr></table></figure>

<p>使用 <code>nfsnobody</code> 用户初始化数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql_install_db --defaults-file=/etc/my.cnf -u nfsnobody --basedir=/var/lib/mysql --datadir=/var/lib/mysql/data/</span><br></pre></td></tr></table></figure>

<p>修改 mysql 服务配置文件，配置以下内容，指定运行时使用的用户</p>
<figure class="highlight shell"><figcaption><span>/etc/my.cnf</span></figcaption><table><tr><td class="code"><pre><span class="line">user = mysql</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx 服务常用配置说明</title>
    <url>/202207261420/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Nginx-服务配置"><a href="#Nginx-服务配置" class="headerlink" title="Nginx 服务配置"></a>Nginx 服务配置</h1><h2 id="全局通用配置"><a href="#全局通用配置" class="headerlink" title="全局通用配置"></a>全局通用配置</h2><figure class="highlight shell"><figcaption><span>nginx.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">user nginx nginx;    </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">建议设置为 cpu 核心数或者 cpu 核心数的 2 倍，进程会包含一个 `master process`，多个 `worker process`</span>  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">master process 负责绑定端口、调度进程等，不负责业务的处理</span>  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">worker process 是业务进程，负责业务的处理</span></span><br><span class="line">worker_processes auto;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一个 worker 进程可以打开的最大的 fd 个数，受 Linux 内核限制</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">理论值应该是系统最多打开文件数（<span class="built_in">ulimit</span> -n）与 nginx 进程数相除</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可通过 <span class="built_in">ulimit</span> 设置或修改系统文件：`/etc/securit/limits.conf`</span></span><br><span class="line">worker_rlimit_nofile 1024；</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">cpu 亲和性设置</span> </span><br><span class="line">worker_cpu_affinity    0001 0010 0100 1000;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">工作进程调度优先级，-20 到 19 之间的值，值越小越优先调用。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果系统同时运行多个任务，你可能需要提高 nginx 的工作进程的优先级</span> </span><br><span class="line">worker_priority 0；              </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ssl 硬件加速服务器，需要硬件支持</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ssl_engine ssl_engine device;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">nginx 是否以守护进程运行，是否让 nignx 运行于后台；调试时可为 off，使得所有信息直接输出在控制台</span></span><br><span class="line">daemon      on | off;         </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">events 模块中包含 nginx 中所有处理连接的设置。</span></span><br><span class="line">events &#123;</span><br><span class="line">    # 每个 worker 进程允许的最多连接数, </span><br><span class="line">    # nginx 服务最大连接数：worker_processes * worker_connections (受 worker_rlimit_nofile 限制)</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">    use epoll;</span><br><span class="line">    </span><br><span class="line">    # 是否允许一次性地响应多个用户请求</span><br><span class="line">    multi_accept on;                    </span><br><span class="line"></span><br><span class="line">    # 是否打开 nginx 的 accept 锁；此锁能够让多个 worker 进行轮流地、序列化地与新的客户端建立连接；</span><br><span class="line">    # 而通常当一个 worker 进程的负载达到其上限的 7/8，master 就尽可能不将请求调度至 worker.</span><br><span class="line">	accept_mutex on | off;              </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">HTTP 模块控制着 nginx http 处理的所有核心特性</span></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    # 是否在错误页面中显示和响应头字段中发出 nginx 版本号。</span><br><span class="line">    # 安全考虑建议关闭</span><br><span class="line">    server_tokens on | off | string; </span><br><span class="line">    </span><br><span class="line">    # 是否启用 sendfile 内核复制模式功能。作为静态服务器可以提供最大的 IO 访问速度。</span><br><span class="line">    sendfile on | off; </span><br><span class="line">    </span><br><span class="line">    # 尽快发送数据，否则会在数据包达到一定大小后再发送数据。这样会减少网络通信次数，降低阻塞概率，但也会影响响应及时性。</span><br><span class="line">    # 比较适合于文件下载这类的大数据通信场景。</span><br><span class="line">    tcp_nodelay on|off; </span><br><span class="line">    </span><br><span class="line">    # 单位s，适当降低此值可以提高响应连接数量</span><br><span class="line">    keepalive_timeout  65; </span><br><span class="line">    </span><br><span class="line">    # 一次长连接上允许的最大请求数</span><br><span class="line">    keepalive_requests 100；       </span><br><span class="line">    </span><br><span class="line">    # 禁止指定浏览器使用 keepalive</span><br><span class="line">    keepalive_disable msie6|none；    </span><br><span class="line">    </span><br><span class="line">    # 读取 http 请求首部的超时时长。如果客户端在此时间内未传输整个头，则会向客户端返回 408（请求超时）错误</span><br><span class="line">    client_header_timeout 1;     </span><br><span class="line">    </span><br><span class="line">    # 读取 http 请求包体的超时时间。</span><br><span class="line">    client_body_timeout 2;</span><br><span class="line">    </span><br><span class="line">    # 发送响应的超时时长。超时后连接将关闭。</span><br><span class="line">    send_timeout 5;  </span><br><span class="line">    </span><br><span class="line">    # http 请求包体的最大值，常用于限定客户端所能够请求的最大包体，根据请求首部中的 Content-Length 来检查，以避免无用的传输。</span><br><span class="line">    client_max_body_size 1m;</span><br><span class="line">    </span><br><span class="line">    # 限制客户端每秒传输的字节数，默认为0，表示没有限制。单位 Byte/s</span><br><span class="line">    limit_rate 0;</span><br><span class="line">    </span><br><span class="line">    # nginx 向客户端发送响应报文时，如果大小超过了此处指定的值，则后续的发送过程开始限速，单位 Byte</span><br><span class="line">    limit_rate_after 0;</span><br><span class="line">    </span><br><span class="line">    # 是否忽略不合法的 http 首部，默认为 on，off 意味着请求首部中出现不合规的首部将拒绝响应。</span><br><span class="line">    ignore_invalid_headers on|off;</span><br><span class="line">    </span><br><span class="line">    # 用户访问的文件不存在时，是否将其记录到错误日志中。</span><br><span class="line">    log_not_found on|off;   </span><br><span class="line">    </span><br><span class="line">    # nginx 使用的 dns 地址，及缓存解析结果的时间               </span><br><span class="line">    resolver 8.8.8.8 [valid=time] [ipv6=on|off];</span><br><span class="line">    </span><br><span class="line">    # dns 解析超时时间 </span><br><span class="line">    resolver_timeout 2；     </span><br><span class="line">    </span><br><span class="line">    # 是否打开文件缓存功能，max：用于缓存条目的最大值，</span><br><span class="line">    # inactive：某缓存条目在指定时长内没有被访问过时，将自动被删除，即缓存有效期，通常默认为 60s。</span><br><span class="line">    open_file_cache off;  </span><br><span class="line">    open_file_cache max=N [inactive=time];    </span><br><span class="line">    </span><br><span class="line">    # 是否缓存文件找不到或没有权限访问等相关信息。</span><br><span class="line">    open_file_cache_errors on | off; </span><br><span class="line">    </span><br><span class="line">    # 多长时间检查一次缓存中的条目是否超出非活动时长。</span><br><span class="line">    # 建议值：小于等于 open_file_cache inactive</span><br><span class="line">    open_file_cache_valid 60;   </span><br><span class="line">    </span><br><span class="line">    # 在 open_file_cache inactive指 定的时长内被访问超过此处指定的次数时，才不会被删除（删除低命中率的缓存）。</span><br><span class="line">    open_file_cache_min_uses 2;     </span><br><span class="line">    </span><br><span class="line">    # 开启内容压缩，可以有效降低客户端的访问流量和网络带宽</span><br><span class="line">    gzip on | off;</span><br><span class="line">    </span><br><span class="line">    # 内容超过最少长度后才开启压缩，太短的内容压缩效果不佳，且会浪费系统资源。</span><br><span class="line">    # 压缩长度会作为 http 响应头 Content-Length 字段返回给客户端。 建议值：64</span><br><span class="line">    gzip_min_length length;</span><br><span class="line">    </span><br><span class="line">    # 压缩级别，默认值为 1。范围为1～9级，压缩级别越高压缩率越高，但对系统性能要求越高。建议值：4</span><br><span class="line">    gzip_comp_level 1~9;</span><br><span class="line">    </span><br><span class="line">    # 压缩内容类型，默认为 text/html;。只压缩 html 文本，一般我们都会压缩 js、css、json 之类的，可以把这些常见的文本数据都配上。</span><br><span class="line">    如：text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;</span><br><span class="line">    gzip_types mime-type …;     </span><br><span class="line">    </span><br><span class="line">    # 自动显示目录</span><br><span class="line">    autoindex on;</span><br><span class="line">    </span><br><span class="line">    # off ： 以人类易读的方式显示文件大小，on：以 bytes 显示文件大小</span><br><span class="line">    autoindex_exact_size off;</span><br><span class="line">    </span><br><span class="line">    # 定义限制区域，imit_req_zone 只能放在 http &#123;&#125; 内，使用此限制可以在 http &#123;&#125; （对服务器内所有的网站生效）、server &#123;&#125; （对具体的一个网站生效）或 location &#123;&#125; （对具体的一个网址生效）</span><br><span class="line">    # 此区域名称为 test，可根据需求自定义； 10m 表示此区域存储 key（$binary_remote_addr）使用的大小</span><br><span class="line">    # 存储大小，一般 1m 空间大约能保存 1.6 万条 IP 地址，空间满了新数据会覆盖旧数据</span><br><span class="line">    # rate=1r/m ，限制访问请求频率为每分钟 1 次，可根据需要自行设置，1r/s 是 1 秒 1 次，时间单位只能选择 s (秒)或 m (分)，最低频率限制是每分钟 1 次访问请求</span><br><span class="line">    # rate=10r/m，1分钟最多访问 10 次，同时不能超过 1r/6s，即 6s 内最多访问 1 次。超过 1r/6s 返回 503</span><br><span class="line">    limit_req_zone $binary_remote_addr zone=test:10m rate=1r/m;</span><br><span class="line">    </span><br><span class="line">    # 定义日志格式</span><br><span class="line">    log_format main &#x27;&#123; time: $time_iso8601|&#x27;</span><br><span class="line">                    &#x27;http_host:$http_host|&#x27;</span><br><span class="line">                    &#x27;cdn_ip:$remote_addr|&#x27;</span><br><span class="line">                    &#x27;request:$request|&#x27;</span><br><span class="line">                    &#x27;request_method:$request_method|&#x27;</span><br><span class="line">                    &#x27;http_user_agent:$http_user_agent|&#x27;</span><br><span class="line">                    &#x27;size:$body_bytes_sent|&#x27;</span><br><span class="line">                    &#x27;responsetime:$request_time|&#x27;</span><br><span class="line">                    &#x27;upstreamtime:$upstream_response_time|&#x27;</span><br><span class="line">                    &#x27;upstreamhost:$upstream_addr|&#x27;</span><br><span class="line">                    &#x27;upstreamstatus:$upstream_status|&#x27;</span><br><span class="line">                    &#x27;url:$http_host$uri|&#x27;</span><br><span class="line">                    &#x27;http_x_forwarded_for:$clientRealIp|&#x27;</span><br><span class="line">                    &#x27;status:$status&#125;&#x27;;</span><br><span class="line">    </span><br><span class="line">    # server 负责具体的 http 服务器实现</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80 [default_server]  [rcvbuf=SIZE]  [sndbuf=SIZE] [ssl];</span><br><span class="line">        </span><br><span class="line">        # 可使用通配符*或正则表达式(~开头)，多个域名先精确匹配，再通配，再正则,&#x27;_&#x27;表示空主机头</span><br><span class="line">        server_name  _  ;</span><br><span class="line">        </span><br><span class="line">        access_log logs/access.log main;</span><br><span class="line">        error_log logs/access.err.log;</span><br><span class="line">        </span><br><span class="line">        # 跨域配置</span><br><span class="line">        add_header Access-Control-Allow-Origin *;</span><br><span class="line">        add_header Access-Control-Allow-Headers &#x27;Origin, No-Cache, X-Requested-With, If-Modified-Since, Pragma, Last-Modified, Cache-Control, Expires, Content-Type, X-E4M-With&#x27;;</span><br><span class="line">        add_header Access-Control-Allow-Methods GET,POST,OPTIONS;</span><br><span class="line">        add_header Access-Control-Allow-Credentials: true;</span><br><span class="line">        </span><br><span class="line">        location / &#123;       </span><br><span class="line">            # web 资源路径             </span><br><span class="line">            root   html;          </span><br><span class="line">            </span><br><span class="line">            # 定义默认页面，从左往右匹配           </span><br><span class="line">            index  index.html index.htm;   </span><br><span class="line">            </span><br><span class="line">            # 自左向右读取指定路径，找到即停止，如果都不存在，返回一个错误码</span><br><span class="line">            try_files $uri $uri.html $uri/index.html =404;        </span><br><span class="line">            </span><br><span class="line">            # 自左向右读取指定路径，找到即停止，如果都不存在，返回一个 uri</span><br><span class="line">            try_files $uri $uri.html $uri/index.html /404.html; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        location /i/ &#123; </span><br><span class="line">            # 路径别名，只能用于 location 中。</span><br><span class="line">            # 访问 http://a.com/i/a.html, 资源路径为：/data/www/html/a.html</span><br><span class="line">            # 若是root指令，访问 http://a.com/i/a.html，资源路径为：/data/www/html/i/a.html</span><br><span class="line">		    alias /data/www/html/;          </span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">	    # 对于某个请求发生错误，如果匹配到错误码，重定向到新的 url</span><br><span class="line">	    error_page  404              /404.html; </span><br><span class="line">	    error_page   500 502 503 504  /50x.html;</span><br><span class="line">	    </span><br><span class="line">	    # 对于某个请求发生错误，如果匹配到错误码，重定向到新的 url,同时可以更改返回码</span><br><span class="line">	    error_page 404 =200 /404.html;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    # 包含其他配置文件</span><br><span class="line">    include vhosts/*.conf;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="Server-常用配置"><a href="#Server-常用配置" class="headerlink" title="Server 常用配置"></a>Server 常用配置</h2><h3 id="nginx-代理-php"><a href="#nginx-代理-php" class="headerlink" title="nginx 代理 php"></a>nginx 代理 php</h3><figure class="highlight shell"><figcaption><span>vhosts/web.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name  _  ;</span><br><span class="line">    root           html;</span><br><span class="line">    </span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        fastcgi_index  index.php;</span><br><span class="line">        fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;          ###fastcgi程序的页面文件位置，$document_root = 之前配置的root           html;</span><br><span class="line">        ##include        fastcgi_params;</span><br><span class="line">	    fastcgi_param  QUERY_STRING       $query_string;                  ###将请求中的参数透传</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="nginx-状态监控"><a href="#nginx-状态监控" class="headerlink" title="nginx 状态监控"></a>nginx 状态监控</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置访问路径，即 uri</span></span><br><span class="line">location = /nginx_status&#123;  </span><br><span class="line">  </span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">开启该模块</span></span><br><span class="line">  stub_status on;    </span><br><span class="line">  </span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">关闭日志</span>  </span><br><span class="line">  access_log off;   </span><br><span class="line">        </span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">允许访问的 ip，即白名单 ip</span> </span><br><span class="line">  allow 101.106.102.129;        </span><br><span class="line">  allow 127.0.0.1;</span><br><span class="line">  </span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">拒绝白名单 ip 以外的 ip 访问</span></span><br><span class="line">  deny all;               </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="ssl-配置"><a href="#ssl-配置" class="headerlink" title="ssl 配置"></a>ssl 配置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name csms.tech;</span><br><span class="line">  </span><br><span class="line">    ssl_certificate /path/to/your_certificate.pem;</span><br><span class="line">    ssl_certificate_key /path/to/your_key.key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">强制跳转 https</span></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name csms.tech;</span><br><span class="line">    rewrite ^(.*)$  https://$host$1 permanent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用 pem 类型证书链：可将中间证书导入 pem 文件，再将私钥导入 pem 文件，<code>ssl_certificate</code> 和 <code>ssl_certificate_key</code> 都使用 pem 文件，可解决以下报错：<br>SSL_CTX_use_PrivateKey_file(“pri.key”) failed  (SSL: error:0906D06C:PEM routines:PEM_read_bio:no start line:Expecting: ANY PRIVATE KEY error:140B0009:SSL routines:SSL_CTX_use_PrivateKey_file:PEM lib</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat gd_bundle-g2-g1.crt &gt;&gt; f549150b196cd59e.pem</span><br><span class="line">cat f549150b196cd59e.key &gt;&gt; f549150b196cd59e.pem</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><figcaption><span>nginx.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">ssl_certificate f549150b196cd59e.pem;</span><br><span class="line">ssl_certificate_key  f549150b196cd59e.pem;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="配置-upstream-代理"><a href="#配置-upstream-代理" class="headerlink" title="配置 upstream 代理"></a>配置 upstream 代理</h3><figure class="highlight shell"><figcaption><span>upstream.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">upstream myserver &#123;</span><br><span class="line">    # 调度策略,默认为轮询</span><br><span class="line">    ip_hash | url_hash ...</span><br><span class="line">    </span><br><span class="line">    # 后端服务器列表</span><br><span class="line">    # backup: 其它所有的非 backup 机器 down 或者忙的时候，请求 backup 机器。所以这台机器压力会最轻。</span><br><span class="line">    # max_fails:允许请求失败的次数，默认为 1.当超过最大次数时，返回 proxy_next_upstream 模块定义的错误.</span><br><span class="line">    # fail_timeout : max_fails 次失败后，暂停的时间。 </span><br><span class="line">    server 10.0.0.1:8080 [weight=1] [backup] [down] [max_fails] [fail_timeout];</span><br><span class="line">    server 10.0.0.2:8080 [weight=1] [backup] [down] [max_fails] [fail_timeout];</span><br><span class="line"></span><br><span class="line">    keepalive 2000;</span><br><span class="line">    </span><br><span class="line">    # 后端健康检测，需要第三方插件 ngx_http_healthcheck_module</span><br><span class="line">    # healthcheck_enabled;         </span><br><span class="line">    # healthcheck_delay 3000;</span><br><span class="line">    # healthcheck_timeout 1000;</span><br><span class="line">    # healthcheck_failcount 2;</span><br><span class="line">    # healthcheck_send &#x27;GET /healthcheck.html HTTP/1.0&#x27; &#x27;Host: local.com&#x27; &#x27;Connection: close&#x27;;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;                                                         </span><br><span class="line">    server_name  csms.tech;                                               </span><br><span class="line">    client_max_body_size 1024M;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        # 指定协议、主机名、端口</span><br><span class="line">        proxy_pass http://myserver/uri;</span><br><span class="line">                     </span><br><span class="line">        [proxy_set_header Host $host:$server_port;]</span><br><span class="line">        [proxy_redirect     off;]</span><br><span class="line">        [proxy_set_header X-Real-IP $remote_addr;]</span><br><span class="line">        [proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;]</span><br><span class="line">        [proxy_set_header X-Forwarded-Proto https;]</span><br><span class="line">        [proxy_ignore_client_abort on;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ip-限制"><a href="#ip-限制" class="headerlink" title="ip 限制"></a>ip 限制</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;                                                         </span><br><span class="line">    server_name  csms.tech;</span><br><span class="line">    </span><br><span class="line">    root html;</span><br><span class="line">    </span><br><span class="line">    if ($http_x_forwarded_for !~ (1.1.1.1|1.1.1.2)) &#123;</span><br><span class="line">        return 403;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="地区限制"><a href="#地区限制" class="headerlink" title="地区限制"></a>地区限制</h3><p>依赖 nginx 的 <code>http_geoip_module</code> 模块，检查 <code>GeoIP</code> 是否安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./sbin/nginx -V </span><br></pre></td></tr></table></figure>
<p>输出结果中如果不包含：<code>--with-http_geoip_module</code>，说明未安装，重新编译安装 nginx<br>安装 <code>http_geoip_module</code> 模块后使用以下配置</p>
<figure class="highlight shell"><figcaption><span>nginx.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    geoip_country /usr/share/GeoIP/GeoIP.dat;</span><br><span class="line">    </span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name csms.tech;</span><br><span class="line">        </span><br><span class="line">        location / &#123;</span><br><span class="line">            if ($geoip_country_code != CN) &#123;</span><br><span class="line">                root outChina;</span><br><span class="line">            &#125;</span><br><span class="line">            root China;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="server-中-location-优先级"><a href="#server-中-location-优先级" class="headerlink" title="server 中 location 优先级"></a>server 中 <code>location</code> 优先级</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    # 精确匹配，最高优先级</span><br><span class="line">    location = /url  &#123;&#125;        </span><br><span class="line"></span><br><span class="line">    # 从前往后匹配，匹配到即停止继续匹配，不是正则匹配，第二优先级</span><br><span class="line">    location ^~ /uri  &#123;&#125;          </span><br><span class="line"></span><br><span class="line">    # 正则匹配，~ 区分大小写， ~* 不区分大小写，第三优先级</span><br><span class="line">    location ~ ^/url$ &#123;&#125;    </span><br><span class="line">    location ~* ^/url$ &#123;&#125;    </span><br><span class="line">	</span><br><span class="line">    # / 会匹配到所有未被匹配到的 url</span><br><span class="line">    location /documents/ &#123;&#125; </span><br><span class="line">    location / &#123;&#125; </span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="301-跳转配置"><a href="#301-跳转配置" class="headerlink" title="301 跳转配置"></a>301 跳转配置</h3><p>如下配置，使用 <code>rewrite</code> 或 <code>return</code> 指令，所有 <a href="https://csms.tech/"><code>csms.tech</code></a> 的请求都会 <code>301</code> 重定向到 <a href="https://csms.tech/"><code>www.csms.tech</code></a>，并携带原来的 <code>uri</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name csms.tech;</span><br><span class="line">    </span><br><span class="line">    rewrite ^/(.*)$ https://www.csms.tech$1 permanent;</span><br><span class="line">    </span><br><span class="line">    # return 301 https://www.csms.tech$request_uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="url-访问频率限制"><a href="#url-访问频率限制" class="headerlink" title="url 访问频率限制"></a>url 访问频率限制</h3><p>要实现访问频率限制，需要先 <a href="#%E5%85%A8%E5%B1%80%E9%80%9A%E7%94%A8%E9%85%8D%E7%BD%AE">定义好限制区域</a>，如本文中在 http {} 中配置了以下限制区域</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义限制区域，imit_req_zone 只能放在 http &#123;&#125; 内，使用此限制可以在 http &#123;&#125; （对服务器内所有的网站生效）、server &#123;&#125; （对具体的一个网站生效）或 location &#123;&#125; （对具体的一个网址生效）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此区域名称为 <span class="built_in">test</span>，可根据需求自定义； 10m 表示此区域存储 key（<span class="variable">$binary_remote_addr</span>）使用的大小</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">存储大小，一般 1m 空间大约能保存 1.6 万条 IP 地址，空间满了新数据会覆盖旧数据</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rate=1r/m ，限制访问请求频率为每分钟 1 次，可根据需要自行设置，1r/s 是 1 秒 1 次，时间单位只能选择 s (秒)或 m (分)，最低频率限制是每分钟 1 次访问请求</span></span><br><span class="line">limit_req_zone $binary_remote_addr zone=test:10m rate=1r/m;</span><br></pre></td></tr></table></figure>
<p>在 server {} 中可以使用以下方式使用频率限制</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        # ...</span><br><span class="line">        # 对 /api/test/ 进行访问频率限制</span><br><span class="line">        location =/api/test/ &#123;</span><br><span class="line">            # 如果同 IP 一分钟内发起 10 并发请求，第 1 个请求立即处理，其余 9 个直接返回 503 错误</span><br><span class="line">            limit_req zone=test;</span><br><span class="line">            </span><br><span class="line">            # 如果同 IP 一分钟内发起 10 并发请求，第 1 个请求立即处理，第 2-6 个请求缓存后排队 1 分钟处理 1 个，第 7-10 个请求返回 503 错误</span><br><span class="line">            limit_req zone=test burst=5;</span><br><span class="line">            </span><br><span class="line">            # 如果同 IP 一分钟内发起 10 并发请求，第 1-5 个请求立即处理，剩下的 5 个直接返回 503 错误</span><br><span class="line">            # nodelay，如果不设置该选项，严格使用平均速率限制请求数</span><br><span class="line">            # burst=5，则 1m 内最多可请求 5 次。</span><br><span class="line">            # 假设 rate=10r/s，burst=5，只要第 1，2，3，4 秒都未超过 10 次，则第 5 秒可以最多请求 （50 减去第 1-4 秒请求次数的和）</span><br><span class="line">            limit_req zone=test burst=5 nodelay;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="stream-配置"><a href="#stream-配置" class="headerlink" title="stream 配置"></a>stream 配置</h2><p>nginx 通过 stream 模块实现了 tcp 代理功能，无需其他软件配合即可实现四层代理和七层代理，即：访问该服务器的指定端口，nginx 就可以充当端口转发的作用将流量导向另一个服务器，同时获取目标服务器的返回数据并返回给请求者。这是一个非常实用的功能。</p>
<p>yum 安装的 nginx ，使用以下命令安装 <code>stream</code> 模块 <sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Nginx Stream 配置](https://blog.junmoyu.com/posts/linux-nginx-install-stream/)">[3]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y nginx-mod-stream</span><br></pre></td></tr></table></figure>
<p><strong>请注意，stream 块和 http 块是两个不同的模块，stream 不属于 http 模块</strong>，即不能放到 <code>/etc/nginx/conf.d/</code>，stream 是通过 tcp 层转发，而不是 http 转发。</p>
<p>如配置在 http 内，启动 nginx 会报如下错误：<br><code>nginx: [emerg] &quot;server&quot; directive is not allowed here</code></p>
<p><code>stream</code> 需要配置在 <code>nginx.conf</code> 中和 <code>http</code> 命令同级的位置。</p>
<figure class="highlight shell"><figcaption><span>nginx.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">load_module /usr/lib64/nginx/modules/ngx_stream_module.so;</span><br><span class="line"></span><br><span class="line">user nginx nginx;</span><br><span class="line">worker_processes  auto;</span><br><span class="line">worker_rlimit_nofile 65535;</span><br><span class="line">pid     conf/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">        use     epoll;</span><br><span class="line">        worker_connections  309600;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">        include     mime.types;</span><br><span class="line">        default_type  application/octet-stream;</span><br><span class="line">        ...</span><br><span class="line">        include     vhosts.d/*.conf;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">stream config.</span></span><br><span class="line">stream &#123;</span><br><span class="line">    log_format proxy &#x27;&#123;time: $time_local|&#x27;</span><br><span class="line">                  &#x27;remote_addr: $remote_addr|&#x27;</span><br><span class="line">				  &#x27;protocol: $protocol|&#x27;</span><br><span class="line">				  &#x27;bytes_sent: $bytes_sent|&#x27;</span><br><span class="line">				  &#x27;bytes_received: $bytes_received|&#x27;</span><br><span class="line">				  &#x27;session_time: $session_time|&#x27;</span><br><span class="line">				  &#x27;upstream_addr: $upstream_addr|&#x27;</span><br><span class="line">				  &#x27;upstream_bytes_sent: $upstream_bytes_sent|&#x27;</span><br><span class="line">				  &#x27;upstream_bytes_received: $upstream_bytes_received|&#x27;</span><br><span class="line">				  &#x27;upstream_connect_time: $upstream_connect_time|&#x27;</span><br><span class="line">				  &#x27;status: $status&#125;&#x27;;</span><br><span class="line">    # tcp/ip proxy</span><br><span class="line">    include /etc/nginx/tcp.d/*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>安装了 <code>nginx-mod-stream</code>，nginx 启动报错：<code>unknown directive &quot;stream&quot;</code>，需要在 <code>nginx.conf</code> 中手动加载模块：<code>load_module /usr/lib64/nginx/modules/ngx_stream_module.so;</code></p>
<p>stream 模块和 http 模块使用独立的日志格式配置，日志格式通过命令 <code>log_format</code> 配置。</p>
<h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><h2 id="worker-connections-exceed-open-file-resource-limit"><a href="#worker-connections-exceed-open-file-resource-limit" class="headerlink" title="worker_connections exceed open file resource limit"></a>worker_connections exceed open file resource limit</h2><p><strong>问题原因</strong>： worker_rlimit_nofile 的值小于 worker_connections 的值，参数说明可参考 <a href="#%E5%85%A8%E5%B1%80%E9%80%9A%E7%94%A8%E9%85%8D%E7%BD%AE">全局通用配置</a>  </p>
<h2 id="Response-to-preflight-request-doesn’t-pass-access-control-check-The-value-of-the-‘Access-Control-Allow-Origin’-header-in-the-response-must-not-be-the-wildcard-‘-’"><a href="#Response-to-preflight-request-doesn’t-pass-access-control-check-The-value-of-the-‘Access-Control-Allow-Origin’-header-in-the-response-must-not-be-the-wildcard-‘-’" class="headerlink" title="Response to preflight request doesn’t pass access control check: The value of the ‘Access-Control-Allow-Origin’ header in the response must not be the wildcard ‘*’"></a>Response to preflight request doesn’t pass access control check: The value of the ‘Access-Control-Allow-Origin’ header in the response must not be the wildcard ‘*’</h2><p><strong>错误场景</strong>：</p>
<p>浏览器访问报跨域错误，nginx 已配置了 <code>add_header Access-Control-Allow-Origin *;</code>，具体报错：<code>Access to XMLHttpRequest at &#39;http://spin-gate.test.com/webhooks/preconfigured&#39; from origin &#39;http://spinnaker.test.com&#39; has been blocked by CORS policy: Response to preflight request doesn&#39;t pass access control check: The value of the &#39;Access-Control-Allow-Origin&#39; header in the response must not be the wildcard &#39;*&#39; when the request&#39;s credentials mode is &#39;include&#39;. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute.</code><br><img src="https://i.csms.tech/img_95.png"><br><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS/Errors/CORSNotSupportingCredentials">问题原因及客户端解决方法</a></p>
<h3 id="nginx-服务端解决方法"><a href="#nginx-服务端解决方法" class="headerlink" title="nginx 服务端解决方法"></a>nginx 服务端解决方法</h3><h4 id="nginx-配置允许单个目标跨域"><a href="#nginx-配置允许单个目标跨域" class="headerlink" title="nginx 配置允许单个目标跨域"></a>nginx 配置允许单个目标跨域</h4><p>nginx 配置 <code>add_header Access-Control-Allow-Origin </code> 可以配置允许跨域，此参数只允许配置单个域名或者 <code>*</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">add_header Access-Control-Allow-Origin *;</span></span><br><span class="line">add_header Access-Control-Allow-Origin http://127.0.0.1;</span><br><span class="line">add_header Access-Control-Allow-Methods &#x27;GET, POST, OPTIONS&#x27;;</span><br><span class="line">add_header Access-Control-Allow-Headers &#x27;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization,lang,access-token&#x27;;</span><br></pre></td></tr></table></figure>

<h4 id="nginx-配置允许多个目标跨域"><a href="#nginx-配置允许多个目标跨域" class="headerlink" title="nginx 配置允许多个目标跨域"></a>nginx 配置允许多个目标跨域</h4><p>nginx 配置 <code>add_header Access-Control-Allow-Origin</code> 只能配置一个目标，不能配置多个目标，要使用此指令配置多个目标允许跨域，可参考以下方法</p>
<ul>
<li><p>通过设置变量值解决指定多个域名白名单跨域请求配置</p>
<p>  通过在 nginx 配置中设置变量，来匹配允许跨域的目标，示例代码如下 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[设置变量解决指定多个域名白名单跨域请求配置](https://www.yidude.com/nginx/100001.html)">[1]</span></a></sup></p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    set $cors_origin &quot;&quot;;</span><br><span class="line">    if ($http_origin ~* &quot;^http://127.0.0.1$&quot;) &#123;</span><br><span class="line">            set $cors_origin $http_origin;</span><br><span class="line">    &#125;</span><br><span class="line">    if ($http_origin ~* &quot;^http://localhost$&quot;) &#123;</span><br><span class="line">            set $cors_origin $http_origin;</span><br><span class="line">    &#125;</span><br><span class="line">    add_header Access-Control-Allow-Origin $cors_origin;</span><br><span class="line">    add_header Access-Control-Allow-Methods GET,POST,PUT,DELETE,OPTIONS;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<p>通过以上配置，可实现允许 <code>http://127.0.0.1</code>，<code>http://localhost</code> 跨域，如果需要允许其他目标跨域，以此添加配置即可。</p>
</li>
<li><p>使用 map 实现 Nginx 允许多个域名跨域</p>
<p>  在 Nginx 中可以使用 map 得到一个自定义变量，可以对请求中的 origin 做一个过滤处理，把符合要求的请求域名放到一个变量中，在设置 allow origin 时使用该变量就能实现一个动态的、多个的允许跨域域名，示例配置如下 <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[使用 map 实现 Nginx 允许多个域名跨域](https://priesttomb.github.io/%E6%8A%80%E6%9C%AF/2020/10/24/using-map-to-set-multiple-allow-origins-in-nginx/)">[2]</span></a></sup></p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map $http_origin $allow_origin &#123;</span><br><span class="line">    default &quot;&quot;;</span><br><span class="line">    &quot;~^(https?://localhost(:[0-9]+)?)$&quot; $1;</span><br><span class="line">    &quot;~^(https?://127.0.0.1(:[0-9]+)?)$&quot; $1;</span><br><span class="line">    &quot;~^(https?://172.10(.[\d]+)&#123;2&#125;(:[0-9]+)?)$&quot; $1;</span><br><span class="line">    &quot;~^(https?://192.168(.[\d]+)&#123;2&#125;(:[0-9]+)?)$&quot; $1;</span><br><span class="line">  </span><br><span class="line">    &quot;~http://www.123admin.com&quot; http://www.123admin.com;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       11111;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    location ~ /xxx/xx &#123;</span><br><span class="line">        if ($request_method = &#x27;OPTIONS&#x27;) &#123;</span><br><span class="line">            return 204;</span><br><span class="line">        &#125;</span><br><span class="line">        add_header Access-Control-Allow-Origin $allow_origin;</span><br><span class="line">        add_header Access-Control-Allow-Methods &#x27;GET, POST, OPTIONS&#x27;;</span><br><span class="line">        add_header Access-Control-Allow-Headers &#x27;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization&#x27;;</span><br><span class="line">        add_header Access-Control-Allow-Credentials &#x27;true&#x27;;</span><br><span class="line">        proxy_pass http://1.2.3.4:5678;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  解释说明：</p>
<ul>
<li><p><code>$http_origin</code> 是 Nginx 的内部变量，用于获取请求头中的 origin</p>
</li>
<li><p><code>$allow_origin</code> 是可以自定义的变量名，用于接收 map 返回的值</p>
</li>
<li><p><code>$1</code> 是 Nginx 对 PCRE 中关于后向引用和子组的兼容，用于获取匹配字符串的整个部分，并返回给 <code>$allow_origin</code></p>
</li>
</ul>
</li>
</ul>
<h2 id="Nginx-配置-ssl-时未指定-ssl"><a href="#Nginx-配置-ssl-时未指定-ssl" class="headerlink" title="Nginx 配置 ssl 时未指定 ssl"></a>Nginx 配置 ssl 时未指定 ssl</h2><p>nginx 如下的 server 配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 443;</span><br><span class="line">        server_name test.com;</span><br><span class="line">      </span><br><span class="line">        ssl_certificate test.com.pem;       </span><br><span class="line">        ssl_certificate_key test.com.pem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过浏览器访问 https 协议，报错： <code>This site can’t provide a secure connection</code> ，<code>ERR_SSL_PROTOCOL_ERROR</code></p>
<p>使用 <code>curl</code> 命令访问报错： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">* NSS error -12263 (SSL_ERROR_RX_RECORD_TOO_LONG)</span><br><span class="line">* SSL received a record that exceeded the maximum permissible length.</span><br><span class="line">* Closing connection 0</span><br><span class="line">curl: (35) SSL received a record that exceeded the maximum permissible length.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>修改配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 443 ssl;</span><br><span class="line">        server_name test.com;</span><br><span class="line">      </span><br><span class="line">        ssl_certificate test.com.pem;       </span><br><span class="line">        ssl_certificate_key test.com.pem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Nginx-常见用法配置示例"><a href="#Nginx-常见用法配置示例" class="headerlink" title="Nginx 常见用法配置示例"></a>Nginx 常见用法配置示例</h1><h2 id="Nginx-反代-FTP-服务"><a href="#Nginx-反代-FTP-服务" class="headerlink" title="Nginx 反代 FTP 服务"></a>Nginx 反代 FTP 服务</h2><p>Nginx 代理 TCP 端口需要使用 <code>stream</code> 模块 <sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[nginx 代理 ftp 端口，实现文件传输](https://blog.csdn.net/MarshalEagle/article/details/120334328)">[4]</span></a></sup></p>
<p>示例配置前提：</p>
<ul>
<li>FTP 服务器使用 <strong>被动模式</strong> (<a href="/202207231311/" title="vsftpd 服务常用配置说明">vsftpd 服务常用配置说明</a>)</li>
<li>FTP 命令传输端口为 21</li>
<li>FTP 数据传输端口范围为 11001 - 11004</li>
</ul>
<p>nginx 配置文件 <code>nginx.conf</code> 中和  <code>http</code> 模块同级的位置添加 <code>stream</code> 配置</p>
<figure class="highlight shell"><figcaption><span>nginx.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">FTP 的命令端口（21）代理配置</span></span><br><span class="line">  server &#123;</span><br><span class="line">          listen 21 ;</span><br><span class="line">          proxy_pass ftp_server;</span><br><span class="line">          proxy_connect_timeout 60s;</span><br><span class="line">          proxy_timeout 60m;</span><br><span class="line">      &#125;</span><br><span class="line">  upstream ftp_server&#123;</span><br><span class="line">         hash $remote_addr consistent;</span><br><span class="line">         server 192.168.1.2:21;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">FTP 的数据传输端口（11001 - 11004 ）代理配置</span></span><br><span class="line">  server &#123;</span><br><span class="line">      listen 11001;</span><br><span class="line">      proxy_pass ftp_trans_data_port1;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  upstream ftp_trans_data_port1 &#123;</span><br><span class="line">      hash $remote_addr consistent;</span><br><span class="line">      server 192.168.1.2:11001;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  server &#123;</span><br><span class="line">      listen 11002;</span><br><span class="line">      proxy_pass ftp_trans_data_port2;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  upstream ftp_trans_data_port2 &#123;</span><br><span class="line">      hash $remote_addr consistent;</span><br><span class="line">      server 192.168.1.2:11002;</span><br><span class="line">  &#125;</span><br><span class="line">  server &#123;</span><br><span class="line">      listen 11003;</span><br><span class="line">      proxy_pass ftp_trans_data_port3;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  upstream ftp_trans_data_port3 &#123;</span><br><span class="line">      hash $remote_addr consistent;</span><br><span class="line">      server 192.168.1.2:11003;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  server &#123;</span><br><span class="line">      listen 11004;</span><br><span class="line">      proxy_pass ftp_trans_data_port4;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  upstream ftp_trans_data_port4 &#123;</span><br><span class="line">      hash $remote_addr consistent;</span><br><span class="line">      server 192.168.1.2:11004;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>整个工作流程大体如下：<br><img src="https://i.csms.tech/img_124.png"></p>
<p><strong>特殊情况说明</strong></p>
<blockquote>
<p>因为 FTP 协议的原因，如果在同一个 Nginx 中要反代多台 FTP 服务器，那么 FTP 服务使用的数据传输端口（被动模式下）不能相同，因为 Nginx 不能重复监听相同的端口。</p>
<p>此种情况下（同一个 Nginx 要反代多台有相同数据传输端口的 FTP 服务），可以将后端 FTP 服务加到同一个 upstream 中，然后 nginx 监听数据传输端口，此时存在的问题是 <strong>如果后端的 2 台或多台 FTP 同时使用了相同的数据传输端口，可能会导致客户端的数据连接被反代到错误的 FTP 服务器</strong></p>
</blockquote>
<p>此种特殊情况下的具体工作流程：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line"></span><br><span class="line">      # ftp 命令(控制)端口</span><br><span class="line">      server &#123;</span><br><span class="line">          listen 21;                          </span><br><span class="line">          proxy_pass ftp1;</span><br><span class="line">      &#125;</span><br><span class="line">      upstream ftp1&#123;</span><br><span class="line">          hash $remote_addr consistent;</span><br><span class="line">          server 192.168.1.2:11000;</span><br><span class="line">          server 192.168.1.3:11000;</span><br><span class="line">      &#125;</span><br><span class="line">      # ftp 数据传输端口,ftp 服务配置为被动模式,数据传输端口 11001-11003</span><br><span class="line">      server &#123;</span><br><span class="line">          listen 11001;</span><br><span class="line">          proxy_pass ftp_data_port1;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      upstream ftp_data_port1 &#123;</span><br><span class="line">          hash $remote_addr consistent;</span><br><span class="line">          server 192.168.1.2:11001;</span><br><span class="line">          server 192.168.1.3:11001;</span><br><span class="line">      &#125;</span><br><span class="line">	  </span><br><span class="line">	  server &#123;</span><br><span class="line">          listen 11002;</span><br><span class="line">          proxy_pass ftp_data_port2;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      upstream ftp_data_port2 &#123;</span><br><span class="line">          hash $remote_addr consistent;</span><br><span class="line">          server 192.168.1.2:11002;</span><br><span class="line">          server 192.168.1.3:11002;</span><br><span class="line">      &#125;</span><br><span class="line">	  server &#123;</span><br><span class="line">          listen 11003;</span><br><span class="line">          proxy_pass ftp_data_port3;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      upstream ftp_data_port3 &#123;</span><br><span class="line">          hash $remote_addr consistent;</span><br><span class="line">          server 192.168.1.2:11003;</span><br><span class="line">          server 192.168.1.3:11003;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_125.png"></p>
<p> 此种配置下可能出现以下几种情况(假定后端 FTP 服务器分别为 A 和 B)：</p>
<ol>
<li><p>第 2 步中，假如 <strong>Nginx 选择了后端 FTP 服务器 A</strong>，并将控制请求转发到了 A.，ftp A 和客户端协商使用 11003 端口进行数据传输。</p>
<p> 客户端收到控制面的响应后，发起和 FTP 服务的 11003 的数据传输请求， 请求到了 Nginx 服务器，Nginx 通过 11003 端口的配置，在 upstream 中<strong>选择了后端的 A 服务器</strong>，并将请求转发到了服务器 A，A 已经监听了此端口，可以正常完成数据传输。</p>
</li>
<li><p>第 2 步中，假如 <strong>Nginx 选择了后端 FTP 服务器 A</strong>，并将控制请求转发到了 A.，ftp A 和客户端协商使用 11003 端口进行数据传输。</p>
<p>  客户端收到控制面的响应后，发起和 FTP 服务的 11003 的数据传输请求， 请求到了 Nginx 服务器，Nginx 通过 11003 端口的配置，在 upstream 中<strong>选择了后端的 B 服务器</strong>，并将请求转发到 B 服务器，<strong>假如 B 服务器未监听此端口（因为此次请求之前的控制面是由 A处理，B 并未参与），后端未响应</strong>，此时 Nginx 会将请求转发到 A 服务器，正常完成数据传输</p>
</li>
<li><p>第 2 步中，假如 <strong>Nginx 选择了后端 FTP 服务器 A</strong>，并将控制请求转发到了 A，ftp A 和客户端协商使用 11003 端口进行数据传输。</p>
<p> 客户端收到控制面的响应后，发起和 FTP 服务的 11003 的数据传输请求， 请求到了 Nginx 服务器，Nginx 通过 11003 端口的配置，在 upstream 中<strong>选择了后端的 B 服务器</strong>，并将请求转发到 B 服务器，<strong>假如 B 服务器也监听了此端口（例如代理到 B 服务器得 FTP 控制端响应中,也和客户端协商了使用 11003 端口进行数据传输），Nginx 和后端 FTP 的 11003 端口可以建立连接</strong>，但是因为鉴权等原因,FTP 服务器会返回传输失败信息给客户端.此时虽然完整的建立了整个流程中的连接,但是<strong>数据传输最终失败</strong>.</p>
</li>
</ol>
<h2 id="Nginx-反代-Rancher"><a href="#Nginx-反代-Rancher" class="headerlink" title="Nginx 反代 Rancher"></a>Nginx 反代 Rancher</h2><a href="/202210071716/" title="Rancher 安装及使用">Rancher 安装及使用</a>

<h2 id="Nginx-反代-OpenVPN-服务"><a href="#Nginx-反代-OpenVPN-服务" class="headerlink" title="Nginx 反代 OpenVPN 服务"></a>Nginx 反代 OpenVPN 服务</h2><p>使用 Nginx stream 模块可以实现 Nginx 反代 OpenVPN 的流量，但是连接 VPN 之后，客户端显示的 IP 依然为 OpenVPN 服务端 IP。</p>
<figure class="highlight python"><figcaption><span>nginx.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    log_format proxy <span class="string">&#x27;&#123;time: $time_local|&#x27;</span></span><br><span class="line">                  <span class="string">&#x27;remote_addr: $remote_addr|&#x27;</span></span><br><span class="line">				  <span class="string">&#x27;protocol: $protocol|&#x27;</span></span><br><span class="line">				  <span class="string">&#x27;bytes_sent: $bytes_sent|&#x27;</span></span><br><span class="line">				  <span class="string">&#x27;bytes_received: $bytes_received|&#x27;</span></span><br><span class="line">				  <span class="string">&#x27;session_time: $session_time|&#x27;</span></span><br><span class="line">				  <span class="string">&#x27;upstream_addr: $upstream_addr|&#x27;</span></span><br><span class="line">				  <span class="string">&#x27;upstream_bytes_sent: $upstream_bytes_sent|&#x27;</span></span><br><span class="line">				  <span class="string">&#x27;upstream_bytes_received: $upstream_bytes_received|&#x27;</span></span><br><span class="line">				  <span class="string">&#x27;upstream_connect_time: $upstream_connect_time|&#x27;</span></span><br><span class="line">				  <span class="string">&#x27;status: $status&#x27;</span>;</span><br><span class="line">	access_log /home/logs/nginx/access/vpn_proxy.access proxy;</span><br><span class="line">	</span><br><span class="line">	server &#123;</span><br><span class="line">		listen <span class="number">1194</span>;</span><br><span class="line">		proxy_pass <span class="number">13.52</span><span class="number">.72</span><span class="number">.24</span>:<span class="number">1194</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_129.png"></p>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.yidude.com/nginx/100001.html">设置变量解决指定多个域名白名单跨域请求配置</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://priesttomb.github.io/%E6%8A%80%E6%9C%AF/2020/10/24/using-map-to-set-multiple-allow-origins-in-nginx/">使用 map 实现 Nginx 允许多个域名跨域</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://blog.junmoyu.com/posts/linux-nginx-install-stream/">Nginx Stream 配置</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://blog.csdn.net/MarshalEagle/article/details/120334328">nginx 代理 ftp 端口，实现文件传输</a><a href="#fnref:4" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>nodejs安装配置</title>
    <url>/647e4c1a/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://nodejs.org/dist/latest/node-v15.12.0-linux-x64.tar.gz</span><br><span class="line">tar -xf node-v15.12.0-linux-x64.tar.gz -C /usr/local</span><br><span class="line">ln -s /usr/local/node-v15.12.0-linux-x64/bin/* /bin/</span><br></pre></td></tr></table></figure>

<p>安装pm2</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install pm2 -g</span><br><span class="line">npm install -g pm2@3.5.1    # 安装指定版本</span><br><span class="line">npm install -g pm2@latest   # 安装最新版本</span><br></pre></td></tr></table></figure>

<h4 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h4><blockquote>
<p>WARN EACCES user “root” does not have permission to access the dev dir “&#x2F;root&#x2F;.node-gyp&#x2F;11.15.0”<br>ERR! stack Error: EACCES: permission denied, mkdir ‘node_modules&#x2F;sqlite3&#x2F;.node-gyp’</p>
</blockquote>
<p>[解决方法]：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --unsafe-perm</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 部署 OpenVPN</title>
    <url>/202302171657/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos 7 3.10.0-1160</li>
<li>Docker 20.10.9</li>
<li>iptables</li>
</ul>
<h1 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h1><p>宿主机操作系统内核配置允许数据转发，<a href="https://csms.tech/202302161539/#开启系统-IPv4-转发功能">开启系统 IPv4 转发功能</a></p>
<h1 id="Docker-部署-OpenVPN-服务端步骤"><a href="#Docker-部署-OpenVPN-服务端步骤" class="headerlink" title="Docker 部署 OpenVPN 服务端步骤"></a>Docker 部署 OpenVPN 服务端步骤</h1><h2 id="创建本地配置目录"><a href="#创建本地配置目录" class="headerlink" title="创建本地配置目录"></a>创建本地配置目录</h2><p>用了在启动容器时挂载以持久化 OpenVPN 配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /opt/openvpn1/</span><br></pre></td></tr></table></figure>

<h2 id="初始化配置文件"><a href="#初始化配置文件" class="headerlink" title="初始化配置文件"></a>初始化配置文件</h2><p>执行以下命令初始化 OpenVPN 服务端配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --rm \</span><br><span class="line">          -v /opt/openvpn1/:/etc/openvpn \</span><br><span class="line">          kylemanna/openvpn:2.4 ovpn_genconfig -u udp://$&#123;PUB_IP&#125;:1194</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><code>udp://$&#123;PUB_IP&#125;:1194</code> - 指定 VPN 服务器配置，使用 <code>1194/udp</code> 端口。${PUB_IP} 为服务器公网 IP。</li>
</ul>
<h2 id="生成密钥-证书-文件"><a href="#生成密钥-证书-文件" class="headerlink" title="生成密钥(证书)文件"></a>生成密钥(证书)文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --rm -it \</span><br><span class="line">          -v /opt/openvpn1/:/etc/openvpn \</span><br><span class="line">          kylemanna/openvpn:2.4 ovpn_initpki</span><br></pre></td></tr></table></figure>
<p>根据提示，输入 CA 根证书密码及名称</p>
<h2 id="创建带有密码的客户端证书"><a href="#创建带有密码的客户端证书" class="headerlink" title="创建带有密码的客户端证书"></a>创建带有密码的客户端证书</h2><p>执行以下命令，根据提示输入客户端证书密码及 CA 密码，生成客户端证书。如果客户端证书无需密码，最后加选项 <code>nopass</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --rm -it \</span><br><span class="line">          -v /opt/openvpn1/:/etc/openvpn \</span><br><span class="line">          kylemanna/openvpn:2.4 easyrsa build-client-full vpn1</span><br></pre></td></tr></table></figure>

<h2 id="导出客户端证书"><a href="#导出客户端证书" class="headerlink" title="导出客户端证书"></a>导出客户端证书</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --rm -it \</span><br><span class="line">          -v /opt/openvpn1/:/etc/openvpn \</span><br><span class="line">          kylemanna/openvpn:2.4 ovpn_getclient vpn1 &gt; /opt/openvpn/client/vpn1.ovpn</span><br></pre></td></tr></table></figure>

<h2 id="启动-OpenVPN"><a href="#启动-OpenVPN" class="headerlink" title="启动 OpenVPN"></a>启动 OpenVPN</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it --name OpenVPN1 \</span><br><span class="line">           -v /opt/openvpn1/:/etc/openvpn \</span><br><span class="line">           -d -p 1194:1194/udp --cap-add=NET_ADMIN \</span><br><span class="line">           kylemanna/openvpn:2.4</span><br><span class="line">           </span><br></pre></td></tr></table></figure>
<p>防火墙放通 <code>1194/udp</code> 端口</p>
<figure class="highlight shell"><figcaption><span>/etc/sysconfig/iptables</span></figcaption><table><tr><td class="code"><pre><span class="line">-A INPUT -p udp --dport 1194 -j ACCEPT -m comment --comment &quot;openvpn&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>OpenVPN 启动后，docker 会在宿主机操作系统的 iptables 中添加对应的 <code>MASQUERADE</code> 规则，负责转发和 NAT 数据，具体规则可通过以下方法查看</p>
<p>查看 NAT 表添加的规则</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iptables -t nat -L -v -n --line-numbers | more</span></span><br><span class="line">Chain PREROUTING (policy ACCEPT 127 packets, 9255 bytes)</span><br><span class="line">num   pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line">1       54  2490 DOCKER     all  --  *      *       0.0.0.0/0            0.0.0.0/0            ADDRTYPE match dst-type LOCAL</span><br><span class="line"></span><br><span class="line">Chain INPUT (policy ACCEPT 0 packets, 0 bytes)</span><br><span class="line">num   pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT 0 packets, 0 bytes)</span><br><span class="line">num   pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line">1        0     0 DOCKER     all  --  *      *       0.0.0.0/0           !127.0.0.0/8          ADDRTYPE match dst-type LOCAL</span><br><span class="line"></span><br><span class="line">Chain POSTROUTING (policy ACCEPT 1 packets, 70 bytes)</span><br><span class="line">num   pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line">1       75  6875 MASQUERADE  all  --  *      !docker0  172.17.0.0/16        0.0.0.0/0           </span><br><span class="line">2      610 36387 MASQUERADE  all  --  *      *       10.8.0.0/24          0.0.0.0/0           </span><br><span class="line">3        0     0 MASQUERADE  udp  --  *      *       172.17.0.2           172.17.0.2           udp dpt:1194</span><br><span class="line"></span><br><span class="line">Chain DOCKER (2 references)</span><br><span class="line">num   pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line">1        0     0 RETURN     all  --  docker0 *       0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">2        1    70 DNAT       udp  --  !docker0 *       0.0.0.0/0            0.0.0.0/0            udp dpt:1194 to:172.17.0.2:1194</span><br></pre></td></tr></table></figure>
<p>查看 FILTER 表添加的规则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ iptables -L -v -n --line-numbers | more</span><br><span class="line">Chain INPUT (policy DROP 0 packets, 0 bytes)</span><br><span class="line">num   pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line">1      641 51489 ACCEPT     all  --  *      *       0.0.0.0/0            0.0.0.0/0            state RELATED,ESTABLISHED</span><br><span class="line">2        0     0 ACCEPT     all  --  lo     *       0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">3        0     0 ACCEPT     udp  --  *      *       0.0.0.0/0            0.0.0.0/0            udp dpt:1194 /* openvpn */</span><br><span class="line">...</span><br><span class="line">13       0     0 ACCEPT     icmp --  *      *       0.0.0.0/0            0.0.0.0/0            icmptype 8</span><br><span class="line">14       0     0 ACCEPT     icmp --  *      *       0.0.0.0/0            0.0.0.0/0            icmptype 0</span><br><span class="line">15     230 14788 REJECT     all  --  *      *       0.0.0.0/0            0.0.0.0/0            reject-with icmp-host-prohibited</span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy DROP 0 packets, 0 bytes)</span><br><span class="line">num   pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line">1    16891 4860K DOCKER-USER  all  --  *      *       0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">2    16891 4860K DOCKER-ISOLATION-STAGE-1  all  --  *      *       0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">3     8465 2439K ACCEPT     all  --  *      docker0  0.0.0.0/0            0.0.0.0/0            ctstate RELATED,ESTABLISHED</span><br><span class="line">4        1    70 DOCKER     all  --  *      docker0  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">5     8425 2421K ACCEPT     all  --  docker0 !docker0  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">6        0     0 ACCEPT     all  --  docker0 docker0  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">7     4177 1774K ACCEPT     all  --  *      *       0.0.0.0/0            0.0.0.0/0            state RELATED,ESTABLISHED</span><br><span class="line">8      202 13030 REJECT     all  --  *      *       0.0.0.0/0            0.0.0.0/0            reject-with icmp-host-prohibited</span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT 343 packets, 61383 bytes)</span><br><span class="line">num   pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line"></span><br><span class="line">Chain DOCKER (1 references)</span><br><span class="line">num   pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line">1        1    70 ACCEPT     udp  --  !docker0 docker0  0.0.0.0/0            172.17.0.2           udp dpt:1194</span><br><span class="line"></span><br><span class="line">Chain DOCKER-ISOLATION-STAGE-1 (1 references)</span><br><span class="line">num   pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line">1     8425 2421K DOCKER-ISOLATION-STAGE-2  all  --  docker0 !docker0  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">2    16891 4860K RETURN     all  --  *      *       0.0.0.0/0            0.0.0.0/0           </span><br><span class="line"></span><br><span class="line">Chain DOCKER-ISOLATION-STAGE-2 (1 references)</span><br><span class="line">num   pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line">1        0     0 DROP       all  --  *      docker0  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">2     8425 2421K RETURN     all  --  *      *       0.0.0.0/0            0.0.0.0/0           </span><br><span class="line"></span><br><span class="line">Chain DOCKER-USER (1 references)</span><br><span class="line">num   pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line">1    16891 4860K RETURN     all  --  *      *       0.0.0.0/0            0.0.0.0/0</span><br></pre></td></tr></table></figure>

<h1 id="客户端连接"><a href="#客户端连接" class="headerlink" title="客户端连接"></a>客户端连接</h1><p>将 <a href="#%E5%AF%BC%E5%87%BA%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%81%E4%B9%A6">导出客户端证书</a> 中生成的客户端证书发送到客户端，测试连接。</p>
<p>客户端连接失败，可以检查以下内容：</p>
<ul>
<li><p>客户端日志及服务端日志，服务端日志可以通过以下方法查看</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logs -f OpenVPN</span><br></pre></td></tr></table></figure>

</li>
<li><p>检查是否是因为 <a href="#%E5%90%AF%E5%8A%A8-OpenVPN">iptables 防火墙规则</a> 问题导致无法连接，如果防火墙相关规则丢失，可以通过重启 docker 和 OpenVPN 容器的方式恢复。</p>
</li>
<li><p>检查容器中启动的端口和 docker 映射的端口是否一致。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Tools</category>
        <category>VPN</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenVPN 安装及使用</title>
    <url>/202302161539/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos 7 5.4.221</li>
<li>openvpn 2.4.12</li>
<li>easy-rsa-3.0.8</li>
<li>iptables</li>
</ul>
<h1 id="OpenVPN-服务端安装配置步骤"><a href="#OpenVPN-服务端安装配置步骤" class="headerlink" title="OpenVPN 服务端安装配置步骤"></a>OpenVPN 服务端安装配置步骤</h1><h2 id="安装-openvpn-服务端程序"><a href="#安装-openvpn-服务端程序" class="headerlink" title="安装 openvpn 服务端程序"></a>安装 openvpn 服务端程序</h2><p>epel 仓库源中包含了 OpenVPN 的安装包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum info openvpn</span></span><br><span class="line"></span><br><span class="line"> * epel: mirror.sfo12.us.leaseweb.net</span><br><span class="line"> * extras: download.cf.centos.org</span><br><span class="line"> * updates: download.cf.centos.org</span><br><span class="line">Available Packages</span><br><span class="line">Name        : openvpn</span><br><span class="line">Arch        : x86_64</span><br><span class="line">Version     : 2.4.12</span><br><span class="line">Release     : 1.el7</span><br><span class="line">Size        : 529 k</span><br><span class="line">Repo        : epel/x86_64</span><br><span class="line">Summary     : A full-featured SSL VPN solution</span><br><span class="line">URL         : https://community.openvpn.net/</span><br><span class="line">License     : GPLv2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum install -y openvpn</span></span><br></pre></td></tr></table></figure>

<h2 id="安装-easy-rsa"><a href="#安装-easy-rsa" class="headerlink" title="安装 easy-rsa"></a>安装 easy-rsa</h2><p>easy-rsa 主要用来生成证书</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install easy-rsa</span><br></pre></td></tr></table></figure>

<span id="more"></span>
<h2 id="初始化，生成证书、密钥和参数文件"><a href="#初始化，生成证书、密钥和参数文件" class="headerlink" title="初始化，生成证书、密钥和参数文件"></a>初始化，生成证书、密钥和参数文件</h2><h3 id="初始化-Esay-RSA"><a href="#初始化-Esay-RSA" class="headerlink" title="初始化 Esay-RSA"></a>初始化 Esay-RSA</h3><p>Esay-RSA 默认安装目录在 <code>/usr/share/easy-rsa/3.0.8</code>，文档配置文件模板在 <code>/usr/share/doc/easy-rsa-3.0.8</code>。</p>
<p>文档建议我们拷贝一份到别的目录使用，以免将来升级的时候被覆盖掉。此处目录选择的 OpenVPN 配置目录下 <code>/etc/openvpn/easy-rsa</code>。 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[CentOS 7安装配置OpenVPN服务器](https://www.simaek.com/archives/203/)">[1]</span></a></sup></p>
<p>拷贝配置文件模板，安装文档要求，必须重命名为 vars 才可以被自动加载。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp -a /usr/share/easy-rsa/3.0.8 /etc/openvpn/easy-rsa</span><br><span class="line"></span><br><span class="line">cp -a /usr/share/doc/easy-rsa-3.0.8/vars.example /etc/openvpn/easy-rsa/vars</span><br></pre></td></tr></table></figure>
<p>编辑配置文件 vars，主要修改证书相关的参数。</p>
<figure class="highlight shell"><figcaption><span>/etc/openvpn/easy-rsa/vars</span></figcaption><table><tr><td class="code"><pre><span class="line">set_var EASYRSA_REQ_COUNTRY    &quot;CN&quot;</span><br><span class="line">set_var EASYRSA_REQ_PROVINCE   &quot;JiangSu&quot;</span><br><span class="line">set_var EASYRSA_REQ_CITY       &quot;Nanjing&quot;</span><br><span class="line">set_var EASYRSA_REQ_ORG        &quot;SIMAEK&quot;</span><br><span class="line">set_var EASYRSA_REQ_EMAIL      &quot;master@simaek.com&quot;</span><br><span class="line">set_var EASYRSA_REQ_OU         &quot;Development Dept.&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明</strong>：</p>
<p>EASYRSA_REQ_COUNTRY “所在的国家”</p>
<p>EASYRSA_REQ_PROVINCE “所在的省份”</p>
<p>EASYRSA_REQ_CITY “所在的城市”</p>
<p>EASYRSA_REQ_ORG “所属的组织”</p>
<p>EASYRSA_REQ_EMAIL “邮件地址”</p>
<p>EASYRSA_REQ_OU “组织单位，部门”</p>
</blockquote>
<p>说明一下我们需要创建的证书：</p>
<ul>
<li>CA 根证书，用于给服务器和客户端证书签名使用。</li>
<li>OpenVPN 服务器证书</li>
<li>Diffie-Hellman 算法用到的 key</li>
</ul>
<p>进入 <code>easy-rsa</code> 脚本所在目录，初始 pki 目录，创建的证书和生成的中间文件都会存放在这个目录里，默认位置为脚本执行的路径。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /etc/openvpn/easy-rsa</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./easyrsa init-pki</span></span><br><span class="line"></span><br><span class="line">Note: using Easy-RSA configuration from: /etc/openvpn/easy-rsa/vars</span><br><span class="line"></span><br><span class="line">init-pki complete; you may now create a CA or requests.</span><br><span class="line">Your newly created PKI dir is: /etc/openvpn/easy-rsa/pki</span><br></pre></td></tr></table></figure>

<h3 id="创建-CA-根证书"><a href="#创建-CA-根证书" class="headerlink" title="创建 CA 根证书"></a>创建 CA 根证书</h3><p>根据提示输入 Common Name，名字自定义。在这部分会提示 <code>Enter New CA Key Passphrase</code>，输入两次 PEM 密码，此密码必须记住，不然以后不能为证书签名。可以加 <code>nopass</code> 参数表示不用密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./easyrsa build-ca</span></span><br><span class="line"></span><br><span class="line">Note: using Easy-RSA configuration from: /etc/openvpn/easy-rsa/vars</span><br><span class="line">Using SSL: openssl OpenSSL 1.0.2k-fips  26 Jan 2017</span><br><span class="line"></span><br><span class="line">Enter New CA Key Passphrase: </span><br><span class="line">Re-Enter New CA Key Passphrase: </span><br><span class="line">Generating RSA private key, 2048 bit long modulus</span><br><span class="line">..................................................+++</span><br><span class="line">.............................................................................................+++</span><br><span class="line">e is 65537 (0x10001)</span><br><span class="line">You are about to be asked to enter information that will be incorporated</span><br><span class="line">into your certificate request.</span><br><span class="line">What you are about to enter is what is called a Distinguished Name or a DN.</span><br><span class="line">There are quite a few fields but you can leave some blank</span><br><span class="line">For some fields there will be a default value,</span><br><span class="line">If you enter &#x27;.&#x27;, the field will be left blank.</span><br><span class="line">-----</span><br><span class="line">Common Name (eg: your user, host, or server name) [Easy-RSA CA]:myca</span><br><span class="line"></span><br><span class="line">CA creation complete and you may now import and sign cert requests.</span><br><span class="line">Your new CA certificate file for publishing is at:</span><br><span class="line">/etc/openvpn/easy-rsa/pki/ca.crt</span><br></pre></td></tr></table></figure>
<p>生成的 CA 证书位于 <code>pki/ca.crt</code>，私钥位于 <code>pki/private/</code></p>
<h3 id="创建-OpenVPN-服务端证书"><a href="#创建-OpenVPN-服务端证书" class="headerlink" title="创建 OpenVPN 服务端证书"></a>创建 OpenVPN 服务端证书</h3><p>命令中的 <code>openvpn-server</code> 为自定义名称，这里建议用使用 <code>nopass</code> 参数，否则以后启动服务时需要输入密码。创建过程中需要输入之前的 CA 根证书的 PEM 密码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./easyrsa build-server-full openvpn-server nopass</span></span><br><span class="line"></span><br><span class="line">Note: using Easy-RSA configuration from: /etc/openvpn/easy-rsa/vars</span><br><span class="line">Using SSL: openssl OpenSSL 1.0.2k-fips  26 Jan 2017</span><br><span class="line">Generating a 2048 bit RSA private key</span><br><span class="line">........................................................+++</span><br><span class="line">................+++</span><br><span class="line">writing new private key to &#x27;/etc/openvpn/easy-rsa/pki/easy-rsa-4754.a78E4M/tmp.ubswzT&#x27;</span><br><span class="line">-----</span><br><span class="line">Using configuration from /etc/openvpn/easy-rsa/pki/easy-rsa-4754.a78E4M/tmp.zSlCOO</span><br><span class="line">Enter pass phrase for /etc/openvpn/easy-rsa/pki/private/ca.key:</span><br><span class="line">Check that the request matches the signature</span><br><span class="line">Signature ok</span><br><span class="line">The Subject&#x27;s Distinguished Name is as follows</span><br><span class="line">commonName            :ASN.1 12:&#x27;openvpn-server&#x27;</span><br><span class="line">Certificate is to be certified until May 21 09:13:22 2025 GMT (825 days)</span><br><span class="line"></span><br><span class="line">Write out database with 1 new entries</span><br><span class="line">Data Base Updated</span><br></pre></td></tr></table></figure>
<p>生成的 OpenVPN 服务端证书位于 <code>pki/issued/</code>，私钥位于 <code>pki/private/</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> pki/issued/</span></span><br><span class="line">openvpn-server.crt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> pki/private/</span></span><br><span class="line">ca.key  openvpn-server.key</span><br></pre></td></tr></table></figure>

<h3 id="生成-Diffie-Hellman-算法需要的密钥文件"><a href="#生成-Diffie-Hellman-算法需要的密钥文件" class="headerlink" title="生成 Diffie-Hellman 算法需要的密钥文件"></a>生成 Diffie-Hellman 算法需要的密钥文件</h3><p>创建 Diffie-Hellman，确保 key 穿越不安全网络的命令，时间会有点长，耐心等待。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./easyrsa gen-dh</span><br></pre></td></tr></table></figure>

<h3 id="生成-tls-auth-key"><a href="#生成-tls-auth-key" class="headerlink" title="生成 tls-auth key"></a>生成 tls-auth key</h3><p>此配置是为了防止 DDOS 和 TLS 攻击，这个属于可选安全配置。</p>
<p>强认证方式，防攻击。如果 OpenVPN 配置文件中启用此项(默认是启用的)，就需要执行此命令，并把 <code>ta.key</code> 放到 <code>/etc/openvpn/server</code> 目录。</p>
<p>配置文件中服务端第二个参数为 0，同时客户端也要有此文件，且 <code>client.conf</code> 中此指令的第二个参数需要为1。<strong>服务端有该配置，那么客户端也必须要有</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openvpn --genkey --secret ta.key</span><br></pre></td></tr></table></figure>

<h3 id="收集证书文件"><a href="#收集证书文件" class="headerlink" title="收集证书文件"></a>收集证书文件</h3><p>创建目录，将需要的证书文件统一放入此目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /etc/openvpn/server/certs</span><br><span class="line"></span><br><span class="line">cp /etc/openvpn/easy-rsa/pki/ca.crt /etc/openvpn/server/certs</span><br><span class="line">cp /etc/openvpn/easy-rsa/pki/private/ca.key /etc/openvpn/server/certs</span><br><span class="line">cp /etc/openvpn/easy-rsa/pki/private/openvpn-server.key /etc/openvpn/server/certs</span><br><span class="line">cp /etc/openvpn/easy-rsa/pki/issued/openvpn-server.crt /etc/openvpn/server/certs</span><br><span class="line">cp /etc/openvpn/easy-rsa/pki/dh.pem /etc/openvpn/server/certs</span><br><span class="line"></span><br><span class="line">cp /etc/openvpn/easy-rsa/ta.key /etc/openvpn/server/certs</span><br></pre></td></tr></table></figure>

<h2 id="配置-OpenVPN-服务端"><a href="#配置-OpenVPN-服务端" class="headerlink" title="配置 OpenVPN 服务端"></a>配置 OpenVPN 服务端</h2><p>修改 OpenVPN 服务端配置文件，拷贝配置模板文件并修改</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /etc/openvpn/server/</span><br><span class="line">cp /usr/share/doc/openvpn-2.4.12/sample/sample-config-files/server.conf ./</span><br></pre></td></tr></table></figure>

<p>配置文件中主要内容如下，<a href="#OpenVPN-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3">配置文件详细说明参考</a> </p>
<figure class="highlight shell"><figcaption><span>/etc/openvpn/server/server.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">local 192.168.88.88</span><br><span class="line">port 1194</span><br><span class="line">proto udp</span><br><span class="line">dev tun</span><br><span class="line">ca server_certs/ca.crt</span><br><span class="line">cert server_certs/openvpn-server.crt</span><br><span class="line">key server_certs/openvpn-server.key</span><br><span class="line">dh dh.pem</span><br><span class="line">server 10.8.0.0 255.255.255.0</span><br><span class="line">ifconfig-pool-persist ipp.txt</span><br><span class="line">push &quot;redirect-gateway def1 bypass-dhcp&quot;</span><br><span class="line">push &quot;dhcp-option DNS 8.8.8.8&quot;</span><br><span class="line">client-to-client</span><br><span class="line">keepalive 10 120</span><br><span class="line">comp-lzo</span><br><span class="line">user nobody</span><br><span class="line">group nobody</span><br><span class="line">persist-key</span><br><span class="line">persist-tun</span><br><span class="line">status openvpn-status.log</span><br><span class="line">log openvpn.log</span><br><span class="line">verb 3</span><br></pre></td></tr></table></figure>

<h3 id="开启系统-IPv4-转发功能"><a href="#开启系统-IPv4-转发功能" class="headerlink" title="开启系统 IPv4 转发功能"></a>开启系统 IPv4 转发功能</h3><p>修改内核配置文件 <code>/etc/sysctl.conf</code>，增加以下配置，开启内核 IPv4 转发功能</p>
<figure class="highlight shell"><figcaption><span>/etc/sysctl.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">net.ipv4.ip_forward = 1</span><br></pre></td></tr></table></figure>
<p>执行命令使配置生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>

<h3 id="添加-iptables-防火墙规则"><a href="#添加-iptables-防火墙规则" class="headerlink" title="添加 iptables 防火墙规则"></a>添加 iptables 防火墙规则</h3><p>配置 iptables 防火墙规则，允许 OpenVPN 分配的网段 NAT</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -j MASQUERADE</span><br></pre></td></tr></table></figure>
<p>配置 iptables 防火墙规则(<code>filter</code> 表)，允许转发，同时放通 OpenVPN 监听的端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -I FORWARD -s 10.8.0.0/24 -j ACCEPT</span><br><span class="line">iptables -I FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line">iptables -I INPUT -p udp --dport 1194 -j ACCEPT -m comment --comment &quot;openvpn&quot;</span><br></pre></td></tr></table></figure>

<p>要持久化配置，可以在 iptables 配置文件中增加如下主要配置</p>
<figure class="highlight shell"><figcaption><span>/etc/sysconfig/iptables</span></figcaption><table><tr><td class="code"><pre><span class="line">*filter</span><br><span class="line">:INPUT DROP [0:0]</span><br><span class="line">:FORWARD DROP [0:0]</span><br><span class="line">:OUTPUT ACCEPT [4:368]</span><br><span class="line">-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">-A INPUT -i lo -j ACCEPT</span><br><span class="line">-A INPUT -p udp --dport 1194 -j ACCEPT -m comment --comment &quot;openvpn&quot;</span><br><span class="line">-A INPUT -p icmp -m icmp --icmp-type 8 -j ACCEPT</span><br><span class="line">-A INPUT -p icmp -m icmp --icmp-type 0 -j ACCEPT</span><br><span class="line">-A INPUT -j REJECT --reject-with icmp-host-prohibited</span><br><span class="line"></span><br><span class="line">-A FORWARD -s 10.8.0.0/24 -j ACCEPT</span><br><span class="line">-A FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">-A FORWARD -j REJECT --reject-with icmp-host-prohibited</span><br><span class="line">COMMIT</span><br><span class="line"></span><br><span class="line">*nat</span><br><span class="line">:INPUT ACCEPT [0:0]</span><br><span class="line">:OUTPUT ACCEPT [4:368]</span><br><span class="line">-A POSTROUTING -s 10.8.0.0/24 -j MASQUERADE</span><br><span class="line">COMMIT</span><br></pre></td></tr></table></figure>

<h3 id="启动-OpenVPN-服务"><a href="#启动-OpenVPN-服务" class="headerlink" title="启动 OpenVPN 服务"></a>启动 OpenVPN 服务</h3><p>执行以下命令可以在前台启动 OpenVPN 服务，并观察错误信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openvpn /etc/openvpn/server/server.conf</span><br></pre></td></tr></table></figure>
<p>启动之后，检查系统是否监听了 1194&#x2F;udp</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">netstat -anutp</span></span><br><span class="line">Active Internet connections (servers and established)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">udp        0      0 0.0.0.0:739             0.0.0.0:*                           620/rpcbind         </span><br><span class="line">udp        0      0 0.0.0.0:1194            0.0.0.0:*                           9898/openvpn        </span><br><span class="line">udp        0      0 0.0.0.0:68              0.0.0.0:*                           931/dhclient        </span><br><span class="line">udp        0      0 0.0.0.0:111             0.0.0.0:*                           620/rpcbind         </span><br><span class="line">udp6       0      0 :::739                  :::*                                620/rpcbind         </span><br><span class="line">udp6       0      0 :::111                  :::*                                620/rpcbind  </span><br></pre></td></tr></table></figure>
<p>端口监听后，说明服务启动无异常，如果端口未监听，检查日志解决。</p>
<h1 id="OpenVPN-客户端安装配置"><a href="#OpenVPN-客户端安装配置" class="headerlink" title="OpenVPN 客户端安装配置"></a>OpenVPN 客户端安装配置</h1><h2 id="Windows-客户端配置"><a href="#Windows-客户端配置" class="headerlink" title="Windows 客户端配置"></a>Windows 客户端配置</h2><p><a href="https://openvpn.net/downloads/openvpn-connect-v3-windows.msi">下载 OpenVPN Windows 客户端</a></p>
<a href="/202302041721/" title="常用工具下载链接">常用工具下载链接</a>
<h3 id="在-OpenVPN-服务端为客户端生成证书"><a href="#在-OpenVPN-服务端为客户端生成证书" class="headerlink" title="在 OpenVPN 服务端为客户端生成证书"></a>在 OpenVPN 服务端为客户端生成证书</h3><p>在 OpenVPN 服务器的 <code>/etc/openvpn/easy-rsa/</code> 目录下，执行以下命令，为客户端生成无密码的证书</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./easyrsa build-client-full client nopass </span><br></pre></td></tr></table></figure>
<p>命令选项中，<code>nopass</code> 指定证书无密码，不安全，建议生产环境中配置密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./easyrsa build-client-full vpn1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为指定用户生成证书，会首先询问设置用户证书密码，签发时会询问 <a href="#%E5%88%9B%E5%BB%BA-CA-%E6%A0%B9%E8%AF%81%E4%B9%A6">CA 证书密码</a>。</p>
<p>证书创建完成后，证书和私钥分别位于以下位置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> pki/issued/</span></span><br><span class="line">openvpn-server.crt  vpn1.crt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> pki/private/</span></span><br><span class="line">ca.key  openvpn-server.key  vpn1.key</span><br></pre></td></tr></table></figure>

<p>客户端需要 CA 根证书（<code>/etc/openvpn/easy-rsa/pki/ca.crt</code>），客户端证书(<code>/etc/openvpn/easy-rsa/pki/issued/vpn1.crt</code>)和私钥(<code>/etc/openvpn/easy-rsa/pki/private/vpn1.key</code>)</p>
<h3 id="生成-OpenVPN-客户端配置文件"><a href="#生成-OpenVPN-客户端配置文件" class="headerlink" title="生成 OpenVPN 客户端配置文件"></a>生成 OpenVPN 客户端配置文件</h3><p><a href="#OpenVPN-%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3">OpenVPN 客户端配置文件说明</a></p>
<p>客户端配置文件名默认 windows 为 <code>client.ovpn</code>，Linux 为 <code>client.conf</code></p>
<p>创建客户端配置文件目录，假设为 <code>/home/openvpn/vpn1/</code>，并拷贝相应的证书文件到此目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /etc/openvpn/easy-rsa/pki/ca.crt /home/openvpn/vpn1/ca.crt</span><br><span class="line">cp /etc/openvpn/easy-rsa/pki/private/vpn1.key /home/openvpn/vpn1/client.key</span><br><span class="line">cp /etc/openvpn/easy-rsa/pki/issued/vpn1.crt /home/openvpn/vpn1/client.crt</span><br></pre></td></tr></table></figure>
<p>为客户端 vpn1 创建 openvpn 客户端配置文件 <code>/home/openvpn/vpn1/client.ovpn</code> </p>
<figure class="highlight shell"><figcaption><span>client.ovpn</span></figcaption><table><tr><td class="code"><pre><span class="line">client</span><br><span class="line">dev tun</span><br><span class="line">proto udp     </span><br><span class="line">remote 39.xxx.xxx.xxx 1194  </span><br><span class="line">resolv-retry infinite</span><br><span class="line">nobind</span><br><span class="line">persist-key</span><br><span class="line">persist-tun</span><br><span class="line">ca ca.crt</span><br><span class="line">cert client.crt     </span><br><span class="line">key client.key        </span><br><span class="line">comp-lzo</span><br><span class="line">verb 3</span><br></pre></td></tr></table></figure>
<p>将 <code>ca.crt</code> , <code>client.ovpn</code> , <code>client.crt</code> , <code>client.key</code> 发送到客户端。</p>
<p>在 Windows 上使用 OpenVPN 客户端导入配置 <code>client.ovpn</code>，即可正常连接。</p>
<h1 id="OpenVPN-服务端配置文件详解"><a href="#OpenVPN-服务端配置文件详解" class="headerlink" title="OpenVPN 服务端配置文件详解"></a>OpenVPN 服务端配置文件详解</h1><figure class="highlight shell"><figcaption><span>/etc/openvpn/server/server.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">表示 openvpn 服务端监听的地址</span></span><br><span class="line">local 0.0.0.0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">监听的端口，默认是 1194</span></span><br><span class="line">port 1194</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用的协议，有 udp 和 tcp。建议选择 tcp</span></span><br><span class="line">proto tcp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用三层路由 IP 隧道( tun )还是二层以太网隧道( tap )。一般都使用 tun</span></span><br><span class="line">dev tun</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ca证书、服务端证书、服务端密钥和密钥交换文件。如果它们和 server.conf 在同一个目录下则可以不写绝对路径，否则需要写绝对路径调用</span></span><br><span class="line">ca ca.crt</span><br><span class="line">cert server.crt</span><br><span class="line">key server.key</span><br><span class="line">dh dh2048.pem</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">vpn 服务端为自己和客户端分配 IP 的地址池。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务端自己获取网段的第一个地址(此处为 10.8.0.1)，后为客户端分配其他的可用地址。以后客户端就可以和 10.8.0.1 进行通信。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意：该网段地址池不要和已有网段冲突或重复。其实一般来说是不用改的。除非当前内网使用了 10.8.0.0/24 的网段。</span></span><br><span class="line"></span><br><span class="line">server 10.8.0.0 255.255.255.0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用一个文件记录已分配虚拟 IP 的客户端和虚拟 IP 的对应关系，</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以后 openvpn 重启时，将可以按照此文件继续为对应的客户端分配此前相同的 IP。也就是自动续借 IP 的意思。</span></span><br><span class="line"></span><br><span class="line">ifconfig-pool-persist ipp.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用tap模式的时候考虑此选项。</span></span><br><span class="line">server-bridge XXXXXX</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">vpn 服务端向客户端推送 vpn 服务端内网网段的路由配置，以便让客户端能够找到服务端内网。多条路由就写多个 push 指令</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">分配网关</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">dhcp分配dns</span></span><br><span class="line">push &quot;redirect-gateway def1 bypass-dhcp&quot;     </span><br><span class="line">push &quot;dhcp-option DNS 8.8.8.8&quot;        </span><br><span class="line"></span><br><span class="line">push &quot;route 10.0.10.0 255.255.255.0&quot;</span><br><span class="line">push &quot;route 192.168.10.0 255.255.255.0&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">让 vpn 客户端之间可以互相看见对方，即能互相通信。默认情况客户端只能看到服务端一个人；</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认是注释的，不能客户端之间相互看见</span> </span><br><span class="line">client-to-client</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">允许多个客户端使用同一个 VPN 帐号连接服务端</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认是注释的，不支持多个客户登录一个账号</span></span><br><span class="line">duplicate-cn</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每 10 秒 ping 一次，120 秒后没收到 ping 就说明对方挂了</span></span><br><span class="line">keepalive 10 120</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加强认证方式，防攻击。如果配置文件中启用此项(默认是启用的)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">需要执行 openvpn --genkey --secret ta.key，并把 ta.key 放到 /etc/openvpn/server 目录</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务端第二个参数为 0；同时客户端也要有此文件，且 client.conf 中此指令的第二个参数需要为 1。</span></span><br><span class="line">tls-auth ta.key 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">选择一个密码。如果在服务器上使用了 cipher 选项，那么您也必须在这里指定它。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意，v2.4 客户端/服务器将在 TLS 模式下自动协商 AES-256-GCM。</span></span><br><span class="line">cipher AES-256-CBC</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">openvpn 2.4 版本的 vpn 才能设置此选项。表示服务端启用 lz4 的压缩功能，传输数据给客户端时会压缩数据包。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">push 后在客户端也配置启用 lz4 的压缩功能，向服务端发数据时也会压缩。如果是 2.4 版本以下的老版本，则使用用 comp-lzo 指令</span></span><br><span class="line"></span><br><span class="line">compress lz4-v2</span><br><span class="line">push &quot;compress lz4-v2&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启用 lzo 数据压缩格式。此指令用于低于 2.4 版本的老版本。且如果服务端配置了该指令，客户端也必须要配置</span></span><br><span class="line">comp-lzo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">并发客户端的连接数</span></span><br><span class="line">max-clients 100</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过 ping 得知超时时，当重启 vpn 后将使用同一个密钥文件以及保持 tun 连接状态</span></span><br><span class="line">persist-key</span><br><span class="line">persist-tun</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在文件中输出当前的连接信息，每分钟截断并重写一次该文件</span></span><br><span class="line">status openvpn-status.log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认vpn的日志会记录到rsyslog中，使用这两个选项可以改变。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">log</span> 指令表示每次启动 vpn 时覆盖式记录到指定日志文件中，</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">log-append 则表示每次启动 vpn 时追加式的记录到指定日志中。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">但两者只能选其一，或者不选时记录到rsyslog中</span></span><br><span class="line">;log openvpn.log</span><br><span class="line">;log-append openvpn.log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">日志记录的详细级别。</span></span><br><span class="line">verb 3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">沉默的重复信息。最多 20 条相同消息类别的连续消息将输出到日志。</span></span><br><span class="line">;mute 20</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当服务器重新启动时，通知客户端，以便它可以自动重新连接。仅在 UDP 协议是可用</span></span><br><span class="line">explicit-exit-notify 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="OpenVPN-客户端配置文件详解"><a href="#OpenVPN-客户端配置文件详解" class="headerlink" title="OpenVPN 客户端配置文件详解"></a>OpenVPN 客户端配置文件详解</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">标识这是个客户端</span></span><br><span class="line">client</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用三层路由IP隧道(tun)还是二层以太网隧道(tap)。服务端是什么客户端就是什么</span></span><br><span class="line">dev tun</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用的协议，有udp和tcp。服务端是什么客户端就是什么</span></span><br><span class="line">proto tcp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务端的地址和端口</span></span><br><span class="line">remote 10.0.0.190 1194</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一直尝试解析 OpenVPN 服务器的主机名。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在机器上非常有用，不是永久连接到互联网，如笔记本电脑。</span></span><br><span class="line">resolv-retry infinite</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">大多数客户机不需要绑定到特定的本地端口号。</span></span><br><span class="line">nobind</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化后的降级特权(仅非 windows)</span></span><br><span class="line">;user nobody</span><br><span class="line">;group nobody</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">尝试在重新启动时保留某些状态。</span></span><br><span class="line">persist-key</span><br><span class="line">persist-tun</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ca 证书、客户端证书、客户端密钥</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果它们和 client.conf 或 client.ovpn 在同一个目录下则可以不写绝对路径，否则需要写绝对路径调用</span></span><br><span class="line">ca ca.crt</span><br><span class="line">cert client.crt</span><br><span class="line">key client.key</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过检查 certificate 是否具有正确的密钥使用设置来验证服务器证书。</span></span><br><span class="line">remote-cert-tls server</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加强认证方式，防攻击。服务端有配置，则客户端必须有</span></span><br><span class="line">tls-auth ta.key 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">选择一个密码。如果在服务器上使用了 cipher 选项，那么您也必须在这里指定它。注意，v2.4 客户端/服务器将在 TLS 模式下自动协商 AES-256-GCM。</span></span><br><span class="line">cipher AES-256-CBC</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务端用的什么，客户端就用的什么</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">表示客户端启用lz4的压缩功能，传输数据给客户端时会压缩数据包。</span></span><br><span class="line">compress lz4-v2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">日志级别</span></span><br><span class="line">verb 3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">沉默的重复信息。最多20条相同消息类别的连续消息将输出到日志。</span></span><br><span class="line">;mute 20</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.simaek.com/archives/203/">CentOS 7安装配置OpenVPN服务器</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Tools</category>
        <category>VPN</category>
      </categories>
      <tags>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title>php 编译安装配置</title>
    <url>/202207301722/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Centos 7</li>
<li>Php 7.2</li>
</ul>
<span id="more"></span>

<h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><p>安装依赖包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y gcc libxml2-devel libjpeg-turbo-devel libpng-devel libxslt libxslt-devel libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel libxml2 libxml2-devel zlib zlib-devel curl curl-devel openssl openssl-devel  bzip2  bzip2-devel  libxslt libxslt-devel  libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel libxml2 libxml2-devel zlib zlib-devel curl curl-devel openssl openssl-devel perl perl-devel httpd-devel readline-devel autoconf</span><br></pre></td></tr></table></figure>
<p>下载安装包，编译安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://am1.php.net/distributions/php-7.2.0.tar.bz2</span><br><span class="line">tar -xf php-7.2.0.tar.bz2</span><br><span class="line">cd php-7.2.0</span><br><span class="line"></span><br><span class="line">./configure --prefix=/usr/local/php7/ \</span><br><span class="line">--with-fpm-user=nginx \</span><br><span class="line">--with-curl  --with-gd --with-gettext --with-iconv-dir --with-kerberos --with-libdir=lib64 \</span><br><span class="line">--with-libxml-dir --with-mysqli --with-openssl --with-pcre-regex --with-pdo-mysql \</span><br><span class="line">--with-pdo-sqlite --with-pear --with-png-dir --with-xmlrpc --with-xsl --with-zlib \</span><br><span class="line">--enable-fpm --enable-bcmath -enable-inline-optimization  --enable-mbregex --enable-mbstring \</span><br><span class="line">--enable-opcache --enable-pcntl --enable-shmop --enable-soap --enable-sockets --enable-sysvsem \</span><br><span class="line">--enable-xml --enable-zip --enable-pcntl --with-curl  --enable-ftp --enable-session --enable-xml \</span><br><span class="line">--with-freetype-dir --with-jpeg-dir --enable-calendar --enable-exif --with-readline --enable-sysvshm --enable-wddx</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>安装完成后，拷贝配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp php.ini-production /usr/local/php7/etc/php.ini</span><br><span class="line">cd /usr/local/php7/etc</span><br><span class="line">mv php-fpm.conf.default php-fpm.conf</span><br></pre></td></tr></table></figure>
<p>php编译好之后，提供了一个php-fpm的程序作为服务管理程序，位置在编译后的源码目录：<code>php-7.2.0/sapi/fpm/</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp php-fpm.service /usr/lib/systemd/system/</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start php-fpm</span><br></pre></td></tr></table></figure>

<h3 id="php-常用扩展安装方法"><a href="#php-常用扩展安装方法" class="headerlink" title="php 常用扩展安装方法"></a>php 常用扩展安装方法</h3><p>php 扩展优先选择使用 <code>pecl</code> 命令安装，需要特殊配置时再选择编译安装， <code>pecl</code> 安装 <code>redis</code> 扩展示例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pecl install redis</span><br></pre></td></tr></table></figure>

<h4 id="yac-扩展安装"><a href="#yac-扩展安装" class="headerlink" title="yac 扩展安装"></a>yac 扩展安装</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/laruence/yac</span><br><span class="line">cd yac</span><br><span class="line">phpize</span><br><span class="line">./configure --with-php-config=/usr/local/php7/bin/php-config</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h4 id="composer-安装"><a href="#composer-安装" class="headerlink" title="composer 安装"></a>composer 安装</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">php -r &quot;readfile(&#x27;https://getcomposer.org/installer&#x27;);&quot; | php</span><br><span class="line">mv composer.phar /usr/local/bin/composer</span><br></pre></td></tr></table></figure>

<h4 id="inotify-安装"><a href="#inotify-安装" class="headerlink" title="inotify 安装"></a>inotify 安装</h4><p>扩展<a href="http://pecl.php.net/package/inotify">下载地址</a><br>比如安装2.0.0版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://pecl.php.net/get/inotify-2.0.0.tgz</span><br><span class="line">tar -xf inotify-2.0.0.tgz</span><br><span class="line">phpize</span><br><span class="line">./configure --with-php-config=/usr/local/php7/bin/php-config --enable-inotify</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h4 id="memcache-扩展安装"><a href="#memcache-扩展安装" class="headerlink" title="memcache 扩展安装"></a>memcache 扩展安装</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install libmemcached libmemcached-devel     ##先按照依赖，否则make报错</span><br><span class="line">git clone https://github.com/php-memcached-dev/php-memcached.git php-memcache</span><br><span class="line">cd php-memcache/</span><br><span class="line">git checkout php7</span><br><span class="line">phpize</span><br><span class="line">./configure --enable-memcached --with-php-config=/usr/local/php7/bin/php-config</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p><code>php.ini</code> 中添加配置 <code>extension=memcached.so</code></p>
<h4 id="gd-扩展安装"><a href="#gd-扩展安装" class="headerlink" title="gd 扩展安装"></a>gd 扩展安装</h4><p>进入到php的源码目录下的ext&#x2F;gd目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd php-7.2.0/ext/gd</span><br><span class="line">yum -y install libjpeglibjpeg-devel libpng libpng-devel freetype freetype-devel</span><br><span class="line">make clean</span><br><span class="line">phpize</span><br><span class="line">./configure --with-png-dir --with-freetype-dir --with-jpeg-dir --with-gd --with-php-config=/usr/local/php7/bin/php-config</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p><code>php.ini</code> 中添加配置 <code>extension=gd.so</code></p>
<h4 id="mongodb-扩展安装"><a href="#mongodb-扩展安装" class="headerlink" title="mongodb 扩展安装"></a>mongodb 扩展安装</h4><p>扩展<a href="http://pecl.php.net/package/mongodb">下载地址</a>  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://pecl.php.net/get/mongodb-1.14.0.tgz</span><br><span class="line">tar -xf mongodb-1.14.0.tgz</span><br><span class="line">cd mongodb-1.14.0</span><br><span class="line">/usr/local/php7/bin/phpize</span><br><span class="line">./configure --with-php-config=/usr/local/php7/bin/php-config</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h4 id="imagick-扩展安装"><a href="#imagick-扩展安装" class="headerlink" title="imagick 扩展安装"></a>imagick 扩展安装</h4><p>首先安装ImageMagick</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://imagemagick.org/download/ImageMagick.tar.gz</span><br><span class="line">tar -xf ImageMagick.tar.gz</span><br><span class="line">cd ImageMagick</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>安装 <code>imagick</code> 扩展</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://pecl.php.net/get/imagick-3.4.4.tgz</span><br><span class="line">/usr/local/php7/bin/phpize </span><br><span class="line">./configure --with-php-config=/usr/local/php7/bin/php-config</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h4 id="trie-filter-扩展安装"><a href="#trie-filter-扩展安装" class="headerlink" title="trie_filter 扩展安装"></a>trie_filter 扩展安装</h4><p>安装依赖 <code>libdatrie</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -O ftp://linux.thai.net/pub/ThaiLinux/software/libthai/libdatrie-0.2.4.tar.gz</span><br><span class="line">tar zxvf libdatrie-0.2.4.tar.gz</span><br><span class="line">cd libdatrie-0.2.4</span><br><span class="line">make clean</span><br><span class="line">./configure --prefix=/usr/local/libdatrie</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>安装扩展 <code>trie_filter</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://github.com/jiopuud/trie_filter/archive/master.zip</span><br><span class="line">unzip master.zip</span><br><span class="line">cd trie_filter-master</span><br><span class="line">phpize</span><br><span class="line">./configure --with-php-config=/usr/local/php7/bin/php-config --with-trie_filter=/usr/local/libdatrie</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="swoole-扩展安装"><a href="#swoole-扩展安装" class="headerlink" title="swoole 扩展安装"></a>swoole 扩展安装</h4><p>安装依赖 <code>hiredis</code>（可选操作）<br><a href="https://github.com/redis/hiredis/releases">下载链接</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>安装 <code>woole</code> 扩展<br><a href="https://github.com/swoole/swoole-src/releases">下载地址</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xf swoole-src-1.9.15.tar.gz</span><br><span class="line">cd swoole-src-1.9.15</span><br><span class="line">phpize</span><br><span class="line">./configure --enable-openssl --enable-async-redis --with-php-config=/usr/local/php7/bin/php-config</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>--enable-async-redis</code> 依赖<code>hiredis</code>， 需要先安装 <code>hiredis</code><br>编译安装过程中，可能出现找不到动态链接库的问题，可将 <code>/usr/local/lib</code> 添加到共享的动态库，<br>编辑 <code>ldconfig</code> 配置文件 <code>/etc/ld.so.conf</code>，追加以下内容</p>
<figure class="highlight shell"><figcaption><span>/etc/ld.so.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">/usr/local/lib</span><br></pre></td></tr></table></figure>
<p>修改 <code>ldconfig</code> 配置后，执行以下命令使新配置生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ldconfig</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="phpredis-扩展安装"><a href="#phpredis-扩展安装" class="headerlink" title="phpredis 扩展安装"></a>phpredis 扩展安装</h4><p><a href="https://github.com/phpredis/phpredis/releases">下载地址</a>  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd phpredis/</span><br><span class="line">phpize</span><br><span class="line">./configure --with-php-config=/usr/local/php7/bin/php-config</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h3 id="php-fpm-常见配置"><a href="#php-fpm-常见配置" class="headerlink" title="php-fpm 常见配置"></a>php-fpm 常见配置</h3><h4 id="php-fpm-日志相关配置"><a href="#php-fpm-日志相关配置" class="headerlink" title="php-fpm 日志相关配置"></a>php-fpm 日志相关配置</h4><p><code>php-fpm</code> 全局错误日志配置默认位于 <code>etc/php-fpm.conf</code></p>
<figure class="highlight shell"><figcaption><span>etc/php-fpm.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">;;;;;;;;;;;;;;;;;;</span><br><span class="line">; Global Options ;</span><br><span class="line">;;;;;;;;;;;;;;;;;;</span><br><span class="line"></span><br><span class="line">[global]</span><br><span class="line">error_log = /var/log/php-fpm/error.log</span><br><span class="line"></span><br><span class="line">; Log level</span><br><span class="line">; Possible Values: alert, error, warning, notice, debug</span><br><span class="line">; Default Value: notice</span><br><span class="line">;log_level = notice</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>php-fpm</code> 默认相关 <code>pool</code> 日志配置主要位于 <code>etc/php-fpm.d/www.conf</code>。默认情况下，<code>pool</code> 中的日志（<code>stdout and stderr</code>） 会被重定向到 <code>/dev/null</code>。</p>
<p>如果需要将对应 <code>pool</code> 中的日志输出到全局错误日志配置的路径，需要配置 <code>catch_workers_output = yes</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">access.log = /var/log/php/www.access.log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">慢日志</span></span><br><span class="line">slowlog = /var/log/php/www.log.slow</span><br><span class="line">request_slowlog_timeout = 10</span><br><span class="line"></span><br><span class="line">; Redirect worker stdout and stderr into main error log. If not set, stdout and</span><br><span class="line">; stderr will be redirected to /dev/null according to FastCGI specs.</span><br><span class="line">; Note: on highloaded environement, this can cause some delay in the page</span><br><span class="line">; process time (several ms).</span><br><span class="line">; Default Value: no</span><br><span class="line">;catch_workers_output = yes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以下配置是对 php.ini 的补充，会在定义的 pool （比如 www） 中覆盖 php.ini 中的配置。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">否则为了记录日志，需要修改 php.ini 文件，增加以下配置</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># log_errors = On</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># error_log = &quot;/usr/local/php/var/log/error_log&quot;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># error_reporting=E_ALL&amp;~E_NOTICE</span></span></span><br><span class="line"></span><br><span class="line">php_flag[display_errors] = on</span><br><span class="line">php_admin_value[error_log] = /var/log/php-fpm/www-error.log</span><br><span class="line">php_admin_flag[log_errors] = on</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>predixy 安装配置</title>
    <url>/202207271506/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3></blockquote>
<ul>
<li>Centos 7</li>
<li>predixy-1.0.5</li>
</ul>
<blockquote>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3></blockquote>
<p><a href="https://github.com/joyieldInc/predixy">下载地址</a>, clone或下载最新的版本或指定版本下载后解压</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install libstdc++-static -y</span><br><span class="line">cd predixy-1.0.5</span><br><span class="line">make</span><br><span class="line">cp src/predixy /usr/local/bin/</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要依赖 <code>libstdc++-static</code>, 否则make会报错：<br>&#x2F;bin&#x2F;ld: cannot find -lstdc++<br>collect2: error: ld returned 1 exit status<br>make[1]: *** [predixy] Error 1<br>make[1]: Leaving directory &#96;&#x2F;root&#x2F;predixy-1.0.5&#x2F;src’<br>make: *** [default] Error 2</p>
</blockquote>
<blockquote>
<h3 id="配置文件说明"><a href="#配置文件说明" class="headerlink" title="配置文件说明"></a>配置文件说明</h3></blockquote>
<ul>
<li><p>predixy.conf，整体配置文件，会引用下面的配置文件</p>
</li>
<li><p>cluster.conf，用于Redis Cluster时，配置后端redis信息</p>
</li>
<li><p>sentinel.conf，用于Redis Sentinel时，配置后端redis信息</p>
</li>
<li><p>auth.conf，访问权限控制配置，可以定义多个验证密码，可每个密码指定读、写、管理权限，以及定义可访问的健空间</p>
</li>
<li><p>dc.conf，多数据中心支持，可以定义读写分离规则，读流量权重分配</p>
</li>
<li><p>latency.conf， 延迟监控规则定义，可以指定需要监控的命令以及延时时间间隔</p>
</li>
</ul>
<blockquote>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3></blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">predixy /predixy/conf/predixy.conf</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用默认的配置文件predixy.conf， predixy将监听地址0.0.0.0:7617，后端的redis是Redis Cluster 127.0.0.1:6379  </p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Predixy</tag>
      </tags>
  </entry>
  <entry>
    <title>Prometheus 和 Grafana 使用示例</title>
    <url>/202306061334/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Prometheus 2.44.0</li>
<li>Grafana 9.5.2</li>
<li>Kubernetes 1.24</li>
</ul>
<h1 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h1><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><h3 id="Grafana-中获取所有-node-的-CPU-使用率"><a href="#Grafana-中获取所有-node-的-CPU-使用率" class="headerlink" title="Grafana 中获取所有 node 的 CPU 使用率"></a>Grafana 中获取所有 node 的 CPU 使用率</h3><p>以下示例中，<code>$node</code> 为在 Grafana 的 Dashboard 中配置的 Variables，其值为 Kubernetes 的节点主机名。<code>$interval</code> 为在 Grafana 的 Dashboard 中配置的 Variables，其值表示 Prometheus 的查询时间范围变量。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">100 - avg(rate(node_cpu_seconds_total&#123;mode=&quot;idle&quot;,kubernetes_io_hostname=~&quot;$node&quot;&#125;[$interval])) * 100</span><br></pre></td></tr></table></figure>

<h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><h3 id="Grafana-中获取所有-node-的-Memory-使用率"><a href="#Grafana-中获取所有-node-的-Memory-使用率" class="headerlink" title="Grafana 中获取所有 node 的 Memory 使用率"></a>Grafana 中获取所有 node 的 Memory 使用率</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">100 - (sum(node_memory_MemFree_bytes&#123;kubernetes_io_hostname=~&quot;$node&quot;&#125;) + sum(node_memory_Cached_bytes&#123;kubernetes_io_hostname=~&quot;$node&quot;&#125;) + sum(node_memory_Buffers_bytes&#123;kubernetes_io_hostname=~&quot;$node&quot;&#125;)) / sum(node_memory_MemTotal_bytes&#123;kubernetes_io_hostname=~&quot;$node&quot;&#125;) * 100</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Disk"><a href="#Disk" class="headerlink" title="Disk"></a>Disk</h2><h3 id="Grafana-中获取所有-node-的-Disk-使用率"><a href="#Grafana-中获取所有-node-的-Disk-使用率" class="headerlink" title="Grafana 中获取所有 node 的 Disk 使用率"></a>Grafana 中获取所有 node 的 Disk 使用率</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">100 - (sum(node_filesystem_avail_bytes&#123;kubernetes_io_hostname=~&quot;$node&quot;&#125;) / sum(node_filesystem_size_bytes&#123;kubernetes_io_hostname=~&quot;$node&quot;&#125;)) * 100</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h2><p>统计节点<strong>物理网卡</strong>的流入流出流量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">irate(node_network_receive_bytes_total&#123;device!~&quot;cni0|docker.*|flannel.*|veth.*|virbr.*|lo&quot;,kubernetes_io_hostname=~&quot;$node&quot;&#125;[$prometheusTimeInterval])</span><br><span class="line"></span><br><span class="line">irate(node_network_transmit_bytes_total&#123;device!~&quot;cni0|docker.*|flannel.*|veth.*|virbr.*|lo&quot;,kubernetes_io_hostname=~&quot;$node&quot;&#125;[$prometheusTimeInterval])</span><br></pre></td></tr></table></figure>

<h2 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h2><h3 id="计算集群中可以使用的-Pod-的数量"><a href="#计算集群中可以使用的-Pod-的数量" class="headerlink" title="计算集群中可以使用的 Pod 的数量"></a>计算集群中可以使用的 Pod 的数量</h3><p><a href="https://csms.tech/202306061427/#Kubernetes-相关指标">相关指标参考说明</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">100 - sum(kubelet_running_pods&#123;kubernetes_io_hostname=~&quot;$node&quot;&#125;) / sum(kube_node_status_capacity&#123;resource=&quot;pods&quot;,node=~&quot;$node&quot;&#125;) * 100</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="按照-namespace-及-Pod-统计-Pod-CPU-使用率"><a href="#按照-namespace-及-Pod-统计-Pod-CPU-使用率" class="headerlink" title="按照 namespace 及 Pod 统计 Pod CPU 使用率"></a>按照 namespace 及 Pod 统计 Pod CPU 使用率</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sum(rate(container_cpu_usage_seconds_total[1m])) by (namespace, pod)</span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_174.png"></p>
<h3 id="统计-Pod-使用的内存"><a href="#统计-Pod-使用的内存" class="headerlink" title="统计 Pod 使用的内存"></a>统计 Pod 使用的内存</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">container_memory_usage_bytes</span><br></pre></td></tr></table></figure>

<h3 id="统计-Pods-的流量"><a href="#统计-Pods-的流量" class="headerlink" title="统计 Pods 的流量"></a>统计 Pods 的流量</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">irate(container_network_receive_bytes_total&#123;namespace=~&quot;$k8sNamespace&quot;,interface=&quot;eth0&quot;,kubernetes_io_hostname=~&quot;$node&quot;&#125;[$prometheusTimeInterval])</span><br></pre></td></tr></table></figure>

<h3 id="统计-Pods-的重启次数"><a href="#统计-Pods-的重启次数" class="headerlink" title="统计 Pods 的重启次数"></a>统计 Pods 的重启次数</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sum(kube_pod_container_status_restarts_total&#123;namespace=~&quot;$k8sNamespace&quot;&#125;) by (namespace,container)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title>Prometheus 指标汇总</title>
    <url>/202306061427/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Prometheus 2.44.0</li>
<li>Grafana 9.5.2</li>
<li>Kubernetes 1.24</li>
</ul>
<h1 id="Kubernetes-相关指标"><a href="#Kubernetes-相关指标" class="headerlink" title="Kubernetes 相关指标"></a>Kubernetes 相关指标</h1><a href="/202212141608/" title="Kubernetes 中部署并监控 Kubernetes 集群参考">Kubernetes 中部署并监控 Kubernetes 集群参考</a>。

<p><a href="https://csms.tech/202212141608/#配置-Prometheus-自动发现-kubelet-并读取监控指标">配置 Prometheus 监控 Kubelet</a> 之后可以采集到 Kubelet 监控指标。</p>
<p><a href="https://csms.tech/202212141608/#配置-Prometheus-从-cAdvisor-读取监控数据">配置 Prometheus 读取 cAdvisor</a> 之后可以通过 cAdvisor 采集到容器相关的监控指标。</p>
<table>
<thead>
<tr>
<th>指标名称</th>
<th>类型</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>kubelet_pod_start_duration_seconds_count</code></td>
<td></td>
<td>Pod 启动的时间</td>
<td></td>
</tr>
<tr>
<td><code>kubelet_pod_start_duration_seconds_bucket</code></td>
<td></td>
<td>Pod 启动的时间的延迟直方图数据</td>
<td><code>kubelet_pod_start_duration_seconds_bucket&#123;le=&quot;0.5&quot;&#125;</code></td>
</tr>
<tr>
<td><code>kubelet_running_pods</code></td>
<td></td>
<td>运行的 Pod 的数量</td>
<td></td>
</tr>
<tr>
<td><code>kubelet_running_containers</code></td>
<td></td>
<td>运行的 Containers 的数量</td>
<td></td>
</tr>
<tr>
<td><code>kubelet_runtime_operations_errors_total</code></td>
<td></td>
<td>Kubelet 和 CRI 交互产生的错误（类型）</td>
<td></td>
</tr>
<tr>
<td><code>kubelet_started_containers_total</code></td>
<td></td>
<td>Kubelet 启动的 Container 总数</td>
<td></td>
</tr>
<tr>
<td><code>kubelet_started_pods_total</code></td>
<td></td>
<td>Kubelet 启动的 Pod 总数</td>
<td></td>
</tr>
<tr>
<td><code>kubelet_volume_stats_available_bytes</code></td>
<td></td>
<td>PV Volume 可以使用的磁盘空间</td>
<td></td>
</tr>
<tr>
<td><code>kube_node_status_allocatable</code><br/><code>kube_node_status_capacity</code></td>
<td></td>
<td>节点的可分配的 <strong>资源</strong> 数量</td>
<td><code>kube_node_status_allocatable&#123;resource=&quot;pods&quot;&#125;</code><br/>节点可分配的 Pod 的数量</td>
</tr>
<tr>
<td><code>kubelet_started_pods_total</code></td>
<td><code>Counter</code></td>
<td>已启动的 Pod 数量</td>
<td></td>
</tr>
<tr>
<td><code>container_cpu_usage_seconds_total</code></td>
<td><code>Counter</code></td>
<td>Container 使用的 CPU</td>
<td></td>
</tr>
<tr>
<td><code>container_memory_usage_bytes</code></td>
<td><code>Gauge</code></td>
<td>Pod 使用的内存</td>
<td><code>container_memory_usage_bytes&#123;namespace=&quot;default&quot;&#125;</code></td>
</tr>
<tr>
<td><code>kube_pod_container_status_restarts_total</code></td>
<td><code>Counter</code></td>
<td>Pod 的重启次数</td>
<td></td>
</tr>
</tbody></table>
<h1 id="node-相关指标"><a href="#node-相关指标" class="headerlink" title="node 相关指标"></a>node 相关指标</h1><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><table>
<thead>
<tr>
<th>指标名称</th>
<th>类型</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>node_cpu_seconds_total</code></td>
<td><code>Counter</code></td>
<td>CPU 使用时间</td>
<td><code>node_cpu_seconds_total&#123;mode=&quot;idle&quot;&#125;</code> - CPU 空闲时间</td>
</tr>
</tbody></table>
<h3 id="统计节点-CPU-使用率"><a href="#统计节点-CPU-使用率" class="headerlink" title="统计节点 CPU 使用率"></a>统计节点 CPU 使用率</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">100 - (avg by (instance) (irate(node_cpu_seconds_total&#123;mode=&quot;idle&quot;&#125;[5m])) * 100)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><table>
<thead>
<tr>
<th>指标名称</th>
<th>类型</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>node_memory_MemTotal_bytes</code></td>
<td><code>Gauge</code></td>
<td>总的内存</td>
<td></td>
</tr>
<tr>
<td><code>node_memory_MemFree_bytes</code></td>
<td><code>Gauge</code></td>
<td>空闲内存</td>
<td></td>
</tr>
<tr>
<td><code>node_memory_Cached_bytes</code></td>
<td><code>Gauge</code></td>
<td>Cache 内存</td>
<td></td>
</tr>
<tr>
<td><code>node_memory_Buffers_bytes</code></td>
<td><code>Gauge</code></td>
<td>Buffers 内存</td>
<td></td>
</tr>
</tbody></table>
<h3 id="统计节点的-内存使用率"><a href="#统计节点的-内存使用率" class="headerlink" title="统计节点的 内存使用率"></a>统计节点的 内存使用率</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(node_memory_MemTotal_bytes - node_memory_MemFree_bytes - node_memory_Cached_bytes - node_memory_Buffers_bytes) / node_memory_MemTotal_bytes * 100</span><br></pre></td></tr></table></figure>

<h2 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h2><table>
<thead>
<tr>
<th>指标名称</th>
<th>类型</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>node_network_receive_bytes_total</code></td>
<td><code>Counter</code></td>
<td>网卡<strong>接收</strong>的流量</td>
<td></td>
</tr>
<tr>
<td><code>node_network_transmit_bytes_total</code></td>
<td><code>Counter</code></td>
<td>网卡<strong>发送</strong>的流量</td>
<td></td>
</tr>
</tbody></table>
<h3 id="网卡流量带宽"><a href="#网卡流量带宽" class="headerlink" title="网卡流量带宽"></a>网卡流量带宽</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">irate(node_network_receive_bytes_total&#123;device!~&quot;cni0|docker.*|flannel.*|veth.*|virbr.*|lo&quot;,kubernetes_io_hostname=~&quot;$node&quot;&#125;[$prometheusTimeInterval])</span><br><span class="line"></span><br><span class="line">irate(node_network_transmit_bytes_total&#123;device!~&quot;cni0|docker.*|flannel.*|veth.*|virbr.*|lo&quot;,kubernetes_io_hostname=~&quot;$node&quot;&#125;[$prometheusTimeInterval])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Prometheus</category>
      </categories>
      <tags>
        <tag>Prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>Pycharm 常用配置</title>
    <url>/202208041319/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>PyCharm 2022.1 (Professional Edition)</li>
</ul>
<h1 id="常见配置"><a href="#常见配置" class="headerlink" title="常见配置"></a>常见配置</h1><h2 id="快速插入时间"><a href="#快速插入时间" class="headerlink" title="快速插入时间"></a>快速插入时间</h2><p>通过配置 <code>Live Template</code> 实现快速插入时间  </p>
<ol>
<li><p>打开 File &gt; Setting &gt; Editor: Live Templates</p>
</li>
<li><p>选中常用的语言，比如 <code>Python</code>，点击右上角的 <code>+</code>，添加 <code>Live Template</code><br> <code>Abbreviation</code> 输入快捷输入的名称，比如 <code>currentTime</code><br> <code>Description</code> 输入描述信息<br> <code>Template Text</code> 输入 <code>$time$</code><br> <img src="https://i.csms.tech/img_32.png"></p>
</li>
<li><p>点击 <code>Edit Variables</code> 配置命令及格式<br> <img src="https://i.csms.tech/img_33.png"></p>
</li>
<li><p><code>Define</code> 选择 <code>Everywhere</code>，<code>Apply</code>让配置生效</p>
</li>
<li><p>编辑时输入 <code>currentTime</code>,可以直接插入当前时间<br> <img src="https://i.csms.tech/img_34.png"></p>
</li>
</ol>
<h2 id="配置-git-仓库"><a href="#配置-git-仓库" class="headerlink" title="配置 git 仓库"></a>配置 git 仓库</h2><ol>
<li><p>打开 <code>File</code> -&gt; <code>Settings</code> -&gt; <code>Version Control</code> -&gt; <code>Git</code>，在 <code>Path to Git executable</code> 处选择 git 的安装位置。配置完成之后，点击<code>【Test】</code>按钮，如果成功，则会显示 Git 版本信息<br><img src="https://i.csms.tech/img_114.png"></p>
</li>
<li><p>点击 <code>VCS</code> -&gt; <code>Get from Version Control</code>，输入 Git 仓库的地址和本地目录。<br><img src="https://i.csms.tech/img_115.png"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>PyCharm</category>
      </categories>
      <tags>
        <tag>PyCharm</tag>
      </tags>
  </entry>
  <entry>
    <title>python 操作日期及时间</title>
    <url>/202301231137/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Python 3.10</li>
</ul>
<h1 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h1><h2 id="获取前一天所属月份"><a href="#获取前一天所属月份" class="headerlink" title="获取前一天所属月份"></a>获取前一天所属月份</h2><h3 id="arrow-模块获取"><a href="#arrow-模块获取" class="headerlink" title="arrow 模块获取"></a>arrow 模块获取</h3><p>以下示例使用 <code>arrow</code> 模块获取前一天所属月份 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[时间日期相关操作](https://developer.aliyun.com/article/673245)">[1]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install arrow</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; a = arrow.now() <span class="comment"># 当前本地时间</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; a.shift(months=-1).format(<span class="string">&quot;YYYYMM&quot;</span>)</span></span><br><span class="line">&#x27;202212&#x27;</span><br></pre></td></tr></table></figure>

<p>指定参数 <code>months = -1</code> 就可以计算前一个月的时间。往后一个月就是 <code>month=+1</code>，<code>format</code> 指定时间格式。</p>
<h2 id="获取前一个月的天数"><a href="#获取前一个月的天数" class="headerlink" title="获取前一个月的天数"></a>获取前一个月的天数</h2><p>通过模块 <code>calendar</code> 获取 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import calendar</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取 2022-1 月份的天数，输出 tuple ，由此月的第一天是星期几和此月的天数构成。</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; calendar.monthrange(2022,1)</span></span><br><span class="line">(5, 31)</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="时间转换为时间戳"><a href="#时间转换为时间戳" class="headerlink" title="时间转换为时间戳"></a>时间转换为时间戳</h2><h3 id="time-模块"><a href="#time-模块" class="headerlink" title="time 模块"></a>time 模块</h3><p>使用 <code>time</code> 模块将指定格式的时间，转为时间戳</p>
<figure class="highlight shell"><figcaption><span>python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import time</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; t = <span class="string">&quot;2022-12-01 00:00:00&quot;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 使用 time.strptime 将指定的时间 t 转换为时间数组</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; timeArray = time.strptime(t, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; timeArray</span></span><br><span class="line">time.struct_time(tm_year=2022, tm_mon=12, tm_mday=1, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=3, tm_yday=335, tm_isdst=-1)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; timestamp = time.mktime(timeArray)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; timestamp</span></span><br><span class="line">1669852800.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="datetime-模块使用"><a href="#datetime-模块使用" class="headerlink" title="datetime 模块使用"></a>datetime 模块使用</h1><h2 id="获取日期和时间"><a href="#获取日期和时间" class="headerlink" title="获取日期和时间"></a>获取日期和时间</h2><h3 id="获取今天的日期"><a href="#获取今天的日期" class="headerlink" title="获取今天的日期"></a>获取今天的日期</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">help</span>(datetime)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>datetime.date.today()</span><br><span class="line">datetime.date(<span class="number">2023</span>, <span class="number">2</span>, <span class="number">28</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>datetime.date.today().year</span><br><span class="line"><span class="number">2023</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>datetime.date.today().day</span><br><span class="line"><span class="number">28</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="获取当前的日期和时间"><a href="#获取当前的日期和时间" class="headerlink" title="获取当前的日期和时间"></a>获取当前的日期和时间</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>datetime.datetime.now(tz=datetime.timezone.utc)</span><br><span class="line">datetime.datetime(<span class="number">2023</span>, <span class="number">2</span>, <span class="number">28</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">48</span>, <span class="number">996356</span>, tzinfo=datetime.timezone.utc)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="获取明天的日期"><a href="#获取明天的日期" class="headerlink" title="获取明天的日期"></a>获取明天的日期</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">help</span>(datetime.timedelta)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>datetime.date.today() + datetime.timedelta(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="比较时间"><a href="#比较时间" class="headerlink" title="比较时间"></a>比较时间</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>expire</span><br><span class="line">datetime.datetime(<span class="number">2023</span>, <span class="number">12</span>, <span class="number">23</span>, <span class="number">6</span>, <span class="number">26</span>, <span class="number">2</span>, tzinfo=datetime.timezone.utc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 日期比较</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>expire.date() &gt; datetime.date.today()</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 日期和时间比较，tz=datetime.timezone.utc 可以解决时区不同的问题： TypeError: can&#x27;t compare offset-naive and offset-aware datetimes</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>expire &gt; datetime.datetime.now(tz=datetime.timezone.utc)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://developer.aliyun.com/article/673245">时间日期相关操作</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python dict 使用</title>
    <url>/202301101011/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Python3.10</li>
</ul>
<h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><h2 id="删除-key"><a href="#删除-key" class="headerlink" title="删除 key"></a>删除 key</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scores = &#123;&#x27;语文&#x27;: 89&#125;</span><br><span class="line">scores[&#x27;数学&#x27;] = 93</span><br><span class="line">scores[92] = 5.7</span><br><span class="line"></span><br><span class="line">del scores[&#x27;语文&#x27;]</span><br><span class="line">del scores[&#x27;数学&#x27;]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除指定的 key，并返回 key 对应的值；如果 key 不存在，返回异常：KeyError，可查看 <span class="built_in">help</span>(dict)</span></span><br><span class="line">scores.pop(92)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除最后一个 key-value，并以元组的形式返回 (key, value)</span></span><br><span class="line">scores.popitem()</span><br></pre></td></tr></table></figure>

<h2 id="清空-dict"><a href="#清空-dict" class="headerlink" title="清空 dict"></a>清空 dict</h2><p><code>clear()</code> 用于清空字典中所有的 key-value 对，对一个字典执行 clear() 方法之后，该字典就会变成一个空字典</p>
<h2 id="更新-dict"><a href="#更新-dict" class="headerlink" title="更新 dict"></a>更新 dict</h2><p><code>update()</code> 方法可使用一个字典所包含的 key-value 对来更新己有的字典。在执行 <code>update()</code> 方法时，如果被更新的字典中己包含对应的 key-value 对，那么原 value 会被覆盖；如果被更新的字典中不包含对应的 key-value 对，则该 key-value 对被添加进去；原来的 <code>dict</code> 中存在（更新中不存在）的 key-value 保持不变。</p>
<span id="more"></span>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python 中 json 格式</title>
    <url>/202301201605/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Python3.10</li>
</ul>
<p>Python 中操作 json 相关格式，主要使用模块 <code>json</code></p>
<h1 id="Python-数据类型转换为-json-格式"><a href="#Python-数据类型转换为-json-格式" class="headerlink" title="Python 数据类型转换为 json 格式"></a>Python 数据类型转换为 json 格式</h1><p>python 数据类型转换为 json ，主要使用方法 <code>dumps()</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; adict = &#123;<span class="string">&#x27;a&#x27;</span>: 1, <span class="string">&#x27;b&#x27;</span>: <span class="string">&#x27;st&#x27;</span>&#125;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; json.dumps(adict)</span></span><br><span class="line">&#x27;&#123;&quot;a&quot;: 1, &quot;b&quot;: &quot;st&quot;&#125;&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; alist = [1,2,3,4]</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; json.dumps(alist)</span></span><br><span class="line">&#x27;[1, 2, 3, 4]&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="json-格式转换为-Python-数据类型"><a href="#json-格式转换为-Python-数据类型" class="headerlink" title="json 格式转换为 Python 数据类型"></a>json 格式转换为 Python 数据类型</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; ajson = <span class="string">&#x27;[1, 2, 3, 4]&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">type</span>(ajson)</span></span><br><span class="line">&lt;class &#x27;str&#x27;&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; json.load(ajson)</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;console&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;/usr/local/lib/python3.10/json/__init__.py&quot;, line 293, in load</span><br><span class="line">    return loads(fp.read(),</span><br><span class="line">AttributeError: &#x27;str&#x27; object has no attribute &#x27;read&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; json.loads(ajson)</span></span><br><span class="line">[1, 2, 3, 4]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; bjson = <span class="string">&#x27;&#123;&quot;a&quot;: 1, &quot;b&quot;: &quot;st&quot;&#125;&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">type</span>(bjson)</span></span><br><span class="line">&lt;class &#x27;str&#x27;&gt;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; json.loads(bjson)</span></span><br><span class="line">&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: &#x27;st&#x27;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<span id="more"></span>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python 代码性能分析工具</title>
    <url>/202301261101/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>python 3.10</li>
</ul>
<h1 id="pyinstrument-使用"><a href="#pyinstrument-使用" class="headerlink" title="pyinstrument 使用"></a>pyinstrument 使用</h1><p><code>pyinstrument</code> 可以快速找到代码运行最慢的部分，帮助提高代码的性能。支持 Python 3.7+ 且能够分析异步代码，仅需一条命令即可显示具体代码的耗时 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[如何快速定位 Python 运行最慢的代码](https://jishuin.proginn.com/p/763bfbd66eae)">[1]</span></a></sup></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install pyinstrument</span><br></pre></td></tr></table></figure>

<h2 id="命令行使用"><a href="#命令行使用" class="headerlink" title="命令行使用"></a>命令行使用</h2><p>在无需更改代码的情况下，直接通过命令行使用 <code>pyinstrument</code> 分析目标代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pyinstrument main.py</span></span><br></pre></td></tr></table></figure>

<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://jishuin.proginn.com/p/763bfbd66eae">如何快速定位 Python 运行最慢的代码</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python3 requests 库使用</title>
    <url>/202302011011/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>python3.10</li>
</ul>
<h1 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h1><p>基础用法可以查看系统帮助信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">help</span>(requests)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>requests</code> 发送请求时，会自动创建 <code>requests.Request</code>，因此发送请求时如果需要发送更多数据，可以查看 <code>Request</code> 类的帮助信息，或者查看 <code>requests.models</code> 获取更多帮助信息，如 <code>headers</code>，<code>files</code> 等</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">help</span>(requests.Request)</span></span><br></pre></td></tr></table></figure>
<p>例如发送请求时需要添加头部信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; headers = &#123;<span class="string">&#x27;Authorization&#x27;</span>: token, <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Python&#x27;</span>&#125;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; r = requests.get(<span class="string">&#x27;https://api.cdn77.com/v3/cdn&#x27;</span>, headers=headers)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; r.text</span></span><br></pre></td></tr></table></figure>

<p><code>Request</code> 请求的响应是 ‘requests.models.Response’ 对象的实例。获取 <code>Response</code> 帮助，可以查看以下内容 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">help</span>(requests.models.Response)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">help</span>(requests.Response)</span></span><br></pre></td></tr></table></figure>

<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python requests 使用</title>
    <url>/202303071126/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Python 3.11.2</li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install requests</span><br></pre></td></tr></table></figure>

<h1 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h1><h2 id="get-请求"><a href="#get-请求" class="headerlink" title="get 请求"></a>get 请求</h2><p><code>get</code> 请求及响应中常用的属性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(<span class="string">&#x27;https://csms.tech&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>(r)</span><br><span class="line">[..., <span class="string">&#x27;content&#x27;</span>, <span class="string">&#x27;cookies&#x27;</span>, <span class="string">&#x27;elapsed&#x27;</span>, <span class="string">&#x27;encoding&#x27;</span>, <span class="string">&#x27;headers&#x27;</span>, <span class="string">&#x27;history&#x27;</span>, </span><br><span class="line"><span class="string">&#x27;is_permanent_redirect&#x27;</span>, <span class="string">&#x27;is_redirect&#x27;</span>, <span class="string">&#x27;iter_content&#x27;</span>, <span class="string">&#x27;iter_lines&#x27;</span>, </span><br><span class="line"><span class="string">&#x27;json&#x27;</span>, <span class="string">&#x27;links&#x27;</span>, <span class="string">&#x27;next&#x27;</span>, <span class="string">&#x27;ok&#x27;</span>, <span class="string">&#x27;raise_for_status&#x27;</span>, <span class="string">&#x27;raw&#x27;</span>, <span class="string">&#x27;reason&#x27;</span>, </span><br><span class="line"><span class="string">&#x27;request&#x27;</span>, <span class="string">&#x27;status_code&#x27;</span>, <span class="string">&#x27;text&#x27;</span>, <span class="string">&#x27;url&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h3 id="带参数的-get-请求"><a href="#带参数的-get-请求" class="headerlink" title="带参数的 get 请求"></a>带参数的 get 请求</h3><p>要在 <code>get</code> 请求中携带请求参数，可以使用以下方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">help</span>(requests.get)</span><br><span class="line">get(url, params=<span class="literal">None</span>, **kwargs)</span><br><span class="line">    Sends a GET request.</span><br><span class="line">    </span><br><span class="line">    :param url: URL <span class="keyword">for</span> the new :<span class="keyword">class</span>:`Request` <span class="built_in">object</span>.</span><br><span class="line">    :param params: (optional) Dictionary, <span class="built_in">list</span> of tuples <span class="keyword">or</span> <span class="built_in">bytes</span> to send</span><br><span class="line">        <span class="keyword">in</span> the query string <span class="keyword">for</span> the :<span class="keyword">class</span>:`Request`.</span><br><span class="line">    :param \*\*kwargs: <span class="type">Optional</span> arguments that ``request`` takes.</span><br><span class="line">    :<span class="keyword">return</span>: :<span class="keyword">class</span>:`Response &lt;Response&gt;` <span class="built_in">object</span></span><br><span class="line">    :rtype: requests.Response</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>params = &#123;<span class="string">&#x27;k1&#x27;</span>: <span class="string">&#x27;v1&#x27;</span>, <span class="string">&#x27;k2&#x27;</span>: <span class="string">&#x27;v2&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(<span class="string">&#x27;https://csms.tech&#x27;</span>, params=params)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置请求头</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>headers = &#123;<span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36&quot;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>response = requests.get(<span class="string">&quot;https://csms.tech&quot;</span>, params = params, headers = headers)</span><br></pre></td></tr></table></figure>
<p><code>get</code> 方法本质上是通过创建了一个 <code>requests.Request</code> 对象，因此 <code>**kwargs</code> 可用的值可以通过查看 <code>requests.Request</code> 的帮助信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">help</span>(requests.Request)</span><br></pre></td></tr></table></figure>


<h2 id="post-请求"><a href="#post-请求" class="headerlink" title="post 请求"></a>post 请求</h2><p><code>post</code> 方法可以发送 <code>POST</code> 请求到指定 url，一般格式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">requests.post(url, data=&#123;key: value&#125;, json=&#123;key: value&#125;, args)</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>url</code> - 请求 url。</p>
</li>
<li><p><code>data</code> - 参数为要发送到指定 url 的字典、元组列表、字节或文件对象。</p>
</li>
<li><p><code>json</code> - 参数为要发送到指定 url 的 JSON 对象。</p>
</li>
<li><p><code>args</code> -  为其他参数，比如 cookies、headers、verify等。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python requirements 的创建及使用</title>
    <url>/202208161710/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Python 3.10</li>
</ul>
<p><code>python</code> 项目中最好包含一个 <code>requirements.txt</code> 文件，用于记录所有依赖包及其精确的版本号。以便新环境部署。</p>
<span id="more"></span>

<h3 id="requirements-生成和使用"><a href="#requirements-生成和使用" class="headerlink" title="requirements 生成和使用"></a>requirements 生成和使用</h3><p>在项目中安装新的包之后，可以运行以下命令更新 <code>requirements</code> 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure>
<p><code>requirements.txt</code> 文件内容示例：</p>
<figure class="highlight shell"><figcaption><span>requirements.txt</span></figcaption><table><tr><td class="code"><pre><span class="line">asgiref==3.5.2</span><br><span class="line">Django==4.0</span><br><span class="line">django-mdeditor==0.1.20</span><br><span class="line">Markdown==3.3.7</span><br><span class="line">Pillow==9.2.0</span><br><span class="line">Pygments==2.12.0</span><br><span class="line">PyMySQL==1.0.2</span><br><span class="line">sqlparse==0.4.2</span><br><span class="line">uWSGI==2.0.20</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>生成的文件中会包含项目需要的所有包以及精确的版本号信息，新环境部署时，可使用以下命令安装依赖包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python 执行 shell 命令</title>
    <url>/202301201542/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Python3.10</li>
</ul>
<h1 id="Python-执行-shell-命令"><a href="#Python-执行-shell-命令" class="headerlink" title="Python 执行 shell 命令"></a>Python 执行 shell 命令</h1><h2 id="subprocess-模块"><a href="#subprocess-模块" class="headerlink" title="subprocess 模块"></a>subprocess 模块</h2><p><code>subprocess.check_output()</code> 执行一个外部命令并以Python字符串的形式获取执行结果 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[执行外部命令并获取它的输出](https://python3-cookbook-personal.readthedocs.io/zh_CN/latest/c13/p06_executing_external_command_and_get_its_output.html#id1)">[1]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">import subprocess</span><br><span class="line">out_bytes = subprocess.check_output([&#x27;netstat&#x27;,&#x27;-a&#x27;])</span><br></pre></td></tr></table></figure>
<p>如果你需要文本形式返回，加一个解码步骤即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">out_text = out_bytes.decode(&#x27;utf-8&#x27;)</span><br></pre></td></tr></table></figure>
<p>如果被执行的命令以非零码返回，就会抛出异常。 下面的例子捕获到错误并获取返回码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    out_bytes = subprocess.check_output([&#x27;cmd&#x27;,&#x27;arg1&#x27;,&#x27;arg2&#x27;])</span><br><span class="line">except subprocess.CalledProcessError as e:</span><br><span class="line">    out_bytes = e.output       # Output generated before error</span><br><span class="line">    code      = e.returncode   # Return code</span><br></pre></td></tr></table></figure>

<p>默认情况下，<code>check_output()</code> 仅仅返回输入到标准输出的值。 如果你需要同时收集标准输出和错误输出，使用 <code>stderr</code> 参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">out_bytes = subprocess.check_output([&#x27;cmd&#x27;,&#x27;arg1&#x27;,&#x27;arg2&#x27;],</span><br><span class="line">                                    stderr=subprocess.STDOUT)</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://python3-cookbook-personal.readthedocs.io/zh_CN/latest/c13/p06_executing_external_command_and_get_its_output.html#id1">执行外部命令并获取它的输出</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python 用法小结及常见错误</title>
    <url>/202302271543/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Python3</li>
</ul>
<h1 id="字符串转换为变量名"><a href="#字符串转换为变量名" class="headerlink" title="字符串转换为变量名"></a>字符串转换为变量名</h1><h2 id="locals-方法"><a href="#locals-方法" class="headerlink" title="locals() 方法"></a>locals() 方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>str1 = <span class="number">666</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">&#x27;str1&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">locals</span>()[a]</span><br><span class="line"><span class="number">666</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="vars-方法"><a href="#vars-方法" class="headerlink" title="vars() 方法"></a>vars() 方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str1 = <span class="number">666</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">&#x27;str1&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">vars</span>()[a]</span><br><span class="line"><span class="number">666</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="eval-方法"><a href="#eval-方法" class="headerlink" title="eval() 方法"></a>eval() 方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>str1 = <span class="number">666</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">&#x27;str1&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(a)</span><br><span class="line"><span class="number">666</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><h2 id="NameError-name-‘null‘-is-not-defined"><a href="#NameError-name-‘null‘-is-not-defined" class="headerlink" title="NameError: name ‘null‘ is not defined"></a>NameError: name ‘null‘ is not defined</h2><p>使用 <code>eval</code> 将 <code>string</code> 转化成 <code>dict</code> 时出错，经过排查，发现 <code>string</code> 数据中包含 <code>null</code>,在转换时就会报错: <code>NameError: name ‘null‘ is not defined</code></p>
<p><strong>解决方法</strong></p>
<p>使用 <code>json</code> 进行转换</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    response_dict = eval(response)</span><br><span class="line">except NameError:</span><br><span class="line">    response_dict = json.loads(str(response.decode()))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>向 Telegram 发送消息</title>
    <url>/202306011739/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos 7</li>
<li>Python 3</li>
</ul>
<h1 id="在-Telegram-中生成-Bot"><a href="#在-Telegram-中生成-Bot" class="headerlink" title="在 Telegram 中生成 Bot"></a>在 Telegram 中生成 Bot</h1><ol>
<li><p>首先在 telegram 中添加 <code>@BotFather</code>，根据提示创建 <strong>机器人</strong>，记录下生成的 <code>token</code> 信息<br><img src="https://i.csms.tech/img_164.png"><br><img src="https://i.csms.tech/img_165.png"></p>
</li>
<li><p>创建新的 Channel 或者 Group 或者将新建的 Bot 加入已有的 Channel&#x2F;Group。</p>
</li>
<li><p>获取 ChatGroup ID，可以使用以下方法之一</p>
<ol>
<li><p>添加机器人 <code>@get_id_bot</code> 到 Channel，会自动显示 <code>Chat ID</code><br><img src="https://i.csms.tech/img_167.png"></p>
</li>
<li><p>使用以下代码获取</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import requests</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; response = requests.get(f<span class="string">&#x27;https://api.telegram.org/bot&#123;token&#125;/getUpdates&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; data = response.json()</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; chat_id = data[<span class="string">&#x27;result&#x27;</span>][0][<span class="string">&#x27;message&#x27;</span>][<span class="string">&#x27;chat&#x27;</span>][<span class="string">&#x27;id&#x27;</span>]</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; chat_id</span></span><br><span class="line">-992754669</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h1 id="使用-curl-向-telegram-发送消息"><a href="#使用-curl-向-telegram-发送消息" class="headerlink" title="使用 curl 向 telegram 发送消息"></a>使用 curl 向 telegram 发送消息</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -v <span class="string">&quot;https://api.telegram.org/bot&#123;token&#125;/sendMessage?text=sa&amp;chat_id=-992754669&quot;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">GET /bot&#123;token&#125;/sendMessage?text=sa&amp;chat_id=-992754669 HTTP/1.1</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">User-Agent: curl/7.29.0</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Host: api.telegram.org</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Accept: */*</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">&lt; HTTP/1.1 200 OK</span></span><br><span class="line">&lt; Server: nginx/1.18.0</span><br><span class="line">&lt; Date: Fri, 02 Jun 2023 03:03:58 GMT</span><br><span class="line">&lt; Content-Type: application/json</span><br><span class="line">&lt; Content-Length: 276</span><br><span class="line">&lt; Connection: keep-alive</span><br><span class="line">&lt; Strict-Transport-Security: max-age=31536000; includeSubDomains; preload</span><br><span class="line">&lt; Access-Control-Allow-Origin: *</span><br><span class="line">&lt; Access-Control-Allow-Methods: GET, POST, OPTIONS</span><br><span class="line">&lt; Access-Control-Expose-Headers: Content-Length,Content-Type,Date,Server,Connection</span><br><span class="line">&lt; </span><br><span class="line">* Connection #0 to host api.telegram.org left intact</span><br><span class="line">&#123;&quot;ok&quot;:true,&quot;result&quot;:&#123;&quot;message_id&quot;:12,&quot;from&quot;:&#123;&quot;id&quot;:5683237521,&quot;is_bot&quot;:true,&quot;first_name&quot;:&quot;AlertManager&quot;,&quot;username&quot;:&quot;AlertManager_Bot&quot;&#125;,&quot;chat&quot;:&#123;&quot;id&quot;:-992754669,&quot;title&quot;:&quot;AlertManager Test&quot;,&quot;type&quot;:&quot;group&quot;,&quot;all_members_are_administrators&quot;:true&#125;,&quot;date&quot;:1685675038,&quot;text&quot;:&quot;sa&quot;&#125;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用-python-向-telegram-发送消息"><a href="#使用-python-向-telegram-发送消息" class="headerlink" title="使用 python 向 telegram 发送消息"></a>使用 python 向 telegram 发送消息</h1><h2 id="使用-requests-库"><a href="#使用-requests-库" class="headerlink" title="使用 requests 库"></a>使用 requests 库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import requests</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; response = requests.get(f<span class="string">&#x27;https://api.telegram.org/bot&#123;token&#125;/sendMessage?text=sa&amp;chat_id=-992754669&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; response.text</span></span><br><span class="line">&#x27;&#123;&quot;ok&quot;:true,&quot;result&quot;:&#123;&quot;message_id&quot;:13,&quot;from&quot;:&#123;&quot;id&quot;:5683237521,&quot;is_bot&quot;:true,&quot;first_name&quot;:&quot;AlertManager&quot;,&quot;username&quot;:&quot;AlertManager_Bot&quot;&#125;,&quot;chat&quot;:&#123;&quot;id&quot;:-992754669,&quot;title&quot;:&quot;AlertManager Test&quot;,&quot;type&quot;:&quot;group&quot;,&quot;all_members_are_administrators&quot;:true&#125;,&quot;date&quot;:1685675769,&quot;text&quot;:&quot;sa&quot;&#125;&#125;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用-telegram-库"><a href="#使用-telegram-库" class="headerlink" title="使用 telegram 库"></a>使用 telegram 库</h2><p>需要安装 <code>python-telegram-bot</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install --upgrade python-telegram-bot</span><br></pre></td></tr></table></figure>
<p>发送消息代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import telegram</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import asyncio</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; bot = telegram.Bot(token=<span class="string">&#x27;5683231111:AAHzaGf0oRg8A&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; async def send_telegram_message():</span></span><br><span class="line">...     response = await bot.send_message(chat_id=-992754669, text=&quot;la&quot;)</span><br><span class="line">...     print(response)</span><br><span class="line">... </span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; loop = asyncio.get_event_loop()</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; loop.run_until_complete(send_telegram_message())</span></span><br><span class="line">Message(channel_chat_created=False, chat=Chat(api_kwargs=&#123;&#x27;all_members_are_administrators&#x27;: True&#125;, id=-992754669, title=&#x27;AlertManager Test&#x27;, type=&lt;ChatType.GROUP&gt;), date=datetime.datetime(2023, 6, 2, 3, 39, 16, tzinfo=datetime.timezone.utc), delete_chat_photo=False, from_user=User(first_name=&#x27;AlertManager&#x27;, id=5683237521, is_bot=True, username=&#x27;MS_AlertManager_Bot&#x27;), group_chat_created=False, message_id=14, supergroup_chat_created=False, text=&#x27;la&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果需要在非异步环境中（例如 Django 试图函数） 运行以上异步代码，会报错： <code>RuntimeError: There is no current event loop in thread &#39;Thread-1&#39;</code>。需要特殊处理，可以使用 <code>asyncio.run()</code> 函数来运行异步代码，它可以在非异步环境中创建一个新的事件循环并运行异步函数。</p>
<p>Django 视图中参考代码如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">def send_message_to_tg(chat_id: int, text: str):</span><br><span class="line">    &#x27;&#x27;&#x27; 发送消息到 tg&#x27;&#x27;&#x27;</span><br><span class="line">    bot = telegram.Bot(token=tg_bot_token)</span><br><span class="line"></span><br><span class="line">    async def send_telegram_message():</span><br><span class="line">        response = await bot.send_message(chat_id=chat_id, text=text)</span><br><span class="line">        print(response)</span><br><span class="line">    # loop = asyncio.get_event_loop()</span><br><span class="line">    # loop.run_until_complete(send_telegram_message()) </span><br><span class="line">    asyncio.run(send_telegram_message())</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>python 虚拟环境</title>
    <url>/202208161730/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Python 3.10</li>
</ul>
<h3 id="虚拟环境创建步骤"><a href="#虚拟环境创建步骤" class="headerlink" title="虚拟环境创建步骤"></a>虚拟环境创建步骤</h3><p>假定项目名为 <code>project01</code>, 目录名为 <code>project01</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir project01</span><br><span class="line">cd project01</span><br><span class="line">python3 -m venv .</span><br></pre></td></tr></table></figure>
<p>以上命令会在目录 <code>project01</code> 中创建虚拟环境，查看当前目录，会产生以下目录和文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">bin  include  lib  lib64  pyvenv.cfg</span><br></pre></td></tr></table></figure>
<p>观察 <code>bin</code> 目录的内容，里面有 <code>python3</code>、<code>pip3</code> 等可执行文件，实际上是链接到 <code>Python</code> 系统目录的软链接。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l bin/</span></span><br><span class="line">total 36</span><br><span class="line">-rw-r--r-- 1 root root 1991 Aug 16 17:35 activate</span><br><span class="line">-rw-r--r-- 1 root root  917 Aug 16 17:35 activate.csh</span><br><span class="line">-rw-r--r-- 1 root root 2059 Aug 16 17:35 activate.fish</span><br><span class="line">-rw-r--r-- 1 root root 9033 Aug 16 17:35 Activate.ps1</span><br><span class="line">-rwxr-xr-x 1 root root  234 Aug 16 17:35 pip</span><br><span class="line">-rwxr-xr-x 1 root root  234 Aug 16 17:35 pip3</span><br><span class="line">-rwxr-xr-x 1 root root  234 Aug 16 17:35 pip3.10</span><br><span class="line">lrwxrwxrwx 1 root root   10 Aug 16 17:35 python -&gt; python3.10</span><br><span class="line">lrwxrwxrwx 1 root root   10 Aug 16 17:35 python3 -&gt; python3.10</span><br><span class="line">lrwxrwxrwx 1 root root   25 Aug 16 17:35 python3.10 -&gt; /usr/local/bin/python3.10</span><br></pre></td></tr></table></figure>

<p><code>Linux</code> 环境使用以下命令激活虚拟环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">source</span> bin/activate</span></span><br><span class="line">(project01) [root@localhost project01]#</span><br></pre></td></tr></table></figure>
<p>命令提示符变了，有个 <code>(project01)</code> 前缀，表示当前环境是一个名为 <code>project01</code> 的 Python 环境。<br>在此虚拟环境中安装包，都会被安装到 <code>(project01)</code> 环境下，具体目录为 <code>project01/lib/python3.10/site-packages/</code>，系统 Python 环境不受任何影响，也就是说，<code>project01</code> 这个环境是专门针对 <code>project01</code> 应用（项目）创建的，和系统 python 环境或其他应用互不影响。  </p>
<p>要退出当前虚拟环境，可以执行以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure>
<p>退出虚拟环境后，再执行如 <code>pip3 install</code> 命令安装的包，会安装到系统 Python 环境。<br>完全可以针对每个应用创建独立的Python运行环境，这样就可以对每个应用的Python环境进行隔离。</p>
<p>如果不再使用某个 <code>venv</code> ，例如 <code>project01</code>，删除它也很简单。首先确认该 <code>venv</code> 没有处于 <code>激活</code> 状态，然后直接把整个目录 <code>project01</code> 删掉就行。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>linux rabbitmq</title>
    <url>/202304261014/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos7 3.10.0-1160.45.1.el7</li>
<li>RabbitMQ 3.9.10</li>
</ul>
<h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><h2 id="RabbitMQ-启动失败"><a href="#RabbitMQ-启动失败" class="headerlink" title="RabbitMQ 启动失败"></a>RabbitMQ 启动失败</h2><p>使用命令启动，报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">/sbin/rabbitmq-server -v</span></span><br><span class="line">2023-04-26 10:02:47.621248+08:00 [noti] &lt;0.146.0&gt; Protocol &#x27;inet_tcp&#x27;: register/listen error: ehostunreach</span><br><span class="line">2023-04-26 10:02:47.621248+08:00 [noti] &lt;0.146.0&gt; </span><br><span class="line">2023-04-26 10:02:47.626643+08:00 [erro] &lt;0.143.0&gt;     supervisor: &#123;local,net_sup&#125;</span><br><span class="line">2023-04-26 10:02:47.626643+08:00 [erro] &lt;0.143.0&gt;     errorContext: start_error</span><br><span class="line">2023-04-26 10:02:47.626643+08:00 [erro] &lt;0.143.0&gt;     reason: &#123;&#x27;EXIT&#x27;,nodistribution&#125;</span><br><span class="line">2023-04-26 10:02:47.626643+08:00 [erro] &lt;0.143.0&gt;     offender: [&#123;pid,undefined&#125;,</span><br><span class="line">2023-04-26 10:02:47.626643+08:00 [erro] &lt;0.143.0&gt;                &#123;id,net_kernel&#125;,</span><br><span class="line">2023-04-26 10:02:47.626643+08:00 [erro] &lt;0.143.0&gt;                &#123;mfargs,&#123;net_kernel,start_link,</span><br><span class="line">2023-04-26 10:02:47.626643+08:00 [erro] &lt;0.143.0&gt;                                    [[rabbit_prelaunch_21812@localhost,</span><br><span class="line">2023-04-26 10:02:47.626643+08:00 [erro] &lt;0.143.0&gt;                                      shortnames],</span><br><span class="line">2023-04-26 10:02:47.626643+08:00 [erro] &lt;0.143.0&gt;                                     false,net_sup_dynamic]&#125;&#125;,</span><br><span class="line">2023-04-26 10:02:47.626643+08:00 [erro] &lt;0.143.0&gt;                &#123;restart_type,permanent&#125;,</span><br><span class="line">2023-04-26 10:02:47.626643+08:00 [erro] &lt;0.143.0&gt;                &#123;shutdown,2000&#125;,</span><br><span class="line">2023-04-26 10:02:47.626643+08:00 [erro] &lt;0.143.0&gt;                &#123;child_type,worker&#125;]</span><br></pre></td></tr></table></figure>

<p>关键错误信息 <code>Protocol &#39;inet_tcp&#39;: register/listen error: ehostunreach</code>，根据提示，可能是某个地址不可达，rabbitmq 启动时需要连接 epmd ，默认端口为 4369，在本地测试连接此端口，发现不通 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Protocol 'inet_tcp': register/listen error: econnrefused](https://stackoverflow.com/questions/51616600/ssh-rabbitmq-protocol-inet-tcp-register-listen-error-econnrefused)">[1]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -v 127.0.0.1:4369</span></span><br><span class="line">* About to connect() to 127.0.0.1 port 4369 (#0)</span><br><span class="line">*   Trying 127.0.0.1...</span><br><span class="line">* No route to host</span><br><span class="line">* Failed connect to 127.0.0.1:4369; No route to host</span><br><span class="line">* Closing connection 0</span><br><span class="line">curl: (7) Failed connect to 127.0.0.1:4369; No route to host</span><br></pre></td></tr></table></figure>
<p>根据输出的错误可知，是因为 <code>127.0.0.1</code> 无法连接，检查 iptables 防火墙策略，发现未允许回环网卡访问，在 iptables 中添加以下规则允许回环网卡访问</p>
<figure class="highlight shell"><figcaption><span>/etc/sysconfig/iptables</span></figcaption><table><tr><td class="code"><pre><span class="line">*filter</span><br><span class="line">:INPUT DROP [0:0]</span><br><span class="line">:FORWARD DROP [0:0]</span><br><span class="line">:OUTPUT ACCEPT [9020367577:7010759848370]</span><br><span class="line">-A INPUT -i lo -j ACCEPT</span><br></pre></td></tr></table></figure>
<p>允许回环网卡访问后，重新测试连接 epmd ，可以正常连接，重新启动 rabbitmq-server 正常。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -v 127.0.0.1:4369</span></span><br><span class="line">* About to connect() to 127.0.0.1 port 4369 (#0)</span><br><span class="line">*   Trying 127.0.0.1...</span><br><span class="line">* Connected to 127.0.0.1 (127.0.0.1) port 4369 (#0)</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">GET / HTTP/1.1</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">User-Agent: curl/7.29.0</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Host: 127.0.0.1:4369</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Accept: */*</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">* Empty reply from server</span></span><br><span class="line">* Connection #0 to host 127.0.0.1 left intact</span><br><span class="line">curl: (52) Empty reply from server</span><br></pre></td></tr></table></figure>

<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://stackoverflow.com/questions/51616600/ssh-rabbitmq-protocol-inet-tcp-register-listen-error-econnrefused">Protocol 'inet_tcp': register/listen error: econnrefused</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Rancher 安装及使用</title>
    <url>/202210071716/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>centos7 3.10.0</li>
<li>kubernetes Server Version: v1.21.2</li>
<li>Helm 3.10.0</li>
<li>Rancher 2.6</li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><a href="https://docs.ranchermanager.rancher.io/zh/pages-for-subheaders/install-upgrade-on-a-kubernetes-cluster">官方安装文档</a></p>
<h2 id="安装-Helm"><a href="#安装-Helm" class="headerlink" title="安装 Helm"></a>安装 Helm</h2><p><a href="https://helm.sh/docs/intro/install/">安装文档官网参考</a></p>
<a href="/202210071543/" title="helm 安装及使用">helm 安装及使用</a>

<h2 id="安装-Ingress-nginx-controller"><a href="#安装-Ingress-nginx-controller" class="headerlink" title="安装 Ingress-nginx-controller"></a>安装 Ingress-nginx-controller</h2><p><a href="https://kubernetes.github.io/ingress-nginx/deploy/#quick-start">安装文档官网参考</a></p>
<a href="/202209301604/" title="ingress-nginx 安装配置">ingress-nginx 安装配置</a>

<span id="more"></span>

<h2 id="添加-Helm-Chart-仓库"><a href="#添加-Helm-Chart-仓库" class="headerlink" title="添加 Helm Chart 仓库"></a>添加 Helm Chart 仓库</h2><p>添加最新版本，生产环境建议使用稳定版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">helm repo add rancher-latest https://releases.rancher.com/server-charts/latest</span><br></pre></td></tr></table></figure>

<h2 id="为-Rancher-创建命名空间"><a href="#为-Rancher-创建命名空间" class="headerlink" title="为 Rancher 创建命名空间"></a>为 Rancher 创建命名空间</h2><p>你需要定义一个 Kubernetes 命名空间，用于安装由 Chart 创建的资源。这个命名空间的名称为 <code>cattle-system</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create namespace cattle-system</span><br></pre></td></tr></table></figure>

<h2 id="安装-cert-manager"><a href="#安装-cert-manager" class="headerlink" title="安装 cert-manager"></a>安装 cert-manager</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.7.1/cert-manager.crds.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加 Jetstack Helm 仓库</span></span><br><span class="line">helm repo add jetstack https://charts.jetstack.io</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新本地 Helm Chart 仓库缓存</span></span><br><span class="line">helm repo update</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 cert-manager Helm Chart</span></span><br><span class="line">helm install cert-manager jetstack/cert-manager \</span><br><span class="line">  --namespace cert-manager \</span><br><span class="line">  --create-namespace \</span><br><span class="line">  --version v1.7.1</span><br></pre></td></tr></table></figure>
<p>安装完 <code>cert-manager</code> 后，你可以通过检查 <code>cert-manager</code> 命名空间中正在运行的 <code>Pod</code> 来验证它是否已正确部署：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods -n cert-manager</span></span><br><span class="line">NAME                                      READY   STATUS    RESTARTS   AGE</span><br><span class="line">cert-manager-5b97785fbd-vvscn             1/1     Running   0          77s</span><br><span class="line">cert-manager-cainjector-c8657d84f-6b8qr   1/1     Running   0          77s</span><br><span class="line">cert-manager-webhook-8564679744-hjgkx     1/1     Running   0          77s</span><br></pre></td></tr></table></figure>
<h2 id="通过-Helm-安装-Rancher"><a href="#通过-Helm-安装-Rancher" class="headerlink" title="通过 Helm 安装 Rancher"></a>通过 Helm 安装 Rancher</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">helm install rancher rancher-stable/rancher --namespace cattle-system \</span><br><span class="line">     --set hostname=rancher.my.com --set bootstrapPassword=admin \</span><br><span class="line">     --set ingress.ingressClassName=nginx</span><br></pre></td></tr></table></figure>
<p>安装成功后，输出结果如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NAME: rancher</span><br><span class="line">LAST DEPLOYED: Wed Oct 12 10:22:25 2022</span><br><span class="line">NAMESPACE: cattle-system</span><br><span class="line">STATUS: deployed</span><br><span class="line">REVISION: 1</span><br><span class="line">TEST SUITE: None</span><br><span class="line">NOTES:</span><br><span class="line">Rancher Server has been installed.</span><br><span class="line"></span><br><span class="line">NOTE: Rancher may take several minutes to fully initialize. Please standby while Certificates are being issued, Containers are started and the Ingress rule comes up.</span><br><span class="line"></span><br><span class="line">Check out our docs at https://rancher.com/docs/</span><br><span class="line"></span><br><span class="line">If you provided your own bootstrap password during installation, browse to https://rancher.my.com to get started.</span><br><span class="line"></span><br><span class="line">If this is the first time you installed Rancher, get started by running this command and clicking the URL it generates:</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">echo https://rancher.my.com/dashboard/?setup=$(kubectl get secret --namespace cattle-system bootstrap-secret -o go-template=&#x27;&#123;&#123;.data.bootstrapPassword|base64decode&#125;&#125;&#x27;)</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">To get just the bootstrap password on its own, run:</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">kubectl get secret --namespace cattle-system bootstrap-secret -o go-template=&#x27;&#123;&#123;.data.bootstrapPassword|base64decode&#125;&#125;&#123;&#123; &quot;\n&quot; &#125;&#125;&#x27;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Happy Containering!</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>根据提示，浏览器中访问 <code>https://rancher.my.com/dashboard/?setup=admin</code>，正常情况下，显示如下页面<br><img src="https://i.csms.tech/img_62.png"></p>
<p>根据页面提示，保持密码，登陆。</p>
<h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><h2 id="helm-版本不支持最新的-kubernetes-版本"><a href="#helm-版本不支持最新的-kubernetes-版本" class="headerlink" title="helm 版本不支持最新的 kubernetes 版本"></a>helm 版本不支持最新的 kubernetes 版本</h2><p>使用 <code>helm</code> 命令报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">helm install rancher rancher-stable/rancher --namespace cattle-system --<span class="built_in">set</span> hostname=rancher.my.org --<span class="built_in">set</span> bootstrapPassword=admin</span></span><br><span class="line">Error: INSTALLATION FAILED: chart requires kubeVersion: &lt; 1.25.0-0 which is incompatible with Kubernetes v1.25.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最新版本 <code>helm</code> 不支持最新版本的 <code>Kubernetes</code>，需按照 <code>helm</code> 提示使用 <a href="https://helm.sh/zh/docs/topics/version_skew/">相应版本</a></p>
<h2 id="Error-INSTALLATION-FAILED-execution-error-at-rancher-x2F-templates-x2F-validate-psp-install-yaml-4-5-The-target-cluster-does-not-have-the-PodSecurityPolicy-API-resource-Please-disable-PSPs-in-this-chart-before-proceeding"><a href="#Error-INSTALLATION-FAILED-execution-error-at-rancher-x2F-templates-x2F-validate-psp-install-yaml-4-5-The-target-cluster-does-not-have-the-PodSecurityPolicy-API-resource-Please-disable-PSPs-in-this-chart-before-proceeding" class="headerlink" title="Error: INSTALLATION FAILED: execution error at (rancher&#x2F;templates&#x2F;validate-psp-install.yaml:4:5): The target cluster does not have the PodSecurityPolicy API resource. Please disable PSPs in this chart before proceeding."></a>Error: INSTALLATION FAILED: execution error at (rancher&#x2F;templates&#x2F;validate-psp-install.yaml:4:5): The target cluster does not have the PodSecurityPolicy API resource. Please disable PSPs in this chart before proceeding.</h2><h3 id="环境信息-1"><a href="#环境信息-1" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>centos7 5.4.242-1</li>
<li>kubernetes v1.25.4</li>
<li>helm v3.11.3</li>
<li>rancher v2.7</li>
</ul>
<p>执行以下命令安装 rancher，结果报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">helm install rancher rancher-latest/rancher \</span></span><br><span class="line"><span class="language-bash">                --namespace cattle-system \</span></span><br><span class="line"><span class="language-bash">                --<span class="built_in">set</span> hostname=rancher.my.com \</span></span><br><span class="line"><span class="language-bash">                --<span class="built_in">set</span> bootstrapPassword=admin \</span></span><br><span class="line"><span class="language-bash">                --<span class="built_in">set</span> ingress.ingressClassName=nginx</span></span><br><span class="line">Error: INSTALLATION FAILED: execution error at (rancher/templates/validate-psp-install.yaml:4:5): The target cluster does not have the PodSecurityPolicy API resource. Please disable PSPs in this chart before proceeding        </span><br></pre></td></tr></table></figure>
<p>对于 Kubernetes 版本等于或高于 1.25 的安装，需要添加选项 <code>--set global.cattle.psp.enabled=false</code> <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[The target cluster does not have the PodSecurityPolicy API resource](https://github.com/rancher/rancher/issues/41295)">[2]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">helm install rancher rancher-latest/rancher \</span></span><br><span class="line"><span class="language-bash">                --namespace cattle-system \</span></span><br><span class="line"><span class="language-bash">                --<span class="built_in">set</span> hostname=rancher.my.com \</span></span><br><span class="line"><span class="language-bash">                --<span class="built_in">set</span> bootstrapPassword=admin \</span></span><br><span class="line"><span class="language-bash">                --<span class="built_in">set</span> ingress.ingressClassName=nginx \</span></span><br><span class="line"><span class="language-bash">                --<span class="built_in">set</span> global.cattle.psp.enabled=<span class="literal">false</span></span></span><br></pre></td></tr></table></figure>

<h1 id="常见配置"><a href="#常见配置" class="headerlink" title="常见配置"></a>常见配置</h1><h2 id="权限管理配置"><a href="#权限管理配置" class="headerlink" title="权限管理配置"></a>权限管理配置</h2><h3 id="配置只读-Role"><a href="#配置只读-Role" class="headerlink" title="配置只读 Role"></a>配置只读 Role</h3><p>本示例在 Rancher 上配置有对 Pod 只读权限的 Role，确保绑定了 Role 的用户可以通过 Rancher 读取到 Pod 信息，可以 <code>exec</code> 到 Pod，查看 Pod 日志，无其他 <strong>修改</strong> 权限。</p>
<ol>
<li><p>在 Rancher 上创建具有对 Pod 只读权限的 Role，本示例中为其命名 <code>PodReadOnlyRole</code></p>
<p> 在全局面板中进入 <code>Users &amp; Authentication</code>，选择 <code>Roles</code><br> <img src="https://i.csms.tech/img_87.png"><br> 选择 <code>Project/Namespaces</code><br> <img src="https://i.csms.tech/img_88.png"><br> 点击 <code>Create Project/Namespaces Role</code>，创建 Role，按照下图，填入对应信息<br> <img src="https://i.csms.tech/img_89.png"><br> 需要添加的 <code>Resource</code> 如下：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pods </span><br><span class="line">pods/attach </span><br><span class="line">pods/exec </span><br><span class="line">pods/portforward </span><br><span class="line">pods/proxy </span><br><span class="line">pods/log </span><br><span class="line">pods/status</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>权限选择：<code>get</code>，<code>list</code>，<code>watch</code>。填写完成后点击 <code>Create</code> 创建，无误后会创建 Role : <code>PodReadOnlyRole</code></p>
</li>
<li><p>创建用户</p>
<p> 在全局面板中进入 <code>Users &amp; Authentication</code>，选择 <code>Users</code>，创建新用户。<br> <img src="https://i.csms.tech/img_90.png"><br> 在 <code>Global Permissions</code> 中，选择系统预设的 Global Role ： <code>User-Base</code>，此角色仅拥有登陆系统的权限。</p>
</li>
<li><p>绑定 User 和 Project&#x2F;Namespaces Role</p>
<p> Rancher 仅支持对 Rancher 中的 <code>Project</code> 分配 <code>Project/Namespaces Role</code>，所以为了分配权限，需要对不同的项目创建对应的 <code>Project</code>。</p>
<p> 进入对应的 Cluster，选择要分配权限的 <code>Project</code>，点击 <code>Edit Config</code><br> <img src="https://i.csms.tech/img_91.png"><br> 在 <code>Members</code> 中选择 <code>Add</code> 为 <code>Project</code> 绑定 <code>User</code> 和 <code>Project Permissions</code>，本示例中，权限选择 <code>PodReadOnlyRole</code><br> <img src="https://i.csms.tech/img_92.png"></p>
</li>
</ol>
<p>通过以上步骤创建及分配权限后，通过新创建的用户登陆 Rancher，检查新用户对 Pod 的权限。</p>
<h2 id="Rancher-新增访问域名"><a href="#Rancher-新增访问域名" class="headerlink" title="Rancher 新增访问域名"></a>Rancher 新增访问域名</h2><p>为 Rancher web UI 新增其他可访问域名，参考以下步骤</p>
<ol>
<li><p>使用 <code>cert-manager</code> 为新增域名申请证书</p>
<a href="/202301050935/" title="使用 cert-manager 申请证书的步骤">使用 cert-manager 申请证书的步骤</a></li>
<li><p>修改 Rancher 的 Ingress 配置，添加新域名及证书到 Ingress</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> spec:</span><br><span class="line">ingressClassName: nginx</span><br><span class="line">rules:</span><br><span class="line">- host: rancher.test.com</span><br><span class="line">  http:</span><br><span class="line">    paths:</span><br><span class="line">    - backend:</span><br><span class="line">        service:</span><br><span class="line">          name: rancher</span><br><span class="line">          port:</span><br><span class="line">            number: 80</span><br><span class="line">      pathType: ImplementationSpecific</span><br><span class="line">- host: rancher1.test.com</span><br><span class="line">  http:</span><br><span class="line">    paths:</span><br><span class="line">    - backend:</span><br><span class="line">        service:</span><br><span class="line">          name: rancher</span><br><span class="line">          port:</span><br><span class="line">            number: 80</span><br><span class="line">      pathType: ImplementationSpecific</span><br><span class="line">tls:</span><br><span class="line">- hosts:</span><br><span class="line">  - rancher.test.com</span><br><span class="line">  secretName: tls-rancher-ingress</span><br><span class="line">- hosts:</span><br><span class="line">  - rancher1.test.com</span><br><span class="line">  secretName: rancher1-test-com</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="nginx-反代-Rancher"><a href="#nginx-反代-Rancher" class="headerlink" title="nginx 反代 Rancher"></a>nginx 反代 Rancher</h2><p>在集群外部通过 Nginx 反代访问 Rancher，可以使用以下 Nginx 配置 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[配置 NGINX 负载均衡](https://docs.rancher.cn/docs/rancher2.5/installation/resources/k8s-tutorials/infrastructure-tutorials/nginx/_index/)">[1]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">map $http_upgrade $connection_upgrade &#123;</span><br><span class="line">        default upgrade;</span><br><span class="line">        &#x27;&#x27;      close;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用来对 用户 ip 进行映射，以便后面做访问控制</span>    </span><br><span class="line">map $http_x_forwarded_for $k8s_admin_access &#123;</span><br><span class="line">         default false;</span><br><span class="line">         include k8s_admin_access.list;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">upstream rancher &#123;</span><br><span class="line">    server 172.31.27.193:443;</span><br><span class="line">    server 172.31.23.72:443;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">	listen 443 ssl;</span><br><span class="line">	server_name rancher.test.com;</span><br><span class="line">	access_log /home/logs/nginx/access/rancher.access.log main;</span><br><span class="line">	error_log /home/logs/nginx/error/rancher.error.log;	</span><br><span class="line"></span><br><span class="line">	ssl_certificate test.com.pem;</span><br><span class="line">    ssl_certificate_key test.com.pem;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	location / &#123;</span><br><span class="line">                if ($k8s_admin_access = false) &#123;</span><br><span class="line">                    return 403;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">		proxy_pass https://rancher;      # 本示例中，rancher 使用 https 访问，必须配置为 https</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header REMOTE-HOST $remote_addr;</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">        proxy_set_header Connection $connection_upgrade;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://docs.rancher.cn/docs/rancher2.5/installation/resources/k8s-tutorials/infrastructure-tutorials/nginx/_index/">配置 NGINX 负载均衡</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://github.com/rancher/rancher/issues/41295">The target cluster does not have the PodSecurityPolicy API resource</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>Rancher</tag>
      </tags>
  </entry>
  <entry>
    <title>Prometheus 安装配置</title>
    <url>/202211221610/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos 7</li>
<li>Prometheus Server 2.4</li>
<li>Node Exporter v1.4.0</li>
<li>Grafana v9.2.5</li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="在-Docker-中安装-Prometheus-Server"><a href="#在-Docker-中安装-Prometheus-Server" class="headerlink" title="在 Docker 中安装 Prometheus Server"></a>在 Docker 中安装 Prometheus Server</h2><p>创建 Prometheus Server 配置文件，如 <code>/root/prometheus/prometheus.yml</code>，内容如下 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[安装Prometheus Server](https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/quickstart/prometheus-quick-start/install-prometheus-server)">[1]</span></a></sup></p>
<figure class="highlight shell"><figcaption><span>/data/prometheus/prometheus.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">my global config</span></span><br><span class="line">global:</span><br><span class="line">  scrape_interval:     15s # Set the scrape interval to every 15 seconds. Default is every 1 minute.</span><br><span class="line">  evaluation_interval: 15s # Evaluate rules every 15 seconds. The default is every 1 minute.</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">scrape_timeout is <span class="built_in">set</span> to the global default (10s).</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Alertmanager configuration</span></span><br><span class="line">alerting:</span><br><span class="line">  alertmanagers:</span><br><span class="line">  - static_configs:</span><br><span class="line">    - targets:</span><br><span class="line">      # - alertmanager:9093</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Load rules once and periodically evaluate them according to the global <span class="string">&#x27;evaluation_interval&#x27;</span>.</span></span><br><span class="line">rule_files:</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">- <span class="string">&quot;first_rules.yml&quot;</span></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">- <span class="string">&quot;second_rules.yml&quot;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">A scrape configuration containing exactly one endpoint to scrape:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Here it<span class="string">&#x27;s Prometheus itself.</span></span></span><br><span class="line">scrape_configs:</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.</span></span></span><br><span class="line">  - job_name: &#x27;prometheus&#x27;</span><br><span class="line"></span><br><span class="line">    # metrics_path defaults to &#x27;/metrics&#x27;</span><br><span class="line">    # scheme defaults to &#x27;http&#x27;.</span><br><span class="line"></span><br><span class="line">    static_configs:</span><br><span class="line">    - targets: [&#x27;localhost:9090&#x27;]</span><br></pre></td></tr></table></figure>
<p>使用 Docker 启动时挂载此文件，作为 Prometheus Server 的配置文件，之后需要修改配置，可以直接修改此文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 9090:9090 \</span><br><span class="line">           --name prometheus \</span><br><span class="line">           -v /root/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml \</span><br><span class="line">           prom/prometheus</span><br></pre></td></tr></table></figure>

<p>启动后，可以通过 <code>$Prometheus_IP:9090</code> 访问 Prometheus Server UI</p>
<span id="more"></span>
<h2 id="安装-Node-Exporter"><a href="#安装-Node-Exporter" class="headerlink" title="安装 Node Exporter"></a>安装 Node Exporter</h2><p>Node Exporter 同样采用 Golang 编写，并且不存在任何的第三方依赖，只需要下载，解压即可运行。<a href="https://prometheus.io/download/">获取最新的 node exporter 版本的二进制包</a>。<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[使用Node Exporter采集主机数据](https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/quickstart/prometheus-quick-start/use-node-exporter)">[2]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://github.com/prometheus/node_exporter/releases/download/v1.4.0/node_exporter-1.4.0.linux-amd64.tar.gz</span><br><span class="line">tar -xf node_exporter-1.4.0.linux-amd64.tar.gz</span><br><span class="line">cd node_exporter-1.4.0.linux-amd64</span><br><span class="line">cp node_exporter /usr/bin/</span><br></pre></td></tr></table></figure>
<p>运行 Node Exporter</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">node_exporter</span></span><br><span class="line">...</span><br><span class="line">ts=2022-11-22T08:29:20.717Z caller=node_exporter.go:199 level=info msg=&quot;Listening on&quot; address=:9100</span><br><span class="line">ts=2022-11-22T08:29:20.717Z caller=tls_config.go:195 level=info msg=&quot;TLS is disabled.&quot; http2=false</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>启动成功后，可以看到以下输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">INFO[0000] Listening on :9100                            source=&quot;node_exporter.go:76&quot;</span><br></pre></td></tr></table></figure>
<p>访问 <code>http://localhost:9100/metrics</code>，可以看到当前 node exporter 获取到的当前主机的所有监控数据，如下所示：<br><img src="https://i.csms.tech/img_93.png"></p>
<h2 id="配置-Prometheus-Server-从-Node-Exporter-收集数据"><a href="#配置-Prometheus-Server-从-Node-Exporter-收集数据" class="headerlink" title="配置 Prometheus Server 从 Node Exporter 收集数据"></a>配置 Prometheus Server 从 Node Exporter 收集数据</h2><p>为了能够让 Prometheus Server 能够从当前 node exporter 获取到监控数据，需要修改 Prometheus Server 配置文件。编辑 <code>prometheus.yml</code> 并在 <code>scrape_configs</code> 节点下添加以下内容 : <sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[从Node Exporter收集监控数据](https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/quickstart/prometheus-quick-start/use-node-exporter#cong-node-exporter-shou-ji-jian-kong-shu-ju)">[3]</span></a></sup></p>
<figure class="highlight shell"><figcaption><span>prometheus.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">scrape_configs:</span><br><span class="line">  - job_name: &#x27;prometheus&#x27;</span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [&#x27;localhost:9090&#x27;]</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">采集 node exporter 监控数据</span></span><br><span class="line">  - job_name: &#x27;test node&#x27;</span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [&#x27;172.17.0.3:9100&#x27;]</span><br></pre></td></tr></table></figure>
<p>重启 Prometheus Server</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker restart prometheus</span><br></pre></td></tr></table></figure>

<h2 id="配置-Grafana-可视化-Prometheus-监控数据"><a href="#配置-Grafana-可视化-Prometheus-监控数据" class="headerlink" title="配置 Grafana 可视化 Prometheus 监控数据"></a>配置 Grafana 可视化 Prometheus 监控数据</h2><p>启动 Grafana <sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[监控数据可视化](https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/quickstart/prometheus-quick-start/use-grafana-create-dashboard)">[4]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name grafana -d -p 3000:3000 grafana/grafana</span><br></pre></td></tr></table></figure>
<p>默认情况下使用账户 <code>admin/admin</code> 进行登录</p>
<h3 id="添加-DATA-SOURCES"><a href="#添加-DATA-SOURCES" class="headerlink" title="添加 DATA SOURCES"></a>添加 DATA SOURCES</h3><p>这里将添加 Prometheus 作为默认的数据源，如下图所示，指定数据源类型为 Prometheus 并且设置 Prometheus 的访问地址即可，在配置正确的情况下点击 <code>Add</code> 按钮，会提示连接成功的信息<br><img src="https://i.csms.tech/img_94.png"></p>
<h1 id="PromQL"><a href="#PromQL" class="headerlink" title="PromQL"></a>PromQL</h1><p>可以通过 Prometheus 提供的 UI 来调试表达式及对应的图形<br><img src="https://i.csms.tech/img_148.png"></p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>当 Prometheus 从目标采集数据指标时，它会自动在采集到的时间序列上附加一些标签，以便于识别被采集的目标： <sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[自动生成标签和时间序列](https://hulining.gitbook.io/prometheus/concepts/jobs_instances#automatically-generated-labels-and-time-series)">[5]</span></a></sup></p>
<ul>
<li><code>job</code> : 采集数据目标所属的已配置的作业名称。</li>
<li><code>instance</code> : 采集数据目标 URL 的 <code>&lt;host&gt;:&lt;port&gt;</code> 部分。</li>
</ul>
<p>例如对 <code>up</code> 这个时间序列，可以根据标签筛选出不同值 <code>up&#123;job=&quot;&lt;job-name&gt;&quot;, instance=&quot;&lt;instance-id&gt;&quot;&#125;</code></p>
<blockquote>
<p>其中以 <code>__</code> 作为前缀的标签，是系统保留的关键字，只能在系统内部使用。在 Prometheus 的底层实现中指标名称实际上是以 <code>__name__=&lt;metric name&gt;</code> 的形式保存在数据库中的，因此以下两种方式均表示的同一条time-series：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">api_http_requests_total&#123;method=&quot;POST&quot;, handler=&quot;/messages&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>等同于</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;__name__=&quot;api_http_requests_total&quot;，method=&quot;POST&quot;, handler=&quot;/messages&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>本质上，时间序列所对应的监控指标（metric）都是通过 <code>labelset</code> 唯一命名的。</p>
</blockquote>
<h3 id="标签表达式算符"><a href="#标签表达式算符" class="headerlink" title="标签表达式算符"></a>标签表达式算符</h3><p>标签匹配操作符如下所示：</p>
<ul>
<li><code>=</code>  选择与提供的字符串完全相同的标签(精确匹配)</li>
<li><code>!=</code>  选择不等于提供的字符串的标签(反向匹配)</li>
<li><code>=~</code>  选择与提供的字符串进行正则表达式匹配的标签(正则表达式匹配)</li>
<li><code>!~</code>  选择正则表达式不匹配提供的字符串的标签(反向正则表达式匹配)</li>
</ul>
<h2 id="范围向量选择器"><a href="#范围向量选择器" class="headerlink" title="范围向量选择器"></a>范围向量选择器</h2><ul>
<li><strong>瞬时向量</strong> -  直接通过类似于 PromQL 表达式 <code>api_http_requests_total</code> 查询时间序列时，返回结果中只包含<strong>该时间序列中各指标最新的样本值</strong>，这种类型的数据集称之为 <strong>瞬时向量</strong>，对应的表达式称为 <strong>瞬时向量表达式</strong></li>
<li><strong>区间向量</strong> &#x2F; <strong>范围向量</strong> - 在 <strong>瞬时向量</strong> 基础上指定时间范围，例如 <code>api_http_requests_total[5m]</code>，表达式被称为 <strong>区间向量表达式</strong> 或者 <strong>范围向量表达式</strong>，其查询到的时间序列是以当前 <strong>瞬时向量</strong> 为基准的过去 5 分钟内的时间序列的集合，其结果称之为 <strong>区间向量</strong></li>
</ul>
<p><strong>范围向量</strong> 从当前瞬间选择了一定范围的样本 <sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[范围向量选择器](https://hulining.gitbook.io/prometheus/prometheus/querying/basics#range-vector-selectors)">[6]</span></a></sup></p>
<p>语法上，将范围持续时间附加在向量选择器末尾的方括号(<code>[]</code>)中，以指定为每个范围向量元素提取多久的时间值。</p>
<p>持续时间指定为数字，紧随其后的是以下单位之一：</p>
<ul>
<li><code>s</code> - 秒</li>
<li><code>m</code> - 分钟</li>
<li><code>h</code> - 小时</li>
<li><code>d</code> - 天</li>
<li><code>w</code> - 周</li>
<li><code>y</code> - 年</li>
</ul>
<p>在此示例中，我们选择在过去 5 分钟，数据指标名称为 <code>http_requests_total</code> 且 <code>job</code> 标签为 <code>prometheus</code> 的所有时间序列记录的所有值：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http_requests_total&#123;job=&quot;prometheus&quot;&#125;[5m]</span><br></pre></td></tr></table></figure>

<h2 id="时间位移操作"><a href="#时间位移操作" class="headerlink" title="时间位移操作"></a>时间位移操作</h2><p>在 <strong>瞬时向量表达式</strong> 和 <strong>区间向量表达式</strong> 中，都是以当前时间为基准。 <sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[范围向量选择器](https://hulining.gitbook.io/prometheus/prometheus/querying/basics#range-vector-selectors)">[6]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http_request_total&#123;&#125; # 瞬时向量表达式，选择当前最新的数据</span><br><span class="line">http_request_total&#123;&#125;[5m] # 区间向量表达式，选择以当前时间为基准，5分钟内的数据</span><br></pre></td></tr></table></figure>
<p>如果想查询 5 分钟前的瞬时样本数据，或者昨天一天的区间内的样本数据，这时候可以使用 <strong>时间位移操作</strong>，关键字为 <code>offset</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http_request_total&#123;&#125; offset 5m    # 瞬时向量表达式，选择 5 分钟之前的样本数据</span><br><span class="line">http_request_total&#123;&#125;[1d] offset 1d  # 区间向量表达式，选择一天前的一天内的样本数据</span><br></pre></td></tr></table></figure>

<h2 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h2><p>在形式上，所有的指标 (Metric) 都通过如下格式标示： <sup id="fnref:7"><a href="#fn:7" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[指标(Metric)](https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/promql/what-is-prometheus-metrics-and-labels#zhi-biao-metric)">[7]</span></a></sup></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;metric name&gt;&#123;&lt;label name&gt;=&lt;label value&gt;, ...&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Metrics-类型"><a href="#Metrics-类型" class="headerlink" title="Metrics 类型"></a>Metrics 类型</h3><p>根据不同监控指标之间的差异，Prometheus 定义了4种不同的指标类型 <sup id="fnref:8"><a href="#fn:8" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Metrics类型](https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/promql/prometheus-metrics-types)">[8]</span></a></sup></p>
<ul>
<li><code>Counter</code> - 计数器。只增不减的计数器。一般在定义 <code>Counter</code> 类型指标的名称时推荐使用 <code>_total</code> 作为后缀</li>
<li><code>Gauge</code> - 仪表盘。侧重于反应系统的当前状态，可增可减</li>
<li><code>Histogram</code> - 直方图。</li>
<li><code>Summary</code> - 摘要。</li>
</ul>
<h3 id="prometheus-相关指标"><a href="#prometheus-相关指标" class="headerlink" title="prometheus 相关指标"></a>prometheus 相关指标</h3><p>以下列出常见的指标名称及其相关信息</p>
<table>
<thead>
<tr>
<th>指标名称</th>
<th>类型</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>up</code></td>
<td></td>
<td>实例运行状态良好，则为 1；<br/>如果采集失败，则为 0</td>
<td></td>
</tr>
<tr>
<td><code>scrape_duration_seconds</code></td>
<td></td>
<td>采集的持续时间</td>
<td></td>
</tr>
</tbody></table>
<h2 id="PromQL-语法"><a href="#PromQL-语法" class="headerlink" title="PromQL 语法"></a>PromQL 语法</h2><p>当我们直接使用监控指标名称查询时，可以查询该指标下的所有时间序列。如： <sup id="fnref:9"><a href="#fn:9" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[初识 PromQL](https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/promql/prometheus-query-language)">[9]</span></a></sup></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http_requests_total</span><br></pre></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http_requests_total&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>等同于</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;__name__=&quot;http_requests_total&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>该查询会返回指标名称为 <code>http_requests_total</code> 的所有时间序列</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http_requests_total&#123;code=&quot;200&quot;,handler=&quot;alerts&quot;,instance=&quot;localhost:9090&quot;,job=&quot;prometheus&quot;,method=&quot;get&quot;&#125;=(20889@1518096812.326)</span><br><span class="line">http_requests_total&#123;code=&quot;200&quot;,handler=&quot;graph&quot;,instance=&quot;localhost:9090&quot;,job=&quot;prometheus&quot;,method=&quot;get&quot;&#125;=(21287@1518096812.326)</span><br></pre></td></tr></table></figure>

<h2 id="PromQL-内置函数"><a href="#PromQL-内置函数" class="headerlink" title="PromQL 内置函数"></a>PromQL 内置函数</h2><h3 id="increase"><a href="#increase" class="headerlink" title="increase"></a>increase</h3><p><code>increase(v range-vector)</code> 函数获取 <strong>区间向量</strong> 中的第一个和最后一个样本并返回其增长量。其中参数 <code>v</code> 是一个 <strong>区间向量</strong> <sup id="fnref:10"><a href="#fn:10" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[PromQL内置函数](https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/promql/prometheus-promql-functions)">[10]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">increase(node_cpu[2m]) / 120</span><br></pre></td></tr></table></figure>
<p>这里通过 <code>node_cpu[2m]</code> 获取时间序列最近两分钟的所有样本，<code>increase</code> 计算出最近两分钟的增长量，最后除以时间 120 秒得到 <code>node_cpu</code> 样本在最近两分钟的平均增长率。并且这个值也近似于主机节点最近两分钟内的平均 CPU 使用率。</p>
<h3 id="rate-amp-irate"><a href="#rate-amp-irate" class="headerlink" title="rate &amp; irate"></a>rate &amp; irate</h3><p><code>rate(v range-vector)</code> 函数可以直接计算出 <strong>区间向量</strong> <code>v</code> 在时间窗口内的平均增长速率。以下表达式获取和 <code>increase(node_cpu[2m]) / 120</code> 函数相同的效果。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rate(node_cpu[2m])</span><br></pre></td></tr></table></figure>
<p>需要注意的是使用 <code>rate</code> 或者 <code>increase</code> 函数去计算样本的平均增长速率，容易陷入“长尾问题”当中，其无法反应在时间窗口内样本数据的突发变化。 例如，对于主机而言在 2 分钟的时间窗口内，可能在某一个由于访问量或者其它问题导致 CPU 占用 100% 的情况，但是通过计算在时间窗口内的平均增长率却无法反应出该问题。</p>
<p>为了解决该问题，PromQL 提供了另外一个灵敏度更高的函数 <code>irate(v range-vector)</code>。<code>irate</code> 同样用于计算区间向量的计算率，但是其反应出的是瞬时增长率。<code>irate</code> 函数是通过区间向量中最后两个样本数据来计算区间向量的增长速率。这种方式可以避免在时间窗口范围内的“长尾问题”，并且体现出更好的灵敏度，通过 <code>irate</code> 函数绘制的图标能够更好的反应样本数据的瞬时变化状态。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">irate(node_cpu[2m])</span><br></pre></td></tr></table></figure>
<p><code>irate</code> 函数相比于 <code>rate</code> 函数提供了更高的灵敏度，不过当需要分析长期趋势或者在告警规则中，<code>irate</code> 的这种灵敏度反而容易造成干扰。因此在长期趋势分析或者告警中更推荐使用 <code>rate</code> 函数。</p>
<h1 id="常用-metrics-及-PromQL"><a href="#常用-metrics-及-PromQL" class="headerlink" title="常用 metrics 及 PromQL"></a>常用 metrics 及 PromQL</h1><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><h3 id="CPU-使用率"><a href="#CPU-使用率" class="headerlink" title="CPU 使用率"></a>CPU 使用率</h3><p>主要使用指标 <code>node_cpu_seconds_total</code>，该指标包括多个标签，分别标记了每种处理模式使用的 CPU 时间，该指标为 <code>counter</code> 类型，不适合直接使用，需要使用 PromQL 转换成感兴趣的指标</p>
<table>
<thead>
<tr>
<th>指标名称</th>
<th>类型</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>node_cpu_seconds_total</code></td>
<td><code>counter</code></td>
<td>每种处理模式使用的 CPU 时间</td>
<td></td>
</tr>
</tbody></table>
<p><img src="https://i.csms.tech/img_154.png"></p>
<p>以下 PromQL 可以用来计算 CPU 使用率，若对其他模式的 CPU 监控指标感兴趣，可以根据需求自己调整。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">100 -avg(irate(node_cpu_seconds_total&#123;job=&quot;kubernetes-nodes&quot;,mode=&quot;idle&quot;&#125;[5m])) by (instance)* 100</span><br></pre></td></tr></table></figure>

<h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><h3 id="Memory-使用率"><a href="#Memory-使用率" class="headerlink" title="Memory 使用率"></a>Memory 使用率</h3><p>涉及到的内存指标</p>
<table>
<thead>
<tr>
<th>指标名称</th>
<th>类型</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>node_memory_MemTotal_bytes</code></td>
<td></td>
<td>总内存大小</td>
<td></td>
</tr>
<tr>
<td><code>node_memory_MemFree_bytes</code></td>
<td></td>
<td>空闲内存大小</td>
<td></td>
</tr>
<tr>
<td><code>node_memory_Buffers_bytes</code></td>
<td></td>
<td>缓冲缓存的大小</td>
<td></td>
</tr>
<tr>
<td><code>node_memory_Cached_bytes</code></td>
<td></td>
<td>页面缓存的大小</td>
<td></td>
</tr>
</tbody></table>
<p>物理内存使用率计算公式如下: <code>（总内存 -（空闲内存 + 缓冲缓存 + 页面缓存））/ 总内存 * 100</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(node_memory_MemTotal_bytes - (node_memory_MemFree_bytes + node_memory_Buffers_bytes+node_memory_Cached_bytes ))/node_memory_MemTotal_bytes * 100 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Disk"><a href="#Disk" class="headerlink" title="Disk"></a>Disk</h2><p>磁盘相关指标，多个分区可以通过 <code>mountpoint</code> 标签区分，<code>device</code> 标签区分所属设备</p>
<table>
<thead>
<tr>
<th>指标名称</th>
<th>类型</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>node_filesystem_size_bytes</code></td>
<td></td>
<td>分区空间总容量</td>
<td></td>
</tr>
<tr>
<td><code>node_filesystem_free_bytes</code></td>
<td></td>
<td>分区空间空闲容量</td>
<td></td>
</tr>
<tr>
<td><code>node_disk_read_bytes_total</code></td>
<td><code>counter</code></td>
<td>分区读总字节数</td>
<td></td>
</tr>
<tr>
<td><code>node_disk_written_bytes_total</code></td>
<td><code>counter</code></td>
<td>分区写总字节数</td>
<td></td>
</tr>
<tr>
<td><code>node_disk_reads_completed_total</code></td>
<td><code>counter</code></td>
<td>分区读总次数</td>
<td></td>
</tr>
<tr>
<td><code>node_disk_writes_completed_total</code></td>
<td><code>counter</code></td>
<td>分区写总次数</td>
<td></td>
</tr>
</tbody></table>
<h3 id="获取根分区的磁盘使用率"><a href="#获取根分区的磁盘使用率" class="headerlink" title="获取根分区的磁盘使用率"></a>获取根分区的磁盘使用率</h3><p>公式如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(node_filesystem_size_bytes&#123;mountpoint=&quot;/&quot;&#125; - node_filesystem_free_bytes&#123;mountpoint=&quot;/&quot;&#125;)/node_filesystem_size_bytes&#123;mountpoint=&quot;/&quot;&#125; * 100</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="磁盘吞吐率"><a href="#磁盘吞吐率" class="headerlink" title="磁盘吞吐率"></a>磁盘吞吐率</h3><p>公式如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">irate(node_disk_read_bytes_total&#123;device=&quot;vda&quot;&#125;[5m]) </span><br><span class="line">irate(node_disk_written_bytes_total&#123;device=&quot;vda&quot;&#125;[5m]) </span><br></pre></td></tr></table></figure>

<h3 id="磁盘-IOPS"><a href="#磁盘-IOPS" class="headerlink" title="磁盘 IOPS"></a>磁盘 IOPS</h3><p>IOPS 表示每秒对磁盘的读写次数，它与吞吐量都是衡量磁盘的重要指标。对于 IOPS 的监控，可通过下面两个指标算得出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">irate(node_disk_reads_completed_total&#123;device=&quot;vda&quot;&#125;[5m]) </span><br><span class="line">irate(node_disk_writes_completed_total&#123;device=&quot;vda&quot;&#125;[5m]) </span><br></pre></td></tr></table></figure>

<h2 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h2><p>网卡流量一般分为上传和下载流量</p>
<table>
<thead>
<tr>
<th>指标名称</th>
<th>类型</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>node_network_receive_bytes_total</code></td>
<td></td>
<td>下载（接收&#x2F;流入）流量总字节数</td>
<td></td>
</tr>
<tr>
<td><code>node_network_transmit_bytes_total</code></td>
<td></td>
<td>上传（&#x2F;发送&#x2F;流出）流量总字节数</td>
<td></td>
</tr>
</tbody></table>
<h3 id="网卡流量"><a href="#网卡流量" class="headerlink" title="网卡流量"></a>网卡流量</h3><p>以下公式计算每秒网卡流量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">irate(node_network_receive_bytes_total&#123;device != &quot;lo&quot;&#125;[1m]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Prometheus-告警"><a href="#Prometheus-告警" class="headerlink" title="Prometheus 告警"></a>Prometheus 告警</h1><h2 id="PromQL-告警规则"><a href="#PromQL-告警规则" class="headerlink" title="PromQL 告警规则"></a>PromQL 告警规则</h2><p><a href="https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/alert/prometheus-alert-rule">使用参考文档</a></p>
<p>一条典型的告警规则如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">groups:</span><br><span class="line">- name: example</span><br><span class="line">  rules:</span><br><span class="line">  - alert: HighErrorRate</span><br><span class="line">    expr: job:request_latency_seconds:mean5m&#123;job=&quot;myjob&quot;&#125; &gt; 0.5</span><br><span class="line">    for: 10m</span><br><span class="line">    labels:</span><br><span class="line">      severity: page</span><br><span class="line">    annotations:</span><br><span class="line">      summary: High request latency</span><br><span class="line">      description: description info</span><br></pre></td></tr></table></figure>
<p>在告警规则文件中，我们可以将一组相关的规则设置定义在一个 <code>group</code> 下。在每一个 <code>group</code> 中我们可以定义多个告警规则(<code>rule</code>)。一条告警规则主要由以下几部分组成：</p>
<ul>
<li><code>alert</code> ：告警规则的名称。</li>
<li><code>expr</code> ：基于 <code>PromQL</code> 表达式告警触发条件，用于计算是否有时间序列满足该条件。</li>
<li><code>for</code> ：评估等待时间，可选参数。用于表示只有当触发条件持续一段时间后才发送告警。在等待期间新产生告警的状态为 <code>pending</code>。</li>
<li><code>labels</code> ：自定义标签，允许用户指定要附加到告警上的一组附加标签。</li>
<li><code>annotations</code> ：用于指定一组附加信息，比如用于描述告警详细信息的文字等，<code>annotations</code> 的内容在告警产生时会一同作为参数发送到 <code>Alertmanager</code>。<ul>
<li><code>summary</code> - 描述告警的概要信息</li>
<li><code>description</code> - 描述告警的详细信息</li>
</ul>
</li>
</ul>
<p>为了能够让 Prometheus 启用定义的告警规则，需要在 <a href="#%E5%9C%A8-Docker-%E4%B8%AD%E5%AE%89%E8%A3%85-Prometheus-Server">Prometheus 的全局配置文件</a> 中通过 <code>rule_files</code> 指定 <strong>告警规则文件的访问路径</strong>。Prometheus 启动后会自动扫描这些路径下规则文件中定义的内容，并且根据这些规则计算是否告警。</p>
<figure class="highlight shell"><figcaption><span>prometheus.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">global:</span><br><span class="line">  scrape_interval: 5s</span><br><span class="line">  evaluation_interval: 5s</span><br><span class="line"></span><br><span class="line">rule_files:</span><br><span class="line">  - /etc/prometheus/*.rules</span><br></pre></td></tr></table></figure>



<p>默认情况下 Prometheus 会每分钟对这些告警规则进行计算，如果用户想定义自己的告警计算周期，则可以通过 <code>evaluation_interval</code> 来覆盖默认的计算周期：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">global:</span><br><span class="line">  [ evaluation_interval: &lt;duration&gt; | default = 1m ]</span><br></pre></td></tr></table></figure>

<p>在 <code>annotations</code> 的 <code>summary</code> 和 <code>description</code> 可以使用变量访问当前告警实例当中指定标签和对应的值</p>
<ul>
<li><code>$labels.&lt;labelname&gt;</code> - 访问名为 <code>&lt;labelname&gt;</code> 的 <code>label</code></li>
<li><code>$value</code> - 访问标签 <code>$labels.&lt;labelname&gt;</code> 的值</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groups:</span><br><span class="line">- name: hostStatsAlert</span><br><span class="line">  rules:</span><br><span class="line">  - alert: hostCpuUsageAlert</span><br><span class="line">    expr: sum by (instance) (avg without (cpu) (irate(node_cpu_seconds_total&#123;mode!=&quot;idle&quot;&#125;[5m]))) &gt; 0.85</span><br><span class="line">    for: 1m</span><br><span class="line">    labels:</span><br><span class="line">      severity: page</span><br><span class="line">    annotations:</span><br><span class="line">      summary: &quot;Instance &#123;&#123; $labels.instance &#125;&#125; CPU usgae high&quot;</span><br><span class="line">      description: &quot;&#123;&#123; $labels.instance &#125;&#125; CPU usage above 85% (current value: &#123;&#123; $value &#125;&#125;)&quot;</span><br><span class="line">  - alert: hostMemUsageAlert</span><br><span class="line">    expr: (node_memory_MemTotal_bytes - node_memory_MemAvailable_bytes) / node_memory_MemTotal_bytes  &gt; 0.85</span><br><span class="line">    for: 1m</span><br><span class="line">    labels:</span><br><span class="line">      severity: page</span><br><span class="line">    annotations:</span><br><span class="line">      summary: &quot;Instance &#123;&#123; $labels.instance &#125;&#125; MEM usgae high&quot;</span><br><span class="line">      description: &quot;&#123;&#123; $labels.instance &#125;&#125; MEM usage above 85% (current value: &#123;&#123; $value &#125;&#125;)&quot;</span><br></pre></td></tr></table></figure>

<p>配置生效后，可以在 Prometheus 的 Web 的 <code>Status --&gt; Rules</code>  下看到所有的告警规则，也可以在 <code>Alerts</code> 中看到所有的告警规则及其状态<br><img src="https://i.csms.tech/img_160.png"><br><img src="https://i.csms.tech/img_161.png"></p>
<p>Prometheus 首次检测到满足条件的样本后，告警就会处于活动状态，由于配置了 <code>for</code> 等待时间，告警状态是（<code>PENDING</code>），如果到了 <code>for</code> 等待时间，告警条件持续满足，则会实际触发告警并且告警状态为 <code>FIRING</code> </p>
<h1 id="Prometheus-配置文件说明"><a href="#Prometheus-配置文件说明" class="headerlink" title="Prometheus 配置文件说明"></a>Prometheus 配置文件说明</h1><p>Prometheus 配置文件内容大体如下，主要分为:</p>
<ul>
<li><code>global</code> - 全局配置选项</li>
<li><code>alerting</code> - 告警管理的配置选项</li>
<li><code>rule_files</code> - 高级规则文件的路径</li>
<li><code>scrape_configs</code> - 要抓取的目标和抓取配置</li>
</ul>
<figure class="highlight shell"><figcaption><span>prometheus.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">global:</span><br><span class="line">  scrape_interval: 5s</span><br><span class="line">  evaluation_interval: 5s</span><br><span class="line"></span><br><span class="line">alerting:</span><br><span class="line">  alertmanagers:</span><br><span class="line">    - static_configs:</span><br><span class="line">        - targets: [&#x27;localhost:9093&#x27;]</span><br><span class="line"></span><br><span class="line">rule_files:</span><br><span class="line">  - /etc/prometheus/*.rules</span><br><span class="line"></span><br><span class="line">scrape_configs:</span><br><span class="line">  - job_name: &#x27;prometheus&#x27;</span><br><span class="line">    static_configs:</span><br><span class="line">    - targets: [&#x27;localhost:9090&#x27;]</span><br><span class="line">      labels:</span><br><span class="line">        customizedLablel1: v1</span><br><span class="line">        customizedLablel2: v2</span><br></pre></td></tr></table></figure>

<h2 id="global-常用选项说明"><a href="#global-常用选项说明" class="headerlink" title="global 常用选项说明"></a>global 常用选项说明</h2><ul>
<li><p><code>scrape_interval</code>  - 指定抓取间隔，即 Prometheus 定期抓取指标数据的时间间隔。默认值为15秒（15s）。</p>
</li>
<li><p><code>scrape_timeout</code> - 指定抓取超时时间，即在超过此时间后如果抓取请求未完成，则认为抓取失败。默认值为10秒（10s）。</p>
</li>
<li><p><code>evaluation_interval</code> - 指定评估间隔，即 Prometheus 对规则和表达式进行计算和评估的时间间隔。默认值为1分钟（1m）。</p>
</li>
<li><p><code>external_labels</code> - 指定用于所有指标时间序列的额外标签。这些标签可以在查询和告警规则中使用，以提供额外的上下文信息。例如：</p>
  <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">external_labels:</span></span><br><span class="line">  <span class="attr">environment:</span> <span class="string">&#x27;production&#x27;</span></span><br><span class="line">  <span class="attr">region:</span> <span class="string">&#x27;us-west&#x27;</span></span><br></pre></td></tr></table></figure>
<p>  这将在所有指标的时间序列中添加 <code>environment=production</code> 和 <code>region=us-west</code> 的标签。</p>
</li>
</ul>
<h2 id="alerting-常用选项说明"><a href="#alerting-常用选项说明" class="headerlink" title="alerting 常用选项说明"></a>alerting 常用选项说明</h2><p>以下配置指定 AlertManager 的配置，以使 Prometheus 可以发送告警。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alerting:</span><br><span class="line">  alertmanagers:</span><br><span class="line">    - static_configs:</span><br><span class="line">        - targets: [&#x27;localhost:9093&#x27;]</span><br></pre></td></tr></table></figure>
<h2 id="rule-files-常用选项说明"><a href="#rule-files-常用选项说明" class="headerlink" title="rule_files 常用选项说明"></a>rule_files 常用选项说明</h2><p><a href="#Prometheus-%E5%91%8A%E8%AD%A6">Prometheus 的告警规则文件配置</a></p>
<h2 id="scrape-configs-常用选项说明"><a href="#scrape-configs-常用选项说明" class="headerlink" title="scrape_configs 常用选项说明"></a>scrape_configs 常用选项说明</h2><p>每个<code>scrape_config</code> 块包含以下选项</p>
<ul>
<li><code>job_name</code> - 抓取任务的名称</li>
<li><code>static_configs</code> - 静态目标配置，可以包含一个或多个目标的配置</li>
<li><code>relabel_configs</code> - 对目标标签进行重新标记或者重写</li>
<li><code>metrics_path</code> - 目标的指标抓取路径</li>
<li><code>params</code> - 为抓取指标的请求提供额外的参数（键值对）</li>
<li><code>scheme</code> - 抓取请求使用的协议，<code>http</code> 或 <code>https</code></li>
<li><code>scrape_interval</code> - 抓取该目标的间隔时间。可以覆盖全局配置。</li>
<li><code>scrape_timeout</code> - 抓取超时时间。</li>
<li><code>honor_labels</code> - <code>true|false</code>，指定是否要保留来自抓取目标的指标的标签。默认值为 <code>false</code><blockquote>
<p>当 <code>honor_labels</code> 设置为 <code>true</code> 时，Prometheus 将尊重被抓取目标提供的标签，并将其视为指标标签的一部分。这意味着来自同一指标名称但带有不同标签值的多个时间序列将被保留和区分。</p>
<p>例如，如果抓取目标提供一个名为 <code>cpu_usage</code> 的指标，并在不同的 Pod 之间使用 <code>pod_name</code> 标签进行区分，那么 Prometheus 会存储多个时间序列，每个时间序列代表一个不同的 Pod 的 CPU 使用情况。通过保留标签，你可以根据 Pod 名称对这些时间序列进行过滤、聚合和查询。</p>
<p>然而，当 <code>honor_labels</code> 设置为 <code>false</code> 时，Prometheus 将忽略来自被抓取目标的标签，并且不会将其包含在存储的指标数据中。在这种情况下，相同指标名称的所有时间序列将被视为相同，并且标签信息将丢失。</p>
<p>通常情况下，如果你希望保留和使用被抓取目标提供的标签信息，你应该将 <code>honor_labels</code> 设置为 <code>true</code>，以便在 Prometheus 中进行更灵活和细粒度的指标查询和操作。</p>
<p><strong><code>honor_labels</code> 选项仅适用于 <code>service_discovery</code> 和 <code>static_configs</code> 中的目标。对于其他类型的目标，例如 <code>relabel_configs</code> 或 <code>file_sd_configs</code>，<code>honor_labels</code> 并不适用。</strong></p>
</blockquote>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scrape_configs:</span><br><span class="line">  - job_name: &#x27;prometheus&#x27;</span><br><span class="line">    static_configs:</span><br><span class="line">    - targets: [&#x27;localhost:9090&#x27;]</span><br><span class="line">      labels:</span><br><span class="line">        customizedLablel1: v1</span><br><span class="line">        customizedLablel2: v2</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>labels</code></td>
<td>配置自定义标签，会附加到指标的标签中</td>
<td></td>
</tr>
</tbody></table>
<h3 id="relabel-configs-详解"><a href="#relabel-configs-详解" class="headerlink" title="relabel_configs 详解"></a>relabel_configs 详解</h3><p><code>relabel</code> 重定义标签是在拉取（<code>Scrape</code>）阶段钱，修改 Target 和 Lables。</p>
<p>默认情况下，Target 会自动被添加以下标签</p>
<ul>
<li><code>job</code> - 设置为配置中 <code>job_name</code> 的值</li>
<li><code>__address__</code> - 设置为配置中 <code>targets</code> 的值</li>
<li><code>instance</code> - 是重定义标签 <code>__address__</code> 的值</li>
<li><code>__scheme__</code> - 设置为配置中 <strong>协议类型</strong> 的值，从配置中读取</li>
<li><code>__metrics_path__</code> - 从配置中读取，拉取 Metrics 的 uri</li>
</ul>
<h4 id="action"><a href="#action" class="headerlink" title="action"></a>action</h4><p><code>action</code> 定义了对标签的动作，主要有以下可选项，默认值为 <code>replace</code></p>
<table>
<thead>
<tr>
<th>action</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>replace</code></td>
<td>使用正则匹配到的<strong>源标签</strong>的值来替换<strong>目标标签</strong>的值，如果有 <code>replacement</code>，则直接使用 <code>replacement</code> 的值替换<strong>目标标签</strong></td>
<td></td>
</tr>
<tr>
<td><code>keep</code></td>
<td>如果正则没有匹配到<strong>源标签</strong>，则删除 Targets</td>
<td></td>
</tr>
<tr>
<td><code>drop</code></td>
<td>如果正则匹配到<strong>源标签</strong>，则删除 Targets</td>
<td></td>
</tr>
<tr>
<td><code>hashmod</code></td>
<td>设置    <strong>目标标签</strong>的值为   <strong>源标签</strong>值的 hash 值</td>
<td></td>
</tr>
<tr>
<td><code>labelmap</code></td>
<td>正则匹配所有标签名，使用<strong>匹配到的标签名</strong> 和 <strong>原标签名的值</strong>    生成新的标签</td>
<td></td>
</tr>
</tbody></table>
<h1 id="Prometheus-优化建议"><a href="#Prometheus-优化建议" class="headerlink" title="Prometheus 优化建议"></a>Prometheus 优化建议</h1><p>Prometheus 随着收集的指标数量的增加，对 CPU 和内存的要求也会上周，一般首先使用率变高的是内存。</p>
<ul>
<li>Prometheus 每隔 2 小时做一个 Block 数据落盘，落盘之前所以的数据都在 内存 中。采集量越多，占用内存越大。</li>
<li>加载历史数据时，是从磁盘读取到内存，因此查询范围越大，内存占用越大</li>
</ul>
<p>为了减小 Prometheus Server  的压力，可以采取以下方法</p>
<ol>
<li>进行指标优化，去除无效的 Metrics 采集<br> 在 Prometheus UI 的 Status 中，有 <code>TSDB Status</code>，里面包含了 Prometheus 的统计概要</li>
</ol>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/quickstart/prometheus-quick-start/install-prometheus-server">安装Prometheus Server</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/quickstart/prometheus-quick-start/use-node-exporter">使用Node Exporter采集主机数据</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/quickstart/prometheus-quick-start/use-node-exporter#cong-node-exporter-shou-ji-jian-kong-shu-ju">从Node Exporter收集监控数据</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/quickstart/prometheus-quick-start/use-grafana-create-dashboard">监控数据可视化</a><a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://hulining.gitbook.io/prometheus/concepts/jobs_instances#automatically-generated-labels-and-time-series">自动生成标签和时间序列</a><a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://hulining.gitbook.io/prometheus/prometheus/querying/basics#range-vector-selectors">范围向量选择器</a><a href="#fnref:6" rev="footnote"> ↩</a></span></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/promql/what-is-prometheus-metrics-and-labels#zhi-biao-metric">指标(Metric)</a><a href="#fnref:7" rev="footnote"> ↩</a></span></li><li id="fn:8"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">8.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/promql/prometheus-metrics-types">Metrics类型</a><a href="#fnref:8" rev="footnote"> ↩</a></span></li><li id="fn:9"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">9.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/promql/prometheus-query-language">初识 PromQL</a><a href="#fnref:9" rev="footnote"> ↩</a></span></li><li id="fn:10"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">10.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/promql/prometheus-promql-functions">PromQL内置函数</a><a href="#fnref:10" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Tools</category>
        <category>Prometheus</category>
      </categories>
  </entry>
  <entry>
    <title>sed 命令使用示例</title>
    <url>/202207291520/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="常用选项说明"><a href="#常用选项说明" class="headerlink" title="常用选项说明"></a>常用选项说明</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-n    使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN （例如文件内容）的内容一般都会被列出到屏幕上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来。</span><br><span class="line">-i    直接修改读取的内容，而不是由屏幕输出。</span><br><span class="line">-f    直接将 sed 的动作写在一个文件内， -f filename 则可以执行 filename 内的sed 动作；</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a    追加， a 的后面可以接字符串，而这些字串会在新的一行出现(当前行的下一行)</span><br><span class="line">i    插入， i 的后面可以接字符串，而这些字串会在新的一行出现(目前行的上一行)；</span><br><span class="line">c    替代， c 的后面可以接字符串，替换整行</span><br><span class="line">s    替换， s/a/b/，a 替换成 b</span><br><span class="line">d    删除</span><br><span class="line">p    打印指定行</span><br></pre></td></tr></table></figure>

<h3 id="行定位方法"><a href="#行定位方法" class="headerlink" title="行定位方法"></a>行定位方法</h3><p>根据行号打印出指定行，<code>$</code> 表示最后一行，<code>!</code> 取反，排除行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -n &#x27;1p&#x27; file</span><br><span class="line">sed -n &#x27;1,10p&#x27; file</span><br><span class="line">sed -n &#x27;2,$p&#x27; file</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印除最后一行之外的其他行</span></span><br><span class="line">sed -n &#x27;$!p&#x27; file</span><br></pre></td></tr></table></figure>
<p>打印出搜索匹配到的行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -n &#x27;/root/p&#x27; file</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印出匹配<span class="string">&#x27;begin&#x27;</span>开始的行，到匹配到<span class="string">&#x27;end&#x27;</span>的行结束</span></span><br><span class="line">sed -n &#x27;/begin/,/end/p&#x27;</span><br><span class="line">sed -n &#x27;/begin/,/end/!p&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="常用示例"><a href="#常用示例" class="headerlink" title="常用示例"></a>常用示例</h3><h4 id="搜索包含指定内容的行，并替换整行内容"><a href="#搜索包含指定内容的行，并替换整行内容" class="headerlink" title="搜索包含指定内容的行，并替换整行内容"></a>搜索包含指定内容的行，并替换整行内容</h4><p>使用 <code>c</code> 命令，替换整行内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;/^updated/cupdate=1&#x27; file</span><br></pre></td></tr></table></figure>

<h4 id="每行的行首或行位添加内容"><a href="#每行的行首或行位添加内容" class="headerlink" title="每行的行首或行位添加内容"></a>每行的行首或行位添加内容</h4><p><code>^</code>，<code>$</code> 匹配行首和行尾  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i `s/^/添加内容/g` file</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>sed</tag>
      </tags>
  </entry>
  <entry>
    <title>sftp 服务常用配置说明</title>
    <url>/202207301332/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>sftp 是 Secure File Transfer Protocol 的缩写，安全文件传送协议。可以为传输文件提供一种安全的加密方法。SFTP 为 SSH 的一部分，由于这种传输方式使用了加密&#x2F;解密技术，所以传输效率比普通的 FTP 要低得多，如果您对网络安全性要求更高时，可以使用 SFTP 代替 FTP。默认ssh启用了sftp，只要可登陆系统的用户（&#x2F;bin&#x2F;bash）就可登陆,登陆后目录无限制，可任意切换其他目录。为了安全起见，可以配置sshd以限制sftp登录用户的权限。最好将登陆后用户限制在指定目录，无法切换到外部目录  </p>
<span id="more"></span>

<h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p><strong><code>ChrootDirectory</code> 配置前提</strong>:<br><code>ChrootDirectory</code> 设置的目录权限及其所有的上级文件夹权限，属主和属组必须是 root；<br><code>ChrootDirectory</code> 设置的目录权限及其所有的上级文件夹权限，只有属主能拥有写权限，权限最大设置只能是 755。</p>
<blockquote>
<p><strong>如果权限配置不对，会导致无法登录</strong><br>如果上级目录无法设置为root权限，可以通过<code>ln</code>链接的方式实现<br>限制后的用户无法 <code>ssh</code> 登录系统</p>
</blockquote>
<p>创建相关用户和组</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groupadd sftp</span><br><span class="line">useradd -g sftp -d /data/sftp/sftpuser1 -s /sbin/nologin sftpuser1</span><br><span class="line">echo 123456 | passwd --stdin sftpuser1</span><br><span class="line"></span><br><span class="line">chown root:root /data/sftp/sftpuser1</span><br><span class="line">chmod 755 /data/sftp/sftpuser1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">因为 /data/sftp/sftpuser1 属主和属组都为root，其他用户无写入权限，需要创建sftpuser1可写入的目录</span></span><br><span class="line">mkdir -p /data/sftp/sftpuser1/upload</span><br><span class="line">chown sftpuser1:sftp /data/sftp/sftpuser/upload</span><br><span class="line">chmod 755 /data/sftp/sftpuser1/upload</span><br></pre></td></tr></table></figure>

<p>修改 <code>sshd_config</code> 配置</p>
<figure class="highlight shell"><figcaption><span>/etc/ssh/sshd_config</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Subsystem      sftp    /usr/libexec/openssh/sftp-server</span></span><br><span class="line">Subsystem sftp internal-sftp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拒绝指定用户登录,不能放在Match user中</span></span><br><span class="line">DenyUsers user1 user2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">maxsessions 10</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">针对用户配置sftp, 多个用户可重复配置以下内容，或者通过针对组配置sftp</span></span><br><span class="line">Match user sftpuser1,sftpuser2</span><br><span class="line">    # 该行强制执行内部 sftp，并忽略任何 ~/.ssh/rc 文件中的命令。</span><br><span class="line">   ForceCommand internal-sftp</span><br><span class="line">	</span><br><span class="line">   ChrootDirectory /data/sftp/sftpuser1</span><br><span class="line">	</span><br><span class="line"><span class="meta prompt_">   # </span><span class="language-bash">下面两项是与安全有关</span></span><br><span class="line">    AllowTcpForwarding no</span><br><span class="line">    X11Forwarding no</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">针对用户组配置sftp</span></span><br><span class="line">Match Group sftp,sftp1</span><br><span class="line">    ForceCommand internal-sftp</span><br><span class="line">    </span><br><span class="line">    # %h 代表用户 home 目录，%u 代表用户名。</span><br><span class="line">    ChrootDirectory /data/sftp/%u</span><br></pre></td></tr></table></figure>
<blockquote>
<p>修改配置后，重启 <code>sshd</code> 服务生效<br><code>systemctl restart sshd</code></p>
</blockquote>
<h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><h4 id="Unable-to-open-permission-denied"><a href="#Unable-to-open-permission-denied" class="headerlink" title="Unable to open .: permission denied"></a>Unable to open .: permission denied</h4><p><strong>解决方法</strong>： 如果启动了 <code>selinux</code>， 关闭 <code>selinux</code></p>
<h4 id="Couldn’t-read-packet-Connection-reset-by-peer"><a href="#Couldn’t-read-packet-Connection-reset-by-peer" class="headerlink" title="Couldn’t read packet: Connection reset by peer"></a>Couldn’t read packet: Connection reset by peer</h4><p><strong>问题原因</strong>: <code>ChrootDirectory (/data/sftp/sftpuser1)</code> 目录及所有上级目录的用户和组必须为 <code>root</code>，权限最多为 755, <a href="#%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE">参考说明</a></p>
<h4 id="remote-readdir-“-x2F-“-Permission-denied"><a href="#remote-readdir-“-x2F-“-Permission-denied" class="headerlink" title="remote readdir(“&#x2F;“): Permission denied"></a>remote readdir(“&#x2F;“): Permission denied</h4><p><strong>问题原因</strong>: sftp 用户对 <code>ChrootDirectory (/data/sftp/sftpuser1)</code> 目录要有读取权限，<a href="#%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE">参考说明</a></p>
<h3 id="禁用-sftp-功能"><a href="#禁用-sftp-功能" class="headerlink" title="禁用 sftp 功能"></a>禁用 sftp 功能</h3><p>修改 <code>sshd</code> 配置文件 <code>/etc/ssh/sshd_config</code>,注释以下内容</p>
<figure class="highlight shell"><figcaption><span>/etc/ssh/sshd_config</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Subsystem sftp /usr/libexec/openssh/sftp-server</span></span><br></pre></td></tr></table></figure>
<p>修改配置文件后重启 <code>sshd</code> 服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure>
<p>使用<code>sftp</code>登录时会报错 ： <code>Error:	Could not connect to server</code></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>sftp</tag>
      </tags>
  </entry>
  <entry>
    <title>spinnaker 常见用法</title>
    <url>/202211101344/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Spinnaker 1.29.0</li>
<li>Kubernetes 1.24.7</li>
</ul>
<h1 id="Spinnaker-引用-Kubernetes-中的-Namespace"><a href="#Spinnaker-引用-Kubernetes-中的-Namespace" class="headerlink" title="Spinnaker 引用 Kubernetes 中的 Namespace"></a>Spinnaker 引用 Kubernetes 中的 Namespace</h1><p>Kubernetes 中的 Namespace，对应 Spinnaker 中的 Application，当 <strong>在 Kubernetes 中创建 Namespace ，并在此 Namespace 创建资源后</strong>，Spinnaker 会自动读取到此 Namespace，并显示在 Applications 中。</p>
<h1 id="Pipelines-中引用-Docker-Registry-类型的触发器"><a href="#Pipelines-中引用-Docker-Registry-类型的触发器" class="headerlink" title="Pipelines 中引用 Docker Registry 类型的触发器"></a>Pipelines 中引用 Docker Registry 类型的触发器</h1><p>在 Pipelines 中配置 Docker Registry 类型的触发器，并在后面的 Stage 中自动引用。</p>
<ol>
<li><p>在要配置的 Pipeline 的 <code>Configuration</code> 部分，配置 <code>Automated Triggers</code>，选择 <code>type</code> 为 <code>Docker Registry</code><br> <img src="https://i.csms.tech/img_85.png"></p>
<ul>
<li>Registry Name - 为 <a href="https://csms.tech/202210121639/#添加自建的私有-docker-镜像源">Halyard 中配置的 Docker Registry 的认证信息</a> 的名称</li>
<li>Organization - 对应 Docker Registry （如 Harbor） 中的 Projects</li>
</ul>
</li>
<li><p>Stage 中使用以下方式引用镜像</p>
<p> <code>image: &#39;$&#123;trigger.artifacts[0].reference&#125;&#39;</code></p>
<p> <code>$&#123;trigger&#125;</code> 为镜像名称，当一个镜像名下有多个不同标签的镜像时，<code>$&#123;trigger.artifacts[0]</code> 表示第一个镜像，依此类推。<code>$&#123;trigger.artifacts[0].reference&#125;</code> 值为第一个镜像的完整镜像名加标签。<br> <img src="https://i.csms.tech/img_86.png"></p>
</li>
</ol>
<span id="more"></span>   ]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Spinnaker</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh 常见配置</title>
    <url>/202208171033/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos 7</li>
</ul>
<h1 id="常见配置"><a href="#常见配置" class="headerlink" title="常见配置"></a>常见配置</h1><p>登录服务器，经常遇见以下提示信息，说明有主机一直在尝试暴力破解用户名密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">There were 696 failed login attempts since the last successful login.</span><br></pre></td></tr></table></figure>

<p>查看登录失败的用户名和 ip 地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep <span class="string">&quot;Failed password for invalid user &quot;</span> /var/log/secure | awk <span class="string">&#x27;&#123;print $11,$13&#125;&#x27;</span> | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c | <span class="built_in">sort</span> -k1 -n</span></span><br><span class="line">      3 wangli 47.74.0.77</span><br><span class="line">      3 work 47.74.0.77</span><br><span class="line">      3 yt 47.74.0.77</span><br><span class="line">      3 yx 47.74.0.77</span><br><span class="line">      3 yyz 47.74.0.77</span><br><span class="line">      3 zabbix 47.74.0.77</span><br><span class="line">      3 zd 47.74.0.77</span><br><span class="line">      3 zhangfan 47.74.0.77</span><br><span class="line">      3 zxy 47.74.0.77</span><br><span class="line">      4 client003 47.74.0.77</span><br><span class="line">      4 client004 47.74.0.77</span><br><span class="line">      4 dell 47.74.0.77</span><br><span class="line">      4 ftpuser 47.74.0.77</span><br><span class="line">      4 inspur 47.74.0.77</span><br><span class="line">      4 wang 47.74.0.77</span><br><span class="line">      5 git 47.74.0.77</span><br><span class="line">      5 nagios 47.74.0.77</span><br><span class="line">      5 testuser 47.74.0.77</span><br><span class="line">      6 omnisky 47.74.0.77</span><br><span class="line">      7 oracle 47.74.0.77</span><br><span class="line">      8 jenkins 47.74.0.77</span><br><span class="line">     10 hadoop 47.74.0.77</span><br><span class="line">     10 postgres 47.74.0.77</span><br><span class="line">     11 ubuntu 47.74.0.77</span><br><span class="line">     11 user 47.74.0.77</span><br><span class="line">     12 admin 47.74.0.77</span><br><span class="line">     15 test 47.74.0.77</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="sshd-加固配置建议"><a href="#sshd-加固配置建议" class="headerlink" title="sshd 加固配置建议"></a>sshd 加固配置建议</h2><p>修改 <code>sshd</code> 配置文件 <code>/etc/ssh/sshd_config</code>，更改以下配置</p>
<ul>
<li><code>sshd</code> 默认端口 22 改为其他端口</li>
<li>禁止 <code>root</code> 用户登录，创建其他普通用户以登录系统，普通用户登录后有需要再切换到 <code>root</code></li>
</ul>
<figure class="highlight shell"><figcaption><span>/etc/ssh/sshd_config</span></figcaption><table><tr><td class="code"><pre><span class="line">Port 30000</span><br><span class="line">PermitRootLogin no</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>修改配置后重启 <code>sshd</code> 服务生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure>

<p>如果可以安全的保存秘钥，也可以使用秘钥登录，禁止用户名密码登录，具体配置可参考：<a href="https://blog.51cto.com/u_15061935/2652298">ssh 秘钥登录</a></p>
<p>若使用密码登陆，建议 <a href="/202208171501/" title="配置 fail2ban 防止暴力破解">配置 fail2ban 防止暴力破解</a></p>
<h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><h2 id="Could-not-load-host-key"><a href="#Could-not-load-host-key" class="headerlink" title="Could not load host key"></a>Could not load host key</h2><p>docker 容器中安装 <code>openssh-server</code> 后，使用命令 <code>/usr/sbin/sshd -D</code> 启动 <code>sshd</code> 服务，通常会报以下错误</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">/usr/sbin/sshd</span></span><br><span class="line">Could not load host key: /etc/ssh/ssh_host_rsa_key</span><br><span class="line">Could not load host key: /etc/ssh/ssh_host_ecdsa_key</span><br><span class="line">Could not load host key: /etc/ssh/ssh_host_ed25519_key</span><br></pre></td></tr></table></figure>

<p>执行以下命令解决:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -q -t rsa -b 2048 -f /etc/ssh/ssh_host_rsa_key -N &#x27;&#x27; </span><br><span class="line">ssh-keygen -q -t ecdsa -f /etc/ssh/ssh_host_ecdsa_key -N &#x27;&#x27;</span><br><span class="line">ssh-keygen -t dsa -f /etc/ssh/ssh_host_ed25519_key  -N &#x27;&#x27;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>腾讯云相关配置</title>
    <url>/202305260914/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Python-SDK"><a href="#Python-SDK" class="headerlink" title="Python SDK"></a>Python SDK</h1><p><a href="https://www.tencentcloud.com/zh/document/product/494/7244">Python SDK 官网使用说明</a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install tencentcloud-sdk-python-intl-en</span><br></pre></td></tr></table></figure>

<h2 id="预热功能"><a href="#预热功能" class="headerlink" title="预热功能"></a>预热功能</h2><p><a href="https://console.tencentcloud.com/api/explorer?Product=vod&Version=2018-07-17&Action=PushUrlCache">参考文档</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> tencentcloud.common <span class="keyword">import</span> credential</span><br><span class="line"><span class="keyword">from</span> tencentcloud.common.profile.client_profile <span class="keyword">import</span> ClientProfile</span><br><span class="line"><span class="keyword">from</span> tencentcloud.common.profile.http_profile <span class="keyword">import</span> HttpProfile</span><br><span class="line"><span class="keyword">from</span> tencentcloud.common.exception.tencent_cloud_sdk_exception <span class="keyword">import</span> TencentCloudSDKException</span><br><span class="line"><span class="keyword">from</span> tencentcloud.vod.v20180717 <span class="keyword">import</span> vod_client, models</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 实例化一个认证对象，入参需要传入腾讯云账户 SecretId 和 SecretKey，此处还需注意密钥对的保密</span></span><br><span class="line">    <span class="comment"># 代码泄露可能会导致 SecretId 和 SecretKey 泄露，并威胁账号下所有资源的安全性。密钥可前往官网控制台 https://console.tencentcloud.com/capi 进行获取</span></span><br><span class="line">    cred = credential.Credential(<span class="string">&quot;SecretId&quot;</span>, <span class="string">&quot;SecretKey&quot;</span>)</span><br><span class="line">    <span class="comment"># 实例化一个http选项，可选的，没有特殊需求可以跳过</span></span><br><span class="line">    httpProfile = HttpProfile()</span><br><span class="line">    httpProfile.endpoint = <span class="string">&quot;vod.tencentcloudapi.com&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 实例化一个client选项，可选的，没有特殊需求可以跳过</span></span><br><span class="line">    clientProfile = ClientProfile()</span><br><span class="line">    clientProfile.httpProfile = httpProfile</span><br><span class="line">    <span class="comment"># 实例化要请求产品的client对象,clientProfile是可选的</span></span><br><span class="line">    client = vod_client.VodClient(cred, <span class="string">&quot;&quot;</span>, clientProfile)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 实例化一个请求对象,每个接口都会对应一个request对象</span></span><br><span class="line">    req = models.PushUrlCacheRequest()</span><br><span class="line">    params = &#123;</span><br><span class="line">        <span class="string">&quot;Urls&quot;</span>: [ <span class="string">&quot;https://test.domain.com/z44R8F4D.ts&quot;</span>, <span class="string">&quot;https://test.domain.com/z70TBUet.ts&quot;</span>, <span class="string">&quot;https://test.domain.com/zB2OEC1t.ts&quot;</span>, </span><br><span class="line">                  <span class="string">&quot;https://test.domain.com/zZw91TCL.ts&quot;</span>, <span class="string">&quot;https://test.domain.com/zbJ9U6Su.ts&quot;</span>, <span class="string">&quot;https://test.domain.com/zbvqkOMN.ts&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    req.from_json_string(json.dumps(params))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回的resp是一个PushUrlCacheResponse的实例，与请求对象对应</span></span><br><span class="line">    resp = client.PushUrlCache(req)</span><br><span class="line">    <span class="comment"># 输出json格式的字符串回包</span></span><br><span class="line">    <span class="built_in">print</span>(resp.to_json_string())</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> TencentCloudSDKException <span class="keyword">as</span> err:</span><br><span class="line">    <span class="built_in">print</span>(err)</span><br></pre></td></tr></table></figure>

<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.tencentcloud.com/zh/document/product/494/7244">Python SDK 官网使用说明</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>云平台</category>
        <category>腾讯云</category>
      </categories>
      <tags>
        <tag>云平台</tag>
      </tags>
  </entry>
  <entry>
    <title>常用工具下载链接</title>
    <url>/202302041721/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="常用工具下载目录"><a href="#常用工具下载目录" class="headerlink" title="常用工具下载目录"></a>常用工具下载目录</h1><p><a href="https://s.csms.tech/file/">常用工具下载目录</a></p>
<p>包含常用工具：</p>
<ul>
<li><p>Xshell 7.0.0<br><a href="!--swig%EF%BF%BC2--">使用参考</a></p>
</li>
<li><p>fiddler-linux.zip<br><a href="!--swig%EF%BF%BC3--">使用参考</a></p>
</li>
<li><p>Fiddler Everywhere 4.2.1</p>
</li>
<li><p>cwrsync_6.2.4_x64_free<br><a href="!--swig%EF%BF%BC4--">使用参考</a></p>
</li>
<li><p>FileZilla_3.62.2_win64</p>
</li>
<li><p>openvpn-connect-3.3.7.2979_signed</p>
</li>
<li><p>VMware-workstation-full-17.0.0-20800274</p>
</li>
<li><p>CentOS-7-x86_64-Minimal-2207-02</p>
</li>
</ul>
<h1 id="常用工具链接"><a href="#常用工具链接" class="headerlink" title="常用工具链接"></a>常用工具链接</h1><h2 id="m3u8-视频在线播放器"><a href="#m3u8-视频在线播放器" class="headerlink" title="m3u8 视频在线播放器"></a>m3u8 视频在线播放器</h2><ul>
<li><a href="https://www.hlsplayer.net/">https://www.hlsplayer.net/</a></li>
<li><a href="https://m3u8-player.com/">https://m3u8-player.com/</a></li>
</ul>
<h2 id="架构图在线绘制工具"><a href="#架构图在线绘制工具" class="headerlink" title="架构图在线绘制工具"></a>架构图在线绘制工具</h2><ul>
<li><a href="https://app.diagrams.net/">https://app.diagrams.net/</a></li>
</ul>
<h2 id="代码或文本比对在线工具"><a href="#代码或文本比对在线工具" class="headerlink" title="代码或文本比对在线工具"></a>代码或文本比对在线工具</h2><ul>
<li><a href="https://tool.oschina.net/diff/">https://tool.oschina.net/diff/</a></li>
</ul>
<h2 id="随机密码或字符串在线生成"><a href="#随机密码或字符串在线生成" class="headerlink" title="随机密码或字符串在线生成"></a>随机密码或字符串在线生成</h2><ul>
<li><a href="https://suijimimashengcheng.bmcx.com/">https://suijimimashengcheng.bmcx.com/</a></li>
</ul>
<p>可以使用 shell 命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">openssl rand -<span class="built_in">base64</span></span></span><br><span class="line">Usage: rand [options] num</span><br><span class="line">where options are</span><br><span class="line">-out file             - write to file</span><br><span class="line">-engine e             - use engine e, possibly a hardware device.</span><br><span class="line">-rand file:file:... - seed PRNG from files</span><br><span class="line">-base64               - base64 encode output</span><br><span class="line">-hex                  - hex encode output</span><br></pre></td></tr></table></figure>
<p>具体示例，生成 8 位随机字符串</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">openssl rand -<span class="built_in">base64</span> 8</span></span><br><span class="line">HEoK6ZRtD7o=</span><br></pre></td></tr></table></figure>

<h2 id="域名-whois-信息在线查询"><a href="#域名-whois-信息在线查询" class="headerlink" title="域名 whois 信息在线查询"></a>域名 whois 信息在线查询</h2><ul>
<li><a href="https://whois.chinaz.com/">https://whois.chinaz.com/</a></li>
</ul>
<h2 id="查询出口-ip-地址"><a href="#查询出口-ip-地址" class="headerlink" title="查询出口 ip 地址"></a>查询出口 ip 地址</h2><ul>
<li><a href="https://whoer.net/zh">https://whoer.net/zh</a></li>
<li><a href="https://whatismyipaddress.com/">https://whatismyipaddress.com/</a></li>
</ul>
<h2 id="JSON-在线校验及格式化"><a href="#JSON-在线校验及格式化" class="headerlink" title="JSON 在线校验及格式化"></a>JSON 在线校验及格式化</h2><ul>
<li><a href="https://jsoneditoronline.org/">https://jsoneditoronline.org/</a></li>
</ul>
<h2 id="证书工具"><a href="#证书工具" class="headerlink" title="证书工具"></a>证书工具</h2><h3 id="查询证书和私钥是否匹配"><a href="#查询证书和私钥是否匹配" class="headerlink" title="查询证书和私钥是否匹配"></a>查询证书和私钥是否匹配</h3><ul>
<li><a href="https://myssl.com/match_key.html">https://myssl.com/match_key.html</a></li>
</ul>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title>tcp/udp 端口连通性测试</title>
    <url>/202210241127/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Centos-下安装"><a href="#Centos-下安装" class="headerlink" title="Centos 下安装"></a>Centos 下安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y nc</span><br></pre></td></tr></table></figure>

<h3 id="Windows-下安装"><a href="#Windows-下安装" class="headerlink" title="Windows 下安装"></a>Windows 下安装</h3><p>Windows 下需要 <a href="https://eternallybored.org/misc/netcat/">下载 netcat 运行程序</a></p>
<p>下载后直接解压，将 <code>nc.exe</code> 复制到 <code>C:\Windows\System32</code> 目录或将 <code>nc.exe</code> 添加到系统 path 环境变量中</p>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>-v</code></td>
<td>打印详细信息</td>
<td></td>
</tr>
<tr>
<td><code>-u</code></td>
<td>使用 UDP 协议，默认为 TCP 协议</td>
<td></td>
</tr>
</tbody></table>
<h3 id="测试-udp-端口连通性"><a href="#测试-udp-端口连通性" class="headerlink" title="测试 udp 端口连通性"></a>测试 udp 端口连通性</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nc -vuz ip/domain 8472</span></span><br><span class="line">Ncat: Version 7.50 ( https://nmap.org/ncat )</span><br><span class="line">Ncat: Connected to ip:8472.</span><br><span class="line">Ncat: UDP packet sent successfully</span><br><span class="line">Ncat: 1 bytes sent, 0 bytes received in 2.01 seconds.</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>netcat</tag>
      </tags>
  </entry>
  <entry>
    <title>windows 中的 zip 类型压缩文件，linux 中 unzip 解压后文件名乱码</title>
    <url>/202208240911/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>centos 7</li>
</ul>
<p>在 windows 系统添加到 zip 类型的压缩文件，上传到 Linux，使用 <code>unzip</code> 解压后，文件名乱码  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">unzip 测试文档.zip</span></span><br><span class="line">Archive:  测试文档.zip</span><br><span class="line">  inflating: ═°╦▐╫╩╘┤╬┤╝╙├▄├╗╙╨╙├╡╜╡─┴╨▒э.csv</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>主要的原因是因为 <code>unzip</code> 在解压的时候会将编码转化为其内部默认的编码，而默认的编码根本不支持中文 <code>CP936</code> 编码。因此我们需要在解压的时候明确的指定需要使用的编码。  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">unzip -O CP936 测试文档.zip</span> </span><br><span class="line">Archive:  测试文档.zip</span><br><span class="line">  inflating: 测试文档.csv  </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>unzip</tag>
      </tags>
  </entry>
  <entry>
    <title>vim</title>
    <url>/202208181117/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Centos 7</li>
</ul>
<h3 id="vim-配置"><a href="#vim-配置" class="headerlink" title="vim 配置"></a>vim 配置</h3><p><code>vim</code> 启动时会读取 <code>/etc/vimrc</code>（全局配置） 和 <code>~/.vimrc</code> （用户配置）</p>
<p>常用配置如下，使用 <code>&quot;</code> 注释</p>
<figure class="highlight shell"><figcaption><span>/etc/vimrc</span></figcaption><table><tr><td class="code"><pre><span class="line">&quot; 自动缩进 </span><br><span class="line">set ai</span><br><span class="line">set autoindent</span><br><span class="line"></span><br><span class="line">&quot; 保存历史命令数量</span><br><span class="line">set history=50</span><br><span class="line"></span><br><span class="line">&quot; 右下角显示当前鼠标位置（行列数）</span><br><span class="line">set ruler</span><br><span class="line"></span><br><span class="line">&quot; 鼠标位置所在行显示下划线</span><br><span class="line">set cursorline</span><br><span class="line"></span><br><span class="line">&quot; 开启语法高亮</span><br><span class="line">syntax on</span><br><span class="line"></span><br><span class="line">&quot; 高亮搜索结果</span><br><span class="line">set hlsearch</span><br><span class="line"></span><br><span class="line">&quot; 搜索时不区分大小写</span><br><span class="line">set ignorecase</span><br><span class="line"></span><br><span class="line">&quot; 将 tab 转换为空格</span><br><span class="line">set expandtab</span><br><span class="line"></span><br><span class="line">&quot; tab 转换为4个空格</span><br><span class="line">set tabstop=4</span><br><span class="line"></span><br><span class="line">&quot; 删除时，可以一次删除4个空格</span><br><span class="line">set softtabstop=4</span><br><span class="line"></span><br><span class="line">&quot; 显示行数</span><br><span class="line">set nu</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h3 id="vim-常见用法"><a href="#vim-常见用法" class="headerlink" title="vim 常见用法"></a>vim 常见用法</h3><h4 id="读写加解密文件"><a href="#读写加解密文件" class="headerlink" title="读写加解密文件"></a>读写加解密文件</h4><h5 id="创建新的加密文件"><a href="#创建新的加密文件" class="headerlink" title="创建新的加密文件"></a>创建新的加密文件</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim -x mysecfile</span><br></pre></td></tr></table></figure>
<p>使用 <code>vim</code> 的 <code>-x</code> 选项，将创建一个新的文件，并提示需要设置加密密码，输入 2 次密码后，将进入 <code>vim</code> 界面，编辑完内容，保存后，产生的文件为 <code>vim</code> 加密的文件，使用 <code>file</code> 命令查看，显示如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">file mysecfile</span></span><br><span class="line">mysecfile: Vim encrypted file data</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>之后要使用 <code>vim</code> 编辑此文件，都要按照提示输入密码，如果未输入密码或者输入的密码错误，打开的文件内容将显示为乱码，只有输入正确的密码，才能看到正确的文件内容，如果使用其他编辑器，可以直接打开文件，但是内容乱码  </p>
<h5 id="加密已有文件"><a href="#加密已有文件" class="headerlink" title="加密已有文件"></a>加密已有文件</h5><p>对于已经存在的未加密文件，使用 <code>vim</code> 的 <code>-x</code> 选项时，会要求输入密码，此时不输入密码，或者随便输入，都会打开正确的文件内容(因为文件并未被 <code>vim</code> 加密保护)  </p>
<p>对于已经存在的未加密文件，若要使用 <code>vim</code> 进行加密，可以在 <code>vim</code> 打开文件后，使用 <code>vim</code> 的 <code>X</code> 命令对文件进行加密。具体操作为： 在 <code>vim</code> 的一般模式下（按 <code>Esc</code> 进入），输入 </p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">X</span></span><br></pre></td></tr></table></figure>
<p>确定后 <code>vim</code> 会提示输入 2 次密码，完成加密，最后保存文件</p>
<figure class="highlight shell"><figcaption><span>vim</span></figcaption><table><tr><td class="code"><pre><span class="line">:wq</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>对于 <code>vim</code> 已经加密的文件，如果使用 <code>vim</code> 打开时输入错误的密码或者未输入密码，打开文件显示乱码，此时如果对文件进行了保存，会导致乱码被保存为文件内容，导致文件内容丢失</strong></p>
</blockquote>
<h5 id="文件解密"><a href="#文件解密" class="headerlink" title="文件解密"></a>文件解密</h5><p>对 <code>vim</code> 已加密的文件，需要解密的话，在正确打开文件后，可以通过 <a href="#%E5%8A%A0%E5%AF%86%E5%B7%B2%E6%9C%89%E6%96%87%E4%BB%B6">加密已有文件</a> 中的步骤，将文件密码设置为空即可<br>或者正确打开加密文件后，进入一般模式下，执行以下命令</p>
<figure class="highlight shell"><figcaption><span>vim</span></figcaption><table><tr><td class="code"><pre><span class="line">:set key=</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Vmware workstation 使用</title>
    <url>/202304031041/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Vmware workstation 17</li>
</ul>
<p><a href="!--swig%EF%BF%BC3--">其他下载地址</a></p>
<p>激活密钥： NZ4RR-FTK5H-H81C1-Q30QH-1V2LA</p>
<h1 id="Centos7-server-中安装使用-Vmware-workstation"><a href="#Centos7-server-中安装使用-Vmware-workstation" class="headerlink" title="Centos7 server 中安装使用 Vmware workstation"></a>Centos7 server 中安装使用 Vmware workstation</h1><p><a href="https://www.51ittech.com/knowledge-base/centos-7-install-vmware-workstation-15/">Centos 7 server版本（无图形界面）安装使用 Vmware workstation 参考链接</a></p>
<h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><h2 id="VMware-Workstation-and-Hyper-V-are-not-compatible-Remove-the-Hyper-V-role-from-the-system-before-running-VMware-Workstation"><a href="#VMware-Workstation-and-Hyper-V-are-not-compatible-Remove-the-Hyper-V-role-from-the-system-before-running-VMware-Workstation" class="headerlink" title="VMware Workstation and Hyper-V are not compatible. Remove the Hyper-V role from the system before running VMware Workstation."></a>VMware Workstation and Hyper-V are not compatible. Remove the Hyper-V role from the system before running VMware Workstation.</h2><p>aws workspace 中不兼容 Vmware workstation</p>
<h2 id="Failed-to-start-SYSV-This-service-starts-and-stops-VMware-services"><a href="#Failed-to-start-SYSV-This-service-starts-and-stops-VMware-services" class="headerlink" title="Failed to start SYSV: This service starts and stops VMware services."></a>Failed to start SYSV: This service starts and stops VMware services.</h2><p>参考 <a href="#Centos7-server-%E4%B8%AD%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8-Vmware-workstation">Centos7 server 中安装使用 Vmware workstation</a> ，安装后，vmware 无法启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">/etc/rc.d/init.d/vmware start</span></span><br><span class="line">Starting vmware (via systemctl):  Job for vmware.service failed because the control process exited with error code. See &quot;systemctl status vmware.service&quot; and &quot;journalctl -xe&quot; for details.</span><br><span class="line">                                                           [FAILED]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">journalctl -xe -u vmware</span></span><br><span class="line">-- </span><br><span class="line">-- Unit vmware.service has failed.</span><br><span class="line">-- </span><br><span class="line">-- The result is failed.</span><br><span class="line">May 02 11:13:39 k8s-uat-xhy-mysql-new systemd[1]: Unit vmware.service entered failed state.</span><br><span class="line">May 02 11:13:39 k8s-uat-xhy-mysql-new systemd[1]: vmware.service failed.</span><br><span class="line">May 02 11:19:37 k8s-uat-xhy-mysql-new systemd[1]: Starting SYSV: This service starts and stops VMware services...</span><br><span class="line">-- Subject: Unit vmware.service has begun start-up</span><br><span class="line">-- Defined-By: systemd</span><br><span class="line">-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel</span><br><span class="line">-- </span><br><span class="line">-- Unit vmware.service has begun starting up.</span><br><span class="line">May 02 11:19:37 k8s-uat-xhy-mysql-new vmware[22226]: Starting VMware services:</span><br><span class="line">May 02 11:19:37 k8s-uat-xhy-mysql-new vmware[22226]: Virtual machine monitor[FAILED]</span><br><span class="line">May 02 11:19:37 k8s-uat-xhy-mysql-new vmware[22226]: Virtual machine communication interface[  OK  ]</span><br><span class="line">May 02 11:19:37 k8s-uat-xhy-mysql-new vmware[22226]: VM communication interface socket family[  OK  ]</span><br><span class="line">May 02 11:19:37 k8s-uat-xhy-mysql-new vmware[22226]: Virtual ethernet[FAILED]</span><br><span class="line">May 02 11:19:37 k8s-uat-xhy-mysql-new vmware[22226]: VMware Authentication Daemon[  OK  ]</span><br><span class="line">May 02 11:19:37 k8s-uat-xhy-mysql-new systemd[1]: vmware.service: control process exited, code=exited status=1</span><br><span class="line">May 02 11:19:37 k8s-uat-xhy-mysql-new systemd[1]: Failed to start SYSV: This service starts and stops VMware services.</span><br><span class="line">-- Subject: Unit vmware.service has failed</span><br><span class="line">-- Defined-By: systemd</span><br><span class="line">-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel</span><br><span class="line">-- </span><br><span class="line">-- Unit vmware.service has failed.</span><br><span class="line">-- </span><br><span class="line">-- The result is failed.</span><br><span class="line">May 02 11:19:37 k8s-uat-xhy-mysql-new systemd[1]: Unit vmware.service entered failed state.</span><br><span class="line">May 02 11:19:37 k8s-uat-xhy-mysql-new systemd[1]: vmware.service failed.</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行以下命令 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Failed to start SYSV: This service starts and stops VMware services.](https://communities.vmware.com/t5/VMware-Workstation-Pro/Failed-to-start-SYSV-This-service-starts-and-stops-VMware/td-p/2318180)">[1]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vmware-modconfig --console --install-status</span></span><br><span class="line">[AppLoader] GLib does not have GSettings support.</span><br><span class="line">vmmon: unknown</span><br><span class="line">vmnet: unknown</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看内核版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">uname</span> -r</span></span><br><span class="line">3.10.0-1062.9.1.el7.x86_64</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://communities.vmware.com/t5/VMware-Workstation-Pro/Failed-to-start-SYSV-This-service-starts-and-stops-VMware/td-p/2318180">Failed to start SYSV: This service starts and stops VMware services.</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>vmware</tag>
      </tags>
  </entry>
  <entry>
    <title>SoftEther VPN 使用</title>
    <url>/202302070928/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="https://www.softether.org/4-docs">SoftEther VPN 官网手册</a></p>
<h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos7 5.4.221</li>
<li>SoftEther VPN Server 4.41</li>
<li>iptables</li>
</ul>
<p>SoftEther VPN Server 有两种模式，<code>Service Mode</code> 和 <code>User Mode</code>，本文档安装使用 <code>Service Mode</code> <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Operating Modes](https://www.softether.org/4-docs/1-manual/3._SoftEther_VPN_Server_Manual/3.2_Operating_Modes)">[1]</span></a></sup></p>
<ul>
<li><code>Service Mode</code> - 安装之后以系统服务的形式存在（被管理）</li>
<li><code>User Mode</code> - 安装之后不存在对应的服务，（管理员）用户直接通过进程管理，程序启动停止需要（管理员）用户手动停止相应进程</li>
</ul>
<h1 id="安装配置过程"><a href="#安装配置过程" class="headerlink" title="安装配置过程"></a>安装配置过程</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装依赖包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install gcc zlib-devel openssl-devel readline-devel ncurses-devel</span><br></pre></td></tr></table></figure>
<p><a href="https://www.softether.org/">参考链接</a> 下载最新的安装包，本文档使用版本 4.41 版本 <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Install on Linux and Initial Configurations](https://www.softether.org/4-docs/1-manual/7._Installing_SoftEther_VPN_Server/7.3_Install_on_Linux_and_Initial_Configurations)">[2]</span></a></sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://github.com/SoftEtherVPN/SoftEtherVPN_Stable/releases/download/v4.41-9782-beta/softether-vpnserver-v4.41-9782-beta-2022.11.17-linux-x64-64bit.tar.gz</span><br><span class="line"></span><br><span class="line">tar -xf softether-vpnserver-v4.41-9782-beta-2022.11.17-linux-x64-64bit.tar.gz</span><br><span class="line"></span><br><span class="line">cd vpnserver/</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用以下命令编译生成可执行文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
<p>将编译后的目录移动到 <code>/usr/local/</code> 下，并修改权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ..</span><br><span class="line">mv vpnserver /usr/local/</span><br><span class="line"></span><br><span class="line">cd /usr/local/vpnserver/</span><br><span class="line"></span><br><span class="line">chmod 600 *</span><br><span class="line"></span><br><span class="line">chmod 700 vpncmd</span><br><span class="line">chmod 700 vpnserver</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>使用 <code>vpncmd check</code> 命令检查 vpn server 是否可以正常运行。在 <code>/usr/local/vpnserver/</code> 目录下执行 <code>./vpncmd</code>，根据提示选择 3 (<code>3. Use of VPN Tools (certificate creation and Network Traffic Speed Test Tool)</code>)， 然后执行 <code>check</code> 命令进行检查。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./vpncmd</span></span><br><span class="line">By using vpncmd program, the following can be achieved. </span><br><span class="line"></span><br><span class="line">1. Management of VPN Server or VPN Bridge </span><br><span class="line">2. Management of VPN Client</span><br><span class="line">3. Use of VPN Tools (certificate creation and Network Traffic Speed Test Tool)</span><br><span class="line"></span><br><span class="line">Select 1, 2 or 3: 3</span><br><span class="line"></span><br><span class="line">VPN Tools&gt;check</span><br><span class="line">Check command - Check whether SoftEther VPN Operation is Possible</span><br><span class="line">---------------------------------------------------</span><br><span class="line">SoftEther VPN Operation Environment Check Tool</span><br><span class="line"></span><br><span class="line">Copyright (c) SoftEther VPN Project.</span><br><span class="line">All Rights Reserved.</span><br><span class="line"></span><br><span class="line">If this operation environment check tool is run on a system and that system passes, it is most likely that SoftEther VPN software can operate on that system. This check may take a while. Please wait...</span><br><span class="line"></span><br><span class="line">Checking &#x27;Kernel System&#x27;... </span><br><span class="line">              Pass</span><br><span class="line">Checking &#x27;Memory Operation System&#x27;... </span><br><span class="line">              Pass</span><br><span class="line">Checking &#x27;ANSI / Unicode string processing system&#x27;... </span><br><span class="line">              Pass</span><br><span class="line">Checking &#x27;File system&#x27;... </span><br><span class="line">              Pass</span><br><span class="line">Checking &#x27;Thread processing system&#x27;... </span><br><span class="line">              Pass</span><br><span class="line">Checking &#x27;Network system&#x27;... </span><br><span class="line">              Pass</span><br><span class="line"></span><br><span class="line">All checks passed. It is most likely that SoftEther VPN Server / Bridge can operate normally on this system.</span><br><span class="line"></span><br><span class="line">The command completed successfully.</span><br></pre></td></tr></table></figure>
<p>执行检查后输出 <code>All checks passed. It is most likely that SoftEther VPN Server / Bridge can operate normally on this system.</code> ，说明系统可正常满足 vpn server 运行的条件。</p>
<p>根据以下内容生成服务启动脚本，将 vpn server 以 service 的形式运行</p>
<figure class="highlight shell"><figcaption><span>/etc/init.d/softether-vpn-server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">chkconfig: 2345 99 01</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">description: SoftEther VPN Server</span></span><br><span class="line">DAEMON=/usr/local/vpnserver/vpnserver</span><br><span class="line">LOCK=/var/lock/subsys/vpnserver</span><br><span class="line">test -x $DAEMON || exit 0</span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">start)</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">DAEMON start</span></span><br><span class="line">touch $LOCK</span><br><span class="line">;;</span><br><span class="line">stop)</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">DAEMON stop</span></span><br><span class="line">rm $LOCK</span><br><span class="line">;;</span><br><span class="line">restart)</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">DAEMON stop</span></span><br><span class="line">sleep 3</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">DAEMON start</span></span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">echo &quot;Usage: $0 &#123;start|stop|restart&#125;&quot;</span><br><span class="line">exit 1</span><br><span class="line">esac</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>
<p>给服务脚本添加可执行权限，并配置开机启动，之后可以通过 <code>systemctl</code> 管理服务状态。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> 755 /etc/init.d/softether-vpn-server</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl daemon-reload</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl status softether-vpn-server</span></span><br><span class="line">● softether-vpn-server.service - SYSV: SoftEther VPN Server</span><br><span class="line">   Loaded: loaded (/etc/rc.d/init.d/softether-vpn-server; bad; vendor preset: disabled)</span><br><span class="line">   Active: inactive (dead)</span><br><span class="line">     Docs: man:systemd-sysv-generator(8)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl <span class="built_in">enable</span> softether-vpn-server</span></span><br><span class="line">softether-vpn-server.service is not a native service, redirecting to /sbin/chkconfig.</span><br><span class="line">Executing /sbin/chkconfig softether-vpn-server on</span><br></pre></td></tr></table></figure>

<p>防火墙添加以下配置 <sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Listener Ports](https://www.softether.org/4-docs/1-manual/3._SoftEther_VPN_Server_Manual/3.3_VPN_Server_Administration)">[4]</span></a></sup></p>
<figure class="highlight shell"><figcaption><span>/etc/sysconfig/iptables</span></figcaption><table><tr><td class="code"><pre><span class="line">-A INPUT -m comment --comment &quot;vpn&quot; -m multiport -p tcp --dports 443,1194,5555,992 -j ACCEPT</span><br><span class="line">-A INPUT -m comment --comment &quot;vpn&quot; -m multiport -p udp --dports 4500,500 -j ACCEPT</span><br></pre></td></tr></table></figure>

<p>启动服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start softether-vpn-server</span><br></pre></td></tr></table></figure>

<h2 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h2><p>安装完 vpn server 之后，可以通过 <code>SoftEther VPN Server Manager</code> 管理 VPN Server。windows 上下载 <a href="https://www.softether-download.com/en.aspx?product=softether"><code>SoftEther VPN Server Manager for Windows</code></a> <sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Initial Configurations](https://www.softether.org/4-docs/1-manual/7._Installing_SoftEther_VPN_Server/7.4_Initial_Configurations)">[5]</span></a></sup> </p>
<p>初次登陆后，建议设置管理员密码<br><img src="https://i.csms.tech/img_116.png"></p>
<p>默认情况下，只存在一个名为 <code>DEFAULT</code> 的 Virtual Hub 注册到了 VPN Server，可以使用此 Virtual Hub，或者删除它重新创建自己的 Virtual Hub。</p>
<p>根据提示选择要创建的的 VPN Server 的类型，普通 VPN 选择 <code>Remote Access VPN Server</code><br><img src="https://i.csms.tech/img_117.png"><br>根据提示，配置要创建的 Virtual Hub 的名称，接着会弹出 <code>Dynamic DNS Function</code> 配置界面。<code>Dynamic DNS Function</code> 的功能，会提供一个 <code>softether.net</code> 域的子域名，通过这个域名，可以解析到 VPN Server 的 IP 地址，如果服务器使用的是动态 IP，此解析会跟着变化。如果服务器只有内网 IP（云主机），此解析会自动解析到公网 IP。<br><img src="https://i.csms.tech/img_118.png"></p>
<p><code>Dynamic DNS Function</code> 配置完成后退出（<code>exit</code>），进入协议配置界面，此处启用所有协议(手机连接 VPN 需要)<br><img src="https://i.csms.tech/img_122.png"></p>
<p>创建 VPN 用户<br><img src="https://i.csms.tech/img_120.png"></p>
<p>回到管理界面后，选择刚刚创建的 Virtual Hub，点击 <code>Manage Virtual Hub</code> 按钮管理配置，选择 <code>Virtual NAT and Virtual DHCP Server(SecureNAT)</code>，启用 <code>SecureNAT</code>，否则客户端可以连接到 VPN Server，但是 VPN Server 不会分配 IP 地址给客户端。<br><img src="https://i.csms.tech/img_121.png"></p>
<h1 id="客户端连接"><a href="#客户端连接" class="headerlink" title="客户端连接"></a>客户端连接</h1><h2 id="android-自带-VPN-客户端连接"><a href="#android-自带-VPN-客户端连接" class="headerlink" title="android 自带 VPN 客户端连接"></a>android 自带 VPN 客户端连接</h2><p>打开手机 VPN 设置，添加 VPN 配置，主要配置以下项：</p>
<ul>
<li><code>Type</code> : <code>L2TP/IPSec PSK</code></li>
<li><code>Server address</code> : 填写 VPN 服务器 IP 或域名</li>
<li><code>IPSec pre-shared key</code> : 填写协议配置界面中配置的 <code>IPsec Pre-shared Key</code> 对应的值，本文档中为<code>vpn</code></li>
<li><code>Username</code> : 填写 VPN 的用户名</li>
<li><code>Password</code> : 填写 VPN 用户密码</li>
</ul>
<h2 id="ios-自带的-VPN-客户端连接"><a href="#ios-自带的-VPN-客户端连接" class="headerlink" title="ios 自带的 VPN 客户端连接"></a>ios 自带的 VPN 客户端连接</h2><p>在 IOS 的 <code>通用</code> –&gt; <code>VPN 与 设备管理</code> –&gt; <code>VPN</code> 中添加 VPN 配置，主要配置以下项：</p>
<ul>
<li><code>类型</code> ： <code>L2TP</code></li>
<li><code>服务器</code> : 填写 VPN 服务器 IP 或域名</li>
<li><code>账户</code> : 填写 VPN 的用户名</li>
<li><code>密码</code> : 填写 VPN 用户密码</li>
<li><code>密钥</code> : 填写协议配置界面中配置的 <code>IPsec Pre-shared Key</code> 对应的值，本文档中为<code>vpn</code></li>
</ul>
<h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><h2 id="VPN-Client-可以连接到-VPN-Server，但是-client-的出口-IP-未变"><a href="#VPN-Client-可以连接到-VPN-Server，但是-client-的出口-IP-未变" class="headerlink" title="VPN Client 可以连接到 VPN Server，但是 client 的出口 IP 未变"></a>VPN Client 可以连接到 VPN Server，但是 client 的出口 IP 未变</h2><p><strong>问题现象</strong></p>
<p>windows 使用 VPN Client 可以正常连接到 VPN Server，但是检查客户端系统的出口 IP，不是 VPN Server 的 IP。检查客户端系统的 IP 地址信息</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ipconfig</span> /all</span><br><span class="line">未知适配器 VPN - VPN Client:</span><br><span class="line"></span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">   描述. . . . . . . . . . . . . . . : VPN Client Adapter - VPN</span><br><span class="line">   物理地址. . . . . . . . . . . . . : <span class="number">5</span>E-<span class="number">7</span>F-<span class="number">99</span>-<span class="number">71</span>-<span class="number">74</span>-AF</span><br><span class="line">   DHCP 已启用 . . . . . . . . . . . : 是</span><br><span class="line">   自动配置已启用. . . . . . . . . . : 是</span><br><span class="line">   本地链接 IPv6 地址. . . . . . . . : fe80::<span class="number">7674</span>:<span class="number">9039</span>:eaca:<span class="number">5976</span>%<span class="number">52</span>(首选)</span><br><span class="line">   自动配置 IPv4 地址  . . . . . . . : <span class="number">169</span>.<span class="number">254</span>.<span class="number">160</span>.<span class="number">75</span>(首选)</span><br><span class="line">   子网掩码  . . . . . . . . . . . . : <span class="number">255</span>.<span class="number">255</span>.<span class="number">0</span>.<span class="number">0</span></span><br><span class="line">   默认网关. . . . . . . . . . . . . :</span><br><span class="line">   DHCPv6 IAID . . . . . . . . . . . : <span class="number">878608281</span></span><br><span class="line">   DHCPv6 客户端 DUID  . . . . . . . : <span class="number">00</span>-<span class="number">01</span>-<span class="number">00</span>-<span class="number">01</span>-<span class="number">29</span>-<span class="number">5</span>D-CA-<span class="number">62</span>-F4-<span class="number">39</span>-<span class="number">09</span>-<span class="number">4</span>B-<span class="number">1</span>C-<span class="number">6</span>A</span><br><span class="line">   DNS 服务器  . . . . . . . . . . . : fec0:<span class="number">0</span>:<span class="number">0</span>:ffff::<span class="number">1</span>%<span class="number">1</span></span><br><span class="line"><span class="function">                                       fec0:0:0:<span class="title">ffff</span>::2%1</span></span><br><span class="line"><span class="function">                                       <span class="title">fec0</span>:0:0:<span class="title">ffff</span>::3%1</span></span><br><span class="line"><span class="function">   <span class="title">TCPIP</span> 上的 <span class="title">NetBIOS</span>  . . . . . . . : 已启用</span></span><br></pre></td></tr></table></figure>
<p>VPN 适配器的 IP 地址为 <code>169.254.160.75</code>，说明客户端未获取 VPN 相应的 IP 地址。检查 VPN Server 配置的 <code>Virtual NAT and Virtual DHCP Server(SecureNAT)</code> 部分，看是否启用了 <code>SecureNAT</code>。启用后重新连接，查看 Windows 系统 IP 地址，看到已经正常分配到 VPN 的 IP，测试公网，变成了 VPN Server 的 IP。 </p>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.softether.org/4-docs/1-manual/3._SoftEther_VPN_Server_Manual/3.2_Operating_Modes">Operating Modes</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.softether.org/4-docs/1-manual/7._Installing_SoftEther_VPN_Server/7.3_Install_on_Linux_and_Initial_Configurations">Install on Linux and Initial Configurations</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.softether.org/4-docs/1-manual/7._Installing_SoftEther_VPN_Server/7.4_Initial_Configurations">Initial Configurations</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.softether.org/4-docs/1-manual/3._SoftEther_VPN_Server_Manual/3.3_VPN_Server_Administration">Listener Ports</a><a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.softether.org/4-docs/1-manual/7._Installing_SoftEther_VPN_Server/7.4_Initial_Configurations">Initial Configurations</a><a href="#fnref:5" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Tools</category>
        <category>VPN</category>
      </categories>
      <tags>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title>vsftpd 服务常见错误</title>
    <url>/202207261304/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="530-Login-incorrect"><a href="#530-Login-incorrect" class="headerlink" title="530 Login incorrect"></a>530 Login incorrect</h3><p><strong>报错信息</strong>： 登录时报错 <code>530 Login incorrect</code><br><strong>错误原因</strong>：</p>
<figure class="highlight shell"><figcaption><span>/etc/pam.d/vsftpd</span></figcaption><table><tr><td class="code"><pre><span class="line">auth  required pam_listfile.so item=user sense=deny file=/etc/vsftpd/ftpusers onerr=succeed </span><br></pre></td></tr></table></figure>
<p>默认情况下，&#x2F;etc&#x2F;vsftpd&#x2F;ftpusers里面的用户是被拒绝登录的，确保要登录的用户不在此文件中</p>
<figure class="highlight shell"><figcaption><span>/etc/pam.d/vsftpd</span></figcaption><table><tr><td class="code"><pre><span class="line">auth       required    pam_shells.so  </span><br></pre></td></tr></table></figure>
<p>此配置指定，只允许登录shell为<code>/etc/shells</code>中的shell的用户登录<br>如果用户shell为<code>/sbin/nologin</code>，则不允许登录，可改为<code>pam_nologin.so</code></p>
<span id="more"></span>

<h3 id="500-OOPS-vsftpd-refusing-to-run-with-writable-root-inside-chroot"><a href="#500-OOPS-vsftpd-refusing-to-run-with-writable-root-inside-chroot" class="headerlink" title="500 OOPS: vsftpd: refusing to run with writable root inside chroot()"></a>500 OOPS: vsftpd: refusing to run with writable root inside chroot()</h3><p><strong>错误原因</strong>: 从2.3.5之后，vsftpd增强了安全检查，如果用户被限定在了其主目录下，则该用户的主目录不能再具有写权限了！如果检查发现还有写权限，就会报该错误。<br><strong>解决方法1</strong>： 用户主目录取消写权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod a-w /data/ftpdir</span><br></pre></td></tr></table></figure>

<p><strong>解决方法2</strong>： 配置文件中增加以下配置</p>
<figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">allow_writeable_chroot=YES</span><br></pre></td></tr></table></figure>

<h3 id="500-OOPS-vsftpd-cannot-locate-user-specified-in-‘guest-username’-ftp"><a href="#500-OOPS-vsftpd-cannot-locate-user-specified-in-‘guest-username’-ftp" class="headerlink" title="500 OOPS: vsftpd: cannot locate user specified in ‘guest_username’:ftp"></a>500 OOPS: vsftpd: cannot locate user specified in ‘guest_username’:ftp</h3><p><strong>错误原因</strong>: 配置文件中启用了匿名用户登录，系统中没有ftp的匿名用户ftp<br><strong>解决方法1</strong>：<br>配置文件中禁用匿名用户登录，同时指定用户</p>
<figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">anonymous_enable=NO</span><br><span class="line">ftp_username=nobody</span><br></pre></td></tr></table></figure>

<h3 id="550-Create-directory-operation-failed"><a href="#550-Create-directory-operation-failed" class="headerlink" title="550 Create directory operation failed"></a>550 Create directory operation failed</h3><p><strong>错误原因</strong>: 匿名登录的用户不允许在ftp根目录下面新建对象，可以在根目录下面创建文件夹，如pub，并给ftp为属主，在pub下面新建文件</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a href="/202207231311/" title="vsftpd 服务常用配置说明">vsftpd 服务常用配置说明</a>  
</li>
<li><a href="/202207251638/" title="vsftpd 虚拟用户配置说明">vsftpd 虚拟用户配置说明</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>Vsftpd</tag>
      </tags>
  </entry>
  <entry>
    <title>rsyncd 服务</title>
    <url>/36f703dc/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync [OPTION]... SRC DEST</span><br><span class="line">rsync [OPTION]... SRC [USER@]host:DEST</span><br><span class="line">rsync [OPTION]... [USER@]HOST:SRC DEST</span><br><span class="line">rsync [OPTION]... [USER@]HOST::SRC DEST</span><br><span class="line">rsync [OPTION]... SRC [USER@]HOST::DEST</span><br><span class="line">rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST]</span><br></pre></td></tr></table></figure>

<p><code>:</code>   ssh 方式进行备份，ssh 非默认端口使用选项 <code>-e</code> 指定端口, <code>-e &#39;ssh -p 30000&#39;</code></p>
<p><code>::</code>   socket 方式进行备份，<code>rsync</code> 以服务方式监听，<code>SRC/DEST</code> 为配置中定义的模块 <code>[]</code></p>
<blockquote>
<ul>
<li><code>rsync</code> 命令使用中，如果源参数的末尾有斜线，只会复制指定目录的内容，而不复制目录本身，没有斜线，则会复制目录本身，包括目录</li>
<li>客户端免密登录时，需要在客户端建立密码文件： <code>/etc/rsync.passwd</code>，文件中只保存密码，权限为600，用选项 <code>--password-file</code> 指明存放密码的文件位置</li>
</ul>
</blockquote>
<span id="more"></span>

<h3 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h3><table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>-v, --verbose </code></td>
<td>详细模式输出。</td>
<td></td>
</tr>
<tr>
<td><code>-q, --quiet </code></td>
<td>精简输出模式。</td>
<td></td>
</tr>
<tr>
<td><code>-c, --checksum </code></td>
<td>打开校验开关，强制对文件传输进行校验。</td>
<td></td>
</tr>
<tr>
<td><code>-a, --archive</code></td>
<td>归档模式，表示以递归方式传输文件，并保持所有文件属性，等于 <code>-rlptgoD</code>。</td>
<td></td>
</tr>
<tr>
<td><code>-r, --recursive</code></td>
<td>对子目录以递归模式处理。</td>
<td></td>
</tr>
<tr>
<td><code>-R, --relative</code></td>
<td>使用相对路径信息。</td>
<td></td>
</tr>
<tr>
<td><code>-b, --backup</code></td>
<td>创建备份，也就是对于目的已经存在有同样的文件名时，将老的文件重新命名为 <code>~filename</code> 。可以使用 <code>--suffix</code> 选项来指定不同的备份文件前缀。</td>
<td></td>
</tr>
<tr>
<td><code> --backup-dir</code></td>
<td>将备份文件(如 <code>~filename</code>)存放在在目录下。</td>
<td></td>
</tr>
<tr>
<td><code>--suffix=SUFFIX </code></td>
<td>定义备份文件前缀。</td>
<td></td>
</tr>
<tr>
<td><code>-u, --update  </code></td>
<td>仅仅进行更新，也就是跳过所有已经存在于 DST，并且文件时间晚于要备份的文件，不覆盖更新的文件。</td>
<td></td>
</tr>
<tr>
<td><code>-l, --links</code></td>
<td>保留软链结。</td>
<td></td>
</tr>
<tr>
<td><code>-L, --copy-links</code></td>
<td>想对待常规文件一样处理软链结。</td>
<td></td>
</tr>
<tr>
<td><code>--copy-unsafe-links  </code></td>
<td>仅仅拷贝指向SRC路径目录树以外的链结。</td>
<td></td>
</tr>
<tr>
<td><code>--safe-links   </code></td>
<td>忽略指向SRC路径目录树以外的链结。</td>
<td></td>
</tr>
<tr>
<td><code>-H, --hard-links</code></td>
<td>保留硬链结。</td>
<td></td>
</tr>
<tr>
<td><code>-p, --perms </code></td>
<td>保持文件权限。</td>
<td></td>
</tr>
<tr>
<td><code>-o, --owner </code></td>
<td>保持文件属主信息。</td>
<td></td>
</tr>
<tr>
<td><code>-g, --group</code></td>
<td>保持文件属组信息。</td>
<td></td>
</tr>
<tr>
<td><code>-D, --devices</code></td>
<td>保持设备文件信息。</td>
<td></td>
</tr>
<tr>
<td><code>-t, --times  </code></td>
<td>保持文件时间信息。</td>
<td></td>
</tr>
<tr>
<td><code>-S, --sparse  </code></td>
<td>对稀疏文件进行特殊处理以节省DST的空间。</td>
<td></td>
</tr>
<tr>
<td><code>-n, --dry-run </code></td>
<td>只显示哪些文件将被传输，不进行真正的传输。</td>
<td></td>
</tr>
<tr>
<td><code>-w, --whole-file </code></td>
<td>拷贝文件，不进行增量检测。</td>
<td></td>
</tr>
<tr>
<td><code>-x, --one-file-system </code></td>
<td>不要跨越文件系统边界。</td>
<td></td>
</tr>
<tr>
<td><code>-B, --block-size=SIZE</code></td>
<td>检验算法使用的块尺寸，默认是700字节。</td>
<td></td>
</tr>
<tr>
<td><code>-e, --rsh=command</code></td>
<td>指定使用rsh、ssh方式进行数据同步。</td>
<td></td>
</tr>
<tr>
<td><code>--rsync-path=PATH</code></td>
<td>指定远程服务器上的rsync命令所在路径信息。</td>
<td></td>
</tr>
<tr>
<td><code>-C, --cvs-exclude </code></td>
<td>使用和CVS一样的方法自动忽略文件，用来排除那些不希望传输的文件。</td>
<td></td>
</tr>
<tr>
<td><code>--existing </code></td>
<td>仅仅更新那些已经存在于DST的文件，而不备份那些新创建的文件。</td>
<td></td>
</tr>
<tr>
<td><code>--delete</code></td>
<td>删除那些DST中存在，而SRC没有的文件。</td>
<td></td>
</tr>
<tr>
<td><code>--delete-excluded  </code></td>
<td>同样删除接收端那些被该选项指定排除的文件。</td>
<td></td>
</tr>
<tr>
<td><code>--delete-after   </code></td>
<td>传输结束以后再删除。</td>
<td></td>
</tr>
<tr>
<td><code>--ignore-errors  </code></td>
<td>及时出现IO错误也进行删除。</td>
<td></td>
</tr>
<tr>
<td><code>--max-delete=NUM </code></td>
<td>最多删除NUM个文件。</td>
<td></td>
</tr>
<tr>
<td><code>--partial</code></td>
<td>保留那些因故没有完全传输的文件，以是加快随后的再次传输。</td>
<td></td>
</tr>
<tr>
<td><code>--force </code></td>
<td>强制删除目录，即使不为空。</td>
<td></td>
</tr>
<tr>
<td><code>--numeric-ids</code></td>
<td>不将数字的用户和组 id 匹配为用户名和组名。</td>
<td></td>
</tr>
<tr>
<td><code>--timeout=time</code></td>
<td>ip 超时时间，单位为秒。</td>
<td></td>
</tr>
<tr>
<td><code>-I, --ignore-times</code></td>
<td>不跳过那些有同样的时间和长度的文件。</td>
<td></td>
</tr>
<tr>
<td><code>--size-only</code></td>
<td>当决定是否要备份文件时，仅仅察看文件大小而不考虑文件时间。</td>
<td></td>
</tr>
<tr>
<td><code>--modify-window=NUM</code></td>
<td>决定文件是否时间相同时使用的时间戳窗口，默认为0。</td>
<td></td>
</tr>
<tr>
<td><code>-T ,--temp-dir=DIR</code></td>
<td>在DIR中创建临时文件。</td>
<td></td>
</tr>
<tr>
<td><code>--compare-dest=DIR</code></td>
<td>同样比较DIR中的文件来决定是否需要备份。</td>
<td></td>
</tr>
<tr>
<td><code>-P</code></td>
<td>等同于 <code>--partial</code>。</td>
<td></td>
</tr>
<tr>
<td><code>--progress</code></td>
<td>显示传输过程。</td>
<td></td>
</tr>
<tr>
<td><code>-z, --compress</code></td>
<td>对备份的文件在传输时进行压缩处理。</td>
<td></td>
</tr>
<tr>
<td><code>--exclude PATTERN  </code></td>
<td>指定排除不需要传输的文件模式。支持通配符</td>
<td></td>
</tr>
<tr>
<td><code>--include PATTERN</code></td>
<td>指定不排除而需要传输的文件模式。</td>
<td></td>
</tr>
<tr>
<td><code>--exclude-from=FILE</code></td>
<td>排除FILE中指定模式的文件。</td>
<td></td>
</tr>
<tr>
<td><code>--include-from=FILE</code></td>
<td>不排除FILE指定模式匹配的文件。</td>
<td></td>
</tr>
<tr>
<td><code>--version</code></td>
<td>打印版本信息。</td>
<td></td>
</tr>
<tr>
<td><code>--address</code></td>
<td>绑定到特定的地址。</td>
<td></td>
</tr>
<tr>
<td><code>--config=FILE</code></td>
<td>指定其他的配置文件，不使用默认的 <code>rsyncd.conf</code> 文件。</td>
<td></td>
</tr>
<tr>
<td><code>--port=PORT</code></td>
<td>指定其他的 rsync 服务端口。</td>
<td></td>
</tr>
<tr>
<td><code>--blocking-io</code></td>
<td>对远程shell使用阻塞IO。</td>
<td></td>
</tr>
<tr>
<td><code>--stats </code></td>
<td>给出某些文件的传输状态。</td>
<td></td>
</tr>
<tr>
<td><code>--log-format=formAT </code></td>
<td>指定日志文件格式。</td>
<td></td>
</tr>
<tr>
<td><code>--password-file=FILE </code></td>
<td>从FILE中得到密码。</td>
<td></td>
</tr>
<tr>
<td><code>--bwlimit=KBPS </code></td>
<td>限制I&#x2F;O带宽，KBytes per second。</td>
<td></td>
</tr>
<tr>
<td><code>-h, --help</code></td>
<td>显示帮助信息。</td>
<td></td>
</tr>
</tbody></table>
<h3 id="rsyncd-配置文件示例"><a href="#rsyncd-配置文件示例" class="headerlink" title="rsyncd 配置文件示例"></a>rsyncd 配置文件示例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">&lt;==该选项指定当模块传输文件时守护进程应该具有的uid、gid</span></span><br><span class="line">uid =root  </span><br><span class="line">gid = root</span><br><span class="line">port = 873</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#消息文件，客户端连接服务器的时显示给客户端</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">motd file = /etc/rsyncd.motd</span>  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">&lt;==安全相关</span></span><br><span class="line">use chroot = no  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">&lt;==设置最大连接数</span></span><br><span class="line">max connections = 200  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">&lt;==设置超时时间</span></span><br><span class="line">timeout = 300   </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">&lt;==定义进程文件</span></span><br><span class="line">pid file = /var/run/rsyncd.pid </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">&lt;==定义锁文件</span>  </span><br><span class="line">lock file = /var/run/rsync.lock </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">&lt;==定义日志文件</span> </span><br><span class="line">log file = /var/log/rsyncd.log  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#关闭解析</span></span> </span><br><span class="line">reverse lookup = no  </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">&lt;==配置一个数据存储的模块</span></span><br><span class="line">[backup]      </span><br><span class="line">    #&lt;==模块备份数据路径</span><br><span class="line">    path = /data/www/videos/  </span><br><span class="line">    ignore errors</span><br><span class="line">    read only = false</span><br><span class="line">    list = false</span><br><span class="line">    #&lt;==配置登录权限，可以多个IP网段用逗号隔开</span><br><span class="line">    #hosts allow = 172.16.1.0/24,172.25.1.0/24  </span><br><span class="line">    #hosts deny = 0.0.0.0/32</span><br><span class="line">    #&lt;==配置服务登录用户（访问服务的权限）</span><br><span class="line">    auth users = rsync        </span><br><span class="line">    #&lt;==配置用户和密码文件,权限必须600，用户名:密码格式 </span><br><span class="line">    secrets file = /etc/rsync.server.password  </span><br><span class="line">    ##是否检查secrets file的权限</span><br><span class="line">    strict modes = yes </span><br></pre></td></tr></table></figure>

<h3 id="rsync-的过滤规则说明"><a href="#rsync-的过滤规则说明" class="headerlink" title="rsync 的过滤规则说明"></a>rsync 的过滤规则说明</h3><p>rsync 过滤规则是用于定义哪些文件要传输（包含某些文件）哪些文件不要传输（排除某些文件）的一些规则。这些规则可以直接写在命令参数里，也可以写在规则文件里，然后由命令引用</p>
<p>与过滤规则有关的选项主要有：</p>
<ul>
<li><code>--include=PATTERN</code> ： 设定一条包含规则，如： <code>--include=&quot;*.php&quot;</code></li>
<li><code>--exclude=PATTERN</code> ： 设定一条排除规则，如：<code>--exclude=&quot;*&quot;</code></li>
<li><code>--include-from=FILE</code> ： 指定一个文件，文件中一行一条包含规则，以 <code>;</code> 或 <code>#</code> 开头的行为注释，空行被忽略</li>
<li><code>--exclude-from=FILE</code> ： 指定一个文件，文件中一行一条排除规则，以 <code>;</code> 或 <code>#</code> 开头的行为注释，空行被忽略</li>
<li><code>--filter=RULE, -f</code> ： 设定一条过滤规则，可能是排除或包含规则（如：<code>-f &quot;- *.php&quot;</code> ），也可能其它类型的规则（如包含一个规则文件 <code>-f &quot;. ./rsync.rules&quot;</code>）</li>
</ul>
<p>这些选项配置的规则，其本质是一样，只是描述方式有些差异。其中 <code>--filter=RULE, -f</code> 选项支持完整的规则表达语法，其它的选项都可以转化为此选项的表达。举例如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -av --include=&quot;*.php&quot; --exclude=&quot;*&quot; src_dir/ dst_dir/</span><br><span class="line">rsync -av -filter &quot;+ *.php&quot; -filter &quot;- *&quot; src_dir/ dst_dir/</span><br><span class="line">rsync -av -f &quot;+ *.php&quot; -f &quot;- *&quot; src_dir/ dst_dir/</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上的命令是完全等价的，<code>-f</code> 方式更简单<br><code>--include=&quot;xxx&quot;</code> 等价于 <code>-f &quot;+ xxx&quot;</code><br><code>--exclude=&quot;xxx&quot;</code> 等价于 <code>-f &quot;- xxx&quot;</code></p>
</blockquote>
<p>由 <code>--include-from</code> 或 <code>--exclude-from</code> 选项引入的规则文件，相当于每个规则前面自动加了 <code>+</code> 或 <code>-</code>。其规则文件内容举例如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--include-from 或 --exclude-from 引用的规则文件，开头没有 + 或 -</span></span><br><span class="line">*.php</span><br><span class="line">*</span><br></pre></td></tr></table></figure>

<h4 id="过滤规则的工作方式"><a href="#过滤规则的工作方式" class="headerlink" title="过滤规则的工作方式"></a>过滤规则的工作方式</h4><p>所有的过滤规则配置最终在 rsync 内部会形成一个有序的规则列表，在命令行中靠前选项，其规则的排序也靠前。随着要传输的（文件&#x2F;目录路径）列表的构建，针对每个路径，rsync 会依次读取有序规则列表中的规则进行检查。当第一个规则匹配成功后，立即进行操作（包含或排除），并停止后面规则的检查；若所有规则都不不匹配，此路径默认为包含。若有递归选项时（如 <code>-r -a</code>），如果子目录被规则排除，那么 rsync 不会递归检查此目录的内容了，也就是此目录下的文件和目录不会进行规则过滤也不会传输，相当于整个子目录都排除了。简单总结如下：</p>
<ol>
<li>规则有顺序，顺序同命令中参数配置顺序（从左到右）</li>
<li>扫描文件系统，读取（目录或文件的）路径后马上进行规则检查，确定包含还是排除</li>
<li>规则检查按序进行，若有命中立即包含或排除，并停止后续规则检查；若无规则命中，默认为包含</li>
<li>目录被排除时，其下所有子目录和文件都被排除</li>
</ol>
<p>此命令会同步 src_dir 目录下的所有 php 文件（<strong>不包含子目录的</strong>）<br>因为 src_dir 目录下每个文件和目录路径都会先由 <code>-f &quot;+ *.php&quot;</code> 规则检查，php 文件符合此规则就被包含了，后面的 <code>-f &quot;- *&quot;</code> 规则不会检查了<br>其余类型的文件和子目录，不符合第一个规则，继续检查第二个规则时，都被排除了<br>子目录被排除后，其中即使有 php 文件，也不会被检查，所以此命令不会同步 src_dir 目录下子目录中的 php 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -av -f &quot;+ *.php&quot; -f &quot;- *&quot; src_dir/ dst_dir/</span><br></pre></td></tr></table></figure>

<p>调换两个参数的顺序，则完全不一样了<br>此命令将不会同步任何文件和目录<br>因为第一条规则把所有文件和目录到排除了，第二条规则没有机会生效  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rsync -av -f &quot;- *&quot; -f &quot;+ *.php&quot; src_dir/ dst_dir/</span><br></pre></td></tr></table></figure>

<p>此命令会同步 src_dir 目录下的所有 php 文件（<strong>包含子目录的</strong>）<br>规则 <code>-f &quot;+ */&quot;</code> 会匹配并包含所有子目录路径，所以 rsync 会检查所有的子目录，然后其中的 php 文件被包含了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rsync -av -f &quot;+ *.php&quot; -f &quot;+ */&quot; -f &quot;- *&quot; src_dir/ dst_dir/</span><br></pre></td></tr></table></figure>
<h4 id="过滤规则的配置语法"><a href="#过滤规则的配置语法" class="headerlink" title="过滤规则的配置语法"></a>过滤规则的配置语法</h4><p>过滤规则的配置语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">操作 [匹配模式]</span><br><span class="line">操作,修饰符 [匹配模式]</span><br></pre></td></tr></table></figure>
<p>常用操作：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>+</code></td>
<td>包含</td>
<td><code>-f &quot;+ *.php&quot;</code></td>
</tr>
<tr>
<td><code>-</code></td>
<td>排除</td>
<td><code>-f &quot;- *.php&quot;</code></td>
</tr>
<tr>
<td><code>.</code></td>
<td>包含规则文件</td>
<td><code>-f &quot;. ./rsync.rules&quot;</code></td>
</tr>
</tbody></table>
<p>常用修饰符：</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>!</code></td>
<td>否定，对匹配结果进行取反，把匹配成功当做匹配失败，把匹配失败当做匹配成功</td>
<td><code>-f &quot;-! *.php&quot;</code></td>
</tr>
</tbody></table>
<p>常见匹配模式：</p>
<table>
<thead>
<tr>
<th>匹配模式</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>/*.php</code></td>
<td>模式以 <code>/</code> 开头时，表示模式必须匹配路径的开始；否则可以匹配路径中任意一层名称</td>
<td></td>
</tr>
<tr>
<td><code>config/</code></td>
<td>模式以 <code>/</code> 结尾时，表示模式只匹配目录，否则可以匹配目录或文件</td>
<td></td>
</tr>
<tr>
<td><code>subdir/view.php</code></td>
<td>模式中间的 <code>/</code> 表示路径分隔符</td>
<td></td>
</tr>
<tr>
<td><code>*</code></td>
<td>匹配任意长度的任意字符，但不匹配 <code>/</code></td>
<td></td>
</tr>
<tr>
<td><code>**</code></td>
<td>结尾时匹配任意长度的任意字符（包括 <code>/</code>）</td>
<td><code>app/**</code> 匹配路径 <code>app/xx/xx/a.txt</code></td>
</tr>
<tr>
<td><code>***</code></td>
<td>结尾时匹配任意长度的任意字符（包括 <code>/</code>），还包括目录本身。</td>
<td><code>app/***</code> 匹配路径 <code>app</code> 和 <code>xxx/app</code></td>
</tr>
<tr>
<td><code>?</code></td>
<td>匹配 <code>/</code> 以外的任意一个字符</td>
<td></td>
</tr>
<tr>
<td><code>[]</code></td>
<td>匹配一个某一类字符</td>
<td><code>[a-z]</code> 匹配一个小写字母，<code>[0-9]</code> 匹配一个数字</td>
</tr>
</tbody></table>
<blockquote>
<p>模式默认必须匹配到路径的末尾。如：<code>foo</code> 匹配 <code>foo</code> 和 <code>xx/foo</code>，但不匹配 <code>xx/foo1</code> 和 <code>foo/xx</code><br>路径被匹配的部分必须是包含完整的（目录或文件）名称，不可从名称中间切开。如：<code>foo</code> 不匹配 <code>xxx/afoo</code> ，<code>abc/foo</code> 不匹配 <code>subdir/aabc/foo</code><br>默认是包含所有文件和目录  </p>
</blockquote>
<h3 id="常用命令示例"><a href="#常用命令示例" class="headerlink" title="常用命令示例"></a>常用命令示例</h3><h4 id="测试同步结果"><a href="#测试同步结果" class="headerlink" title="测试同步结果"></a>测试同步结果</h4><p>如果不确定 <code>rsync</code> 执行的结果，可以不写目标目录，这样不会同步数据，只会输出要同步的目录和文件列表。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -a --exclude &#x27;file.txt&#x27; src_dir/</span><br></pre></td></tr></table></figure>
<p>或者使用选项 <code>--dry-run, -n</code>，模拟实际的运行效果，但不真的执行同步  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -a --dry-run --exclude &#x27;file.txt&#x27; src_dir/ dst_dir/</span><br></pre></td></tr></table></figure>

<h4 id="ssh-模式同步，默认-ssh-端口非-22-时指定-ssh-端口，使用-e-39-ssh-p-222-39-选项"><a href="#ssh-模式同步，默认-ssh-端口非-22-时指定-ssh-端口，使用-e-39-ssh-p-222-39-选项" class="headerlink" title="ssh 模式同步，默认 ssh 端口非 22 时指定 ssh 端口，使用 -e &#39;ssh -p 222&#39; 选项"></a>ssh 模式同步，默认 ssh 端口非 22 时指定 ssh 端口，使用 <code>-e &#39;ssh -p 222&#39;</code> 选项</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -e &#x27;ssh -p 222&#x27; /data/wwwroot/  rsync@9.9.9.9:/home/wwwroot/</span><br></pre></td></tr></table></figure>

<h4 id="Windows-中使用方式，以类似-cygdrive-d-的方式指定-d-盘"><a href="#Windows-中使用方式，以类似-cygdrive-d-的方式指定-d-盘" class="headerlink" title="Windows 中使用方式，以类似 /cygdrive/d/ 的方式指定 d 盘"></a>Windows 中使用方式，以类似 <code>/cygdrive/d/</code> 的方式指定 d 盘</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -c -r -u -t --timeout=300 -z --password-file C:\rsyncPasswd.txt /cygdrive/d/DATA/ rsync@0.0.0.0::zy/</span><br></pre></td></tr></table></figure>

<h4 id="同步过程中忽略-跳过-指定文件-目录"><a href="#同步过程中忽略-跳过-指定文件-目录" class="headerlink" title="同步过程中忽略(跳过)指定文件(目录)"></a>同步过程中忽略(跳过)指定文件(目录)</h4><p>要排除特定文件，请将文件的相对路径传递给 <code>--exclude</code> 选项</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -a --exclude &#x27;file.txt&#x27; src_dir/ dst_dir/</span><br><span class="line">rsync -a -f &#x27;- file.txt&#x27; src_dir/ dst_dir/</span><br></pre></td></tr></table></figure>

<p>排除特定目录与排除文件相同，只需将目录的相对路径传递给 <code>--exclude</code> 选项</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -a --exclude &#x27;dir1&#x27; src_dir/ dst_dir/</span><br><span class="line">rsync -a -f &#x27;- dir1&#x27; src_dir/ dst_dir/</span><br></pre></td></tr></table></figure>
<p>如果要排除目录内容，但不排除目录本身，请使用 <code>dir1/*</code> 而不是 <code>dir1</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -a --exclude &#x27;dir1/*&#x27; src_dir/ dst_dir/</span><br><span class="line">rsync -a -f &#x27;- dir1/*&#x27; src_dir/ dst_dir/</span><br></pre></td></tr></table></figure>
<p>要排除多个文件或目录，只需指定多个 <code>--exclude</code> 选项, 或使用 <code>&#123;&#125;</code> 包含多个目标项</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -a --exclude &#x27;f1.txt&#x27; --exclude &#x27;dir1/*&#x27; --exclude &#x27;dir2&#x27; src_dir/ dst_dir/</span><br><span class="line">rsync -a --exclude=&#123;&#x27;f1.txt&#x27;,&#x27;dir1/*&#x27;,&#x27;dir2&#x27;&#125; src_dir/ dst_dir/</span><br><span class="line">rsync -a -f &#x27;- f1.txt&#x27; -f &#x27;- dir1/*&#x27; -f &#x27;- dir2&#x27; src_dir/ dst_dir/</span><br></pre></td></tr></table></figure>

<p>通配符排除多个文件，例如要排除所有 <code>jpg</code> 类型的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -a --exclude &#x27;*.jpg*&#x27; src_dir/ dst_dir/</span><br><span class="line">rsync -a -f &#x27;- *.jpg*&#x27; src_dir/ dst_dir/</span><br></pre></td></tr></table></figure>



<h3 id="windows-安装-rsync-客户端"><a href="#windows-安装-rsync-客户端" class="headerlink" title="windows 安装 rsync 客户端"></a>windows 安装 rsync 客户端</h3><p>windows 下 rsync客户端使用 <code>cwRsync</code><br>下载地址：<br><a href="https://www.itefix.net/cwrsync?spm=a2c6h.12873639.article-detail.6.58dd67f17cs3Ta">官网链接</a><br><a href="https://s.csms.tech/file/cwrsync_6.2.4_x64_free.zip">其他地址</a></p>
<p>下载解压安装包后，目录内容如下：<br><img src="https://i.csms.tech/img_22.png"></p>
<p><code>bin</code> 目录下包含常用命令，其中 <code>rsync</code> 命令和 linux 中使用方法相同</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://zhuanlan.zhihu.com/p/441161884">rsync命令过滤规则入门教程</a><br><a href="https://iguoli.github.io/2017/07/03/Rsync.html">Rsync 命令</a></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Rsync</tag>
      </tags>
  </entry>
  <entry>
    <title>linux network namespace 使用说明</title>
    <url>/202304031317/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos 7 5.4.239-1</li>
</ul>
<p>Linux 的 namespace 的作用是 <code>隔离内核资源</code>，目前主要实现了以下 namespace</p>
<ul>
<li><code>mount namespace</code> - 文件系统挂载点</li>
<li><code>UTS namespace</code> - 主机名</li>
<li><code>IPC namespace</code> - POSIX 进程间通信消息队列</li>
<li><code>PID namespace</code> - 进程 pid 数字空间</li>
<li><code>network namespace</code> - network</li>
<li><code>user namespace</code> - user ID 数字空间</li>
</ul>
<p>其中，除了 <code>network namespace</code>，其他 namespace 的操作需要使用 C 语言调用系统 API 实现。<code>network namespace</code> 的增删改查功能已经集成到了 Linux 的 <code>ip</code> 工具集的 <code>netns</code> 子命令中</p>
<p>Linux 里面的 namespace 给处在其中的进程造成 2 个错觉：</p>
<ol>
<li>它是系统里面唯一的进程</li>
<li>它独享系统的所有资源</li>
</ol>
<p>默认情况下，Linux 里面的所有进程处在和宿主机相同的 namespace ，即初始 namespace 里，默认享有全局系统资源。</p>
<h1 id="network-namespace-常用操作"><a href="#network-namespace-常用操作" class="headerlink" title="network namespace 常用操作"></a>network namespace 常用操作</h1><p>network namespace 的增删改查功能已经集成到了 Linux 的 <code>ip</code> 工具集的 <code>netns</code> 子命令中，因此在 Linux 系统中，对 network namespace 的操作主要使用 <code>ip netns</code> 命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip netns <span class="built_in">help</span></span></span><br><span class="line">Usage: ip netns list</span><br><span class="line">       ip netns add NAME</span><br><span class="line">       ip netns set NAME NETNSID</span><br><span class="line">       ip [-all] netns delete [NAME]</span><br><span class="line">       ip netns identify [PID]</span><br><span class="line">       ip netns pids NAME</span><br><span class="line">       ip [-all] netns exec [NAME] cmd ...</span><br><span class="line">       ip netns monitor</span><br><span class="line">       ip netns list-id</span><br></pre></td></tr></table></figure>
<h2 id="创建并查看-network-namespace"><a href="#创建并查看-network-namespace" class="headerlink" title="创建并查看 network namespace"></a>创建并查看 network namespace</h2><p>使用以下命令创建名为 <code>netns1</code> 的 <code>network namespace</code> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip netns add netns1</span><br></pre></td></tr></table></figure>

<p>以下命令查看系统中的 <code>network namespace</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip netns list</span></span><br><span class="line">netns1</span><br></pre></td></tr></table></figure>
<p>新的 <code>network namespace</code> 创建后，系统会在 <code>/var/run/netns/</code> 下面生成一个同名的挂载点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l /var/run/netns/</span></span><br><span class="line">total 0</span><br><span class="line">-r--r--r-- 1 root root 0 Apr  3 13:33 netns1</span><br></pre></td></tr></table></figure>

<p>此挂载点的主要作用一方面是方便对 namespace 的管理，一方面是使 namespace 即使没有进程运行也能继续存在。</p>
<p>新的 <code>network namespace</code> 创建后，可以使用 <code>ip netns exec</code> 命令进入 namespace，做网络配置或者查询的工作。</p>
<blockquote>
<p><code>ip netns exec</code> 命令只能根据 network namespace 的名称进入 namespace</p>
</blockquote>
<p>以下命令查询 <code>netns1</code> 的 <code>network namespace</code> 的 IP 地址信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip netns <span class="built_in">exec</span> netns1 ip add</span></span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br></pre></td></tr></table></figure>
<p>默认的 <code>network namespace</code> 除了附带一个 <code>lo</code> 网卡外，没有任何其他网络设备，并且此 <code>lo</code> 接口还处于 <code>DOWN</code> 的状态，因此此回环网卡也是不可访问的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip netns <span class="built_in">exec</span> netns1 ping 127.0.0.1</span></span><br><span class="line">connect: Network is unreachable</span><br></pre></td></tr></table></figure>

<p>在此示例中，如果想启用本地回环地址，首先需要进入 namespace，将本地回环网卡的状态修改为 <code>UP</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip netns <span class="built_in">exec</span> netns1 ip <span class="built_in">link</span> <span class="built_in">set</span> dev lo up</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip netns <span class="built_in">exec</span> netns1 ip add</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip netns <span class="built_in">exec</span> netns1 ping 127.0.0.1</span></span><br><span class="line">PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.</span><br><span class="line">64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.021 ms</span><br><span class="line">^C</span><br><span class="line">--- 127.0.0.1 ping statistics ---</span><br><span class="line">1 packets transmitted, 1 received, 0% packet loss, time 0ms</span><br><span class="line">rtt min/avg/max/mdev = 0.021/0.021/0.021/0.000 ms</span><br></pre></td></tr></table></figure>

<p>此时，namespace 中的 <code>lo</code> 网卡可以正常使用，但是因为 namespace 中没有其他网络设备，此 <code>network namespace</code> 无法和其他网络通信，要和其他网络通信，需要用到其他的网络技术，例如 <a href="#veth-pair"><code>veth pair</code></a></p>
<h2 id="删除-network-namespace"><a href="#删除-network-namespace" class="headerlink" title="删除 network namespace"></a>删除 network namespace</h2><p>要删除 <code>network namespace</code>，可以使用以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip netns delete netns1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面这条命令并没有实际删除 <code>netns1</code> 这个 <code>network namespace</code>，它只是移除了这个 namespace 对应的挂载点(<code>/var/run/netns/netns1</code>)，只要里面的进程还运行着，<code>network namespace</code> 就会一直存在 </p>
</blockquote>
<h1 id="veth-pair"><a href="#veth-pair" class="headerlink" title="veth pair"></a>veth pair</h1><p>veth 是虚拟以太网（Virtual Ethernet）的缩写。veth 设备总是成对出现的，因此我们称之为 <code>veth pair</code>，<code>veth pair</code> 的一端发送的数据会在另外一端接收。根据这一特性，<code>veth pair</code> 常被用于跨 <code>network namespace</code> 的通信，即分别将 <code>veth pair</code> 的 2 端放在不同的 <code>network namespace</code>。</p>
<span id="more"></span>

<h2 id="veth-pair-的创建和使用"><a href="#veth-pair-的创建和使用" class="headerlink" title="veth pair 的创建和使用"></a>veth pair 的创建和使用</h2><p>创建 <code>veth pair</code>，名称分别是 <code>veth1</code> 和 <code>veth2</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip link add veth0 type veth peer name veth1</span><br></pre></td></tr></table></figure>
<p>查看主机上面的网卡信息，创建的 <code>veth pair</code> 在主机上表现为 2 块网卡:  <code>veth1</code> 和 <code>veth2</code>，mtu 为 1500，初始状态为 <code>DOWN</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip <span class="built_in">link</span> list</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 00:0c:29:e7:c0:27 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">5: veth1@veth0: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 46:d5:d3:da:b8:80 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">6: veth0@veth1: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 5a:b4:83:22:2b:99 brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure>
<p>使用以下命令修改 <code>veth pair</code> 状态和配置 ip 地址信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip <span class="built_in">link</span> <span class="built_in">set</span> dev veth0 up</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip <span class="built_in">link</span> <span class="built_in">set</span> dev veth1 up</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip <span class="built_in">link</span></span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 00:0c:29:e7:c0:27 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">5: veth1@veth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 46:d5:d3:da:b8:80 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">6: veth0@veth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 5a:b4:83:22:2b:99 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ifconfig veth0 192.168.10.10/24</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ifconfig veth1 192.168.10.11/24</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip add</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line">5: veth1@veth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000</span><br><span class="line">    link/ether 46:d5:d3:da:b8:80 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.10.11/24 brd 192.168.10.255 scope global veth1</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::44d5:d3ff:feda:b880/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">6: veth0@veth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000</span><br><span class="line">    link/ether 5a:b4:83:22:2b:99 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.10.10/24 brd 192.168.10.255 scope global veth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::58b4:83ff:fe22:2b99/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>

<p>以下示例创建 2 个 <code>network namespace</code>，并将上面新创建的 <code>veth pair</code> 移动到 2 个新建的 <code>network namespace</code>，实现 2 个 <code>network namespace</code> 之间的通信</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip netns add newnetns1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip netns add newnetns2</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip netns list</span></span><br><span class="line">newnetns2</span><br><span class="line">newnetns1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>将 <code>veth1</code> 配置给 <code>newnetns1</code>，<code>veth2</code> 配置给 <code>newnetns2</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip link set veth0 netns newnetns1</span><br><span class="line">ip link set veth1 netns newnetns2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将 <code>veth pair</code> 放入指定的 network namespace，除了可以使用 network namespace 的名称之外，还可以使用指定进程的 PID，实现在不知道进程对应的 network namespace 的名称的情况下操作  network namespace 。假如要将 veth 放入 PID 为 84040 的进程对应的  network namespace，可以使用如下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip link set veth0 netns 84040 </span><br></pre></td></tr></table></figure>
</blockquote>
<p>在宿主机查看网卡信息以及 ip 信息，<code>veth1</code> 和 <code>veth2</code> 不出现在列表中，因为它们已经不在根网络命名空间中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip <span class="built_in">link</span> show</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip add</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    link/ether 00:0c:29:e7:c0:27 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.142.10/24 brd 192.168.142.255 scope global noprefixroute ens33</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::20c:29ff:fee7:c027/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>
<p>分别查看 <code>newnetns1</code> 和 <code>newnetns2</code> 的 <code>network namespae</code> 信息如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip netns <span class="built_in">exec</span> newnetns1 ip <span class="built_in">link</span></span></span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">6: veth0@if5: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 5a:b4:83:22:2b:99 brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip netns <span class="built_in">exec</span> newnetns2 ip <span class="built_in">link</span></span></span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">5: veth1@if6: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 46:d5:d3:da:b8:80 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip netns <span class="built_in">exec</span> newnetns1 ip add</span></span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">6: veth0@if5: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/ether 5a:b4:83:22:2b:99 brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip netns <span class="built_in">exec</span> newnetns2 ip add</span></span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">5: veth1@if6: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/ether 46:d5:d3:da:b8:80 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br></pre></td></tr></table></figure>
<p>配置 ip 地址信息，并测试 2 个 <code>network namespace</code> 是否能 ping 通</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip netns <span class="built_in">exec</span> newnetns1 ifconfig veth0 up</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip netns <span class="built_in">exec</span> newnetns2 ifconfig veth1 up</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip netns <span class="built_in">exec</span> newnetns1 ifconfig veth0 192.168.10.10/24</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip netns <span class="built_in">exec</span> newnetns2 ifconfig veth1 192.168.10.11/24</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip netns <span class="built_in">exec</span> newnetns1 ip add</span></span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">6: veth0@if5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000</span><br><span class="line">    link/ether 5a:b4:83:22:2b:99 brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br><span class="line">    inet 192.168.10.10/24 brd 192.168.10.255 scope global veth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::58b4:83ff:fe22:2b99/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">       </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip netns <span class="built_in">exec</span> newnetns2 ip add</span></span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">5: veth1@if6: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000</span><br><span class="line">    link/ether 46:d5:d3:da:b8:80 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 192.168.10.11/24 brd 192.168.10.255 scope global veth1</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::44d5:d3ff:feda:b880/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip netns <span class="built_in">exec</span> newnetns2 ping 192.168.10.10</span></span><br><span class="line">PING 192.168.10.10 (192.168.10.10) 56(84) bytes of data.</span><br><span class="line">64 bytes from 192.168.10.10: icmp_seq=1 ttl=64 time=0.071 ms</span><br><span class="line"></span><br><span class="line">--- 192.168.10.10 ping statistics ---</span><br><span class="line">1 packets transmitted, 1 received, 0% packet loss, time 0ms</span><br><span class="line">rtt min/avg/max/mdev = 0.071/0.071/0.071/0.000 ms</span><br></pre></td></tr></table></figure>

<h1 id="Linux-bridge"><a href="#Linux-bridge" class="headerlink" title="Linux bridge"></a>Linux bridge</h1><p><code>veth pair</code> 可以连接 2 个 <code>network namespace</code>， 要连接更多的 <code>network namespace</code>，就需要 <code>bridge</code> 设备。</p>
<h2 id="创建-bridge"><a href="#创建-bridge" class="headerlink" title="创建 bridge"></a>创建 bridge</h2><p>使用以下命令创建一个名为 <code>br0</code> 的 bridge 设备</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip <span class="built_in">link</span> add name br0 <span class="built_in">type</span> bridge</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip <span class="built_in">link</span> <span class="built_in">set</span> br0 up</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip <span class="built_in">link</span></span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 00:0c:29:e7:c0:27 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">7: br0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether ca:80:61:e4:98:94 brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure>

<p>除了使用 <code>ip link</code> 命令管理网桥外，还可以使用 <code>bridge-utils</code> 里面的 <code>brctl</code> 命令管理网桥设备，例如创建名为 br0 的 bridge 设备</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum install -y bridge-utils</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">brctl <span class="built_in">help</span></span></span><br><span class="line">never heard of command [help]</span><br><span class="line">Usage: brctl [commands]</span><br><span class="line">commands:</span><br><span class="line">	addbr     	&lt;bridge&gt;		add bridge</span><br><span class="line">	delbr     	&lt;bridge&gt;		delete bridge</span><br><span class="line">	addif     	&lt;bridge&gt; &lt;device&gt;	add interface to bridge</span><br><span class="line">	delif     	&lt;bridge&gt; &lt;device&gt;	delete interface from bridge</span><br><span class="line">	hairpin   	&lt;bridge&gt; &lt;port&gt; &#123;on|off&#125;	turn hairpin on/off</span><br><span class="line">	setageing 	&lt;bridge&gt; &lt;time&gt;		set ageing time</span><br><span class="line">	setbridgeprio	&lt;bridge&gt; &lt;prio&gt;		set bridge priority</span><br><span class="line">	setfd     	&lt;bridge&gt; &lt;time&gt;		set bridge forward delay</span><br><span class="line">	sethello  	&lt;bridge&gt; &lt;time&gt;		set hello time</span><br><span class="line">	setmaxage 	&lt;bridge&gt; &lt;time&gt;		set max message age</span><br><span class="line">	setpathcost	&lt;bridge&gt; &lt;port&gt; &lt;cost&gt;	set path cost</span><br><span class="line">	setportprio	&lt;bridge&gt; &lt;port&gt; &lt;prio&gt;	set port priority</span><br><span class="line">	show      	[ &lt;bridge&gt; ]		show a list of bridges</span><br><span class="line">	showmacs  	&lt;bridge&gt;		show a list of mac addrs</span><br><span class="line">	showstp   	&lt;bridge&gt;		show bridge stp info</span><br><span class="line">	stp       	&lt;bridge&gt; &#123;on|off&#125;	turn stp on/off</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">brctl addbr br0</span></span><br></pre></td></tr></table></figure>

<p>以下命令演示创建 <code>veth pair</code> 并将其中的一端连接到 <code>br0</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip link add veth0 type veth peer name veth0_p</span><br><span class="line">ip add add 172.17.0.2/24 dev veth0</span><br><span class="line">ip add add 172.17.0.3/24 dev veth0_p</span><br><span class="line">ip link set veth0 up</span><br><span class="line">ip link set veth0_p up</span><br><span class="line"></span><br><span class="line">ip link set dev veth0 master br0</span><br></pre></td></tr></table></figure>

<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="network-namespace-网卡配置-ip-后无法-ping-通本机网卡"><a href="#network-namespace-网卡配置-ip-后无法-ping-通本机网卡" class="headerlink" title="network namespace 网卡配置 ip 后无法 ping 通本机网卡"></a>network namespace 网卡配置 ip 后无法 ping 通本机网卡</h2><p>示例操作如下，主要为创建 network namespace，添加网卡，配置 IP</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip netns add testns</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip <span class="built_in">link</span> add veth0 <span class="built_in">type</span> veth peer name veth0_p</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip <span class="built_in">link</span> <span class="built_in">set</span> veth0 netns testns</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip netns <span class="built_in">exec</span> testns ip <span class="built_in">link</span></span></span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">9: veth0@if8: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether ae:c7:2f:73:31:9e brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip netns <span class="built_in">exec</span> testns ip add add 10.10.1.1/24 dev veth0</span>    </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip netns <span class="built_in">exec</span> testns ip <span class="built_in">link</span> <span class="built_in">set</span> veth0 up</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip netns <span class="built_in">exec</span> testns ping 10.10.1.1</span></span><br><span class="line">PING 10.10.1.1 (10.10.1.1) 56(84) bytes of data.</span><br><span class="line">^C</span><br><span class="line">--- 10.10.1.1 ping statistics ---</span><br><span class="line">4 packets transmitted, 0 received, 100% packet loss, time 3054ms</span><br></pre></td></tr></table></figure>

<p>如上操作，为 network namespace 创建了网卡并配置了 IP，网卡处于 UP 状态，但是配置的 IP 在本机无法 ping 通。</p>
<p>原因为 <strong>回环网卡 lo 处于 <code>DOWN</code> 状态</strong>，启用 <code>lo</code>，重新 ping，可以正常 ping 通本地 IP</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip netns <span class="built_in">exec</span> testns ip <span class="built_in">link</span> <span class="built_in">set</span> lo up</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip netns <span class="built_in">exec</span> testns ping 10.10.1.1</span></span><br><span class="line">PING 10.10.1.1 (10.10.1.1) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.10.1.1: icmp_seq=1 ttl=64 time=0.031 ms</span><br><span class="line">64 bytes from 10.10.1.1: icmp_seq=2 ttl=64 time=0.023 ms</span><br><span class="line">^C</span><br><span class="line">--- 10.10.1.1 ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 1060ms</span><br><span class="line">rtt min/avg/max/mdev = 0.023/0.027/0.031/0.004 ms</span><br></pre></td></tr></table></figure>

<h2 id="2-个-network-namespace-配置后无法-ping-通"><a href="#2-个-network-namespace-配置后无法-ping-通" class="headerlink" title="2 个 network namespace 配置后无法 ping 通"></a>2 个 network namespace 配置后无法 ping 通</h2><p>示例操作如下</p>
<ol>
<li><p>创建 netwrk namespace</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip netns add ns1</span><br><span class="line">ip netns add ns2</span><br></pre></td></tr></table></figure></li>
<li><p>创建 <code>veth pair</code> 并分配给 netwrk namespace</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip link add veth1 type veth peer name veth1_p</span><br><span class="line">ip link add veth2 type veth peer name veth2_p</span><br><span class="line">   </span><br><span class="line">ip link set veth1 netns ns1</span><br><span class="line">ip link set veth2 netns ns2</span><br></pre></td></tr></table></figure>
</li>
<li><p>为 veth 网卡配置 IP 并启用</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip addr add 10.10.10.1/24 dev veth1_p</span><br><span class="line">ip link set veth1_p up</span><br><span class="line"></span><br><span class="line">ip addr add 10.10.20.1/24 dev veth2_p</span><br><span class="line">ip link set veth2_p up</span><br><span class="line"></span><br><span class="line">ip netns exec ns1 ip addr add 10.10.10.2/24 dev veth1</span><br><span class="line">ip netns exec ns1 ip link set veth1 up</span><br><span class="line">   </span><br><span class="line">ip netns exec ns2 ip addr add 10.10.20.2/24 dev veth2</span><br><span class="line">ip netns exec ns2 ip link set veth2 up</span><br></pre></td></tr></table></figure></li>
<li><p>为 netwrk namespace 添加到对方的路由</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip netns exec ns1 route add -net 10.10.20.0 netmask 255.255.255.0 gw 10.10.10.1</span><br><span class="line">ip netns exec ns2 route add -net 10.10.10.0 netmask 255.255.255.0 gw 10.10.20.1</span><br></pre></td></tr></table></figure>
<p> 分别查看 2 个 netwrk namespace 的路由信息</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip netns <span class="built_in">exec</span> ns1 route -n</span></span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">10.10.10.0      0.0.0.0         255.255.255.0   U     0      0        0 veth1</span><br><span class="line">10.10.20.0      10.10.10.1      255.255.255.0   UG    0      0        0 veth1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip netns <span class="built_in">exec</span> ns2 route -n</span></span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">10.10.10.0      10.10.20.1      255.255.255.0   UG    0      0        0 veth2</span><br><span class="line">10.10.20.0      0.0.0.0         255.255.255.0   U     0      0        0 veth2</span><br></pre></td></tr></table></figure>
<p> 本示例网络拓扑如下<br> <img src="https://i.csms.tech/img_138.png"></p>
</li>
<li><p>确保系统开启了 ip_forward</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /proc/sys/net/ipv4/ip_forward</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>尝试互相 ping</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip netns <span class="built_in">exec</span> ns1 ping 10.10.20.2</span></span><br><span class="line">PING 10.10.20.2 (10.10.20.2) 56(84) bytes of data.</span><br><span class="line">^C</span><br><span class="line">--- 10.10.20.2 ping statistics ---</span><br><span class="line">7 packets transmitted, 0 received, 100% packet loss, time 6133ms</span><br><span class="line">   </span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<p>结果无法 ping 通，检查 iptables 防火墙，发现防火墙未开启，但是 <code>filter</code> 表中的 <code>FORWARD</code> 链的默认动作为 <code>DROP</code>，并且测试 network namespace 中的网卡互 ping 时，<code>policy DROP 17 packets, 1428 bytes</code> 显示 DROP 的包会增多。由此可知，无法 ping 通是因为此处包被 DROP </p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iptables -L -v -n</span></span><br><span class="line">Chain INPUT (policy ACCEPT 6292 packets, 425K bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy DROP 17 packets, 1428 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT 4532 packets, 328K bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行以下命令修改 iptables 防火墙的 <code>filter</code> 表中 <code>FORWARD</code> 链的默认动作为 <code>ACCEPT</code></p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iptables -P FORWARD ACCEPT</span><br></pre></td></tr></table></figure>
<p>重新测试 ping，可以正常 ping 通</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ip netns exec ns1 ping 10.10.20.2</span><br><span class="line">PING 10.10.20.2 (10.10.20.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.10.20.2: icmp_seq=1 ttl=63 time=0.084 ms</span><br><span class="line">64 bytes from 10.10.20.2: icmp_seq=2 ttl=63 time=0.037 ms</span><br><span class="line">^C</span><br><span class="line">--- 10.10.20.2 ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 1062ms</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="查看指定类型的网卡"><a href="#查看指定类型的网卡" class="headerlink" title="查看指定类型的网卡"></a>查看指定类型的网卡</h2><p>要查看系统上网卡属于哪种类型，可以通过以下命令查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip <span class="built_in">link</span> show <span class="built_in">type</span> vxlan</span></span><br><span class="line">6: flannel.1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 8951 qdisc noqueue state UNKNOWN mode DEFAULT group default </span><br><span class="line">    link/ether ce:8c:56:84:e1:7a brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip <span class="built_in">link</span> show <span class="built_in">type</span> veth</span></span><br><span class="line">2350: veth2fd77154@if3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 8951 qdisc noqueue master cni0 state UP mode DEFAULT group default </span><br><span class="line">    link/ether 5a:02:6c:65:c8:5f brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">2352: vethfef50370@if3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 8951 qdisc noqueue master cni0 state UP mode DEFAULT group default </span><br><span class="line">    link/ether 3a:1c:0b:4f:af:b2 brd ff:ff:ff:ff:ff:ff link-netnsid 2</span><br><span class="line">    </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip <span class="built_in">link</span> show <span class="built_in">type</span> bridge</span></span><br><span class="line">3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN mode DEFAULT group default </span><br><span class="line">    link/ether 02:42:48:54:ca:75 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">2349: cni0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 8951 qdisc noqueue state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 26:4e:46:b2:2a:4c brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure>
<p>以下命令查看网卡的详细信息，包括网卡类型</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip -d <span class="built_in">link</span> show veth1_p</span></span><br><span class="line">4: veth1_p@if5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 72:f1:d6:f6:c9:53 brd ff:ff:ff:ff:ff:ff link-netnsid 0 promiscuity 0 </span><br><span class="line">    veth addrgenmode eui64 numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535</span><br><span class="line">    </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip -d <span class="built_in">link</span> show docker0</span></span><br><span class="line">3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN mode DEFAULT group default </span><br><span class="line">    link/ether 02:42:f2:1b:dc:ea brd ff:ff:ff:ff:ff:ff promiscuity 0 </span><br><span class="line">    bridge forward_delay 1500 hello_time 200 max_age 2000 ageing_time 30000 stp_state 0 priority 32768 vlan_filtering 0 vlan_protocol 802.1Q bridge_id 8000.2:42:f2:1b:dc:ea designated_root 8000.2:42:f2:1b:dc:ea root_port 0 root_path_cost 0 topology_change 0 topology_change_detected 0 hello_timer    0.00 tcn_timer    0.00 topology_change_timer    0.00 gc_timer   48.83 vlan_default_pvid 1 vlan_stats_enabled 0 group_fwd_mask 0 group_address 01:80:c2:00:00:00 mcast_snooping 1 mcast_router 1 mcast_query_use_ifaddr 0 mcast_querier 0 mcast_hash_elasticity 16 mcast_hash_max 4096 mcast_last_member_count 2 mcast_startup_query_count 2 mcast_last_member_interval 100 mcast_membership_interval 26000 mcast_querier_interval 25500 mcast_query_interval 12500 mcast_query_response_interval 1000 mcast_startup_query_interval 3125 mcast_stats_enabled 0 mcast_igmp_version 2 mcast_mld_version 1 nf_call_iptables 0 nf_call_ip6tables 0 nf_call_arptables 0 addrgenmode eui64 numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535</span><br><span class="line">    </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip -d add</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 promiscuity 0 numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535 </span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    link/ether 00:0c:29:e7:c0:27 brd ff:ff:ff:ff:ff:ff promiscuity 0 numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535 </span><br><span class="line">    inet 192.168.142.10/24 brd 192.168.142.255 scope global noprefixroute ens33</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::20c:29ff:fee7:c027/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default </span><br><span class="line">    link/ether 02:42:f2:1b:dc:ea brd ff:ff:ff:ff:ff:ff promiscuity 0 </span><br><span class="line">    bridge forward_delay 1500 hello_time 200 max_age 2000 ageing_time 30000 stp_state 0 priority 32768 vlan_filtering 0 vlan_protocol 802.1Q bridge_id 8000.2:42:f2:1b:dc:ea designated_root 8000.2:42:f2:1b:dc:ea root_port 0 root_path_cost 0 topology_change 0 topology_change_detected 0 hello_timer    0.00 tcn_timer    0.00 topology_change_timer    0.00 gc_timer  147.42 vlan_default_pvid 1 vlan_stats_enabled 0 group_fwd_mask 0 group_address 01:80:c2:00:00:00 mcast_snooping 1 mcast_router 1 mcast_query_use_ifaddr 0 mcast_querier 0 mcast_hash_elasticity 16 mcast_hash_max 4096 mcast_last_member_count 2 mcast_startup_query_count 2 mcast_last_member_interval 100 mcast_membership_interval 26000 mcast_querier_interval 25500 mcast_query_interval 12500 mcast_query_response_interval 1000 mcast_startup_query_interval 3125 mcast_stats_enabled 0 mcast_igmp_version 2 mcast_mld_version 1 nf_call_iptables 0 nf_call_ip6tables 0 nf_call_arptables 0 numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535 </span><br><span class="line">    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">4: veth1_p@if5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000</span><br><span class="line">    link/ether 72:f1:d6:f6:c9:53 brd ff:ff:ff:ff:ff:ff link-netnsid 0 promiscuity 0 </span><br><span class="line">    veth numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535 </span><br><span class="line">    inet 10.10.10.1/24 scope global veth1_p</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::70f1:d6ff:fef6:c953/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">6: veth2_p@if7: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000</span><br><span class="line">    link/ether b6:17:a8:92:57:09 brd ff:ff:ff:ff:ff:ff link-netnsid 1 promiscuity 0 </span><br><span class="line">    veth numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535 </span><br><span class="line">    inet 10.10.20.1/24 scope global veth2_p</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::b417:a8ff:fe92:5709/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever  </span><br><span class="line">       </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip -d <span class="built_in">link</span></span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 promiscuity 0 addrgenmode eui64 numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535 </span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 00:0c:29:e7:c0:27 brd ff:ff:ff:ff:ff:ff promiscuity 0 addrgenmode eui64 numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535 </span><br><span class="line">3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN mode DEFAULT group default </span><br><span class="line">    link/ether 02:42:f2:1b:dc:ea brd ff:ff:ff:ff:ff:ff promiscuity 0 </span><br><span class="line">    bridge forward_delay 1500 hello_time 200 max_age 2000 ageing_time 30000 stp_state 0 priority 32768 vlan_filtering 0 vlan_protocol 802.1Q bridge_id 8000.2:42:f2:1b:dc:ea designated_root 8000.2:42:f2:1b:dc:ea root_port 0 root_path_cost 0 topology_change 0 topology_change_detected 0 hello_timer    0.00 tcn_timer    0.00 topology_change_timer    0.00 gc_timer   67.56 vlan_default_pvid 1 vlan_stats_enabled 0 group_fwd_mask 0 group_address 01:80:c2:00:00:00 mcast_snooping 1 mcast_router 1 mcast_query_use_ifaddr 0 mcast_querier 0 mcast_hash_elasticity 16 mcast_hash_max 4096 mcast_last_member_count 2 mcast_startup_query_count 2 mcast_last_member_interval 100 mcast_membership_interval 26000 mcast_querier_interval 25500 mcast_query_interval 12500 mcast_query_response_interval 1000 mcast_startup_query_interval 3125 mcast_stats_enabled 0 mcast_igmp_version 2 mcast_mld_version 1 nf_call_iptables 0 nf_call_ip6tables 0 nf_call_arptables 0 addrgenmode eui64 numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535 </span><br><span class="line">4: veth1_p@if5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 72:f1:d6:f6:c9:53 brd ff:ff:ff:ff:ff:ff link-netnsid 0 promiscuity 0 </span><br><span class="line">    veth addrgenmode eui64 numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535 </span><br><span class="line">6: veth2_p@if7: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether b6:17:a8:92:57:09 brd ff:ff:ff:ff:ff:ff link-netnsid 1 promiscuity 0 </span><br><span class="line">    veth addrgenmode eui64 numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535       </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
        <category>network</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>网宿云 cdn 预热脚本</title>
    <url>/202207251026/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>将源站的内容主动预取到 CDN 节点，用户首次访问可直接命中缓存，即提升首次访问速度，又能有效缓解源站压力。</p>
<ul>
<li>数据格式：请求和响应都支持 json&#x2F;xml，xml 的参数与 json 的参数基本一致，json 的参数是驼峰分隔，xml 的参数是“-”分隔，详见示例。</li>
<li>限制说明：每个账号的预取并发是 10，调高并发会增加回源的压力，请联系技术支持人员评估。</li>
</ul>
<span id="more"></span>

<h3 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h3><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">类型</th>
<th align="center">是否必填</th>
<th align="left">说明</th>
<th align="left">内部备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">urls</td>
<td align="center">Array</td>
<td align="center">是</td>
<td align="left">要预取到 CDN 节点的 url 集合，url 格式说明：<br/>1）URL 必须以’http:&#x2F;&#x2F;‘ 或 ‘https:&#x2F;&#x2F;‘ 开头，输入示例：<a href="http://www.a.com/image/test.png%E3%80%82">http://www.a.com/image/test.png。</a> <br/>2）每个 url 最大长度 2000 字符。<br/>3）每个 url 所在的域名必须是在我司加速的域名且有预取权限。<br/>4）url 中如果包含中文字符，则提交的 url 需要是中文转义后的url，采用 utf-8 方式转义。<br/>5）每日不超过 20000 条，不超过 200G 文件大小（账号粒度可调，联系技术支持人员调整）。<br/>6）每次接口调用 url 的总数不超过 400 条。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">isRange</td>
<td align="center">Int</td>
<td align="center">否</td>
<td align="left">是否需要预取 range 段。<br/>1）默认为 0，表示预取完整的文件；<br/>2）1 表示预取文件 0~512KB 的 range 段（账号粒度可调，联系技术支持人员调整）。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">aliasDomain</td>
<td align="center">String</td>
<td align="center">否</td>
<td align="left">账号开启 ts 解析<br/>有值的话，m3u8 和生成的 ts 文件需要同时生成一份带别名的url</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">parentDir</td>
<td align="center">String</td>
<td align="center">否</td>
<td align="left">一级目录，该参数和 aliasDomain 一起使用<br/>如果有值的话，是做为别名的一级目录</td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="响应参数"><a href="#响应参数" class="headerlink" title="响应参数"></a>响应参数</h3><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">x-cnc-request-id</td>
<td align="center">String</td>
<td align="left">本次请求的唯一标识,当接口调用异常时，可将 requestID 提供给网宿技术支持，便于排查接口的访问日志。</td>
</tr>
<tr>
<td align="center">Code</td>
<td align="center">Int</td>
<td align="left">表示任务创建结果的状态码，1 表示任务提交成功，0 表示任务提交失败</td>
</tr>
<tr>
<td align="center">Message</td>
<td align="center">String</td>
<td align="left">表示任务提交后，系统的响应消息</td>
</tr>
<tr>
<td align="center">itemId</td>
<td align="center">String</td>
<td align="left">调用一次接口并提交任务成功后，将返回一个 itemId，是当次提交任务的唯一标识，通过 itemId 可批量查询任务的状态（成功&#x2F;失败）。</td>
</tr>
</tbody></table>
<h3 id="请求示例"><a href="#请求示例" class="headerlink" title="请求示例"></a>请求示例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">username=&quot;username&quot;</span><br><span class="line">apiKey=&quot;apiKey&quot;</span><br><span class="line">date=`env LANG=&quot;en_US.UTF-8&quot; date -u &quot;+%a, %d %b %Y %H:%M:%S GMT&quot;`</span><br><span class="line">password=`echo -en &quot;$date&quot; | openssl dgst -sha1 -hmac $apiKey -binary | </span><br><span class="line">openssl enc -base64`</span><br><span class="line">curl -i --url &quot;https://open.chinanetcenter.com/ccm/fetch/ItemIdReceiver&quot; -X &quot;POST&quot; -u &quot;$username:$password&quot; \</span><br><span class="line"> -H &quot;Date:$date&quot; -H &quot;Content-Type: application/json&quot; -d &#x27;&#123;</span><br><span class="line"> &quot;urls&quot;: [</span><br><span class="line"> &quot;http://www.testb.com/test/test1.txt&quot;,</span><br><span class="line"> &quot;http://www.testb.com/test/test2.txt&quot;</span><br><span class="line"> ],</span><br><span class="line">&quot;isRange&quot;:0</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://wcs.chinanetcenter.com/document/Tools/GenerateUploadToken"><code>apiKey</code> 生成链接</a></p>
</blockquote>
<p>正确的响应示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Fri, 26 Oct 2012 06:33:26 GMT</span><br><span class="line">Content-Type: application/json;charset=UTF-8 x-cnc-request-id:&#123;id string auto generated by cloud server&#125;</span><br><span class="line">&#123;</span><br><span class="line"> &quot;Code&quot;: 1,</span><br><span class="line"> &quot;Message&quot;: &quot;success&quot;,</span><br><span class="line"> &quot;itemId&quot;: &quot;a2cfcc6fe79c4a8abcab806578f9bada&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://wcs.chinanetcenter.com/document/Tools/GenerateUploadToken">官网说明</a><br><a href="https://s.csms.tech/file/01%E6%8E%A8%E8%8D%90-%E9%A2%84%E5%8F%96%E6%96%87%E4%BB%B6.pdf">网宿cdn预热完整文档</a></p>
]]></content>
      <categories>
        <category>云平台</category>
        <category>网宿</category>
      </categories>
      <tags>
        <tag>云平台</tag>
        <tag>网宿</tag>
      </tags>
  </entry>
  <entry>
    <title>网宿云存储 python sdk 常用操作</title>
    <url>/f63bf868/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li><p>Centos7</p>
</li>
<li><p>Python3</p>
</li>
<li><p>wcs-python3-sdk (5.0.35)</p>
</li>
</ul>
<p># 网宿云python sdk, <code>pip3 install wcs-python3-sdk</code>， 安装后包含cli工具<code>wcscmd</code></p>
<h3 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wcscmd --configure [--config=FILE] </span><br></pre></td></tr></table></figure>

<p><code>--config=FILE  </code>配置文件存储路径，默认<code>~/.wcscfg</code> <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[参考链接](https://github.com/Wangsu-Cloud-Storage/wcs-python-sdk)">[1]</span></a></sup></p>
<h3 id="wcscmd-常用操作"><a href="#wcscmd-常用操作" class="headerlink" title="wcscmd 常用操作"></a>wcscmd 常用操作</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wcscmd listbucket </span><br><span class="line">wcscmd stat wcs://BUCKET/OBJECT  \# 查询文件信息</span><br><span class="line">wcscmd deletePrefix wcs://BUCKET PREFIX  \# 根据前缀（文件路径，必须从头开始匹配，不需要最前面的/）删除目录或文件</span><br><span class="line">wcscmd put wcs://BUCKET/file file</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="python3-sdk-操作"><a href="#python3-sdk-操作" class="headerlink" title="python3 sdk 操作"></a>python3 sdk 操作</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> wcs.commons.config <span class="keyword">import</span> Config</span><br><span class="line"><span class="keyword">from</span> wcs.services.client <span class="keyword">import</span> Client</span><br><span class="line"></span><br><span class="line">config_file = <span class="string">&quot;/root/.wcscfg&quot;</span></span><br><span class="line">cfg = Config(config_file)</span><br><span class="line">cli = Client(cfg)</span><br><span class="line">bucketName = <span class="string">&quot;TestBucket&quot;</span></span><br><span class="line">buckList = cli.bucket_list(bucketName, marker=<span class="string">&#x27;&#x27;</span>)    <span class="comment"># 列出bucket中的文件列表，每次最多获取1000个，第一页 `marker=&#x27;&#x27;`, 请求第一页的响应中marker的值为新的页的marker，可通过新的marker继续发起请求</span></span><br></pre></td></tr></table></figure>

<h4 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h4><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://github.com/Wangsu-Cloud-Storage/wcs-python-sdk">参考链接</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>云平台</category>
        <category>网宿</category>
      </categories>
      <tags>
        <tag>云平台</tag>
        <tag>网宿</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 小脚本</title>
    <url>/202302251557/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="定时同步数据到-Linux-rsync-服务器"><a href="#定时同步数据到-Linux-rsync-服务器" class="headerlink" title="定时同步数据到 Linux rsync 服务器"></a>定时同步数据到 Linux rsync 服务器</h1><p>脚本内容如下，本示例中 Windows 版 <code>rsync</code> 客户端安装位置： <code>d:\cwrsync_6.2.4_x64_free\</code>，密码文件路径：<code>d:\cwrsync_6.2.4_x64_free\rsync.client.pswd</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">:start</span><br><span class="line">cd d:\</span><br><span class="line">cd cwrsync_6.2.4_x64_free</span><br><span class="line"></span><br><span class="line">.\bin\rsync.exe --progress -a -c -r -u -t --timeout=300 -z --password-file rsync.client.pswd --exclude &#x27;.idea&#x27; --exclude &#x27;rsync2Server.bat&#x27; /cygdrive/d/cwrsync_6.2.4_x64_free/data/ rsync@$&#123;RSYNC_SERVER&#125;:backup</span><br><span class="line"></span><br><span class="line">choice /t 5 /d y /n &gt;nul</span><br><span class="line"></span><br><span class="line">goto start</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>windows 远程登录失败</title>
    <url>/f5e030ac/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>远程登录 windows 失败，报错:</p>
<blockquote>
<p>由于没有远程桌面授权服务器可以提供许可证，远程会话连接已断开，请跟服务器管理员联系</p>
</blockquote>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ol>
<li>打开 cmd，执行以下命令远程登录无法登录的 Windows 主机<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">mstsc /v:<span class="number">1</span>.<span class="number">1</span>.<span class="number">1</span>.<span class="number">1</span> /admin</span><br></pre></td></tr></table></figure></li>
<li>打开注册表</li>
</ol>
<p><img src="https://i.csms.tech/img_1.png"><br>3. 找到路径： HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\RCM\GracePeriod.如果超过120天后RCM下面会有一个GracePeriod,先备份这项注册表，再删除除了默认的的注册表项。</p>
<ol start="4">
<li>重启电脑后生效.</li>
</ol>
]]></content>
      <categories>
        <category>Windows</category>
        <category>常见错误</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>wireshark 抓包工具使用</title>
    <url>/202211251613/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="wiresark-显示过滤器使用方法"><a href="#wiresark-显示过滤器使用方法" class="headerlink" title="wiresark 显示过滤器使用方法"></a>wiresark 显示过滤器使用方法</h1><p>Wireshark 提供了两种过滤器</p>
<ul>
<li><strong>捕获过滤器</strong>：在抓包之前就设定好过滤条件，然后只抓取符合条件的数据包。</li>
<li><strong>显示过滤器</strong>：在已捕获的数据包集合中设置过滤条件，隐藏不想显示的数据包，只显示符合条件的数据包。</li>
</ul>
<p>这两种过滤器所使用的语法是完全不同的，捕捉网卡数据的其实并不是 Wireshark，而是 WinPcap，要按 WinPcap 的规则来，显示过滤器就是 Wireshark 对已捕捉的数据进行筛选。</p>
<h2 id="显示过滤器中常用的关系计算符号"><a href="#显示过滤器中常用的关系计算符号" class="headerlink" title="显示过滤器中常用的关系计算符号"></a>显示过滤器中常用的关系计算符号</h2><table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>eq</code><br/><code>==</code></td>
<td>等于</td>
<td><code>ip.src==10.10.10.10</code> <br/><code>ip.src eq 10.10.10.10</code></td>
</tr>
<tr>
<td><code>ne</code><br/><code>!=</code></td>
<td>不等于</td>
<td><code>ip.src!=10.10.10.10</code> <br/><code>ip.src ne 10.10.10.10</code></td>
</tr>
<tr>
<td><code>gt</code><br/><code>&gt;</code></td>
<td>大于</td>
<td></td>
</tr>
<tr>
<td><code>lt</code><br/><code>&lt;</code></td>
<td>小于</td>
<td></td>
</tr>
<tr>
<td><code>ge</code><br/><code>&gt;=</code></td>
<td>大于等于</td>
<td></td>
</tr>
<tr>
<td><code>le</code><br/><code>&lt;=</code></td>
<td>小于等于</td>
<td></td>
</tr>
<tr>
<td><code>contains</code></td>
<td>包含</td>
<td><code>http.host contains com</code></td>
</tr>
</tbody></table>
<h2 id="显示过滤器中常用的逻辑计算符号"><a href="#显示过滤器中常用的逻辑计算符号" class="headerlink" title="显示过滤器中常用的逻辑计算符号"></a>显示过滤器中常用的逻辑计算符号</h2><table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>and</code><br/><code>&amp;&amp;</code></td>
<td>与</td>
<td><code>http.host contains com &amp;&amp; ip.src == 44.199.163.86</code><br/><code>http.host contains com and ip.src == 44.199.163.86</code></td>
</tr>
<tr>
<td><code>or</code><br/><code>||</code></td>
<td>或</td>
<td></td>
</tr>
<tr>
<td><code>not</code><br/><code>!</code></td>
<td>非</td>
<td></td>
</tr>
</tbody></table>
<h2 id="常用示例"><a href="#常用示例" class="headerlink" title="常用示例"></a>常用示例</h2><h3 id="针对-IP-过滤"><a href="#针对-IP-过滤" class="headerlink" title="针对 IP 过滤"></a>针对 IP 过滤</h3><ul>
<li>对源地址进行过滤<br><code>ip.src == 192.168.0.1</code></li>
<li>对目的地址进行过滤<br><code>ip.dst == 192.168.0.1</code></li>
<li>对源地址或者目的地址进行过滤<br><code>ip.addr == 192.168.0.1</code></li>
<li>如果想排除以上的数据包，只需要将其用括号囊括，然后使用 <code>!</code> 即可<br><code>!(ip.addr == 192.168.0.1)</code></li>
</ul>
<h3 id="针对协议过滤"><a href="#针对协议过滤" class="headerlink" title="针对协议过滤"></a>针对协议过滤</h3><p>针对某种协议的数据包，表达式很简单仅仅需要把协议的名字（必须小写）输入即可</p>
<p>常见协议：<br><code>tcp</code><br><code>udp</code><br><code>arp</code><br><code>icmp</code><br><code>http</code><br><code>smtp</code><br><code>ftp</code><br><code>dns</code><br><code>msnms</code><br><code>ip</code><br><code>ssl</code><br><code>oicq</code><br><code>bootp</code></p>
<h3 id="针对端口过滤"><a href="#针对端口过滤" class="headerlink" title="针对端口过滤"></a>针对端口过滤</h3><ul>
<li>捕获某一端口的数据包（以 tcp 协议为例）<br><code>tcp.port == 80</code></li>
<li>捕获多端口的数据包，可以使用 <code>and</code> 来连接，下面是捕获高于某端口的表达式（以 udp 协议为例）<br><code>udp.port &gt;= 2048</code></li>
</ul>
<h3 id="针对-http-请求的一些过滤实例"><a href="#针对-http-请求的一些过滤实例" class="headerlink" title="针对 http 请求的一些过滤实例"></a>针对 http 请求的一些过滤实例</h3><ul>
<li>过滤出请求地址中包含 <code>user</code> 的请求，不包括域名<br><code>http.request.uri contains &quot;User&quot;</code></li>
<li>精确过滤域名<br><code>http.host==baidu.com</code></li>
<li>模糊过滤域名<br><code>http.host contains &quot;baidu&quot;</code></li>
<li>过滤请求的 content_type 类型<br><code>http.content_type ==&quot;text/html&quot;</code><br>-过滤 http 请求方法<br><code>http.request.method==&quot;POST&quot;</code></li>
<li>过滤 tcp 端口<br><code>tcp.port==80</code><br><code>http &amp;&amp; tcp.port==80 or tcp.port==5566</code></li>
<li>过滤 http 响应状态码<br><code>http.response.code==302</code></li>
<li>过滤含有指定 cookie 的 http 数据包<br><code>http.cookie contains &quot;userid&quot;</code></li>
</ul>
]]></content>
      <categories>
        <category>TCPIP</category>
      </categories>
      <tags>
        <tag>wireshark</tag>
      </tags>
  </entry>
  <entry>
    <title>xshell 常用配置</title>
    <url>/202208101059/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>xshell7</li>
</ul>
<h3 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h3><h4 id="字体配置"><a href="#字体配置" class="headerlink" title="字体配置"></a>字体配置</h4><p>(菜单栏)查看 &gt; 工具栏 &gt; 标准按钮  </p>
<p><img src="https://i.csms.tech/img_36.png"></p>
<span id="more"></span>

<h4 id="Meta-键配置"><a href="#Meta-键配置" class="headerlink" title="Meta 键配置"></a>Meta 键配置</h4><p>(菜单栏)文件 &gt; 当前会话属性:<br><img src="https://i.csms.tech/img_37.png"></p>
<p>终端中使用 <code>Alt .</code> 可自动补齐上一条命令的最后一个参数  </p>
<h4 id="配置-选中即复制"><a href="#配置-选中即复制" class="headerlink" title="配置 选中即复制"></a>配置 选中即复制</h4><p>工具-&gt;选项<br><img src="https://i.csms.tech/img_38.png"></p>
<p>选择 <code>键盘和鼠标</code><br><img src="https://i.csms.tech/img_39.png"></p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>xshell</category>
      </categories>
      <tags>
        <tag>xshell</tag>
      </tags>
  </entry>
  <entry>
    <title>yum</title>
    <url>/202208111442/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>CentOS Linux release 7.9.2009 (Core)</li>
<li>yum-3.4.3</li>
</ul>
<h1 id="yum-命令示例"><a href="#yum-命令示例" class="headerlink" title="yum 命令示例"></a>yum 命令示例</h1><h2 id="查询指定命令来自哪个安装包"><a href="#查询指定命令来自哪个安装包" class="headerlink" title="查询指定命令来自哪个安装包"></a>查询指定命令来自哪个安装包</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum whatprovides ip</span></span><br><span class="line">iproute-4.11.0-30.el7.x86_64 : Advanced IP routing and network device configuration tools</span><br><span class="line">Repo        : base</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : /sbin/ip</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>rpm</code> 查询已安装文件来自哪个安装包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rpm -qf /sbin/ip</span></span><br><span class="line">iproute-4.11.0-30.el7.x86_64</span><br></pre></td></tr></table></figure>

<h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><h2 id="The-GPG-keys-listed-for-the-“MySQL-5-7-Community-Server”-repository-are-already-installed-but-they-are-not-correct-for-this-package"><a href="#The-GPG-keys-listed-for-the-“MySQL-5-7-Community-Server”-repository-are-already-installed-but-they-are-not-correct-for-this-package" class="headerlink" title="The GPG keys listed for the “MySQL 5.7 Community Server” repository are already installed but they are not correct for this package"></a>The GPG keys listed for the “MySQL 5.7 Community Server” repository are already installed but they are not correct for this package</h2><p><strong>解救方法</strong></p>
<p>修改对应 <code>yum</code> 源的配置文件，将其中的配置 <code>gpgcheck=1</code> 改为 <code>gpgcheck=0</code>，以此跳过 key 验证</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Prometheus Node exporter 使用</title>
    <url>/202306071109/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos 7</li>
<li>Prometheus 2.44.0</li>
</ul>
<h1 id="node-exporter-配置信息"><a href="#node-exporter-配置信息" class="headerlink" title="node_exporter 配置信息"></a>node_exporter 配置信息</h1><h2 id="启动参数详解"><a href="#启动参数详解" class="headerlink" title="启动参数详解"></a>启动参数详解</h2><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>--web.listen-address=&quot;:9100&quot;</code></td>
<td>node_exporter 监听端口，默认 9100</td>
<td></td>
</tr>
<tr>
<td><code>--web.telemetry-path=&quot;/metrics&quot;</code></td>
<td>prometheus 获取 Metrics 访问的 url，默认 <code>/metrics</code></td>
<td></td>
</tr>
<tr>
<td><code>--log.level=&quot;info&quot;</code></td>
<td>日志级别</td>
<td></td>
</tr>
<tr>
<td><code>--log.format=&quot;logger:stderr&quot;</code></td>
<td>日志打印格式</td>
<td></td>
</tr>
<tr>
<td><code>--collector.disable-defaults</code></td>
<td>关闭默认的采集项</td>
<td></td>
</tr>
<tr>
<td><code>--no-collector.$&#123;item&#125;</code></td>
<td>关闭某一项默认开启的采集项</td>
<td><code>--no-collector.cpu</code></td>
</tr>
<tr>
<td><code>--collector.systemd.unit-include=&quot;(docker&#39;|&#39;sshd).service&quot;</code></td>
<td>收集指定服务的指标</td>
<td></td>
</tr>
</tbody></table>
<p>可以配置通过正则表达式屏蔽或者选择某些监控项 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[node_exporter 官网 github](https://github.com/prometheus/node_exporter)">[1]</span></a></sup></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>--collector.diskstats.ignored-devices=&quot;^(ram&#39;|&#39;loop&#39;|&#39;)\\d+$&quot;</code></td>
<td>忽略某些磁盘的信息收集</td>
<td></td>
</tr>
<tr>
<td><code>--collector.filesystem.ignored-mount-points=&quot;^/(dev&#39;|&#39;proc&#39;|&#39;)($&#39;|&#39;/)&quot;</code></td>
<td>忽略某些文件系统挂载点的信息收集</td>
<td></td>
</tr>
<tr>
<td><code>--collector.filesystem.ignored-fs-types=&quot;^(autofs&#39;|&#39;proc)$&quot;</code></td>
<td>忽略某些文件系统类型的信息收集</td>
<td></td>
</tr>
<tr>
<td><code>--collector.netclass.ignored-devices=&quot;^$&quot;</code></td>
<td>忽略某些网络类的信息收集</td>
<td></td>
</tr>
<tr>
<td><code>--collector.netdev.ignored-devices=&quot;^$&quot;</code></td>
<td>忽略某些网络设备的信息收集</td>
<td></td>
</tr>
<tr>
<td><code>--collector.netstat.fields=&quot;^$&quot;</code></td>
<td>配置需要获取的网络状态信息</td>
<td></td>
</tr>
<tr>
<td><code>--collector.vmstat.fields=&quot;^(oom_kill&#39;|&#39;pgpg&#39;|&#39;pswp).*&quot;</code></td>
<td>配置 vmstat 返回信息中需要收集的选项</td>
<td></td>
</tr>
</tbody></table>
<h2 id="功能对照表"><a href="#功能对照表" class="headerlink" title="功能对照表"></a>功能对照表</h2><h3 id="默认开启的功能"><a href="#默认开启的功能" class="headerlink" title="默认开启的功能"></a>默认开启的功能</h3><p>默认开启的功能 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[node_exporter 官网 github](https://github.com/prometheus/node_exporter)">[1]</span></a></sup></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
<th>系统</th>
</tr>
</thead>
<tbody><tr>
<td><code>arp</code></td>
<td>从 <code>/proc/net/arp</code> 中收集 ARP 统计信息</td>
<td>Linux</td>
</tr>
<tr>
<td><code>conntrack</code></td>
<td>从 <code>/proc/sys/net/netfilter/</code> 中收集 <code>conntrack</code> 统计信息</td>
<td>Linux</td>
</tr>
<tr>
<td><code>cpu</code></td>
<td>收集 cpu 统计信息</td>
<td>Darwin, Dragonfly, FreeBSD, Linux</td>
</tr>
<tr>
<td><code>diskstats</code></td>
<td>从 <code>/proc/diskstats</code> 中收集磁盘 I&#x2F;O 统计信息</td>
<td>Linux</td>
</tr>
<tr>
<td><code>edac</code></td>
<td>错误检测与纠正统计信息</td>
<td>Linux</td>
</tr>
<tr>
<td><code>entropy</code></td>
<td>可用内核熵信息</td>
<td>Linux</td>
</tr>
<tr>
<td><code>exec</code></td>
<td>execution 统计信息</td>
<td>Dragonfly, FreeBSD</td>
</tr>
<tr>
<td><code>filefd</code></td>
<td>从 <code>/proc/sys/fs/file-nr</code> 中收集文件描述符统计信息</td>
<td>Linux</td>
</tr>
<tr>
<td><code>filesystem</code></td>
<td>文件系统统计信息，例如磁盘已使用空间</td>
<td>Darwin, Dragonfly, FreeBSD, Linux, OpenBSD</td>
</tr>
<tr>
<td><code>hwmon</code></td>
<td>从 <code>/sys/class/hwmon/</code> 中收集监控器或传感器数据信息</td>
<td>Linux</td>
</tr>
<tr>
<td><code>infiniband</code></td>
<td>从 InfiniBand 配置中收集网络统计信息</td>
<td>Linux</td>
</tr>
<tr>
<td><code>loadavg</code></td>
<td>收集系统负载信息</td>
<td>Darwin, Dragonfly, FreeBSD, Linux, NetBSD, OpenBSD, Solaris</td>
</tr>
<tr>
<td><code>mdadm</code></td>
<td>从 <code>/proc/mdstat</code> 中获取设备统计信息</td>
<td>Linux</td>
</tr>
<tr>
<td><code>meminfo</code></td>
<td>内存统计信息</td>
<td>Darwin, Dragonfly, FreeBSD, Linux</td>
</tr>
<tr>
<td><code>netdev</code></td>
<td>网口流量统计信息，单位 bytes</td>
<td>Darwin, Dragonfly, FreeBSD, Linux, OpenBSD</td>
</tr>
<tr>
<td><code>netstat</code></td>
<td>从 <code>/proc/net/netstat</code> 收集网络统计数据，等同于 <code>netstat -s</code></td>
<td>Linux</td>
</tr>
<tr>
<td><code>sockstat</code></td>
<td>从 <code>/proc/net/sockstat</code> 中收集 socket 统计信息</td>
<td>Linux</td>
</tr>
<tr>
<td><code>stat</code></td>
<td>从 <code>/proc/stat</code> 中收集各种统计信息，包含系统启动时间，forks, 中断等</td>
<td>Linux</td>
</tr>
<tr>
<td><code>textfile</code></td>
<td>通过 <code>--collector.textfile.directory</code> 参数指定本地文本收集路径，收集文本信息</td>
<td>any</td>
</tr>
<tr>
<td><code>time</code></td>
<td>系统当前时间</td>
<td>any</td>
</tr>
<tr>
<td><code>uname</code></td>
<td>通过 <code>uname</code> 系统调用, 获取系统信息</td>
<td>any</td>
</tr>
<tr>
<td><code>vmstat</code></td>
<td>从 <code>/proc/vmstat</code> 中收集统计信息</td>
<td>Linux</td>
</tr>
<tr>
<td><code>wifi</code></td>
<td>收集 <code>wifi</code> 设备相关统计数据</td>
<td>Linux</td>
</tr>
<tr>
<td><code>xfs</code></td>
<td>收集 xfs 运行时统计信息</td>
<td>Linux (kernel 4.4+)</td>
</tr>
<tr>
<td><code>zfs</code></td>
<td>收集 zfs 性能统计信息</td>
<td>Linux</td>
</tr>
</tbody></table>
<h3 id="默认关闭的功能"><a href="#默认关闭的功能" class="headerlink" title="默认关闭的功能"></a>默认关闭的功能</h3><p>默认关闭的功能 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[node_exporter 官网 github](https://github.com/prometheus/node_exporter)">[1]</span></a></sup></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
<th>系统</th>
</tr>
</thead>
<tbody><tr>
<td><code>bonding</code></td>
<td>收集系统配置以及激活的绑定网卡数量</td>
<td>Linux</td>
</tr>
<tr>
<td><code>buddyinfo</code></td>
<td>从 <code>/proc/buddyinfo</code> 中收集内存碎片统计信息</td>
<td>Linux</td>
</tr>
<tr>
<td><code>devstat</code></td>
<td>收集设备统计信息</td>
<td>Dragonfly, FreeBSD</td>
</tr>
<tr>
<td><code>drbd</code></td>
<td>收集远程镜像块设备（DRBD）统计信息</td>
<td>Linux</td>
</tr>
<tr>
<td><code>interrupts</code></td>
<td>收集更具体的中断统计信息</td>
<td>Linux，OpenBSD</td>
</tr>
<tr>
<td><code>ipvs</code></td>
<td>从 <code>/proc/net/ip_vs</code> 中收集 IPVS 状态信息，从 <code>/proc/net/ip_vs_stats</code> 获取统计信息</td>
<td>Linux</td>
</tr>
<tr>
<td><code>ksmd</code></td>
<td>从 <code>/sys/kernel/mm/ksm</code> 中获取内核和系统统计信息</td>
<td>Linux</td>
</tr>
<tr>
<td><code>logind</code></td>
<td>从 <code>logind</code> 中收集会话统计信息</td>
<td>Linux</td>
</tr>
<tr>
<td><code>meminfo_numa</code></td>
<td>从 <code>/proc/meminfo_numa</code> 中收集内存统计信息</td>
<td>Linux</td>
</tr>
<tr>
<td><code>mountstats</code></td>
<td>从 <code>/proc/self/mountstat</code> 中收集文件系统统计信息，包括 NFS 客户端统计信息</td>
<td>Linux</td>
</tr>
<tr>
<td><code>nfs</code></td>
<td>从 <code>/proc/net/rpc/nfs</code> 中收集 NFS 统计信息，等同于 <code>nfsstat -c</code></td>
<td>Linux</td>
</tr>
<tr>
<td><code>qdisc</code></td>
<td>收集队列推定统计信息</td>
<td>Linux</td>
</tr>
<tr>
<td><code>runit</code></td>
<td>收集 <code>runit</code> 状态信息</td>
<td>any</td>
</tr>
<tr>
<td><code>supervisord</code></td>
<td>收集 <code>supervisord</code> 状态信息</td>
<td>any</td>
</tr>
<tr>
<td><code>systemd</code></td>
<td>从 <code>systemd</code> 中收集设备系统状态信息</td>
<td>Linux</td>
</tr>
<tr>
<td><code>tcpstat</code></td>
<td>从 <code>/proc/net/tcp</code> 和 <code>/proc/net/tcp6</code> 收集 TCP 连接状态信息</td>
<td>Linux</td>
</tr>
</tbody></table>
<h2 id="配置示例"><a href="#配置示例" class="headerlink" title="配置示例"></a>配置示例</h2><h3 id="采集白名单配置"><a href="#采集白名单配置" class="headerlink" title="采集白名单配置"></a>采集白名单配置</h3><p>关闭默认的采集项，只开启指定的采集项（白名单）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node-exporter --collector.disable-defaults --collector.cpu --collector.meminfo</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h3 id="采集黑名单配置"><a href="#采集黑名单配置" class="headerlink" title="采集黑名单配置"></a>采集黑名单配置</h3><p>关闭某一项默认开启的采集项</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node-exporter --no-collector.cpu</span><br></pre></td></tr></table></figure>

<h3 id="配置-node-exporter-收集系统服务"><a href="#配置-node-exporter-收集系统服务" class="headerlink" title="配置 node_exporter 收集系统服务"></a>配置 node_exporter 收集系统服务</h3><p>修改 <code>node_exporter</code> 使用以下参数，本示例中使用 Kubernetes DaemonSet 启动。<strong>需要先配置参数 <code>--collector.systemd</code>，再填加服务白名单，否则无法使用 <code>--collector.systemd.unit-whitelist</code> 参数</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">containers:</span><br><span class="line">- args:</span><br><span class="line">  - --path.procfs</span><br><span class="line">  - /host/proc</span><br><span class="line">  - --path.sysfs</span><br><span class="line">  - /host/sys</span><br><span class="line">  - --collector.filesystem.ignored-mount-points</span><br><span class="line">  - &#x27;&quot;^/(sys|proc|dev|host|etc)($|/)&quot;&#x27;</span><br><span class="line">  - --collector.systemd</span><br><span class="line">  - --collector.systemd.unit-include</span><br><span class="line">  - &#x27;(sshd|docker|cri-docker|crond|iptables|systemd-journald).service&#x27;</span><br><span class="line">  image: prom/node-exporter</span><br><span class="line">  imagePullPolicy: Always</span><br><span class="line">  name: node-exporter</span><br><span class="line">  ports:</span><br><span class="line">  - containerPort: 9100</span><br><span class="line">    hostPort: 9100</span><br><span class="line">    name: http</span><br><span class="line">    protocol: TCP</span><br><span class="line">  resources: &#123;&#125;</span><br><span class="line">  securityContext:</span><br><span class="line">    privileged: true</span><br><span class="line">  terminationMessagePath: /dev/termination-log</span><br><span class="line">  terminationMessagePolicy: File</span><br><span class="line">  volumeMounts:</span><br><span class="line">  - mountPath: /host/dev</span><br><span class="line">    name: dev</span><br><span class="line">  - mountPath: /host/proc</span><br><span class="line">    name: proc</span><br><span class="line">  - mountPath: /host/sys</span><br><span class="line">    name: sys</span><br><span class="line">  - mountPath: /rootfs</span><br><span class="line">    name: rootfs</span><br><span class="line">volumes:</span><br><span class="line">- hostPath:</span><br><span class="line">    path: /proc</span><br><span class="line">    type: &quot;&quot;</span><br><span class="line">  name: proc</span><br><span class="line">- hostPath:</span><br><span class="line">    path: /dev</span><br><span class="line">    type: &quot;&quot;</span><br><span class="line">  name: dev</span><br><span class="line">- hostPath:</span><br><span class="line">    path: /sys</span><br><span class="line">    type: &quot;&quot;</span><br><span class="line">  name: sys</span><br><span class="line">- hostPath:</span><br><span class="line">    path: /</span><br><span class="line">    type: &quot;&quot;</span><br><span class="line">  name: rootfs    </span><br></pre></td></tr></table></figure>

<p><code>node_exporter</code> 启动后，在节点上检查 <code>node_exporter</code> 输出的 Metrics</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl localhost:9100/metrics | grep -i node_systemd</span></span><br><span class="line">node_systemd_unit_state&#123;name=&quot;cri-docker.service&quot;,state=&quot;activating&quot;,type=&quot;notify&quot;&#125; 0</span><br><span class="line">node_systemd_unit_state&#123;name=&quot;cri-docker.service&quot;,state=&quot;active&quot;,type=&quot;notify&quot;&#125; 1</span><br><span class="line">node_systemd_unit_state&#123;name=&quot;cri-docker.service&quot;,state=&quot;deactivating&quot;,type=&quot;notify&quot;&#125; 0</span><br><span class="line">node_systemd_unit_state&#123;name=&quot;cri-docker.service&quot;,state=&quot;failed&quot;,type=&quot;notify&quot;&#125; 0</span><br><span class="line">node_systemd_unit_state&#123;name=&quot;cri-docker.service&quot;,state=&quot;inactive&quot;,type=&quot;notify&quot;&#125; 0</span><br><span class="line">node_systemd_unit_state&#123;name=&quot;crond.service&quot;,state=&quot;activating&quot;,type=&quot;simple&quot;&#125; 0</span><br><span class="line">node_systemd_unit_state&#123;name=&quot;crond.service&quot;,state=&quot;active&quot;,type=&quot;simple&quot;&#125; 1</span><br><span class="line">node_systemd_unit_state&#123;name=&quot;crond.service&quot;,state=&quot;deactivating&quot;,type=&quot;simple&quot;&#125; 0</span><br><span class="line">node_systemd_unit_state&#123;name=&quot;crond.service&quot;,state=&quot;failed&quot;,type=&quot;simple&quot;&#125; 0</span><br><span class="line">node_systemd_unit_state&#123;name=&quot;crond.service&quot;,state=&quot;inactive&quot;,type=&quot;simple&quot;&#125; 0</span><br></pre></td></tr></table></figure>

<p>在 Prometheus 的 UI 界面中检查<br><img src="https://i.csms.tech/img_175.png"></p>
<h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><h2 id="couldn’t-get-dbus-connection"><a href="#couldn’t-get-dbus-connection" class="headerlink" title="couldn’t get dbus connection"></a>couldn’t get dbus connection</h2><p><a href="https://csms.tech/202212141608/#集群节点上部署-node-exporter-对集群节点进行监控">Kubernetes 中使用 DaemonSet 部署的 <code>node_exporter</code></a>，<a href="#%E9%85%8D%E7%BD%AE-node_exporter-%E6%94%B6%E9%9B%86%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1">启用了 <code>systemd</code> 功能监控</a>，<code>node_exporter</code> 启动报错：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ts=2023-06-07T04:06:16.429Z caller=node_exporter.go:180 level=info msg=&quot;Starting node_exporter&quot; version=&quot;(version=1.6.0, branch=HEAD, revision=ff7f9d69b645cb691dd3e84dc3afc88f5c006962)&quot;</span><br><span class="line">ts=2023-06-07T04:06:16.429Z caller=node_exporter.go:181 level=info msg=&quot;Build context&quot; build_context=&quot;(go=go1.20.4, platform=linux/amd64, user=root@f9c3ed0cfbd3, date=20230527-12:03:54, tags=netgo osusergo static_build)&quot;</span><br><span class="line">ts=2023-06-07T04:06:16.429Z caller=systemd_linux.go:146 level=warn collector=systemd msg=&quot;--collector.systemd.unit-whitelist is DEPRECATED and will be removed in 2.0.0, use --collector.systemd.unit-include&quot;</span><br><span class="line">ts=2023-06-07T04:06:16.429Z caller=systemd_linux.go:152 level=info collector=systemd msg=&quot;Parsed flag --collector.systemd.unit-include&quot; flag=&quot;\&quot;(sshd|docker|cri-docker|crond|iptables|systemd-journald|).service\&quot;&quot;</span><br><span class="line">ts=2023-06-07T04:06:16.430Z caller=systemd_linux.go:154 level=info collector=systemd msg=&quot;Parsed flag --collector.systemd.unit-exclude&quot; flag=.+\.(automount|device|mount|scope|slice)</span><br><span class="line">ts=2023-06-07T04:06:16.430Z caller=diskstats_common.go:111 level=info collector=diskstats msg=&quot;Parsed flag --collector.diskstats.device-exclude&quot; flag=^(ram|loop|fd|(h|s|v|xv)d[a-z]|nvme\d+n\d+p)\d+$</span><br><span class="line">ts=2023-06-07T04:06:16.430Z caller=diskstats_linux.go:265 level=error collector=diskstats msg=&quot;Failed to open directory, disabling udev device properties&quot; path=/run/udev/data</span><br><span class="line">ts=2023-06-07T04:06:16.430Z caller=filesystem_common.go:94 level=warn collector=filesystem msg=&quot;--collector.filesystem.ignored-mount-points is DEPRECATED and will be removed in 2.0.0, use --collector.filesystem.mount-points-exclude&quot;</span><br><span class="line">ts=2023-06-07T04:06:16.430Z caller=filesystem_common.go:111 level=info collector=filesystem msg=&quot;Parsed flag --collector.filesystem.mount-points-exclude&quot; flag=&quot;\&quot;^/(sys|proc|dev|host|etc)($|/)\&quot;&quot;</span><br><span class="line">ts=2023-06-07T04:06:16.430Z caller=filesystem_common.go:113 level=info collector=filesystem msg=&quot;Parsed flag --collector.filesystem.fs-types-exclude&quot; flag=^(autofs|binfmt_misc|bpf|cgroup2?|configfs|debugfs|devpts|devtmpfs|fusectl|hugetlbfs|iso9660|mqueue|nsfs|overlay|proc|procfs|pstore|rpc_pipefs|securityfs|selinuxfs|squashfs|sysfs|tracefs)$</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=node_exporter.go:110 level=info msg=&quot;Enabled collectors&quot;</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=node_exporter.go:117 level=info collector=arp</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=node_exporter.go:117 level=info collector=bcache</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=node_exporter.go:117 level=info collector=bonding</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=node_exporter.go:117 level=info collector=btrfs</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=node_exporter.go:117 level=info collector=conntrack</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=node_exporter.go:117 level=info collector=cpu</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=node_exporter.go:117 level=info collector=cpufreq</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=node_exporter.go:117 level=info collector=diskstats</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=node_exporter.go:117 level=info collector=dmi</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=node_exporter.go:117 level=info collector=edac</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=node_exporter.go:117 level=info collector=entropy</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=node_exporter.go:117 level=info collector=fibrechannel</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=node_exporter.go:117 level=info collector=filefd</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=node_exporter.go:117 level=info collector=filesystem</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=node_exporter.go:117 level=info collector=hwmon</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=node_exporter.go:117 level=info collector=infiniband</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=node_exporter.go:117 level=info collector=ipvs</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=node_exporter.go:117 level=info collector=loadavg</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=node_exporter.go:117 level=info collector=mdadm</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=node_exporter.go:117 level=info collector=meminfo</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=node_exporter.go:117 level=info collector=netclass</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=node_exporter.go:117 level=info collector=netdev</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=node_exporter.go:117 level=info collector=netstat</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=node_exporter.go:117 level=info collector=nfs</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=node_exporter.go:117 level=info collector=nfsd</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=node_exporter.go:117 level=info collector=nvme</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=node_exporter.go:117 level=info collector=os</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=node_exporter.go:117 level=info collector=powersupplyclass</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=node_exporter.go:117 level=info collector=pressure</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=node_exporter.go:117 level=info collector=rapl</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=node_exporter.go:117 level=info collector=schedstat</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=node_exporter.go:117 level=info collector=selinux</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=node_exporter.go:117 level=info collector=sockstat</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=node_exporter.go:117 level=info collector=softnet</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=node_exporter.go:117 level=info collector=stat</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=node_exporter.go:117 level=info collector=systemd</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=node_exporter.go:117 level=info collector=tapestats</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=node_exporter.go:117 level=info collector=textfile</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=node_exporter.go:117 level=info collector=thermal_zone</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=node_exporter.go:117 level=info collector=time</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=node_exporter.go:117 level=info collector=timex</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=node_exporter.go:117 level=info collector=udp_queues</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=node_exporter.go:117 level=info collector=uname</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=node_exporter.go:117 level=info collector=vmstat</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=node_exporter.go:117 level=info collector=xfs</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=node_exporter.go:117 level=info collector=zfs</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=tls_config.go:274 level=info msg=&quot;Listening on&quot; address=[::]:9100</span><br><span class="line">ts=2023-06-07T04:06:16.431Z caller=tls_config.go:277 level=info msg=&quot;TLS is disabled.&quot; http2=false address=[::]:9100</span><br><span class="line">ts=2023-06-07T04:06:16.511Z caller=collector.go:169 level=error msg=&quot;collector failed&quot; name=systemd duration_seconds=8.649e-05 err=&quot;couldn&#x27;t get dbus connection: dial unix /var/run/dbus/system_bus_socket: connect: no such file or directory&quot;</span><br><span class="line">ts=2023-06-07T04:06:21.499Z caller=collector.go:169 level=error msg=&quot;collector failed&quot; name=systemd duration_seconds=4.6418e-05 err=&quot;couldn&#x27;t get dbus connection: dial unix /var/run/dbus/system_bus_socket: connect: no such file or directory&quot;</span><br></pre></td></tr></table></figure>

<p>根据报错提示，应该是 <code>node_exporter</code> 无法访问节点的 <code>/var/run/dbus/system_bus_socket</code>。尝试挂载节点的此目录到 <code>node_exporter</code> 容器中，参考以下配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">containers:</span><br><span class="line">- args:</span><br><span class="line">  - --path.procfs</span><br><span class="line">  - /host/proc</span><br><span class="line">  - --path.sysfs</span><br><span class="line">  - /host/sys</span><br><span class="line">  - --collector.filesystem.ignored-mount-points</span><br><span class="line">  - &#x27;&quot;^/(sys|proc|dev|host|etc)($|/)&quot;&#x27;</span><br><span class="line">  - --collector.systemd</span><br><span class="line">  - --collector.systemd.unit-whitelist</span><br><span class="line">  - &#x27;&quot;(sshd|docker|cri-docker|crond|iptables|systemd-journald|).service&quot;&#x27;</span><br><span class="line">  image: prom/node-exporter</span><br><span class="line">  imagePullPolicy: Always</span><br><span class="line">  name: node-exporter</span><br><span class="line">  ports:</span><br><span class="line">  - containerPort: 9100</span><br><span class="line">    hostPort: 9100</span><br><span class="line">    name: http</span><br><span class="line">    protocol: TCP</span><br><span class="line">  resources: &#123;&#125;</span><br><span class="line">  securityContext:</span><br><span class="line">    privileged: true</span><br><span class="line">  terminationMessagePath: /dev/termination-log</span><br><span class="line">  terminationMessagePolicy: File</span><br><span class="line">  volumeMounts:</span><br><span class="line">  - mountPath: /host/dev</span><br><span class="line">    name: dev</span><br><span class="line">  - mountPath: /host/proc</span><br><span class="line">    name: proc</span><br><span class="line">  - mountPath: /host/sys</span><br><span class="line">    name: sys</span><br><span class="line">  - mountPath: /rootfs</span><br><span class="line">    name: rootfs</span><br><span class="line">  - mountPath: /var/run/dbus/</span><br><span class="line">    name: var-run-dbus</span><br><span class="line">    readOnly: true</span><br><span class="line">volumes:</span><br><span class="line">- hostPath:</span><br><span class="line">    path: /proc</span><br><span class="line">    type: &quot;&quot;</span><br><span class="line">  name: proc</span><br><span class="line">- hostPath:</span><br><span class="line">    path: /dev</span><br><span class="line">    type: &quot;&quot;</span><br><span class="line">  name: dev</span><br><span class="line">- hostPath:</span><br><span class="line">    path: /sys</span><br><span class="line">    type: &quot;&quot;</span><br><span class="line">  name: sys</span><br><span class="line">- hostPath:</span><br><span class="line">    path: /</span><br><span class="line">    type: &quot;&quot;</span><br><span class="line">  name: rootfs   </span><br><span class="line">- hostPath:</span><br><span class="line">    path: /var/run/dbus/</span><br><span class="line">    type: &quot;&quot;</span><br><span class="line">  name: var-run-dbus</span><br></pre></td></tr></table></figure>

<p>重启 Pod 后，重新观察日志，<code>node_exporter</code> 启动正常。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://github.com/prometheus/node_exporter">Node Exporter</a></p>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://github.com/prometheus/node_exporter">node_exporter 官网 github</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Tools</category>
        <category>Prometheus</category>
      </categories>
      <tags>
        <tag>Prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>vsftpd 虚拟用户配置说明</title>
    <url>/202207251638/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3></blockquote>
<ul>
<li>Centos 7</li>
<li>Vsftpd 3.0.2</li>
</ul>
<p>vsftpd虚拟用户通过映射系统用户权限的方式，使虚拟用户具有和本地系统用户一样的权限，或者灵活的控制虚拟用户的权限(不和本地用户权限相同，不能高于本地权限)，达到访问权限的灵活控制，同时防止大批vsftpd用户添加到系统账号库中，使系统用户管理变动臃肿。</p>
<span id="more"></span>

<h3 id="创建虚拟用户映射的系统用户"><a href="#创建虚拟用户映射的系统用户" class="headerlink" title="创建虚拟用户映射的系统用户"></a>创建虚拟用户映射的系统用户</h3><p>系统用户virtftp拥有对ftp的读写权限，假设ftp根目录为&#x2F;data&#x2F;vsftpd&#x2F;<br>创建ftp用户组和用户virtftp，ftp相关系统账号属于ftp组  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groupadd ftp</span><br><span class="line">useradd -d /data/vsftpd -M -s /sbin/nologin -g ftp virtftp</span><br><span class="line">mkdir /data/vsftpd</span><br><span class="line">chown -R virtftp:ftp /data/vsftpd</span><br><span class="line">chmod -R 750 /data/vsftpd</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ftp根目录属于用户virtftp,用户组为ftp，设置权限750，使virtftp用户拥有读写权限</p>
</blockquote>
<h3 id="创建虚拟用户的口令库"><a href="#创建虚拟用户的口令库" class="headerlink" title="创建虚拟用户的口令库"></a>创建虚拟用户的口令库</h3><p>需要使用db_load命令根据原始口令文件(<code>/etc/vsftpd/passwd.txt</code>)生成db口令库文件，原始文件中奇数行为用户名，偶数行为密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db_load -T -t hash -f /etc/vsftpd/passwd.txt /etc/vsftpd/passwd.db</span><br><span class="line">chmod 600 /etc/vsftpd/passwd.db</span><br></pre></td></tr></table></figure>
<p>修改pam认证文件&#x2F;etc&#x2F;pam.d&#x2F;vsftpd,只保留以下2行<br>或者重新创建文件&#x2F;etc&#x2F;pam.d&#x2F;vsftpd_vu,并在<code>vsftpd.conf</code>中配置<code>pam_service_name=vsftpd_vu</code>)</p>
<figure class="highlight shell"><figcaption><span>vsftpd_vu</span></figcaption><table><tr><td class="code"><pre><span class="line">auth required /lib64/security/pam_userdb.so db=/etc/vsftpd/passwd</span><br><span class="line">account required /lib64/security/pam_userdb.so db=/etc/vsftpd/passwd  </span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>db=/etc/vsftpd/passwd</code> 为<code>db_load</code>生产的文件，不要带后缀 <code>.db</code><br>如果认证发生错误，可检查日志文件：<code>/var/log/secure</code></p>
</blockquote>
<h3 id="配置-vsftpd-启用虚拟用户"><a href="#配置-vsftpd-启用虚拟用户" class="headerlink" title="配置 vsftpd 启用虚拟用户"></a>配置 vsftpd 启用虚拟用户</h3><p>修改vsftpd配置文件，默认为<code>/etc/vsftpd/vsftpd.conf</code> <a href="/202207231311/" title="vsftpd.conf常用配置文件说明">vsftpd.conf常用配置文件说明</a></p>
<figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用虚拟用户功能，必须允许本地用户</span></span><br><span class="line">local_enable=YES     </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启用虚拟用户配置，所有非匿名用户登录将视为游客，将被映射为guest_username</span>     </span><br><span class="line">guest_enable=YES     </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">主配置文件中必需有，否则报错</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">500 OOPS: vsftpd: cannot locate user specified <span class="keyword">in</span> <span class="string">&#x27;guest_username&#x27;</span>:ftp</span></span><br><span class="line">guest_username=virtftp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">虚拟用户独立配置文件目录,每个虚拟用户有一个同名的配置文件于此目录下</span></span><br><span class="line">user_config_dir=/etc/vsftpd/virtual_user_conf          </span><br><span class="line">                        </span><br></pre></td></tr></table></figure>

<h3 id="配置虚拟用户配置文件"><a href="#配置虚拟用户配置文件" class="headerlink" title="配置虚拟用户配置文件"></a>配置虚拟用户配置文件</h3><p>虚拟用户配置文件位于 <code>vsftpd.conf</code> 配置 <code>user_config_dir</code> 指定的目录下，每个用户一个配置文件，配置文件和用户名同名<br>用户名，配置文件名，必须和口令文件中的用户名保持一致  </p>
<figure class="highlight shell"><figcaption><span>user1</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定虚拟用户根目录</span></span><br><span class="line">local_root=/home/ftpsite/user1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">虚拟用户是和本地用户有相同权限;NO：虚拟用户和匿名用户权限相同</span>        </span><br><span class="line">virtual_use_local_privs=YES         </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">虚拟用户对应的系统用户</span></span><br><span class="line">guest_username=virtftp   </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">虚拟用户将被锁定在自己的宿主目录</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">chroot_local_user=YES</span>    </span><br><span class="line">         </span><br><span class="line">write_enable=YES                               </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">lock_upload_files=NO</span></span><br><span class="line">anon_umask=022</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">download_enable=NO</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">anon_upload_enable=YES</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">anon_mkdir_write_enable=YES</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">anon_other_write_enable=YES</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">chown_uploads=YES</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">chown_username=nono</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">allow_anon_ssl=YES</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">force_anon_logins_ssl=YES</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">force_anon_data_ssl=YES</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">cmds_allowed=CWD,LIST,MDTM,MKD,NLST,PASS,PASV,PORT,PWD,QUIT,RMD,RETR,SIZE,STOR,TYPE,USER,ACCT,APPE,CDUP,HELP,MODE,NOOP,REIN,STAT,STOU,STRU,SYST</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="常用配置说明"><a href="#常用配置说明" class="headerlink" title="常用配置说明"></a>常用配置说明</h3><p>virtual_use_local_privs参数说明<br>当<code>virtual_use_local_privs=YES</code>时，虚拟用户和本地用户有相同的权限；<br>当<code>virtual_use_local_privs=NO</code> 时，虚拟用户和匿名用户有相同的权限，默认是NO。<br>当<code>virtual_use_local_privs=YES</code>，<code>write_enable=YES</code>时，虚拟用户具有写权限（上传、下载、删除、重命名）。<br>当<code>virtual_use_local_privs=NO</code>，<code>write_enable=YES</code>，<code>anon_world_readable_only=YES</code>，<code>anon_upload_enable=YES</code> 时，虚拟用户不能浏览目录，只能上传文件，无其他权限。<br>当<code>virtual_use_local_privs=NO</code>，<code>write_enable=YES</code>，<code>anon_world_readable_only=NO</code>，<code>anon_upload_enable=NO</code> 时，虚拟用户只能下载文件，无其他权限。<br>当<code>virtual_use_local_privs=NO</code>，<code>write_enable=YES</code>，<code>anon_world_readable_only=NO</code>，<code>anon_upload_enable=YES</code> 时，虚拟用户只能上传和下载文件，无其他权限。<br>当<code>virtual_use_local_privs=NO</code>，<code>write_enable=YES</code>，<code>anon_world_readable_only=NO</code>，<code>anon_mkdir_write_enable=YES</code> 时，虚拟用户只能下载文件和创建文件夹，无其他权限。<br>当<code>virtual_use_local_privs=NO</code>，<code>write_enable=YES</code>，<code>anon_world_readable_only=NO</code>，<code>anon_other_write_enable=YES</code> 时，虚拟用户只能下载、删除和重命名文件，无其他权限。  </p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>Vsftpd</tag>
      </tags>
  </entry>
  <entry>
    <title>vsftpd 服务常用配置说明</title>
    <url>/202207231311/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos 7</li>
<li>vsftpd 3.0.2</li>
</ul>
<p>FTP(File transfer Protocol)是一种在互联网中进行文件传输的协议，基于客户端&#x2F;服务器模式，默认使用 20、21 号端口，<br>其中端口 20（数据端口）用于进行数据传输，端口 21（命令端口）用于接受客户端发出的相关 FTP 命令与参数。</p>
<p>FTP 有两种工作模式：</p>
<ul>
<li>主动模式(PORT) - 服务器主动向客户端发起连接请求.</li>
<li>被动模式(PAVS) - FTP 服务器打开协商好的端口，等待客户端发起连接请求（默认工作模式）.</li>
</ul>
<p>FTP 协议需要用到两个 TCP 连接：</p>
<ul>
<li>命令连接 - 用来在 FTP 客户端与服务器之间传递命令。</li>
<li>数据连接 - 用来在服务器和客户端进行文件传输。</li>
</ul>
<p>无论是主动模式还是被动模式，其要进行文件传输都必须依次建立两个连接，分别为命令连接与数据连接。而主动模式与被动模式的差异主要体现在数据连接通道上。<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[FTP协议](https://www.cnblogs.com/steven-dou/p/14836224.html)">[1]</span></a></sup> </p>
<h1 id="服务配置文件"><a href="#服务配置文件" class="headerlink" title="服务配置文件"></a>服务配置文件</h1><h2 id="通用配置"><a href="#通用配置" class="headerlink" title="通用配置"></a>通用配置</h2><figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">匿名用户和本地用户是否能登录，匿名用户使用的登陆名为ftp或anonymous，口令为空，匿名用户不能离开匿名 用户家目录/var/ftp,且只能下载不能上传。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">本地用户的登录名为本地用户名，口令为此本地用户的口令；本地用户可以在自己家目录中进行读写操作；本地用户可以离开自家目录切换至有权限访问的其他目录，并在权限允许的情况下进行上传/下载。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认写在文件/etc/vsftpd.ftpusers中的本地用户禁止登陆。</span></span><br><span class="line">anonymous_enable=YES </span><br><span class="line">local_enable=YES </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">否允许登录用户有写权限。属于全局设置，默认值为YES。</span></span><br><span class="line">write_enable=YES</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果设置为NO，所有的文件都不能下载到本地，文件夹不受影响。默认值为YES。</span></span><br><span class="line">download_enable=YES/NO</span><br></pre></td></tr></table></figure>

<h2 id="匿名用户（anonymous）设置"><a href="#匿名用户（anonymous）设置" class="headerlink" title="匿名用户（anonymous）设置"></a>匿名用户（anonymous）设置</h2><figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">若是启动这项功能，则使用匿名登入时，不会询问密码。默认值为NO。</span></span><br><span class="line">no_anon_password=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义匿名登入的使用者名称。默认值为ftp。</span></span><br><span class="line">ftp_username=ftp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用匿名登入时，所登入的目录。默认值为/var/ftp。注意ftp目录不能是777的权限属性，即匿名用户的家目录不能有777的权限。</span></span><br><span class="line">anon_root=/var/ftp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果设为YES，则允许匿名登入者有上传文件（非目录）的权限，只有在write_enable=YES时，此项才有效。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当然，匿名用户必须要有对上层目录的写入权。默认值为NO。</span></span><br><span class="line">anon_upload_enable=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果设为YES，则允许匿名登入者下载可阅读的档案（可以下载到本机阅读，不能直接在FTP服务器中打开阅读）。默认值为YES。</span></span><br><span class="line">anon_world_readable_only=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果设为YES，则允许匿名登入者有新增目录的权限，只有在write_enable=YES时，此项才有效。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当然，匿名用户必须要有对上层目录的写入权。默认值为NO。</span></span><br><span class="line">anon_mkdir_write_enable=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果设为YES，则允许匿名登入者更多于上传或者建立目录之外的权限，譬如删除或者重命名。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果anon_upload_enable=NO，则匿名用户 不能上传文件，但可以删除或者重命名已经存在的文件；</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果anon_mkdir_write_enable=NO，则匿名用户不能上传或者新建文件夹，但 可以删除或者重命名已经存在的文件夹。）默认值为NO。</span></span><br><span class="line">anon_other_write_enable=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置是否改变匿名用户上传文件（非目录）的属主。默认值为NO。</span></span><br><span class="line">chown_uploads=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置匿名用户上传文件（非目录）的属主名。建议不要设置为root。</span></span><br><span class="line">chown_username=username</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置匿名登入者新增或上传档案时的<span class="built_in">umask</span> 值。默认值为077，则新建档案的对应权限为700。</span></span><br><span class="line">anon_umask=077</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">若是启动这项功能，则必须提供一个档案/etc/vsftpd/banner_emails，内容为email address。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">若是使用匿名登入，则会要求输入email address，若输入的email address 在此档案内，则不允许进入。默认值为NO。</span></span><br><span class="line">deny_email_enable=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此文件用来输入email address，只有在deny_email_enable=YES时，才会使用到此档案。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">若是使用匿名登入，则会要求输入email address，若输入的email address 在此档案内，则不允许进入。</span></span><br><span class="line">banned_email_file=/etc/vsftpd/banner_emails</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="本地用户设置"><a href="#本地用户设置" class="headerlink" title="本地用户设置"></a>本地用户设置</h2><figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">控制是否允许本地用户登入，默认值为YES。</span></span><br><span class="line">local_enable=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当本地用户登入时，将被更换到定义的目录下。默认值为各用户的家目录</span></span><br><span class="line">local_root=/home/username</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">本地用户新增档案时的<span class="built_in">umask</span> 值。默认值为077。</span></span><br><span class="line">local_umask=022</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">本地用户上传档案后的档案权限，与<span class="built_in">chmod</span> 所使用的数值相同。默认值为0666。</span></span><br><span class="line">file_open_mode=0755</span><br></pre></td></tr></table></figure>

<h2 id="欢迎语设置"><a href="#欢迎语设置" class="headerlink" title="欢迎语设置"></a>欢迎语设置</h2><figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果启动这个选项，那么使用者第一次进入一个目录时，会检查该目录下是否有.message这个档案</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果有，则会出现此档案的内容，通常这个档案会放置欢迎话语，或是对该目录的说明。默认值为开启。</span></span><br><span class="line">dirmessage_enable=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置目录消息文件，可将要显示的信息写入该文件。默认值为.message。</span></span><br><span class="line">message_file=.message</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当使用者登入时，会显示此设定所在的档案内容，通常为欢迎话语或是说明。默认值为无。如果欢迎信息较多，则使用该配置项。</span></span><br><span class="line">banner_file=/etc/vsftpd/banner</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里用来定义欢迎话语的字符串，banner_file是档案的形式，而ftpd_banner 则是字符串的形式。预设为无。</span></span><br><span class="line">ftpd_banner=Welcome to BOB&#x27;s FTP server</span><br></pre></td></tr></table></figure>

<h2 id="控制用户是否允许切换到上级目录"><a href="#控制用户是否允许切换到上级目录" class="headerlink" title="控制用户是否允许切换到上级目录"></a>控制用户是否允许切换到上级目录</h2><figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">是否将用户限制在用户主目录。默认值为NO。</span></span><br><span class="line">chroot_local_user=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在默认配置下(chroot_local_user=NO)，本地用户登入FTP后可以使用<span class="built_in">cd</span>命令切换到其他目录，这样会对系统带来安全隐患。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置是否启用chroot_list_file配置项指定的用户列表文件。默认值为NO。</span></span><br><span class="line">chroot_list_enable=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用于指定用户列表文件，该文件用于控制哪些用户可以切换到用户家目录的上级目录。</span></span><br><span class="line">chroot_list_file=/etc/vsftpd.chroot_list</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 通过搭配能实现以下几种效果：</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 当chroot_local_user=YES, chroot_list_enable=YES时，</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在/etc/vsftpd.chroot_list文件中列出的用户，可以切换到其他目录；未在文件中列出的用户，不能切换到其他目录。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. 当chroot_local_user=YES, chroot_list_enable=NO时，</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">所有用户被限制在主目录，不启用chroot_list_file白名单，没有例外</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3. 当chroot_local_user=NO， chroot_list_enable=YES时</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">所有用户不限制在主目录，chroot_list_file中的用户例外，限制切换到主目录之外</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4. 当chroot_local_user=NO， chroot_list_enable=NO时</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">所有用户不限制在主目录,不启用chroot_list_file，没有任何例外</span></span><br></pre></td></tr></table></figure>

<h2 id="数据传输模式设置"><a href="#数据传输模式设置" class="headerlink" title="数据传输模式设置"></a>数据传输模式设置</h2><figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">FTP在传输数据时，可以使用二进制方式，也可以使用ASCII模式来上传或下载数据。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置是否启用ASCII 模式上传数据。默认值为NO。</span></span><br><span class="line">ascii_upload_enable=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置是否启用ASCII 模式下载数据。默认值为NO。</span></span><br><span class="line">ascii_download_enable=YES/NO</span><br></pre></td></tr></table></figure>
<h2 id="访问控制设置"><a href="#访问控制设置" class="headerlink" title="访问控制设置"></a>访问控制设置</h2><figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">两种控制方式：一种控制主机访问，另一种控制用户访问。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置vsftpd是否与tcp wrapper相结合来进行主机的访问控制。默认值为YES。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果启用，则vsftpd服务器会检查/etc/hosts.allow 和/etc/hosts.deny 中的设置，来决定请求连接的主机，是否允许访问该FTP服务器。这两个文件可以起到简易的防火墙功能。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">比如：若要仅允许192.168.0.1—192.168.0.254的用户可以连接FTP服务器，则在/etc/hosts.allow文件中添加以下内容：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">vsftpd:192.168.0. :allow</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">all:all :deny</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">对于用户的访问控制可以通过/etc目录下的vsftpd.user_list和ftpusers文件来实现。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">控制用户访问FTP的文件，里面写着用户名称。一个用户名称一行。</span></span><br><span class="line">userlist_file=/etc/vsftpd.user_list</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">是否启用vsftpd.user_list文件。</span></span><br><span class="line">userlist_enable=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">决定vsftpd.user_list文件中的用户是否能够访问FTP服务器。userlist_enable=YES 才有效</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">若设置为YES，则vsftpd.user_list文件中的用户不允许访问FTP，为黑名单，其他用户可以访问</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">若设置为NO，则vsftpd.user_list文件中的用户能访问FTP，为白名单，其他用户不能访问</span></span><br><span class="line">userlist_deny=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/etc/vsftpd/ftpusers文件专门用于定义不允许访问FTP服务器的用户列表，不受任何配置文件影响，里面的用户始终不允许方法vsftpd</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认情况下vsftpd.user_list和ftpusers，这两个 文件已经预设置了一些不允许访问FTP服务器的系统内部账户。如果系统没有这两个文件，那么新建这两个文件，将用户添加进去即可。</span></span><br></pre></td></tr></table></figure>

<h2 id="访问速率设置"><a href="#访问速率设置" class="headerlink" title="访问速率设置"></a>访问速率设置</h2><figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置匿名登入者使用的最大传输速度，单位为B/s，0 表示不限制速度。默认值为0。</span></span><br><span class="line">anon_max_rate=0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">本地用户使用的最大传输速度，单位为B/s，0 表示不限制速度。预设值为0。</span></span><br><span class="line">local_max_rate=0</span><br></pre></td></tr></table></figure>

<h2 id="超时时间设置"><a href="#超时时间设置" class="headerlink" title="超时时间设置"></a>超时时间设置</h2><figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置建立FTP连接的超时时间，单位为秒。默认值为60。</span></span><br><span class="line">accept_timeout=60</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">PORT 方式下建立数据连接的超时时间，单位为秒。默认值为60。</span></span><br><span class="line">connect_timeout=60</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置建立FTP数据连接的超时时间，单位为秒。默认值为120。</span></span><br><span class="line">data_connection_timeout=120</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置多长时间不对FTP服务器进行任何操作，则断开该FTP连接，单位为秒。默认值为300 。</span></span><br><span class="line">idle_session_timeout=300</span><br></pre></td></tr></table></figure>

<h2 id="日志文件设置"><a href="#日志文件设置" class="headerlink" title="日志文件设置"></a>日志文件设置</h2><figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">是否启用上传/下载日志记录。如果启用，则上传与下载的信息将被完整纪录在xferlog_file 所定义的档案中。预设为开启</span></span><br><span class="line">xferlog_enable= YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置日志文件名和路径，默认值为/var/log/vsftpd.log。</span></span><br><span class="line">xferlog_file=/var/log/vsftpd.log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果启用，则日志文件将会写成xferlog的标准格式，如同wu-ftpd 一般。默认值为关闭。</span></span><br><span class="line">xferlog_std_format=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果启用此选项，所有的FTP请求和响应都会被记录到日志中，默认日志文件在/var/log/vsftpd.log。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启用此选项时，xferlog_std_format不能被激活。这个选项有助于调试。默认值为NO。</span></span><br><span class="line">log_ftp_protocol=YES|NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">登录日志</span></span><br><span class="line">dual_log_enable=YES</span><br><span class="line">vsftpd_log_file=/var/log/vsftpd.log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">日志中的时间与系统时间保持一致</span></span><br><span class="line">use_localtime=YES</span><br></pre></td></tr></table></figure>
<h2 id="FTP-的工作方式与端口设置"><a href="#FTP-的工作方式与端口设置" class="headerlink" title="FTP 的工作方式与端口设置"></a>FTP 的工作方式与端口设置</h2><figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">FTP有两种工作方式：PORT FTP（主动模式）和 PASV FTP（被动模式）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置FTP服务器建立连接所监听的端口，默认值为21。</span></span><br><span class="line">listen_port=21</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定FTP使用20端口进行数据传输，默认值为YES。</span></span><br><span class="line">connect_from_port_20=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置在PORT方式下，FTP数据连接使用的端口，默认值为20。</span></span><br><span class="line">ftp_data_port=20</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">若设置为YES，则使用PASV工作模式；若设置为NO，则使用PORT模式。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认值为YES，即使用PASV工作模式。</span></span><br><span class="line">pasv_enable=YES/NO（YES）</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在PASV工作模式下，数据连接可以使用的端口范围的最大端口，0 表示任意端口。默认值为0。</span></span><br><span class="line">pasv_max_port=0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在PASV工作模式下，数据连接可以使用的端口范围的最小端口，0 表示任意端口。默认值为0。</span></span><br><span class="line">pasv_min_port=0</span><br></pre></td></tr></table></figure>
<h2 id="与连接相关的设置"><a href="#与连接相关的设置" class="headerlink" title="与连接相关的设置"></a>与连接相关的设置</h2><figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置vsftpd服务器是否以standalone模式运行。以standalone模式运行是一种较好的方式，此时listen必须设置为YES，此为默认值。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">建议不要更改，有很多与服务器运行相关的配置命令，需要在此模式下才有效。若设置为NO，则vsftpd不是以独立的服务运行，要受到xinetd 服务的管控，功能上会受到限制。</span></span><br><span class="line">listen=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置vsftpd允许的最大连接数，默认值为0，表示不受限制。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">若设置为100时，则同时允许有100个连接，超出的将被拒绝。只有在standalone模式运行才有效。</span></span><br><span class="line">max_clients=0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置每个IP允许与FTP服务器同时建立连接的数目。默认值为0，表示不受限制。只有在standalone模式运行才有效。</span></span><br><span class="line">max_per_ip=0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置FTP服务器在指定的IP地址上侦听用户的FTP请求。若不设置，则对服务器绑定的所有IP地址进行侦听。只有在standalone模式运行才有效。</span></span><br><span class="line">listen_address=IP地址</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置每个与FTP服务器的连接，是否以不同的进程表现出来。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认值为NO，此时使用ps aux |grep ftp只会有一个vsftpd的进程。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">若设置为YES，则每个连接都会有一个vsftpd的进程。</span></span><br><span class="line">setproctitle_enable=YES/NO</span><br></pre></td></tr></table></figure>

<h2 id="虚拟用户相关配置"><a href="#虚拟用户相关配置" class="headerlink" title="虚拟用户相关配置"></a>虚拟用户相关配置</h2><a href="/202207251638/" title="vsftpd 虚拟用户配置过程参考">vsftpd 虚拟用户配置过程参考</a>

<figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用虚拟用户功能，必须允许本地用户登录</span></span><br><span class="line">local_enable=YES</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启用虚拟用户配置，所有非匿名用户登录将视为游客，将被映射为guest_username</span></span><br><span class="line">guest_enable=YES</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">虚拟用户映射的本地用户</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">主配置文件中必需有，否则报错</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">500 OOPS: vsftpd: cannot locate user specified <span class="keyword">in</span> <span class="string">&#x27;guest_username&#x27;</span>:ftp</span></span><br><span class="line">guest_username=virftp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">虚拟用户独立配置文件目录</span></span><br><span class="line">user_config_dir=/etc/vsftpd/virtual_user_conf          </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">虚拟用户使用本地用户的权限</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认为NO，虚拟用户具有和匿名用户一样的权限</span></span><br><span class="line">virtual_use_local_privs=YES | NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">虚拟用户加载的 pam 模块，默认为 /etc/pam.d/vsftpd</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pam_service_name=vsftpd_vu</span></span><br></pre></td></tr></table></figure>

<h2 id="虚拟用户配置文件"><a href="#虚拟用户配置文件" class="headerlink" title="虚拟用户配置文件"></a>虚拟用户配置文件</h2><p>每个虚拟用户都需要一个单独的配置文件，虚拟用户配置文件在 vsftpd 配置中 <code>user_config_dir</code> 对应的目录 (<code>/etc/vsftpd/virtual_user_conf</code>) 下<br>文件名必须和用户名一样</p>
<figure class="highlight shell"><figcaption><span>user1</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定虚拟用户根目录</span></span><br><span class="line">local_root=/home/ftpsite/user1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">虚拟用户是和本地用户有相同权限;NO：虚拟用户和匿名用户权限相同</span></span><br><span class="line">virtual_use_local_privs=YES</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">虚拟用户对应的系统用户</span></span><br><span class="line">guest_username=virftp</span><br><span class="line"></span><br><span class="line">write_enable=YES</span><br><span class="line">lock_upload_files=NO</span><br><span class="line">anon_umask=022</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">download_enable=NO</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">anon_upload_enable=YES</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">anon_mkdir_write_enable=YES</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">anon_other_write_enable=YES</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">chown_uploads=YES</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">chown_username=nono</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">allow_anon_ssl=YES</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">force_anon_logins_ssl=YES</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">force_anon_data_ssl=YES</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">cmds_allowed=CWD,LIST,MDTM,MKD,NLST,PASS,PASV,PORT,PWD,QUIT,RMD,RETR,SIZE,STOR,TYPE,USER,ACCT,APPE,CDUP,HELP,MODE,NOOP,REIN,STAT,STOU,STRU,SYST</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">虚拟用户将被锁定在自己的宿主目录</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">chroot_local_user=YES</span>            </span><br></pre></td></tr></table></figure>

<h1 id="常用配置参考"><a href="#常用配置参考" class="headerlink" title="常用配置参考"></a>常用配置参考</h1><h2 id="nginx-反代-FTP-服务"><a href="#nginx-反代-FTP-服务" class="headerlink" title="nginx 反代 FTP 服务"></a>nginx 反代 FTP 服务</h2><a href="/202207261420/" title="Nginx 服务常用配置说明">Nginx 服务常用配置说明</a>

<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.cnblogs.com/steven-dou/p/14836224.html">FTP协议</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>Vsftpd</tag>
      </tags>
  </entry>
</search>
