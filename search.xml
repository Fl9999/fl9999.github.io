<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AppScan v10.0.7.28135 安装破解</title>
    <url>/2207220210/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>HCL AppScan（原名IBM Security AppScan）是原IBM的Rational软件部门的一组网络安全测试和监控工具，2019年被HCL技术公司收购。AppScan旨在在开发过程中对Web应用程序的安全漏洞进行测试。  </p>
<span id="more"></span>

<h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Windows Server 2016 Datacenter</li>
<li>AppScan v10.0.7.28135</li>
</ul>
<h3 id="AppScan-安装激活"><a href="#AppScan-安装激活" class="headerlink" title="AppScan 安装激活"></a>AppScan 安装激活</h3><p>下载链接<br><a href="https://www.yunzhongzhuan.com/#sharefile=H51riiWG_46315">www.ddosi.org下载入口</a></p>
<blockquote>
<p>解压密码:<a href="http://www.ddosi.org/">www.ddosi.org</a></p>
</blockquote>
<p><a href="https://s.csms.tech/file/HCL_AppScan_Standard_v10.0.7.28135.rar">其他下载地址</a></p>
<p>下载安装包后，点击文件 <code>Appscan_Setup_v10.0.7.28135.exe</code> 安装</p>
<p>安装完成后，复制Crack目录下的文件 <code>AppScanSDK.dll</code>,<code>HclLicenseProvider.dll</code> 到 APPscan安装目录(默认为 <code>C:\Program Files (x86)\HCL\AppScan Standard</code>) 进行替换，完成破解</p>
<p>成功破解后的截图如下</p>
<p><img src="https://i.csms.tech/img_17.png"> </p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.ddosi.org/appscan-2/">参考链接</a></p>
]]></content>
      <categories>
        <category>安全</category>
        <category>AppScan</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>AppScan</tag>
      </tags>
  </entry>
  <entry>
    <title>Django+uwsgi+nginx 配置示例</title>
    <url>/7d1a39d2/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>centos 7</li>
<li>Python 3.10</li>
<li>Django 4.0</li>
<li>uwsgi 2.0.20</li>
<li>nginx 1.20.1</li>
<li>venv<blockquote>
<p>示例中虚拟环境位于 <code>/opt/vb/</code>, Django工程目录位于 <code>/opt/vb/vb/</code> , 工程名称为vb</p>
</blockquote>
</li>
</ul>
<h3 id="uwsgi配置文件-uwsgi-ini-配置示例"><a href="#uwsgi配置文件-uwsgi-ini-配置示例" class="headerlink" title="uwsgi配置文件 (uwsgi.ini) 配置示例"></a>uwsgi配置文件 (uwsgi.ini) 配置示例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[uwsgi]</span><br><span class="line">socket = 127.0.0.1:8081</span><br><span class="line">chdir = /opt/vb/vb</span><br><span class="line">wsgi-file = ./vb/wsgi.py</span><br><span class="line">master = true         //主进程</span><br><span class="line">vhost = true          //多站模式</span><br><span class="line">no-site = true        //多站模式时不设置入口模块和文件</span><br><span class="line">workers = 2           //子进程数</span><br><span class="line">reload-mercy = 10     </span><br><span class="line">vacuum = true         //退出、重启时清理文件</span><br><span class="line">max-requests = 1000   </span><br><span class="line">limit-as = 512</span><br><span class="line">buffer-size = 30000</span><br><span class="line">pidfile = uwsgi-8081.pid</span><br><span class="line">daemonize = uwsgi-8081.log</span><br><span class="line">pythonpath = /opt/vb/env/lib/python3.10/site-packages/</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h3 id="nginx-配置文件示例"><a href="#nginx-配置文件示例" class="headerlink" title="nginx 配置文件示例"></a>nginx 配置文件示例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">       listen 80;</span><br><span class="line">       server_name csms.tech;</span><br><span class="line"></span><br><span class="line">        location / &#123;            </span><br><span class="line">            include  uwsgi_params;</span><br><span class="line">            uwsgi_pass  127.0.0.1:8081;</span><br><span class="line">            uwsgi_param UWSGI_SCRIPT vb.wsgi;</span><br><span class="line">            uwsgi_param UWSGI_CHDIR /opt/vb/vb;       </span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        location /static/ &#123;</span><br><span class="line">                alias /opt/vb/vb/staticCollects/;</span><br><span class="line">        &#125;</span><br><span class="line">        access_log log/uwsgi.access.log main;</span><br><span class="line">        error_log log/uwsgi.error.log;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a href="/d5da7d5e/" title="Django 常见错误">Django 常见错误</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Nginx</tag>
        <tag>Django</tag>
        <tag>Uwsgi</tag>
      </tags>
  </entry>
  <entry>
    <title>Django 常见错误</title>
    <url>/d5da7d5e/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><hr>
<h4 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h4><ul>
<li>centos7</li>
<li>python3.6</li>
</ul>
<h4 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h4><blockquote>
<p>ModuleNotFoundError: No module named ‘MySQLdb’<br>…<br>django.core.exceptions.ImproperlyConfigured: Error loading MySQLdb module.</p>
</blockquote>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip3 install pymysql</span><br></pre></td></tr></table></figure>

<p>编辑文件<code>./python36/lib/python3.6/site-packages/django/db/backends/mysql/__init__.py</code>, 输入以下内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql </span><br><span class="line">pymysql.install_as_MySQLdb()</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<hr>
<h4 id="环境信息-1"><a href="#环境信息-1" class="headerlink" title="环境信息"></a>环境信息</h4><ul>
<li>centos7</li>
<li>python3.6</li>
</ul>
<h4 id="报错信息-1"><a href="#报错信息-1" class="headerlink" title="报错信息"></a>报错信息</h4><p><code>django-admin runserver</code></p>
<blockquote>
<p>django.core.exceptions.ImproperlyConfigured: Requested setting DEBUG, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings</p>
</blockquote>
<h4 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h4><p>使用命令<br><code>python3 manage.py runserver</code></p>
<hr>
<h4 id="环境信息-2"><a href="#环境信息-2" class="headerlink" title="环境信息"></a>环境信息</h4><ul>
<li>centos7</li>
<li>python3.10</li>
<li>uwsgi 2.0.20</li>
<li>venv</li>
</ul>
<h4 id="报错信息-2"><a href="#报错信息-2" class="headerlink" title="报错信息"></a>报错信息</h4><p>uwsgi 启动后报错(查看uwsgi日志输出)</p>
<blockquote>
<p>from django.core.wsgi import get_wsgi_application<br>ModuleNotFoundError: No module named ‘django’</p>
</blockquote>
<h4 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h4><p>uwsgi配置文件(<code>uwsgi.ini</code> )中添加python路径, 在配置文件中添加如下配置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pythonpath = /env/lib/python3<span class="number">.10</span>/site-packages/</span><br></pre></td></tr></table></figure>

<p>完整uwsgi配置文件示例(使用python venv模块创建虚拟环境情况下)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[uwsgi]</span><br><span class="line">socket = 127.0.0.1:8081</span><br><span class="line">chdir = /opt/vb/vb</span><br><span class="line">wsgi-file = ./vb/wsgi.py</span><br><span class="line">master = true         //主进程</span><br><span class="line">vhost = true          //多站模式</span><br><span class="line">no-site = true        //多站模式时不设置入口模块和文件</span><br><span class="line">workers = 2           //子进程数</span><br><span class="line">reload-mercy = 10     </span><br><span class="line">vacuum = true         //退出、重启时清理文件</span><br><span class="line">max-requests = 1000   </span><br><span class="line">limit-as = 512</span><br><span class="line">buffer-size = 30000</span><br><span class="line">pidfile = uwsgi-8081.pid</span><br><span class="line">daemonize = uwsgi-8081.log</span><br><span class="line">pythonpath = /opt/vb/env/lib/python3.10/site-packages/</span><br></pre></td></tr></table></figure>

<h4 id="报错信息-3"><a href="#报错信息-3" class="headerlink" title="报错信息"></a>报错信息</h4><p>uwsgi 启动后报错(查看uwsgi日志输出)</p>
<blockquote>
<p>unable to load app 0 (mountpoint&#x3D;’|’) (callable not found or import error)<br>— no python application found, check your startup logs for errors —</p>
</blockquote>
<h4 id="解决方法-3"><a href="#解决方法-3" class="headerlink" title="解决方法"></a>解决方法</h4><p>uwsgi配置文件(<code>uwsgi.ini</code> )中添加<code>wsgi.py</code>路径, 在配置文件中添加如下配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wsgi-file = ./vb/wsgi.py</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Django 模板中循环嵌套</title>
    <url>/c97b0902/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>模板中需要循环中循环，<code>&#123;% for i in alist %&#125;</code>,假如i是个元组或列表，需要继续循环：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">for</span> i <span class="keyword">in</span> alist %&#125;</span><br><span class="line">	&#123;% <span class="keyword">with</span> temp=I %&#125;</span><br><span class="line">		&#123;% <span class="keyword">for</span> k <span class="keyword">in</span> temp %&#125;</span><br><span class="line">		    …</span><br><span class="line">		&#123;% endfor %&#125;</span><br><span class="line">	&#123;% endwith %&#125;</span><br><span class="line">&#123;%endfor%&#125;</span><br></pre></td></tr></table></figure>
<p>或使用如下方式，data &#x3D; [[1,2],[3,4]]：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">for</span> l <span class="keyword">in</span> data%&#125;</span><br><span class="line"></span><br><span class="line">	&#123;% <span class="keyword">for</span> temp <span class="keyword">in</span> l % &#125;</span><br><span class="line">		&#123;% <span class="keyword">if</span> forloop.first % &#125;</span><br><span class="line">			<span class="string">&#x27;&#123;&#123;temp&#125;&#125;&#x27;</span>,</span><br><span class="line">		&#123;% <span class="keyword">else</span> %&#125;</span><br><span class="line">			&#123;&#123;temp&#125;&#125;</span><br><span class="line">		&#123;% endif %&#125;</span><br><span class="line">	&#123;% endfor %&#125;</span><br><span class="line"></span><br><span class="line">&#123;%endfor%&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Django model 外键的反向引用</title>
    <url>/dcca5850/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Question</span>(models.Model):</span><br><span class="line">	question_text=models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">	pub_date=models.DateTimeField(<span class="string">&#x27;datepublished&#x27;</span>)</span><br><span class="line"></span><br><span class="line">	def__str__(self):</span><br><span class="line">		returnself.question_text</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Choice</span>(models.Model):</span><br><span class="line">	question=models.ForeignKey(Question,on_delete=models.CASCADE)</span><br><span class="line">	choice_text=models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">	votes=models.IntegerField(default=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	def__str__(self):</span><br><span class="line">		returnself.choice_text</span><br><span class="line">  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上例中，Choice引用了Question作为外键，在模板中通过Question对象获取所有引用了Question对象的Choice对象，可以使用以下方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% for choice in question.choice_set.all %&#125;</span><br><span class="line">	&lt;li&gt;&#123;&#123;choice.choice_text&#125;&#125;&lt;/li&gt;</span><br><span class="line">&#123;%endfor%&#125;</span><br></pre></td></tr></table></figure>

<p>使用question.choice_set.all的方式获取所有引用question对象的Choice对象实例</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Python</tag>
        <tag>Model</tag>
      </tags>
  </entry>
  <entry>
    <title>Dockerfile 简介</title>
    <url>/202208050928/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Dockerfile 是一个文本文件，其内包含了一条条的 <code>指令(Instruction)</code>，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p>
<span id="more"></span>

<h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><p><code>docker build</code> 命令使用 <code>Dockerfile</code> 进行镜像构建。其格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build [选项] &lt;上下文路径/URL/-&gt;</span><br></pre></td></tr></table></figure>

<h4 id="docker-build-命令常用选项"><a href="#docker-build-命令常用选项" class="headerlink" title="docker build 命令常用选项"></a><code>docker build</code> 命令常用选项</h4><table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>-t, --tag</code></td>
<td>给新构建的镜像一个新的标签，格式为：<code>name:tag</code></td>
<td><code>docker build -t nginx:v3 .</code></td>
</tr>
<tr>
<td><code>-f, --file string </code></td>
<td><code>Dockerfile</code>的路径（文件名），默认为 <code>上下文（Context）目录/Dockerfile</code></td>
<td></td>
</tr>
</tbody></table>
<h4 id="上下文路径-格式"><a href="#上下文路径-格式" class="headerlink" title="上下文路径 格式"></a><code>上下文路径</code> 格式</h4><p>上下文路径可以是以下方式</p>
<ul>
<li><p>本地路径</p>
</li>
<li><p>用 <code>Git repo</code> 进行构建</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t hello-world https://github.com/docker-library/hello-world.git#master:amd64/hello-world</span><br></pre></td></tr></table></figure>

<p>  这行命令指定了构建所需的 Git repo，并且指定分支为 master，构建目录为 &#x2F;amd64&#x2F;hello-world&#x2F;，然后 Docker 就会自己去 git clone 这个项目、切换到指定分支、并进入到指定目录后开始构建。</p>
</li>
<li><p>用给定的 <code>tar</code> 压缩包构建</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build http://server/context.tar.gz</span><br></pre></td></tr></table></figure>
<p>如果所给出的 URL 不是个 Git repo，而是个 tar 压缩包，那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。</p>
</li>
<li><p>从标准输入中读取 <code>Dockerfile</code> 进行构建</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build - &lt; Dockerfile</span><br></pre></td></tr></table></figure>
<p>或</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat Dockerfile | docker build -</span><br></pre></td></tr></table></figure>
<p>  如果标准输入传入的是文本文件，则将其视为 <code>Dockerfile</code>，并开始构建。这种形式由于直接从标准输入中读取 <code>Dockerfile</code> 的内容，它没有上下文，因此不可以像其他方法那样可以将本地文件 <code>COPY</code> 进镜像之类的事情。  </p>
</li>
<li><p>从标准输入中读取上下文压缩包进行构建</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build - &lt; context.tar.gz</span><br></pre></td></tr></table></figure>
<p>如果发现标准输入的文件格式是 <code>gzip</code>、<code>bzip2</code> 以及 <code>xz</code> 的话，将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。</p>
</li>
</ul>
<h3 id="镜像构建上下文（Context）"><a href="#镜像构建上下文（Context）" class="headerlink" title="镜像构建上下文（Context）"></a>镜像构建上下文（Context）</h3><p>Docker 在运行时分为 <code>Docker 引擎</code>（也就是服务端守护进程）和<code>客户端工具</code>。Docker 的引擎提供了一组 <code>REST API</code>，被称为 <a href="https://docs.docker.com/engine/api/sdk/"><code>Docker Remote API</code></a>，而如 <code>docker</code> 命令这样的客户端工具，则是通过这组 <code>API</code> 与 <code>Docker 引擎</code> 交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 <code>docker</code> 功能，但实际上，一切都是使用的远程调用形式在服务端（<code>Docker 引擎</code>）完成。也因为这种 C&#x2F;S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[使用 Dockerfile 定制镜像](https://yeasy.gitbook.io/docker_practice/image/build)  ">[1]</span></a></sup></p>
<p>当我们进行镜像构建的时候，并非所有定制都会通过 <code>RUN</code> 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 <code>COPY</code> 指令、<code>ADD</code> 指令等。而 <code>docker build</code> 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 <code>Docker 引擎</code> 中构建的。那么在这种客户端&#x2F;服务端的架构中，如何才能让服务端获得本地文件呢？</p>
<p>这就引入了 <code>上下文</code> 的概念。当构建的时候，用户会指定构建镜像上下文的路径，<code>docker build</code> 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 <code>Docker 引擎</code>。这样 <code>Docker 引擎</code> 收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p>
<p>如果在 Dockerfile 中这么写：</p>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">COPY ./package.json /app/</span><br></pre></td></tr></table></figure>

<p>这并不是要复制执行 <code>docker build</code> 命令所在的目录下的 <code>package.json</code>，也不是复制 <code>Dockerfile</code> 所在目录下的 <code>package.json</code>，而是复制 <code>上下文（context）</code> 目录下的 <code>package.json</code>。</p>
<p>因此，<code>COPY</code> 这类指令中的源文件的路径都是相对路径。</p>
<p>一般来说，应该会将 <code>Dockerfile</code> 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 <code>Docker 引擎</code>，那么可以用 <code>.gitignore</code> 一样的语法写一个 <code>.dockerignore</code>，该文件是用于剔除不需要作为上下文传递给 <code>Docker 引擎</code> 的。</p>
<p>默认情况下，如果不额外指定 <code>Dockerfile</code> 的话，会将上下文目录下的名为 <code>Dockerfile</code> 的文件作为 <code>Dockerfile</code>。</p>
<p>这只是默认行为，实际上 <code>Dockerfile</code> 的文件名并不要求必须为 <code>Dockerfile</code>，而且并不要求必须位于上下文目录中，比如可以用 <code>-f ../Dockerfile.php</code> 参数指定某个文件作为 <code>Dockerfile</code>。<br>当然，一般大家习惯性的会使用默认的文件名 <code>Dockerfile</code>，以及会将其置于镜像构建上下文目录中</p>
<h3 id="Dockerfile-指令详解"><a href="#Dockerfile-指令详解" class="headerlink" title="Dockerfile 指令详解"></a>Dockerfile 指令详解</h3><p><code>Dockerfile</code> 文件示例</p>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN echo &#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27; &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure>

<h4 id="FROM-指令"><a href="#FROM-指令" class="headerlink" title="FROM 指令"></a>FROM 指令</h4><p>定制镜像，一定要以一个镜像为基础，在其上进行定制。</p>
<p><code>FROM</code> 就是指定 <code>基础镜像</code>，因此一个 <code>Dockerfile</code> 中 <code>FROM</code> 是<strong>必备的指令</strong>，并且<strong>必须是第一条指令</strong>。<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[使用 Dockerfile 定制镜像](https://yeasy.gitbook.io/docker_practice/image/build)  ">[1]</span></a></sup>  </p>
<p>除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 <code>scratch</code>。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。</p>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">FROM scratch</span><br></pre></td></tr></table></figure>

<p>如果以 <code>scratch</code> 为基础镜像的话，意味着不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。</p>
<h4 id="RUN-指令"><a href="#RUN-指令" class="headerlink" title="RUN 指令"></a>RUN 指令</h4><p><code>RUN</code> 指令是用来执行命令行命令的。由于命令行的强大能力，<code>RUN</code> 指令在定制镜像时是最常用的指令之一。<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[使用 Dockerfile 定制镜像](https://yeasy.gitbook.io/docker_practice/image/build)  ">[1]</span></a></sup>其格式有两种：</p>
<ul>
<li>shell 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样。<a href="#Dockerfile-%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3">上面</a>写的 <code>Dockerfile</code> 中的 <code>RUN</code> 指令就是这种格式。  </li>
<li>exec 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式。</li>
</ul>
<p>既然 RUN 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样：  </p>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">FROM debian:stretch</span><br><span class="line"></span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install -y gcc libc6-dev make wget</span><br><span class="line">RUN wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span><br><span class="line">RUN mkdir -p /usr/src/redis</span><br><span class="line">RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</span><br><span class="line">RUN make -C /usr/src/redis</span><br><span class="line">RUN make -C /usr/src/redis install</span><br></pre></td></tr></table></figure>

<p><code>Dockerfile</code> 中每一个指令都会建立一层，<code>RUN</code> 也不例外。每一个 <code>RUN</code> 的行为，就和我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，<code>commit</code> 这一层的修改，构成新的镜像。<br>每一个 RUN 都是启动一个容器、执行命令、然后提交存储层文件变更。当前的 <code>RUN</code> 指令和前后的 <code>RUN</code> 指令是<strong>不存在环境变量的共享及关联的</strong></p>
<p>而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。</p>
<p><code>Union FS</code> 是有最大层数限制的，比如 <code>AUFS</code>，曾经是最大不得超过 42 层，现在是不得超过 127 层。</p>
<p>上面的 <code>Dockerfile</code> 正确的写法应该是这样：</p>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">FROM debian:stretch</span><br><span class="line"></span><br><span class="line">RUN set -x; buildDeps=&#x27;gcc libc6-dev make wget&#x27; \</span><br><span class="line">    &amp;&amp; apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y $buildDeps \</span><br><span class="line">    &amp;&amp; wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot; \</span><br><span class="line">    &amp;&amp; mkdir -p /usr/src/redis \</span><br><span class="line">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis install \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/* \</span><br><span class="line">    &amp;&amp; rm redis.tar.gz \</span><br><span class="line">    &amp;&amp; rm -r /usr/src/redis \</span><br><span class="line">    &amp;&amp; apt-get purge -y --auto-remove $buildDeps</span><br></pre></td></tr></table></figure>

<p>首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 <code>RUN</code> 一一对应不同的命令，而是仅仅使用一个 <code>RUN</code> 指令，并使用 <code>&amp;&amp;</code> 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 <code>Dockerfile</code> 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。  </p>
<p>并且，这里为了格式化还进行了换行。<code>Dockerfile</code> 支持 <code>Shell</code> 类的行尾添加 <code>\</code> 的命令换行方式，以及行首 <code>#</code> 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。  </p>
<p>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 apt 缓存文件。这是很重要的一步，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p>
<h4 id="COPY-复制文件指令"><a href="#COPY-复制文件指令" class="headerlink" title="COPY 复制文件指令"></a>COPY 复制文件指令</h4><p><code>COPY</code> 指令将构建上下文目录中的 <code>&lt;源路径&gt;</code> 的文件&#x2F;目录复制到新的一层镜像内的 <code>&lt;目标路径&gt;</code> 位置。<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[COPY 复制文件](https://yeasy.gitbook.io/docker_practice/image/dockerfile/copy)">[2]</span></a></sup></p>
<p>命令格式：</p>
<ul>
<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;</code></li>
<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></li>
</ul>
<p><code>&lt;源路径&gt;</code> 可以是多个，甚至可以是通配符，其通配符规则要满足 <code>Go</code> 的 <a href="https://pkg.go.dev/path/filepath#Match"><code>filepath.Match</code></a> 规则，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">COPY hom* /mydir/</span><br><span class="line">COPY hom?.txt /mydir/</span><br></pre></td></tr></table></figure>

<p>如果源路径为文件夹，复制的时候不是直接复制该文件夹，而是将文件夹中的内容复制到目标路径。  </p>
<p><code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <code>WORKDIR</code> 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p>
<p>使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。  </p>
<p><code>COPY</code> 指令其他选项：</p>
<style>
table th:nth-of-type(1){
width: 10%;
}
table th:nth-of-type(2){
width: 20%;
}
table th:nth-of-type(3){
width: 70%;
}
</style>

<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>--from</code></td>
<td>从其他镜像或构件阶段拷贝文件</td>
<td><code>COPY --from=0 /go/app .</code>  多阶段构建 <sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Dockerfile 多阶段构建](https://yeasy.gitbook.io/docker_practice/image/multistage-builds)">[6]</span></a></sup> 中，从第1阶段的镜像中复制文件<br/><code>COPY --from=step1 /go/app .</code> 多阶段构建中，从名为 <code>step1</code> 的镜像中复制<br/></td>
</tr>
</tbody></table>
<h4 id="CMD-容器启动指令"><a href="#CMD-容器启动指令" class="headerlink" title="CMD 容器启动指令"></a>CMD 容器启动指令</h4><p>镜像启动时默认执行的指令，在启动容器时，容器后面跟其他指令，会替换默认指令</p>
<p><code>CMD</code> 指令<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[CMD 容器启动命令](https://yeasy.gitbook.io/docker_practice/image/dockerfile/cmd)">[3]</span></a></sup>的格式和 <code>RUN</code> 相似，也是两种格式：  </p>
<ul>
<li>shell 格式：<code>CMD &lt;命令&gt;</code>  </li>
<li>exec 格式：<code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code>  </li>
<li>参数列表格式：<code>CMD [&quot;参数1&quot;, &quot;参数2&quot;...]</code>。在指定了 <code>ENTRYPOINT</code> 指令后，用 <code>CMD</code> 指定具体的参数。</li>
</ul>
<p>如果使用 <code>shell</code> 格式的话，实际的命令会被包装为 <code>sh -c</code> 的参数的形式进行执行。比如：</p>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">CMD echo $HOME</span><br></pre></td></tr></table></figure>

<p>在实际执行中，会将其变更为：</p>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</span><br></pre></td></tr></table></figure>

<p>其中主进程是 <code>sh</code> 。Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 <code>systemd</code> 去启动后台服务，容器内没有后台服务的概念。  </p>
<p>比如以下指令：</p>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">CMD service nginx start</span><br></pre></td></tr></table></figure>

<p>容器执行后就会立即退出，对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。</p>
<p>而使用 <code>service nginx start</code> 或 <code>systemctl start nginx</code> 等类似命令，被理解为 <code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;systemctl start nginx&quot;]</code>，因此主进程实际上是 <code>sh</code>, 那么当 <code>systemctl start nginx</code> 命令结束后，<code>sh</code> 也就结束了，<code>sh</code> 作为主进程退出了，自然就会令容器退出。  </p>
<p>正确的做法是直接执行 <code>nginx</code> 可执行文件，并且要求以前台形式运行。比如：</p>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</span><br></pre></td></tr></table></figure>

<h4 id="ENTRYPOINT-容器启动程序指令"><a href="#ENTRYPOINT-容器启动程序指令" class="headerlink" title="ENTRYPOINT 容器启动程序指令"></a>ENTRYPOINT 容器启动程序指令</h4><p><code>ENTRYPOINT</code> 的格式和 <a href="#RUN-%E6%8C%87%E4%BB%A4"><code>RUN</code> 指令格式</a>一样，分为 <code>exec</code> 格式和 <code>shell</code> 格式。  </p>
<p><code>ENTRYPOINT</code> 的目的和 <a href="#CMD-%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%8C%87%E4%BB%A4"><code>CMD</code></a> 一样，都是在指定容器启动程序及参数。<code>ENTRYPOINT</code> 在容器启动时也可以替代，不过比 <code>CMD</code> 要略显繁琐，需要通过 <code>docker run</code> 的参数 <a href="https://csms.tech/202208041317/#运行镜像"><code>--entrypoint</code></a> 来指定。<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[ENTRYPOINT 入口点 | ENTRYPOINT 和 CMD 的不同使用场景](https://yeasy.gitbook.io/docker_practice/image/dockerfile/entrypoint)">[4]</span></a></sup>  </p>
<p>当指定了 <code>ENTRYPOINT</code> 后，<code>CMD</code> (包括 <code>Dockerfile</code> 和 <code>docker run</code> 中的 <code>CMD</code>)的含义就发生了改变，不再是直接的运行其命令，而是将 <code>CMD</code> 的内容作为参数传给 <code>ENTRYPOINT</code> 指令，即实际执行时，将变为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</span><br></pre></td></tr></table></figure>

<h4 id="ENV-设置环境变量指令"><a href="#ENV-设置环境变量指令" class="headerlink" title="ENV 设置环境变量指令"></a>ENV 设置环境变量指令</h4><p>设置环境变量，无论是后面的其它指令，如 <code>RUN</code>，还是运行时的应用，都可以直接使用这里定义的环境变量。</p>
<p>当使用生成的镜像运行容器时，使用 <code>ENV</code> 设置的环境变量将持久存在于容器内。 你可以使用 <code>docker inspect</code> 查看这些值，并使用 <code>docker run --env &lt;key&gt;=&lt;value&gt;</code> 修改它们</p>
<blockquote>
<p>环境变量持久性可能会导致意想不到的副作用。 例如，设置 <code>ENV DEBIAN_FRONTEND=noninteractive</code> 会改变 <code>apt-get</code> 的行为，并可能让使用镜像的用户感到困惑。<br>如果只在构建过程中需要环境变量，而不是在最终镜像中使用，可以使用 <a href="#ARG-%E6%9E%84%E5%BB%BA%E5%8F%82%E6%95%B0"><code>ARG</code></a>，它不会在最终镜像中持久存在</p>
</blockquote>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">ENV VERSION=1.0 DEBUG=on \</span><br><span class="line">    NAME=&quot;Happy Feet&quot;</span><br></pre></td></tr></table></figure>

<p>调用方式：</p>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">RUN echo $VERSION</span><br></pre></td></tr></table></figure>

<h4 id="ARG-构建参数"><a href="#ARG-构建参数" class="headerlink" title="ARG 构建参数"></a>ARG 构建参数</h4><p>格式：<code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code>  </p>
<p>构建参数和 <code>ENV</code> 的效果一样，都是设置环境变量。所不同的是，<code>ARG</code> 所设置的是<strong>构建环境的环境变量，在将来容器运行时是不会存在</strong>这些环境变量的。但是不要因此就使用 ARG 保存密码之类的信息，因为 <code>docker history</code> 还是可以看到所有值的。  </p>
<p><code>Dockerfile</code> 中的 <code>ARG</code> 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 <code>docker build</code> 中用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖。</p>
<p><code>ARG</code> 指令有生效范围，如果在 <code>FROM</code> 指令之前指定，那么只能用于 <code>FROM</code> 指令中。  </p>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">ARG DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line">FROM $&#123;DOCKER_USERNAME&#125;/alpine</span><br><span class="line"></span><br><span class="line">RUN set -x ; echo $&#123;DOCKER_USERNAME&#125;</span><br></pre></td></tr></table></figure>
<p>使用上述 <code>Dockerfile</code> 会发现无法输出 <code>$&#123;DOCKER_USERNAME&#125;</code> 变量的值，要想正常输出，你必须在 <code>FROM</code> 之后再次指定 <code>ARG</code>  </p>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只在 FROM 中生效</span></span><br><span class="line">ARG DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line">FROM $&#123;DOCKER_USERNAME&#125;/alpine</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">要想在 FROM 之后使用，必须再次指定</span></span><br><span class="line">ARG DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line">RUN set -x ; echo $&#123;DOCKER_USERNAME&#125;</span><br></pre></td></tr></table></figure>

<h4 id="VOLUME-定义匿名卷指令"><a href="#VOLUME-定义匿名卷指令" class="headerlink" title="VOLUME 定义匿名卷指令"></a>VOLUME 定义匿名卷指令</h4><p>容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。  </p>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">VOLUME /data</span><br></pre></td></tr></table></figure>

<p>这里的 <code>/data</code> 目录就会在容器运行时自动挂载为匿名卷，任何向 <code>/data</code> 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行容器时可以覆盖这个挂载设置。比如：  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -v mydata:/data xxxx</span><br></pre></td></tr></table></figure>

<p>在这行命令中，就使用了 <code>mydata</code> 这个命名卷挂载到了 <code>/data</code> 这个位置，替代了 <code>Dockerfile</code> 中定义的匿名卷的挂载配置。  </p>
<h4 id="EXPOSE-暴露端口指令"><a href="#EXPOSE-暴露端口指令" class="headerlink" title="EXPOSE 暴露端口指令"></a>EXPOSE 暴露端口指令</h4><p>格式为 <code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code>。</p>
<p><code>EXPOSE</code> 指令是声明容器运行时提供服务的端口，这<strong>只是一个声明</strong>，在容器运行时并<strong>不会因为这个声明，应用就会开启这个端口</strong>的服务。在 <code>Dockerfile</code> 中写入这样的声明有两个好处:</p>
<ul>
<li>一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；</li>
<li>另一个用处则是在运行时使用随机端口映射时，也就是 <code>docker run -P</code> 时，会自动随机映射 <code>EXPOSE</code> 的端口。</li>
</ul>
<p>要将 <code>EXPOSE</code> 和在运行时使用 <code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 区分开来。<code>-p</code>，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 <code>EXPOSE</code> 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p>
<h4 id="WORKDIR-指定工作目录指令"><a href="#WORKDIR-指定工作目录指令" class="headerlink" title="WORKDIR 指定工作目录指令"></a>WORKDIR 指定工作目录指令</h4><p>格式为 <code>WORKDIR &lt;工作目录路径&gt;</code>。  </p>
<p>使用 <code>WORKDIR</code> 指令可以来指定工作目录（或者称为当前目录），<strong>以后各层</strong>的当前目录就被改为指定的目录，如该目录不存在，<code>WORKDIR</code> 会帮你建立目录。  </p>
<p>如果 <code>WORKDIR</code> 指令使用的是<code>相对路径</code>，那么所切换的路径与之前的 <code>WORKDIR</code> 有关</p>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">WORKDIR /a</span><br><span class="line">WORKDIR b</span><br><span class="line">WORKDIR c</span><br><span class="line"></span><br><span class="line">RUN pwd</span><br></pre></td></tr></table></figure>

<p><code>RUN pwd</code> 的工作目录为 &#x2F;a&#x2F;b&#x2F;c。</p>
<h4 id="USER-指定当前用户指令"><a href="#USER-指定当前用户指令" class="headerlink" title="USER 指定当前用户指令"></a>USER 指定当前用户指令</h4><p>格式：<code>USER &lt;用户名&gt;[:&lt;用户组&gt;]</code></p>
<p><code>USER</code> 指令和 <a href="#WORKDIR-%E6%8C%87%E5%AE%9A%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%E6%8C%87%E4%BB%A4"><code>WORKDIR</code></a> 相似，都是改变环境状态并影响以后的层。<code>WORKDIR</code> 是改变工作目录，<code>USER</code> 则是改变之后层的执行 <code>RUN</code>, <code>CMD</code> 以及 <code>ENTRYPOINT</code> 这类命令的身份。 <code>USER</code> 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。</p>
<h4 id="HEALTHCHECK-健康状态检查命令"><a href="#HEALTHCHECK-健康状态检查命令" class="headerlink" title="HEALTHCHECK 健康状态检查命令"></a>HEALTHCHECK 健康状态检查命令</h4><p>格式：<br><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>：设置检查容器健康状况的命令 <sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[HEALTHCHECK 健康检查](https://yeasy.gitbook.io/docker_practice/image/dockerfile/healthcheck)">[5]</span></a></sup><br><code>HEALTHCHECK NONE</code>：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令  </p>
<p>HEALTHCHECK 支持下列选项：</p>
<style>
table th:nth-of-type(1){
width: 15%;
}
table th:nth-of-type(2){
width: 40%;
}
table th:nth-of-type(3){
width: 35%;
}
</style>

<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>--interval=&lt;30s&gt;</code></td>
<td>两次健康检查的间隔，默认为 30 秒</td>
<td></td>
</tr>
<tr>
<td><code>--timeout=&lt;30s&gt;</code></td>
<td>健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；</td>
<td></td>
</tr>
<tr>
<td><code>--retries=&lt;次数&gt;</code></td>
<td>当连续失败指定次数后，则将容器状态视为 <code>unhealthy</code>，默认 3 次。</td>
<td></td>
</tr>
</tbody></table>
<p>当在一个镜像指定了 <code>HEALTHCHECK</code> 指令后，用其启动容器，初始状态会为 <code>starting</code>，在 <code>HEALTHCHECK</code> 指令检查成功后变为 <code>healthy</code>，如果连续一定次数失败，则会变为 <code>unhealthy</code>。  </p>
<p>和 <code>CMD</code>, <code>ENTRYPOINT</code> 一样，<code>HEALTHCHECK</code> 只可以出现一次，如果写了多个，只有最后一个生效。  </p>
<p>在 <code>HEALTHCHECK [选项] CMD</code> 后面的命令，格式和 <code>ENTRYPOINT</code> 一样，分为 <code>shell</code> 格式，和 <code>exec</code> 格式。命令的返回值决定了该次健康检查的成功与否：  </p>
<ul>
<li>0：成功；</li>
<li>1：失败；</li>
<li>2：保留，不要使用这个值。</li>
</ul>
<p>假设我们有个镜像是个最简单的 Web 服务，我们希望增加健康检查来判断其 Web 服务是否在正常工作，我们可以用 <code>curl</code> 来帮助判断，其 <code>Dockerfile</code> 的 <code>HEALTHCHECK</code> 可以这么写：  </p>
<figure class="highlight shell"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN yum install -y curl &amp;&amp; yum clean all</span><br><span class="line">HEALTHCHECK --interval=5s --timeout=3s CMD \</span><br><span class="line">  curl -fs http://localhost/ || exit 1</span><br></pre></td></tr></table></figure>

<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://yeasy.gitbook.io/docker_practice/">docker 从入门到实践</a>  </p>
<h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://yeasy.gitbook.io/docker_practice/image/build">使用 Dockerfile 定制镜像</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/copy">COPY 复制文件</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/cmd">CMD 容器启动命令</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/entrypoint">ENTRYPOINT 入口点 | ENTRYPOINT 和 CMD 的不同使用场景</a><a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/healthcheck">HEALTHCHECK 健康检查</a><a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://yeasy.gitbook.io/docker_practice/image/multistage-builds">Dockerfile 多阶段构建</a><a href="#fnref:6" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo Next 自定义配置示例</title>
    <url>/202207241754/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Hexo 6.2.0</li>
<li>Next 8.12.2</li>
</ul>
<blockquote>
<p>Hexo 查看版本方式： <code>npm list</code><br>Next 版本信息可在文件 <code>themes/next/package.json </code> 中查看</p>
</blockquote>
<span id="more"></span>

<h3 id="调整页面显示宽度"><a href="#调整页面显示宽度" class="headerlink" title="调整页面显示宽度"></a>调整页面显示宽度</h3><p>针对Next中的主题方案<code>Pisces</code>或<code>Gemini</code>, 更改Next主题中的文件 <code>themes/next/source/css/_variables/Pisces.styl</code> <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[官网说明](https://hexo-next.readthedocs.io/zh_CN/latest/next/advanced/%E8%B0%83%E6%95%B4%E9%A1%B5%E9%9D%A2%E5%AE%BD%E5%BA%A6/)">[1]</span></a></sup> </p>
<figure class="highlight shell"><figcaption><span>Pisces.styl</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">content-desktop-large        = 90em;</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">content-desktop-largest      = 90%;</span></span><br></pre></td></tr></table></figure>

<h3 id="首页按照更新时间排序"><a href="#首页按照更新时间排序" class="headerlink" title="首页按照更新时间排序"></a>首页按照更新时间排序</h3><p>更改主配置文件 <code>_config.yml</code> 中的以下部分(<code>index_generator.order_by</code>):  </p>
<figure class="highlight shell"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">index_generator:</span><br><span class="line">  path: &#x27;&#x27;</span><br><span class="line">  per_page: 10</span><br><span class="line">  order_by: -updated</span><br></pre></td></tr></table></figure>

<h3 id="代码块不显示行号"><a href="#代码块不显示行号" class="headerlink" title="代码块不显示行号"></a>代码块不显示行号</h3><p>更改 <code>Hexo</code> 配置文件 <code>_config.yml</code>，修改以下配置</p>
<figure class="highlight shell"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">highlight:</span><br><span class="line">  enable: true</span><br><span class="line">  line_number: false </span><br></pre></td></tr></table></figure>

<p>将 <code>line_number</code> 值改为 <code>false</code></p>
<h3 id="配置站点地图"><a href="#配置站点地图" class="headerlink" title="配置站点地图"></a>配置站点地图</h3><p>通过设置站点地图(sitemap)，可以让搜索引擎获取你的页面信息，这样可以增加别人搜索到你的几率，具体配置参考官网步骤<br><a href="https://hexo-next.readthedocs.io/zh_CN/latest/next/advanced/Baidu-Google-%E7%AB%99%E7%82%B9%E5%9C%B0%E5%9B%BE/">官网说明</a></p>
<h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://hexo-next.readthedocs.io/zh_CN/latest/next/advanced/%E8%B0%83%E6%95%B4%E9%A1%B5%E9%9D%A2%E5%AE%BD%E5%BA%A6/">官网说明</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo markdown常用语法</title>
    <url>/2215beeb/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="url-链接"><a href="#url-链接" class="headerlink" title="url 链接"></a>url 链接</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[这是一个链接](https://csms.tech [title])</span><br></pre></td></tr></table></figure>
<p><a href="https://csms.tech/">这是一个链接</a></p>
<h3 id="图片链接"><a href="#图片链接" class="headerlink" title="图片链接"></a>图片链接</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![图片名称](https://i.csms.tech/img_10.png [title])</span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_10.png" alt="图片名称"></p>
<span id="more"></span>

<h3 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;https://csms.tech&gt;</span><br></pre></td></tr></table></figure>
<p><a href="https://csms.tech/">https://csms.tech</a><br><a href="https://csms.tech/">https://csms.tech</a></p>
<h3 id="链接到文章内的标题"><a href="#链接到文章内的标题" class="headerlink" title="链接到文章内的标题"></a>链接到文章内的标题</h3><p><code>Hexo</code> 会自动为各个层级的标题添加锚点，锚点 id 为标题名称，如果标题名称中有空格，空格会被替换成<code>-</code>，多个空格合并成一个。如果标题开头中包含 <code>/</code>，会被替换成 <code>x2F-</code>，如果标题中间出现 <code>/</code>，会被替换成 <code>-x2F-</code>，使用示例如下</p>
<table>
<thead>
<tr>
<th>标题</th>
<th>锚点 id</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>### 三级标题</td>
<td><code>id=&quot;三级标题&quot;</code></td>
<td></td>
</tr>
<tr>
<td>### this is  title</td>
<td><code>id=&quot;this-is-title&quot;</code></td>
<td>多个空格会合并成一个</td>
</tr>
<tr>
<td>### &#x2F;home&#x2F;dir</td>
<td><code>id=&quot;x2F-home-x2F-dir&quot;</code></td>
<td></td>
</tr>
</tbody></table>
<p>在文章中要跳转到指定的锚点，可以使用以下方式：  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[这是一个锚点](#this-is-title)</span><br></pre></td></tr></table></figure>

<h3 id="链接到本站其他文章的指定标题"><a href="#链接到本站其他文章的指定标题" class="headerlink" title="链接到本站其他文章的指定标题"></a>链接到本站其他文章的指定标题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[名称](https://csms.tech&#123;% post_path &#x27;文章文件名&#x27; %&#125;#id)</span><br></pre></td></tr></table></figure>
<p><code>&#123;% post_path 'Hexo-markdown-grammar' %&#125;</code> 的值为： <code>/2022/07/Hexo-markdown-grammar/</code><br><a href="https://csms.tech/2215beeb/#图片链接">跳转</a></p>
<h3 id="链接到标题之外的锚点"><a href="#链接到标题之外的锚点" class="headerlink" title="链接到标题之外的锚点"></a>链接到标题之外的锚点</h3><p>可以使用html标签先创建对应锚点，如<code>&lt;div id=&#39;1&#39;&gt;这是一个文章锚点&lt;/div&gt;</code></p>
<div id='1'>这是一个文章锚点</div>

<p><a href="#1">跳转到id&#x3D;1的锚点</a></p>
<h3 id="站内文章链接"><a href="#站内文章链接" class="headerlink" title="站内文章链接"></a>站内文章链接</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% post_link &#x27;文章文件名&#x27; [&#x27;显示的名称, 默认为文章title&#x27;] %&#125;</span><br></pre></td></tr></table></figure>
<p>本篇文章 <a href="/2215beeb/" title="hexo markdown常用语法">hexo markdown常用语法</a></p>
<h3 id="note标签"><a href="#note标签" class="headerlink" title="note标签"></a>note标签</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;% note class %&#125;</span><br><span class="line">文本内容 (支持行内标签)</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
<p>支持的class包括：<code>default</code> <code>primary</code> <code>success</code> <code>info</code> <code>warning</code> <code>danger</code></p>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><figure class="highlight shell"><figcaption><span>代码块示例</span><a href="https://csms.tech">主页</a></figcaption><table><tr><td class="code"><pre><span class="line">```shell name url urlshowname</span><br><span class="line">log-bin=binlog</span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| title1 | title2  | title3 |</span><br><span class="line">|:------|:-------:|-------:|</span><br><span class="line">| 第1列 |第2列     |第3列  |</span><br><span class="line">|左对齐| 居中对齐   | 右对齐|</span><br><span class="line">| 竖线 &amp;#124; |竖线 &amp;#x7C; |</span><br><span class="line">|Hexo中竖线使用 `\|`||</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="left">title1</th>
<th align="center">title2</th>
<th align="right">title3</th>
</tr>
</thead>
<tbody><tr>
<td align="left">第1列</td>
<td align="center">第2列</td>
<td align="right">第3列</td>
</tr>
<tr>
<td align="left">左对齐</td>
<td align="center">居中对齐</td>
<td align="right">右对齐</td>
</tr>
<tr>
<td align="left">竖线 <code>&amp;#124;</code></td>
<td align="center">竖线 <code>&amp;#x7C;</code></td>
<td align="right"></td>
</tr>
<tr>
<td align="left">Hexo中竖线使用 <code>|</code></td>
<td align="center"></td>
<td align="right"></td>
</tr>
</tbody></table>
<blockquote>
<p>要在表格中使用<code>|</code>, 可用以下2中之一代替</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&amp;#124;</span><br><span class="line">&amp;#x7C;</span><br></pre></td></tr></table></figure>
<p>Hexo 表格中需要使用 <code>\|</code> 方式输出 <code>|</code></p>
</blockquote>
<p>设置表格宽度，在表格之前使用以下 <code>style</code>：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line"><span class="selector-tag">table</span> <span class="selector-tag">th</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">10%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">table</span> <span class="selector-tag">th</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">2</span>)&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">70%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">table</span> <span class="selector-tag">th</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">3</span>)&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">20%</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">table th:nth-of-type(1)&#123;</span><br><span class="line">width: 10%;</span><br><span class="line">&#125;</span><br><span class="line">table th:nth-of-type(2)&#123;</span><br><span class="line">width: 70%;</span><br><span class="line">&#125;</span><br><span class="line">table th:nth-of-type(3)&#123;</span><br><span class="line">width: 20%;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">| 选项      | 说明    |示例|</span><br><span class="line">|:--------|--------|---|</span><br><span class="line">|第一列：10%|第二列：70%|第三列：20%|</span><br></pre></td></tr></table></figure>

<p>以上输出显示效果如下：</p>
<style>
table th:nth-of-type(1){
width: 10%;
}
table th:nth-of-type(2){
width: 70%;
}
table th:nth-of-type(3){
width: 20%;
}
</style>

<table>
<thead>
<tr>
<th align="left">选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">第一列：10%</td>
<td>第二列：70%</td>
<td>第三列：20%</td>
</tr>
</tbody></table>
<blockquote>
<p>一个文档中出现多次，以最后一个 <code>style</code> 配置为最终效果</p>
</blockquote>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://hexo.io/zh-cn/docs/writing">Hexo Markdown 语法手册</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql从库提升为主库，原来的其他从库成为新的主库的从库</title>
    <url>/b12589a5/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Mysql 5.7</li>
</ul>
<h3 id="场景说明"><a href="#场景说明" class="headerlink" title="场景说明"></a>场景说明</h3><p>Mysql 一主多从的情况下，主库宕机（或其他无法使用的情况），将其中一台从库提升为主库，同时将原来其他的从库配置为新的主库的从库。  </p>
<div class="note primary"><p>主从恢复正常之前，数据库不应该有新的数据写入</p>
</div>

<span id="more"></span>

<h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><h4 id="确保所有从库已经执行了relay-log中的全部更新"><a href="#确保所有从库已经执行了relay-log中的全部更新" class="headerlink" title="确保所有从库已经执行了relay log中的全部更新"></a>确保所有从库已经执行了relay log中的全部更新</h4><p>登录mysql从库，在每个从库上，执行<code>stop slave io_thread</code>,停止IO线程, 通过以下2个命令之一检查从库relay log的执行情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">show processlist;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_6.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">show slave status\G</span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_7.png">  </p>
<p>当输出中<code>Slave_SQL_Running_State</code> 为 <code>Slave has read all relay log; waiting for more updates</code>，表示更新都执行完毕。  </p>
<blockquote>
<ul>
<li>正常情况下，此时在每个从库上面查看slave状态(<code>show slave status\G</code>), 每个从库读取的主库的<code>Master_Log_File</code>和<code>Read_Master_Log_Pos</code>都应该是一样的，意味着所有的从库都已经更新到了主库宕机时的状态。此种情况下，可随便选择从库作为新的主库。<br><img src="https://i.csms.tech/img_8.png"></li>
<li>如果，从库上面查看slave状态，各个从库读取的主库的<code>Master_Log_File</code>和<code>Read_Master_Log_Pos</code>不一致，说明主库宕机之前各个从库和主库的主从延迟情况可能不一，导致各个从库的状态不一致，此种情况下，从数据完整性的角度考虑，应该选择position最大的一个从库，作为新选定的主库。对其他从库，应该通过从binlog中读取缺失的数据，补足数据。或者直接通过<a href="/94ee2c23/" title="备份恢复">备份恢复</a>的方式，和新选定的主库，重新建立主从连接。</li>
</ul>
</blockquote>
<h4 id="更新新的主库的配置"><a href="#更新新的主库的配置" class="headerlink" title="更新新的主库的配置"></a>更新新的主库的配置</h4><p>在新选定的主库上，配置文件(默认<code>/etc/my.cnf</code>)中开启binlog，如已配置，跳过</p>
<figure class="highlight shell"><figcaption><span>/etc/my.cnf</span></figcaption><table><tr><td class="code"><pre><span class="line">log-bin=mysql-bin</span><br></pre></td></tr></table></figure>
<p>新选定的主库上，如果配置了readonly，在配置文件(默认<code>/etc/my.cnf</code>)中取消readonly配置</p>
<figure class="highlight shell"><figcaption><span>/etc/my.cnf</span></figcaption><table><tr><td class="code"><pre><span class="line">read_only=0</span><br></pre></td></tr></table></figure>
<blockquote>
<p>更改mysql配置文件后，重启mysql生效</p>
</blockquote>
<p>在新选定的主库上，执行以下命令，重置从库配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">stop slave;  </span><br><span class="line">reset master;</span><br><span class="line">reset slave all;  </span><br></pre></td></tr></table></figure>
<p>在新选定的主库上，执行以下命令，创建具有同步权限的账号，如果已存在，跳过</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grant replication slave on *.* to &#x27;repl&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
<p>在新选定的主库上，执行以下命令，查看当前主库的master位置信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">show master status\G</span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_9.png"></p>
<blockquote>
<p>在主从重新建立之前，不应该有新的数据写入数据库，在此前提之下，多次查看master status，显示的<code>File</code>和<code>Position</code> 应该是确定不变的值，后续可根据此值，让其他从库和新选定的主库建立主从连接。  </p>
</blockquote>
<h4 id="建立新的主从"><a href="#建立新的主从" class="headerlink" title="建立新的主从"></a>建立新的主从</h4><p>在其他从库上，执行以下命令，和新选定的主库，建立主从连接，其中需要的<code>master_log_file</code>和<code>master_log_pos</code>从<a href="#%E6%9B%B4%E6%96%B0%E6%96%B0%E7%9A%84%E4%B8%BB%E5%BA%93%E7%9A%84%E9%85%8D%E7%BD%AE">上一步</a>中获得。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">stop slave;</span><br><span class="line">change master to master_host=&#x27;1.1.1.1&#x27;,master_user=&#x27;repl&#x27;,master_password=&#x27;123456&#x27;,master_port=3306,master_log_file=&#x27;mysql-bin.000982&#x27;,master_log_pos=638932979;</span><br><span class="line">start slave</span><br></pre></td></tr></table></figure>

<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3>]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>awk 使用示例</title>
    <url>/202208031132/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>awk 是一种编程语言，用于在linux&#x2F;unix下对文本和数据进行处理。数据可以来自标准输入(stdin)、一个或多个文件，或其它命令的输出。它支持用户自定义函数和动态正则表达式等先进功能，是linux&#x2F;unix下的一个强大编程工具。它在命令行中使用，但更多是作为脚本来使用。awk有很多内建的功能，比如数组、函数等，这是它和C语言的相同之处，灵活性是awk最大的优势。  </p>
<span id="more"></span>

<h3 id="awk-脚本基本结构"><a href="#awk-脚本基本结构" class="headerlink" title="awk 脚本基本结构"></a>awk 脚本基本结构</h3><p><code>awk &#39;BEGIN&#123; commands &#125; pattern&#123; commands &#125; END&#123; commands &#125;&#39;</code>  </p>
<p>一个awk脚本通常由：<strong>BEGIN语句块</strong>、<strong>能够使用模式匹配的通用语句块</strong>、<strong>END语句块</strong> 3部分组成，这三个部分是可选的。任意一个部分都可以不出现在脚本中，脚本通常是被放置在 <strong>单引号</strong> 中  </p>
<h3 id="awk-的工作原理"><a href="#awk-的工作原理" class="headerlink" title="awk 的工作原理"></a>awk 的工作原理</h3><ol>
<li>执行 <code>BEGIN&#123; commands &#125;</code> 语句块中的语句；  </li>
<li>从文件或标准输入(stdin)读取一行，然后执行 <code>pattern&#123; commands &#125;</code> 语句块，它逐行扫描文件，从第一行到最后一行重复这个过程，直到文件全部被读取完毕。  </li>
<li>当读至输入流末尾时，执行 <code>END&#123; commands &#125;</code> 语句块。</li>
</ol>
<p><code>BEGIN语句块</code> 在awk开始从输入流中读取行 <strong>之前</strong> 被执行，这是一个可选的语句块，比如变量初始化、打印输出表格的表头等语句通常可以写在BEGIN语句块中  </p>
<p><code>END语句块</code> 在awk从输入流中读取完所有的行 <strong>之后</strong> 即被执行，比如打印所有行的分析结果这类信息汇总都是在END语句块中完成，它也是一个可选语句块。  </p>
<p><code>pattern语句块</code> 中的通用命令是最重要的部分，它也是可选的。如果没有提供<code>pattern语句块</code>，则默认执行 <code>&#123; print &#125;</code>，即打印每一个读取到的行，<strong>awk读取的每一行都会执行该语句块</strong>。 </p>
<h3 id="awk-内置变量（预定义变量）"><a href="#awk-内置变量（预定义变量）" class="headerlink" title="awk 内置变量（预定义变量）"></a>awk 内置变量（预定义变量）</h3><table>
<thead>
<tr>
<th align="left">变量</th>
<th align="left">说明</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$0</td>
<td align="left">当前行的整行内容</td>
<td align="left"><code>&#39;&#123;print $0&#125;&#39;</code> 打印出当前处理行的整行内容</td>
</tr>
<tr>
<td align="left">$n</td>
<td align="left">当前记录（行）的第n个字段</td>
<td align="left"><code>&#39;&#123;print $1&#125;&#39;</code> 打印出当前行的第1个字段</td>
</tr>
<tr>
<td align="left">NR</td>
<td align="left">当前处理行的行号（第多少行）</td>
<td align="left"><code>&#39;&#123;print NR,$1&#125;&#39; END&#123;print NR&#125;</code> 打印出当前处理行的行号和第1列，最后打印出总的行号</td>
</tr>
<tr>
<td align="left">FNR</td>
<td align="left">当前处理行在当前处理文件中的行号，只有1个输入文件时，NR&#x3D;FNR</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">NF</td>
<td align="left">当前行的字段数</td>
<td align="left"><code>&#39;&#123;print NF,$NF,$(NF-1)&#125;&#39;</code>  输出当前行的字段数，最后一个字段 ,倒数第2个字段</td>
</tr>
<tr>
<td align="left">FILENAME</td>
<td align="left">当前输入文件的文件名，<code>-</code>表示stdin</td>
<td align="left"><code>&#39;&#123;print FILENAME,FNR&#125;&#39;</code> 打印当前处理的文件名及当前行号</td>
</tr>
<tr>
<td align="left">FS</td>
<td align="left">输入字段分隔符，等同于选项 <code>-F</code> ,默认为空格</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">OFS</td>
<td align="left">输出字段的分隔符，默认为空格</td>
<td align="left"><code>&#39;BEGIN&#123;OFS=&quot;|&quot;&#125; &#123;print FILENAME,FS,NR,NF,$2,$NF&#125;&#39;</code> 输出结果将会以 <code>|</code> 分割</td>
</tr>
<tr>
<td align="left">RS</td>
<td align="left">输入记录分隔符（行分隔符），默认为换行</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">ORS</td>
<td align="left">输出记录分隔符（行分隔符），默认为换行</td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="awk-常用选项"><a href="#awk-常用选项" class="headerlink" title="awk 常用选项"></a>awk 常用选项</h3><table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>-F&quot;sep&quot;</code><br/><code>-F&quot;[,.]&quot;</code></td>
<td>等同于内置变量 <code>FS</code>，有2种格式：<br/><code>-F&quot;sep&quot;</code> 使用 <code>sep</code> 整体作为字段分隔符<br/> <code>-F[,.]</code>  <code>[]</code>其中的每个字符都可以作为分隔符<br/>等同于<code>BEGIN</code>预定义变量<code>FS</code></td>
<td></td>
</tr>
<tr>
<td><code>-v var=1</code></td>
<td>传递用户自定义变量给awk</td>
<td><code>awk -va=1 -vb=2 &#39;&#123;print a+b&#125;&#39;</code></td>
</tr>
</tbody></table>
<h3 id="awk-常用运算符"><a href="#awk-常用运算符" class="headerlink" title="awk 常用运算符"></a>awk 常用运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;<br/>+&#x3D;<br/> -&#x3D;<br/> *&#x3D;<br/> &#x2F;&#x3D;<br/> %&#x3D;<br/> ^&#x3D;<br/> **&#x3D;</td>
<td>赋值</td>
<td></td>
</tr>
<tr>
<td><code>~</code><br/><code>!~</code></td>
<td>匹配正则表达式<br/>不匹配正则表达式</td>
<td><code>awk &#39;$2 ~ /th/ &#123;print $2,$4&#125;&#39; log.txt</code> 第2列中包含’th’，则输出第2,4列<br/><code>awk &#39;BEGIN&#123;IGNORECASE=1&#125; /this/&#39; log.txt</code>    忽略大小写匹配 <br/><code>awk &#39;$2 !~ /th/ &#123;print $2,$4&#125;&#39; log.txt</code> 不匹配正则表达式</td>
</tr>
<tr>
<td>&lt; <br/>&lt;&#x3D;<br/> &gt;<br/> &gt;&#x3D;<br/> !&#x3D; <br/>&#x3D;&#x3D;</td>
<td>关系运算符</td>
<td><code>awk &#39;$1&gt;2&#39; log.txt</code>  第1列的值大于2，输出整行<br/><code>awk &#39;$1==2 &#123;print $1,$3&#125;&#39; log.txt</code> 第1列的值等于2，则输出第1,3列</td>
</tr>
<tr>
<td>+<br/>-<br/>*<br/>&#x2F;<br/>%<br/></td>
<td>加，减，乘，除与求余</td>
<td></td>
</tr>
<tr>
<td>+ <br/>- <br/>!</td>
<td>一元加，减和逻辑非</td>
<td></td>
</tr>
<tr>
<td>| |</td>
<td>逻辑或</td>
<td></td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>逻辑与</td>
<td><code>awk &#39;$1&gt;2 &amp;&amp; $2==&quot;Are&quot; &#123;print $1,$2,$3&#125;&#39; log.txt </code>  第1列大于2，并且第2列等于”Are”,则输出第1,2,3列</td>
</tr>
</tbody></table>
<h3 id="awk-常用用法示例"><a href="#awk-常用用法示例" class="headerlink" title="awk 常用用法示例"></a>awk 常用用法示例</h3><h4 id="每一行中第个字段值累加"><a href="#每一行中第个字段值累加" class="headerlink" title="每一行中第个字段值累加"></a>每一行中第个字段值累加</h4><figure class="highlight shell"><figcaption><span>awk</span></figcaption><table><tr><td class="code"><pre><span class="line">seq 1 10 | awk &#x27;BEGIN&#123;sum=0;print &quot;第1列求和&quot;&#125;&#123;sum+=$1&#125;END&#123;print &quot;sum=&quot;sum&#125;&#x27;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第1列求和<br>sum&#x3D;55</p>
</blockquote>
<h4 id="判断2列的内容是否相同"><a href="#判断2列的内容是否相同" class="headerlink" title="判断2列的内容是否相同"></a>判断2列的内容是否相同</h4><figure class="highlight shell"><figcaption><span>awk</span></figcaption><table><tr><td class="code"><pre><span class="line">awk &#x27;&#123;if($1==$2)&#123;print $1&#125;&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="找出字段数-列数-大于3的行"><a href="#找出字段数-列数-大于3的行" class="headerlink" title="找出字段数(列数)大于3的行"></a>找出字段数(列数)大于3的行</h4><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;NF&gt;3&#123;print $0&#125;&#x27;</span> </span><br></pre></td></tr></table></figure>

<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://wangchujiang.com/linux-command/c/awk.html">参考文章</a></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>awk</tag>
      </tags>
  </entry>
  <entry>
    <title>aws python sdk 常用操作</title>
    <url>/202207251345/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>centos 7</li>
<li>Python3.10</li>
<li>boto3 1.23.2 <blockquote>
<p>(<code>pip3 install boto3</code>)</p>
</blockquote>
</li>
</ul>
<span id="more"></span>

<h3 id="获取-s3-中文件大小"><a href="#获取-s3-中文件大小" class="headerlink" title="获取 s3 中文件大小"></a>获取 s3 中文件大小</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> boto3.session <span class="keyword">import</span> Session</span><br><span class="line"></span><br><span class="line">ak = <span class="string">&#x27;XXXXXXX&#x27;</span></span><br><span class="line">sk = <span class="string">&#x27;XXXXXXXXXX&#x27;</span></span><br><span class="line">region = <span class="string">&#x27;us-west-1&#x27;</span></span><br><span class="line">bucketName = <span class="string">&#x27;testBucket&#x27;</span></span><br><span class="line"></span><br><span class="line">session = Session(aws_access_key_id=ak, aws_secret_access_key=sk, region_name=region)</span><br><span class="line">s3 = session.resource(<span class="string">&#x27;s3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">bucket = s3.Bucket(bucketName)</span><br><span class="line">obj = bucket.objects.<span class="built_in">filter</span>(Prefix=<span class="string">&#x27;filename&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> obj:</span><br><span class="line">    <span class="keyword">if</span> i.size:</span><br><span class="line">        <span class="keyword">return</span> i.size</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>云平台</category>
        <category>Aws</category>
      </categories>
      <tags>
        <tag>云平台</tag>
        <tag>Aws</tag>
      </tags>
  </entry>
  <entry>
    <title>Awvs 破解版14.6.211213163 安装破解</title>
    <url>/2207221019/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Acunetix Web Vulnerability Scanner（简称AWVS）是一款知名的网络漏洞扫描工具，它通过网络爬虫测试你的网站安全，检测流行安全漏洞。  </p>
<span id="more"></span>

<h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Windows Server 2016 Datacenter</li>
<li>14.6.211213163</li>
</ul>
<h3 id="AWVS-安装激活"><a href="#AWVS-安装激活" class="headerlink" title="AWVS 安装激活"></a>AWVS 安装激活</h3><p>官方版本需要License才能下载，可通过如下链接下载破解版及补丁<br><a href="https://yzzpan.com/#sharefile=Nh2pQnaW_22930">www.ddosi.org下载入口</a><br><a href="https://yzzpan.com/#sharefile=DXt5k9dh_22034">www.ddosi.org破解工具下载入口</a></p>
<blockquote>
<p>解压密码均为: <a href="http://www.ddosi.org/">www.ddosi.org</a></p>
</blockquote>
<p><a href="https://s.csms.tech/file/acunetix_14.6.211213163.exe.rar">其他下载地址</a><br><a href="https://s.csms.tecn/file/awvs_crack.rar">其他下载地址-破解工具</a> </p>
<p>下载后，双击文件 <code>acunetix_14.6.211213163.exe</code> 进行安装，按照提示，一直点击<code>下一步</code>，直到安装完成。<br>安装完成，打开登录后，处于未激活状态，显示如下图：<br><img src="https://i.csms.tech/img_14.png">  </p>
<p>复制 <code>awvs_crack</code> 目录下的文件 <code>license_info.json</code> 和 <code>wa_data.dat</code> </p>
<p><img src="https://i.csms.tech/img_15.png"> </p>
<p>覆盖目录 <code>C:\ProgramData\Acunetix\shared\license</code> 下的文件</p>
<p>修改hosts文件(<code>C:\Windows\System32\drivers\etc</code>), 添加以下内容：</p>
<figure class="highlight plaintext"><figcaption><span>C:\Windows\System32\drivers\etc</span></figcaption><table><tr><td class="code"><pre><span class="line">127.0.0.1 updates.acunetix.com</span><br><span class="line">127.0.0.1 erp.acunetix.com</span><br></pre></td></tr></table></figure>

<p>返回页面刷新，即可激活成功<br><img src="https://i.csms.tech/img_16.png"> </p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.ddosi.org/awvs-14-6/">Awvs破解版14.6.211213163|可扫Log4j RCE漏洞</a><br><a href="https://www.ddosi.org/awvs-14-5-2/">Awvs破解版14.5.211115146 Windows+Linux+Mac cracked</a></p>
]]></content>
      <categories>
        <category>安全</category>
        <category>Awvs</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>Awvs</tag>
        <tag>Acunetix</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos 7 升级内核</title>
    <url>/202209140931/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Centos 7 内核版本由 3.10 升级到 5.4.212-1</p>
<h3 id="环境息息"><a href="#环境息息" class="headerlink" title="环境息息"></a>环境息息</h3><ul>
<li>Centos7 3.10.0-1062.9.1.el7.x86_64</li>
</ul>
<h3 id="升级步骤"><a href="#升级步骤" class="headerlink" title="升级步骤"></a>升级步骤</h3><h4 id="安装-elrepo-源"><a href="#安装-elrepo-源" class="headerlink" title="安装 elrepo 源"></a>安装 elrepo 源</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</span><br><span class="line">rpm -Uvh https://www.elrepo.org/elrepo-release-7.el7.elrepo.noarch.rpm</span><br><span class="line">yum --disablerepo=&quot;*&quot; --enablerepo=&quot;elrepo-kernel&quot; repolist</span><br></pre></td></tr></table></figure>

<h4 id="安装新版本内核"><a href="#安装新版本内核" class="headerlink" title="安装新版本内核"></a>安装新版本内核</h4><p>查看可用的内核版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum --disablerepo=<span class="string">&quot;*&quot;</span> --enablerepo=<span class="string">&quot;elrepo-kernel&quot;</span> list available</span></span><br><span class="line">Available Packages</span><br><span class="line">kernel-lt-doc.noarch                                      5.4.212-1.el7.elrepo                          elrepo-kernel</span><br><span class="line">kernel-lt-headers.x86_64                                  5.4.212-1.el7.elrepo                          elrepo-kernel</span><br><span class="line">kernel-lt-tools.x86_64                                    5.4.212-1.el7.elrepo                          elrepo-kernel</span><br><span class="line">kernel-lt-tools-libs.x86_64                               5.4.212-1.el7.elrepo                          elrepo-kernel</span><br><span class="line">kernel-lt-tools-libs-devel.x86_64                         5.4.212-1.el7.elrepo                          elrepo-kernel</span><br><span class="line">kernel-ml.x86_64                                          5.19.8-1.el7.elrepo                           elrepo-kernel</span><br><span class="line">kernel-ml-devel.x86_64                                    5.19.8-1.el7.elrepo                           elrepo-kernel</span><br><span class="line">kernel-ml-doc.noarch                                      5.19.8-1.el7.elrepo                           elrepo-kernel</span><br><span class="line">kernel-ml-headers.x86_64                                  5.19.8-1.el7.elrepo                           elrepo-kernel</span><br><span class="line">kernel-ml-tools.x86_64                                    5.19.8-1.el7.elrepo                           elrepo-kernel</span><br><span class="line">kernel-ml-tools-libs.x86_64                               5.19.8-1.el7.elrepo                           elrepo-kernel</span><br><span class="line">kernel-ml-tools-libs-devel.x86_64                         5.19.8-1.el7.elrepo                           elrepo-kernel</span><br><span class="line">perf.x86_64                                               5.19.8-1.el7.elrepo                           elrepo-kernel</span><br><span class="line">python-perf.x86_64                                        5.19.8-1.el7.elrepo                           elrepo-kernel</span><br></pre></td></tr></table></figure>
<blockquote>
<p>kernel-lt 和 kernel-ml 二者的区别：  </p>
<ul>
<li>kernel-ml 软件包是根据 Linux Kernel Archives 的主线稳定分支提供的源构建的。 内核配置基于默认的 RHEL-7 配置，并根据需要启用了添加的功能。 这些软件包有意命名为 kernel-ml，以免与 RHEL-7 内核发生冲突，因此，它们可以与常规内核一起安装和更新。  </li>
<li>kernel-lt 包是从 Linux Kernel Archives 提供的源代码构建的，就像 kernel-ml 软件包一样。 不同之处在于 kernel-lt 基于长期支持分支，而 kernel-ml 基于主线稳定分支。</li>
</ul>
<p>在 ELRepo 中有两个内核选项，一个是 kernel-lt（长期支持版），一个是 kernel-ml（主线最新版本），采用长期支持版本（kernel-lt），更加稳定一些。</p>
</blockquote>
<p>安装最新的长期支持版</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum --disablerepo=&quot;*&quot; --enablerepo=&quot;elrepo-kernel&quot; install kernel-lt kernel-lt-devel</span><br></pre></td></tr></table></figure>

<p>查看系统上可用的内核</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk -F\<span class="string">&#x27; &#x27;</span><span class="variable">$1</span>==<span class="string">&quot;menuentry &quot;</span> &#123;<span class="built_in">print</span> <span class="variable">$2</span>&#125;<span class="string">&#x27; /etc/grub2.cfg</span></span></span><br><span class="line">CentOS Linux (5.4.212-1.el7.elrepo.x86_64) 7 (Core)</span><br><span class="line">CentOS Linux (3.10.0-1062.9.1.el7.x86_64) 7 (Core)</span><br><span class="line">CentOS Linux (0-rescue-ed7b5ef29925468cbc59b47c142c26b8) 7 (Core)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="设置开机从新内核启动"><a href="#设置开机从新内核启动" class="headerlink" title="设置开机从新内核启动"></a>设置开机从新内核启动</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grub2-set-default 0</span><br></pre></td></tr></table></figure>

<h4 id="生成grub-配置文件"><a href="#生成grub-配置文件" class="headerlink" title="生成grub 配置文件"></a>生成grub 配置文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grub2-mkconfig -o /boot/grub2/grub.cfg</span></span><br><span class="line"></span><br><span class="line">Generating grub configuration file ...</span><br><span class="line">Found linux image: /boot/vmlinuz-5.4.212-1.el7.elrepo.x86_64</span><br><span class="line">Found initrd image: /boot/initramfs-5.4.212-1.el7.elrepo.x86_64.img</span><br><span class="line">Found linux image: /boot/vmlinuz-3.10.0-1062.9.1.el7.x86_64</span><br><span class="line">Found initrd image: /boot/initramfs-3.10.0-1062.9.1.el7.x86_64.img</span><br><span class="line">Found linux image: /boot/vmlinuz-0-rescue-ed7b5ef29925468cbc59b47c142c26b8</span><br><span class="line">Found initrd image: /boot/initramfs-0-rescue-ed7b5ef29925468cbc59b47c142c26b8.img</span><br><span class="line">done</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="重启系统并验证"><a href="#重启系统并验证" class="headerlink" title="重启系统并验证"></a>重启系统并验证</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">reboot</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者</span></span><br><span class="line">shutdown -r now</span><br></pre></td></tr></table></figure>
<p>重启后查看内核版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">uname</span> -r</span></span><br><span class="line">5.4.212-1.el7.elrepo.x86_64</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="查看系统中已安装的内核"><a href="#查看系统中已安装的内核" class="headerlink" title="查看系统中已安装的内核"></a>查看系统中已安装的内核</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rpm -qa | grep kernel</span></span><br><span class="line">kernel-lt-5.4.212-1.el7.elrepo.x86_64</span><br><span class="line">kernel-tools-libs-3.10.0-1062.9.1.el7.x86_64</span><br><span class="line">kernel-lt-devel-5.4.212-1.el7.elrepo.x86_64</span><br><span class="line">kernel-3.10.0-1062.9.1.el7.x86_64</span><br><span class="line">kernel-headers-3.10.0-1160.76.1.el7.x86_64</span><br><span class="line">kernel-tools-3.10.0-1062.9.1.el7.x86_64</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="删除旧内核，这一步是可选的"><a href="#删除旧内核，这一步是可选的" class="headerlink" title="删除旧内核，这一步是可选的"></a>删除旧内核，这一步是可选的</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum remove -y  kernel-devel-3.10.0   kernel-3.10.0  kernel-headers-3.10.0 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看已安装内核</span></span><br><span class="line">rpm -qa | grep kernel</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">也可以安装 yum-utils 工具，当系统安装的内核大于3个时，会自动删除旧的内核版本</span></span><br><span class="line">yum install -y  yum-utils</span><br></pre></td></tr></table></figure>

<h4 id="升级内核工具包"><a href="#升级内核工具包" class="headerlink" title="升级内核工具包"></a>升级内核工具包</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除旧版本工具包--可选</span></span><br><span class="line">yum remove kernel-tools-libs.x86_64 kernel-tools.x86_64</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装新版本工具包</span></span><br><span class="line">yum --disablerepo=&quot;*&quot; --enablerepo=elrepo-kernel install -y kernel-lt-tools.x86_64</span><br></pre></td></tr></table></figure>
<p>查看已安装内核</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ rpm -qa | grep kernel</span><br><span class="line"></span><br><span class="line">kernel-lt-5.4.212-1.el7.elrepo.x86_64</span><br><span class="line">kernel-lt-devel-5.4.212-1.el7.elrepo.x86_64</span><br><span class="line">kernel-lt-tools-libs-5.4.212-1.el7.elrepo.x86_64</span><br><span class="line">kernel-lt-tools-5.4.212-1.el7.elrepo.x86_64</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>内核升级完成后可再次重启系统进行验证</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.cnblogs.com/yanjieli/p/14839445.html">CentOS7 内核升级</a><br><a href="https://zhuanlan.zhihu.com/p/368879345">CentOS7 内核升级</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Centos</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos VNC server 配置</title>
    <url>/202208191637/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Centos 7</li>
</ul>
<p><code>VNC</code> 是一个图形桌面共享系统，可以通过远程连接的方式连接到服务器的图形系统以控制操作系统<br><code>VNC</code> 包括以下四个部分 ： <code>vncserver</code>，<code>vncviewer</code>，<code>vncpassword</code> 及 <code>vncconnect</code>。<br><code>VNC client</code> 端通过 <code>VNC</code> 协议远程连接到 <code>vnc server</code> 端，进行桌面共享及交互；  </p>
<h3 id="安装-tigervnc"><a href="#安装-tigervnc" class="headerlink" title="安装 tigervnc"></a>安装 tigervnc</h3><p>安装之前首先要确保系统已安装图形系统，本文以 <code>GNOME Desktop</code> 为图形桌面系统，执行以下命令检查是否已安装 <code>GNOME Desktop</code>，如果未安装，使用命令 <code>yum groupinstall &quot;GNOME Desktop&quot;</code> 安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum grouplist</span></span><br><span class="line">Loaded plugins: fastestmirror, langpacks</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line">Installed Environment Groups:</span><br><span class="line">   GNOME Desktop</span><br><span class="line">Available Environment Groups:</span><br><span class="line">   Minimal Install</span><br><span class="line">   Compute Node</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>桌面系统安装后，使用以下命令，安装 <code>tigervnc</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y tigervnc-server</span><br></pre></td></tr></table></figure>

<p>可以参考 <code>/lib/systemd/system/vncserver@.service</code> 中的指示，生成服务配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /lib/systemd/system/vncserver@.service /etc/systemd/system/vncserver@:1.service</span><br><span class="line">vim /etc/systemd/system/vncserver@\:1.service</span><br></pre></td></tr></table></figure>
<p>修改以下行，将其中的 <code>&lt;USER&gt;</code> 改为要远程登录的用户名，例如 <code>root</code></p>
<figure class="highlight shell"><figcaption><span>/etc/systemd/system/vncserver@\:1.service</span></figcaption><table><tr><td class="code"><pre><span class="line">ExecStart=/usr/bin/vncserver_wrapper root %i</span><br></pre></td></tr></table></figure>

<p>如果有多个用户需要远程连接，可以重复以上步骤，建立多个配置文件，如 <code>/etc/systemd/system/vncserver@:2.service</code>，各个服务之间互不影响，关闭一个服务，不影响其他的 <code>vnc</code> 服务 (如关闭： <code>vncserver@:2.service</code>，<code>vncserver@:1.service</code>的 <code>vnc</code> 远程依旧可以使用)  </p>
<p>修改服务文件后，使用以下命令重新加载服务启动脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure>

<p>启动服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start vncserver@:1.service</span><br></pre></td></tr></table></figure>
<p>服务启动后，会监听 5901 端口，如果有第二个服务，会监听在 5902 端口，以此类推，防火墙需要放通此端口<br><img src="https://i.csms.tech/img_41.png"></p>
<p>切换到需要 vnc 远程登录的用户，使用以下命令配置 <code>vnc</code> 远程登录用户的密码(只是 vnc 登录时使用的密码，非系统用户密码)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# su - USER</span><br><span class="line">[USER@localhost ~]$ vncpasswd</span><br></pre></td></tr></table></figure>
<p>设置 <code>vncpasswd</code> 密码后，在账号的家目录里就会自动建立 .vnc 文件，其中包括对应用户的 <code>vnc</code> 相关的日志</p>
<p>配置完成后，<a href="https://www.realvnc.com/en/connect/download/viewer/">下载客户端</a> 进行远程登录</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>tigervnc</tag>
      </tags>
  </entry>
  <entry>
    <title>Confluence 常用基本操作</title>
    <url>/202208250937/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Confluence 是一个专业的企业知识管理与协同软件，也可以用于构建企业 <a href="https://zh.m.wikipedia.org/zh/Wiki"><code>wiki</code></a>。通过它可以实现团队成员之间的协作和知识共享。在这里，团队成员齐心协力，各擅其能，协同地编写文档和管理项目。从此打破不同团队、不同部门以及个人之间信息孤岛的僵局，Confluence 真正实现了组织资源共享。Confluence 使用简单，但它强大的编辑和站点管理特征能够帮助团队成员之间共享信息、文档协作、集体讨论。</p>
<span id="more"></span>

<h3 id="根据标题生成文章目录"><a href="#根据标题生成文章目录" class="headerlink" title="根据标题生成文章目录"></a>根据标题生成文章目录</h3><p>在 confluence 中编写文章时，可以根据不同级别的 <code>标题</code> 对文章内容进行分层，如下图所示    </p>
<p><img src="https://i.csms.tech/img_44.png"></p>
<p>在此情况之下，可以根据文章中的标题，生成文章目录，在文章内容过长或过多的情况下，可以根据目录轻松快速的定位到需要的内容章节，操作过长如下：<br>编辑需要生成目录的文章，按照下图所示的位置选择 <code>插入目录宏</code>  </p>
<p><img src="https://i.csms.tech/img_45.png"></p>
<p>在弹出的 <code>编辑‘目录’宏</code> 页面中配置相关参数，配置完成后，点击 <code>保存</code>，将会在页面中生成文章目录<br><img src="https://i.csms.tech/img_46.png"><br><img src="https://i.csms.tech/img_47.png"></p>
<p>如果要在特点的地方显示文章目录，可以使用 <code>页面布局</code> 操作，比如选择 <code>页面布局</code> 中的 <code>包含侧边栏的两列节</code> 并将目录放置在右边的侧边栏，示例及效果如下图<br><img src="https://i.csms.tech/img_48.png"><br><img src="https://i.csms.tech/img_49.png"></p>
<h3 id="链接到文章内的锚点"><a href="#链接到文章内的锚点" class="headerlink" title="链接到文章内的锚点"></a>链接到文章内的锚点</h3><h4 id="创建锚点"><a href="#创建锚点" class="headerlink" title="创建锚点"></a>创建锚点</h4><p>在需要创建 <code>锚点</code> 的地方，选择 <code>插入 ‘锚’ 宏</code>，输入 <code>锚名称</code>，插入后产生对应 <code>锚点</code><br><img src="https://i.csms.tech/img_50.png"></p>
<h4 id="链接到同一文章内锚点"><a href="#链接到同一文章内锚点" class="headerlink" title="链接到同一文章内锚点"></a>链接到同一文章内锚点</h4><p>在需要链接 <code>锚点</code> 的地方，选择 <code>插入链接</code>，链接中 <code>锚点</code> 使用 <code>#锚点名称</code> 进行链接<br><img src="https://i.csms.tech/img_51.png"></p>
<h4 id="链接到其他文章内的锚点"><a href="#链接到其他文章内的锚点" class="headerlink" title="链接到其他文章内的锚点"></a>链接到其他文章内的锚点</h4><p><code>confluence</code> 的同一个空间内不允许存在同名的页面（文章），因此所有页面（文章）名具有独一性，当需要链接到其他页面中的锚点时，可以参照以下配置。比如要链接到页面 <code>cs</code> 中的 <code>test</code> 锚点，按照以下配置，在需要链接的地方插入链接<br><img src="https://i.csms.tech/img_52.png"></p>
<blockquote>
<p>这种方式下，锚点所在的页面改名，锚点依然生效，使用锚点的链接中页面名也会随之改变  </p>
</blockquote>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Confluence</tag>
      </tags>
  </entry>
  <entry>
    <title>Django admin 配置</title>
    <url>/202209021312/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Django 自带的 <code>Admin Site</code> 管理页面可以方便用户快速构建一个简单的后台管理系统，少量代码即可快速实现对数据库中的数据进行展示、修改、保存的可视化页面和功能。当需要对后台展示的数据进行配置时，只需要在 <code>app</code> 的代码文件 <code>admin.py</code> 中进行相应配置即可。</p>
<h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>centos 7</li>
<li>python 3.10</li>
<li>django 4.0</li>
</ul>
<h3 id="配置登录页面和-web-页面中显示的-title"><a href="#配置登录页面和-web-页面中显示的-title" class="headerlink" title="配置登录页面和 web 页面中显示的 title"></a>配置登录页面和 web 页面中显示的 title</h3><figure class="highlight shell"><figcaption><span>admin.py</span></figcaption><table><tr><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line"></span><br><span class="line">admin.site.site_header = &quot;My Admin Site&quot;</span><br><span class="line">admin.site.site_title = &quot;My Admin Site&quot;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_53.png"></p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>django 定时任务</title>
    <url>/202208170917/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>centos 7</li>
<li>python 3.10</li>
<li>django 4.0</li>
<li>django-crontab</li>
</ul>
<p><code>django-crontab</code> 依赖 <code>Linux</code> 系统中的 <code>crontab</code>，因此只能在 <code>Linux</code> 系统中使用</p>
<span id="more"></span>

<h3 id="安装-django-crontab"><a href="#安装-django-crontab" class="headerlink" title="安装 django-crontab"></a>安装 django-crontab</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install django-crontab</span><br></pre></td></tr></table></figure>

<p><code>django-crontab</code> 插件是以 <code>app</code> 的方式存在， 将 <code>django-crontab</code> 添加到 <code>django</code> 工程配置文件 <code>settings.py</code> 中的 <code>INSTALLED_APPS</code></p>
<figure class="highlight shell"><figcaption><span>settings.py</span></figcaption><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    &#x27;django.contrib.admin&#x27;,</span><br><span class="line">    &#x27;django.contrib.auth&#x27;,</span><br><span class="line">    &#x27;django.contrib.contenttypes&#x27;,</span><br><span class="line">    &#x27;django.contrib.sessions&#x27;,</span><br><span class="line">    &#x27;django.contrib.messages&#x27;,</span><br><span class="line">    &#x27;django.contrib.staticfiles&#x27;,</span><br><span class="line">    ...</span><br><span class="line">    &#x27;django_crontab&#x27;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="配置定时任务"><a href="#配置定时任务" class="headerlink" title="配置定时任务"></a>配置定时任务</h3><p>假设定时任务路径为 <code>myapp.cron.scheduled_job</code><br>编写好定时任务后，要启用定时任务，需要在 <code>django</code> 工程配置文件 <code>settings.py</code> 中配置以下内容</p>
<figure class="highlight shell"><figcaption><span>settings.py</span></figcaption><table><tr><td class="code"><pre><span class="line">CRONJOBS = [</span><br><span class="line">    (&#x27;* * * * *&#x27;, &#x27;myapp.cron.scheduled_job&#x27;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>如果定时任务需要参数，可以使用如下格式</p>
<figure class="highlight shell"><figcaption><span>settings.py</span></figcaption><table><tr><td class="code"><pre><span class="line">CRONJOBS = [</span><br><span class="line">    (&#x27;* * * * *&#x27;, &#x27;myapp.cron.scheduled_job&#x27;, &#x27;&gt;&gt; run.log 2&gt;&amp;1&#x27;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>以上定时任务，会将任务执行过程中的标准输出和标准错误输出写入到文件 <code>run.log</code></p>
<p>也可以使用列表参数</p>
<figure class="highlight shell"><figcaption><span>settings.py</span></figcaption><table><tr><td class="code"><pre><span class="line">CRONJOBS = [</span><br><span class="line">    (&#x27;* * * * *&#x27;, &#x27;myapp.cron.scheduled_job&#x27;, [&#x27;list_args1&#x27;, &#x27;list_args2&#x27;], &#123;&#x27;dict_args1&#x27;: v1, &#x27;dict_args2&#x27;: v2&#125;),</span><br><span class="line">    (&#x27;* * * * *&#x27;, &#x27;myapp.cron.scheduled_job&#x27;, [&#x27;list_args1&#x27;])</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>其中，定时任务的第一部分（<code>* * * * *</code>），语法和 <code>Linux</code> 系统 <code>crontab</code> 一致，具体语法可参考： <a href="https://www.runoob.com/linux/linux-comm-crontab.html">linux crontab 语法</a></p>
<p>配置好定时任务之后，执行以下命令添加定时任务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 manage.py crontab add</span><br></pre></td></tr></table></figure>


<p>运行定时任务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 manage.py crontab run </span><br></pre></td></tr></table></figure>
<p>运行定时任务后，会在系统 <code>crontab</code> 中追加一个定时任务，可使用 <code>crontab -l</code> 命令查看定时任务  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">crontab -l</span></span><br><span class="line">* * * * * python3 /django/project/manage.py crontab run b4564bdabd9dcb16a9b69d79a612430f &gt;&gt; run.log 2&gt;&amp;1   # django-cronjobs for project</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>显示定时任务列表</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 manage.py crontab show</span><br></pre></td></tr></table></figure>
<p>删除定时任务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 manage.py crontab remove b4564bdabd9dc</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意事项</strong>： <code>CRONJOBS</code> 中配置的定时任务及所有参数不能有变量值，比如以下配置，在第二天时，不会再执行。</p>
<figure class="highlight shell"><figcaption><span>settings.py</span></figcaption><table><tr><td class="code"><pre><span class="line">CRONJOBS = [</span><br><span class="line">(&#x27;0 7 * * *&#x27;, &#x27;myapp.cron.scheduled_job&#x27;, &#x27;&gt;&gt; %s&#x27; time.time())</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>因为，<code>CRONJOBS</code> 生成任务时，会生成对应的哈希值（hashes），标识每个任务。所以，当文件名变更时，<code>CRONJOBS</code> 中的值每天都在变化，导致不同的定时任务哈希值（hashes）。而系统 <code>crontab</code> 定时任务中的任务哈希值还是第一次执行 <code>python3 manage.py crontab add</code> 时的值</p>
</blockquote>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://cloud.tencent.com/developer/article/1599968">django 定时任务 django-crontab 的使用</a><br><a href="https://www.runoob.com/linux/linux-comm-crontab.html">Linux crontab 命令</a></p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>django logging 模块</title>
    <url>/202208151622/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>python 3.10</li>
<li>django 4.0</li>
</ul>
<h3 id="Python-logging-模块说明"><a href="#Python-logging-模块说明" class="headerlink" title="Python logging 模块说明"></a>Python logging 模块说明</h3><p><code>Django</code> 使用 <code>Python</code> 内置的 <code>logging</code> 模块处理系统日志，一份 <code>Python logging</code> 配置由下面四个部分组成：</p>
<ul>
<li>Loggers</li>
<li>Handlers</li>
<li>Filters</li>
<li>Formatters</li>
</ul>
<h4 id="Loggers"><a href="#Loggers" class="headerlink" title="Loggers"></a>Loggers</h4><p><code>logger</code> 是日志系统的入口。每个 <code>logger</code> 都是命名了的 <code>bucket</code>， 消息写入 <code>bucket</code> 以便进一步处理<br><code>logger</code> 可以配置 <code>日志级别</code>。日志级别描述了由该 <code>logger</code> 处理的消息的严重性。<code>Python</code> 定义了下面几种日志级别：</p>
<ul>
<li><code>DEBUG</code>：排查故障时使用的低级别系统信息</li>
<li><code>INFO</code>：一般的系统信息</li>
<li><code>WARNING</code>：描述系统发生了一些小问题的信息</li>
<li><code>ERROR</code>：描述系统发生了大问题的信息</li>
<li><code>CRITICAL</code>：描述系统发生严重问题的信息</li>
</ul>
<p>每一条写入 <code>logger</code> 的消息都是一条 <code>日志记录</code>。每一条日志记录也包含 <code>日志级别</code>，代表对应消息的严重程度。日志记录还包含有用的元数据，来描述被记录了日志的事件细节，例如堆栈跟踪或者错误码。  </p>
<p>当 <code>logger</code> 处理一条消息时，会将自己的 <code>日志级别</code> 和这条消息的 <code>日志级别</code> 做对比。如果消息的日志级别匹配或者高于 <code>logger</code> 的日志级别，它就会被进一步处理。否则这条消息就会被忽略掉。  </p>
<p>当 <code>logger</code> 确定了一条消息需要处理之后，会把它传给 <code>Handler</code>。</p>
<span id="more"></span>

<h4 id="Handlers"><a href="#Handlers" class="headerlink" title="Handlers"></a>Handlers</h4><p><code>Handler</code> 是决定如何处理 <code>logger</code> 中每一条消息的引擎。它描述特定的日志行为，比如把消息输出到<code>屏幕(stdout)</code>、<code>文件</code>或<code>网络 socket</code>。<br>和 <code>logger</code> 一样，<code>handler</code> 也有 <code>日志级别</code> 的概念。如果一条日志记录的级别不匹配或者低于 <code>handler</code> 的日志级别，对应的消息会被 <code>handler</code> 忽略。</p>
<p>一个 <code>logger</code> 可以有多个 <code>handler</code>，每一个 <code>handler</code> 可以有不同的日志级别。这样就可以根据消息的重要性不同，来提供不同格式的输出。例如，你可以添加一个 <code>handler</code> 把 <code>ERROR</code> 和 <code>CRITICAL</code> 消息发送短消息，再添加另一个 <code>handler</code> 把所有的消息（包括 <code>ERROR</code> 和 <code>CRITICAL</code> 消息）保存到文件里以便日后分析。</p>
<h4 id="Filters"><a href="#Filters" class="headerlink" title="Filters"></a>Filters</h4><p>在日志记录从 <code>logger</code> 传到 <code>handler</code> 的过程中，使用 <code>Filter</code> 来做额外的控制。<br>默认情况下，只要级别匹配，任何日志消息都会被处理。不过，也可以通过添加 <code>filter</code> 来给日志处理的过程增加额外条件。例如，可以添加一个 <code>filter</code> 只允许某个特定来源的 <code>ERROR</code> 消息输出。  </p>
<p><code>Filter</code> 还被用来在日志输出之前对日志记录做修改。例如，可以写一个 <code>filter</code>，当满足一定条件时，把日志记录从 <code>ERROR</code> 降到 <code>WARNING</code> 级别。  </p>
<p><code>Filter</code> 在 <code>logger</code> 和 <code>handler</code> 中都可以添加；多个 <code>filter</code> 可以链接起来使用，来做多重过滤操作。</p>
<h4 id="Formatters"><a href="#Formatters" class="headerlink" title="Formatters"></a>Formatters</h4><p>日志记录最终是需要以文本来呈现的。<code>Formatter</code> 描述了文本的格式。一个 <code>formatter</code> 通常由包含 <a href="https://docs.python.org/3/library/logging.html#logrecord-attributes"><code>LogRecord attributes</code></a> 的 <code>Python 格式化字符串</code> 组成，不过你也可以为特定的格式来配置自定义的 formatter。</p>
<h3 id="Python-logging-模块使用方式介绍"><a href="#Python-logging-模块使用方式介绍" class="headerlink" title="Python logging 模块使用方式介绍"></a>Python logging 模块使用方式介绍</h3><p><code>logging</code> 模块提供了两种记录日志的方式：</p>
<ul>
<li>第一种方式是使用 <code>logging</code> 提供的模块级别的方法</li>
<li>第二种方式是使用 <code>Logging</code> 日志系统的四大组件</li>
</ul>
<h4 id="logging-模块级别方法使用说明"><a href="#logging-模块级别方法使用说明" class="headerlink" title="logging 模块级别方法使用说明"></a>logging 模块级别方法使用说明</h4><p><code>logging</code> 提供的模块级别常用方法有：  </p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>logging.basicConfig(**kwargs)</code></td>
<td>对 <code>root logger</code> 进行一次性配置</td>
<td></td>
</tr>
<tr>
<td><code>logging.debug(msg, args, *kwargs)</code></td>
<td>记录级别为 <code>DEBUG</code> 的日志</td>
<td><code>logging.debug(&#39;debug msg&#39;)</code></td>
</tr>
<tr>
<td><code>logging.info(msg, args, *kwargs)</code></td>
<td>记录级别为 <code>INFO</code> 的日志</td>
<td></td>
</tr>
<tr>
<td><code>logging.warning(msg, args, *kwargs)	</code></td>
<td>记录级别为 <code>WARNING</code> 的日志</td>
<td></td>
</tr>
<tr>
<td><code>logging.error(msg, args, *kwargs)	</code></td>
<td>记录级别为 <code>ERROR</code> 的日志</td>
<td></td>
</tr>
<tr>
<td><code>logging.critical(msg, args, *kwargs)	</code></td>
<td>记录级别为 <code>CRITICAL</code> 的日志</td>
<td></td>
</tr>
<tr>
<td><code>logging.log(level, args, *kwargs)	</code></td>
<td>记录级别为 <code>level</code> 的日志</td>
<td><code>logging.log(logging.DEBUG, &#39;debug msg&#39;)</code></td>
</tr>
</tbody></table>
<h5 id="logging-basicConfig-方法说明"><a href="#logging-basicConfig-方法说明" class="headerlink" title="logging.basicConfig() 方法说明"></a>logging.basicConfig() 方法说明</h5><p>该方法用于为 <code>logging</code> 日志系统做一些基本配置，<code>logging.basicConfig()</code> 函数是一个一次性的简单配置工具使，也就是说只有在第一次调用该函数时会起作用，后续再次调用该函数时完全不会产生任何操作的，多次调用的设置并不是累加操作。方法定义如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">logging.basicConfig(**kwargs)</span><br></pre></td></tr></table></figure>

<p>该方法可接收的关键字参数如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>filename</code></td>
<td>写入日志的文件名</td>
</tr>
<tr>
<td><code>filemode</code></td>
<td>打开日志文件的模式，默认为 <code>a</code>，该选项在 <code>filename</code> 指定时才生效</td>
</tr>
<tr>
<td><code>format</code></td>
<td>日志格式字符串, 指定日志输出时所包含的字段信息以及它们的顺序</td>
</tr>
<tr>
<td><code>datefmt</code></td>
<td>指定日期&#x2F;时间格式。该选项要在 <code>format</code> 中包含时间字段 <code>%(asctime)s</code> 时才有效</td>
</tr>
<tr>
<td><code>level</code></td>
<td>指定日志级别</td>
</tr>
<tr>
<td><code>stream</code></td>
<td>指定日志输出目标 stream，如 <code>sys.stdout</code>、<code>sys.stderr</code>以及 <code>网络stream</code>。需要说明的是，<code>stream</code> 和 <code>filename </code>不能同时提供，否则会引发 <code>ValueError</code> 异常</td>
</tr>
<tr>
<td><code>style</code></td>
<td><code>Python 3.2</code> 中新添加的配置项。指定 <code>format</code> 格式字符串的风格，可取值为 <code>%</code>、<code>&#123;</code> 和 <code>$</code>，默认为 <code>%</code></td>
</tr>
<tr>
<td><code>handlers</code></td>
<td><code>Python 3.3</code> 中新添加的配置项。该选项如果被指定，它应该是一个创建了多个 <code>Handler</code> 的可迭代对象，这些 <code>handler</code> 将会被添加到 <code>root logger</code> 。需要说明的是：<code>filename</code>、s<code>tream</code> 和 <code>handlers</code> 这三个配置项只能有一个存在，不能同时出现2个或3个，否则会引发 <code>ValueError</code> 异常。</td>
</tr>
</tbody></table>
<p><code>logging</code> 模块中定义好的可以用于 <code>format</code> 日志格式字符串的字段主要有  </p>
<table>
<thead>
<tr>
<th>字段名称</th>
<th>使用格式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>asctime</code></td>
<td><code>%(asctime)s</code></td>
<td>日志事件发生的时间(可读时间)，如：2003-07-08 16:49:45,896</td>
</tr>
<tr>
<td><code>created</code></td>
<td><code>%(created)f	</code></td>
<td>日志事件发生的时间(时间戳)</td>
</tr>
<tr>
<td><code>levelname</code></td>
<td><code>%(levelname)s</code></td>
<td>日志级别</td>
</tr>
<tr>
<td><code>levelno</code></td>
<td><code>%(levelno)s	</code></td>
<td>日志记录的数字形式的日志级别（10, 20, 30, 40, 50）</td>
</tr>
<tr>
<td><code>name</code></td>
<td><code>%(name)s	</code></td>
<td>所使用的日志器名称，默认是 <code>root</code>，因为默认使用的是 <code>rootLogger</code></td>
</tr>
<tr>
<td><code>message</code></td>
<td><code>%(message)s	</code></td>
<td>日志记录的文本内容</td>
</tr>
<tr>
<td><code>pathname</code></td>
<td><code>%(pathname)s	</code></td>
<td>调用日志记录方法的源码文件的全路径</td>
</tr>
<tr>
<td><code>filename</code></td>
<td><code>%(filename)s	</code></td>
<td><code>pathname</code> 的文件名部分，包含文件后缀</td>
</tr>
<tr>
<td><code>module</code></td>
<td><code>%(module)s	</code></td>
<td>filename的名称部分，不包含后缀</td>
</tr>
<tr>
<td><code>lineno</code></td>
<td><code>%(lineno)d	</code></td>
<td>调用日志记录方法的源代码所在的行号</td>
</tr>
<tr>
<td><code>funcName</code></td>
<td><code>%(funcName)s	</code></td>
<td>调用日志记录方法的函数名</td>
</tr>
<tr>
<td><code>process</code></td>
<td><code>%(process)d	</code></td>
<td>进程ID</td>
</tr>
<tr>
<td><code>processName</code></td>
<td><code>%(processName)s	</code></td>
<td>进程名称，Python 3.1新增</td>
</tr>
<tr>
<td><code>thread</code></td>
<td><code>%(thread)d	</code></td>
<td>线程ID</td>
</tr>
<tr>
<td><code>threadName</code></td>
<td><code>%(thread)s	</code></td>
<td>线程名称</td>
</tr>
</tbody></table>
<h5 id="logging-模块级别方法中的-kwargs-参数说明"><a href="#logging-模块级别方法中的-kwargs-参数说明" class="headerlink" title="logging 模块级别方法中的 kwargs 参数说明"></a>logging 模块级别方法中的 kwargs 参数说明</h5><p><code>logging.debug()</code>, <code>logging.info()</code> 等方法的定义中，除了 <code>msg</code> 和 <code>args</code> 参数外，还有一个 <code>**kwargs</code> 参数。它们支持3个关键字参数: <code>exc_info</code>, <code>stack_info</code>, <code>extra</code></p>
<ul>
<li><code>exc_info</code> : 布尔值，如果该参数的值设置为 <code>True</code>，则会将异常异常信息添加到日志消息中。如果没有异常信息则添加 <code>None</code> 到日志信息中。</li>
<li><code>stack_info</code> : 布尔值，默认值为 <code>False</code>。如果该参数的值设置为 <code>True</code>，栈信息将会被添加到日志信息中。</li>
<li><code>extra</code> : 这是一个字典（<code>dict</code>）参数，它可以用来自定义消息格式中所包含的字段，但是它的 <code>key</code> 不能与 <code>logging</code> 模块定义的字段冲突</li>
</ul>
<p><code>exc_info</code> 使用示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="number">1</span> / <span class="number">0</span></span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span>:</span><br><span class="line"><span class="meta">... </span>    logging.error(<span class="string">&#x27;except occor&#x27;</span>, exc_info=<span class="literal">True</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">ERROR:root:<span class="keyword">except</span> occor</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ZeroDivisionError: division by zero</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>stack_info</code> 使用示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="number">1</span> / <span class="number">0</span></span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span>:</span><br><span class="line"><span class="meta">... </span>    logging.error(<span class="string">&#x27;except&#x27;</span>, stack_info=<span class="literal">True</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">ERROR:root:<span class="keyword">except</span></span><br><span class="line">Stack (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">4</span>, <span class="keyword">in</span> &lt;module&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Django-配置-logging"><a href="#Django-配置-logging" class="headerlink" title="Django 配置 logging"></a>Django 配置 logging</h3><p>在 <code>Django</code> 配置文件( <code>settings.py</code> ) 中添加以下配置  </p>
<figure class="highlight django"><figcaption><span>settings.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="language-xml">LOGGING = &#123;</span></span><br><span class="line"><span class="language-xml">    &#x27;version&#x27;: 1,</span></span><br><span class="line"><span class="language-xml">    &#x27;disable_existing_loggers&#x27;: False,</span></span><br><span class="line"><span class="language-xml">    &#x27;formatters&#x27;: &#123;</span></span><br><span class="line"><span class="language-xml">        &#x27;verbose&#x27;: &#123;</span></span><br><span class="line"><span class="language-xml">            &#x27;format&#x27;: &#x27;[%(asctime)s][%(levelname)s][%(pathname)s %(module)s %(lineno)s %(process)d %(thread)d] %(message)s&#x27;</span></span><br><span class="line"><span class="language-xml">        &#125;</span></span><br><span class="line"><span class="language-xml">    &#125;,</span></span><br><span class="line"><span class="language-xml">    &#x27;handlers&#x27;: &#123;</span></span><br><span class="line"><span class="language-xml">        &#x27;file&#x27;: &#123;</span></span><br><span class="line"><span class="language-xml">            &#x27;level&#x27;: &#x27;INFO&#x27;,</span></span><br><span class="line"><span class="language-xml">            &#x27;class&#x27;: &#x27;logging.handlers.RotatingFileHandler&#x27;,</span></span><br><span class="line"><span class="language-xml">            &#x27;filename&#x27;: &#x27;default.log&#x27;,</span></span><br><span class="line"><span class="language-xml">            &#x27;maxBytes&#x27;: 1024 * 1024 * 5,</span></span><br><span class="line"><span class="language-xml">            &#x27;backupCount&#x27;: 5,</span></span><br><span class="line"><span class="language-xml">            &#x27;formatter&#x27;: &#x27;verbose&#x27;,</span></span><br><span class="line"><span class="language-xml">        &#125;,</span></span><br><span class="line"><span class="language-xml">        &#x27;console&#x27;: &#123;</span></span><br><span class="line"><span class="language-xml">            &#x27;class&#x27;: &#x27;logging.StreamHandler&#x27;,</span></span><br><span class="line"><span class="language-xml">            &#x27;formatter&#x27;: &#x27;verbose&#x27;,</span></span><br><span class="line"><span class="language-xml">        &#125;,</span></span><br><span class="line"><span class="language-xml">        &#x27;django.server&#x27;: &#123;</span></span><br><span class="line"><span class="language-xml">            &#x27;level&#x27;: &#x27;INFO&#x27;,</span></span><br><span class="line"><span class="language-xml">            &#x27;class&#x27;: &#x27;logging.StreamHandler&#x27;,</span></span><br><span class="line"><span class="language-xml">            &#x27;formatter&#x27;: &#x27;verbose&#x27;,</span></span><br><span class="line"><span class="language-xml">        &#125;,</span></span><br><span class="line"><span class="language-xml">    &#125;,</span></span><br><span class="line"><span class="language-xml">    &#x27;loggers&#x27;: &#123;</span></span><br><span class="line"><span class="language-xml">        &#x27;django&#x27;: &#123;</span></span><br><span class="line"><span class="language-xml">            &#x27;handlers&#x27;: [&#x27;console&#x27;, &#x27;file&#x27;],</span></span><br><span class="line"><span class="language-xml">            &#x27;level&#x27;: &#x27;INFO&#x27;,</span></span><br><span class="line"><span class="language-xml">        &#125;,</span></span><br><span class="line"><span class="language-xml">        &#x27;django.server&#x27;: &#123;</span></span><br><span class="line"><span class="language-xml">            &#x27;handlers&#x27;: [&#x27;django.server&#x27;],</span></span><br><span class="line"><span class="language-xml">            &#x27;level&#x27;: &#x27;INFO&#x27;,</span></span><br><span class="line"><span class="language-xml">            &#x27;propagate&#x27;: False,</span></span><br><span class="line"><span class="language-xml">        &#125;,</span></span><br><span class="line"><span class="language-xml">    &#125;</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br></pre></td></tr></table></figure>

<p>代码中可以通过以下方式写入日志到对应 <code>logger</code>:  </p>
<figure class="highlight python"><figcaption><span>views.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logger = logging.getLogger(`django.server`)</span><br><span class="line">logger.info(<span class="string">&#x27;aaa&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p> <code>loggers</code> 类型 为 <code>django</code> 将处理所有类型的日志</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://docs.djangoproject.com/zh-hans/4.0/topics/logging/">django logging 模块官网说明</a></p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>docker 容器中安装常见工具</title>
    <url>/202209051507/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="常用工具安装"><a href="#常用工具安装" class="headerlink" title="常用工具安装"></a>常用工具安装</h3><p>查找 netstat 命令由哪个安装包提供</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum whatprovides /bin/netstat</span></span><br><span class="line">net-tools-2.0-0.25.20131004git.el7.x86_64 : Basic networking tools</span><br><span class="line">Repo        : base</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : /bin/netstat</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>安装 net-tools</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y net-tools</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install -y net-tools</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>安装 <code>ping</code> 命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum whatprovides /bin/ping</span></span><br><span class="line">iputils-20160308-10.el7.x86_64 : Network monitoring tools including ping</span><br><span class="line">Repo        : base</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : /bin/ping</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">apt-cache search iputils</span></span><br><span class="line">iputils-arping - Tool to send ICMP echo requests to an ARP address</span><br><span class="line">iputils-clockdiff - Measure the time difference between networked computers</span><br><span class="line">iputils-ping - Tools to test the reachability of network hosts</span><br><span class="line">iputils-tracepath - Tools to trace the network path to a remote host</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install -y iputils-ping</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker compose 命令</title>
    <url>/202208311004/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>对于 <code>Compose</code> 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。  </p>
<p>执行 <code>docker compose [COMMAND] --help</code>  可以查看具体某个命令的使用格式。  </p>
<p><code>docker compose</code> 命令的基本的使用格式是  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...]</span><br></pre></td></tr></table></figure>
<p>常用选项  </p>
<ul>
<li><code>-f, --file FILE</code>  指定使用的 Compose 模板文件，默认为 <code>docker-compose.yml</code>，可以多次指定。  </li>
<li><code>-p, --project-name NAME</code> 指定项目名称，默认将使用所在目录名称作为项目名。</li>
</ul>
<span id="more"></span>

<h3 id="build"><a href="#build" class="headerlink" title="build"></a>build</h3><p>格式为 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker compose build [options] [SERVICE...]</span><br></pre></td></tr></table></figure>
<p>构建（重新构建）项目中的服务容器。  </p>
<p>服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db。<br>可以随时在项目目录下运行 <code>docker compose build</code> 来重新构建服务。<br>常用选项包括：</p>
<ul>
<li><code>--no-cache</code>  构建镜像过程中不使用 cache（这将加长构建过程）。</li>
<li><code>--pull</code>  始终尝试通过 <code>pull</code> 来获取更新版本的镜像。</li>
<li><code>-q, --quiet</code>  不输出任何内容到 STDOUT</li>
</ul>
<h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker compose config</span><br></pre></td></tr></table></figure>
<p>验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因。</p>
<h3 id="up"><a href="#up" class="headerlink" title="up"></a>up</h3><p>格式为 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker compose up [options] [SERVICE...]</span><br></pre></td></tr></table></figure>
<p>该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。  </p>
<p>链接的服务都将会被自动启动，除非已经处于运行状态。</p>
<p>可以说，大部分时候都可以直接通过该命令来启动一个项目。</p>
<p>默认情况，<code>docker compose up</code> 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。</p>
<p>当通过 <code>Ctrl-C</code> 停止命令时，所有容器将会停止。</p>
<p>如果使用 <code>docker compose up -d</code>，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。</p>
<p>默认情况，如果服务容器已经存在，<code>docker compose up</code> 将会尝试停止容器，然后重新创建（保持使用 volumes-from 挂载的卷），以保证新启动的服务匹配 <code>docker-compose.yml</code> 文件的最新内容。如果用户不希望容器被停止并重新创建，可以使用 <code>docker compose up --no-recreate</code>。这样将只会启动处于停止状态的容器，而忽略已经运行的服务。如果用户只想重新部署某个服务，可以使用 <code>docker compose up --no-deps -d &lt;SERVICE_NAME&gt;</code> 来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。</p>
<p>常用选项说明：  </p>
<ul>
<li><code>-d, --detach</code> 在后台运行服务容器</li>
<li><code>--no-color</code> 不使用颜色来区分不同的服务的控制台输出</li>
<li><code>--no-deps</code> 不启动服务所链接的容器。</li>
<li><code>--force-recreate</code> 强制重新创建容器，不能与 <code>--no-recreate</code> 同时使用</li>
<li><code>--no-recreate</code> 如果容器已经存在了，则不重新创建，不能与 <code>--force-recreate</code> 同时使用。</li>
<li><code>--no-build</code> 不自动构建缺失的服务镜像</li>
<li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）时间。</li>
<li><code>--no-start</code> 创建服务但是不启动服务</li>
<li><code>--build</code>  启动容器之前，重新构建容器</li>
</ul>
<h3 id="down"><a href="#down" class="headerlink" title="down"></a>down</h3><p>此命令将会停止 <code>up</code> 命令所启动的容器，并移除网络</p>
<h3 id="start"><a href="#start" class="headerlink" title="start"></a>start</h3><p>启动已经存在的服务容器。</p>
<h3 id="pause"><a href="#pause" class="headerlink" title="pause"></a>pause</h3><p>暂停一个服务容器。</p>
<h3 id="unpause"><a href="#unpause" class="headerlink" title="unpause"></a>unpause</h3><p>恢复处于暂停状态中的服务。</p>
<h3 id="restart"><a href="#restart" class="headerlink" title="restart"></a>restart</h3><p>重启项目中的服务。</p>
<h3 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h3><p>停止已经处于运行状态的容器，但不删除它。通过 <code>docker compose start</code> 可以再次启动这些容器。</p>
<h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>列出项目中目前的所有容器。</p>
<h3 id="port"><a href="#port" class="headerlink" title="port"></a>port</h3><p>格式为 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker compose port [options] SERVICE PRIVATE_PORT</span><br></pre></td></tr></table></figure>
<p>打印某个容器端口所映射的公共端口  </p>
<p>常用选项  </p>
<ul>
<li><code>--protocol=proto</code> 指定端口协议，tcp（默认值）或者 udp。</li>
<li><code>--index=index</code> 如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1）</li>
</ul>
<h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><p>进入指定的容器。</p>
<h3 id="images"><a href="#images" class="headerlink" title="images"></a>images</h3><p>列出 Compose 文件中包含的镜像。</p>
<h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>格式为 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker compose kill [options] [SERVICE...]</span><br></pre></td></tr></table></figure>
<p>通过发送 SIGKILL 信号来强制停止服务容器。</p>
<p>支持通过 <code>-s</code> 参数来指定发送的信号，例如通过如下指令发送 SIGINT 信号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker compose kill -s SIGINT</span><br></pre></td></tr></table></figure>

<h3 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h3><p>格式为 </p>
<pre><code>docker compose logs [options] [SERVICE...]
</code></pre>
<p>查看服务容器的输出。默认情况下，<code>docker compose</code> 将对不同的服务输出使用不同的颜色来区分。可以通过 <code>--no-color</code> 来关闭颜色。<br>该命令在调试问题的时候十分有用。</p>
<h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>查看各个服务容器内运行的进程。</p>
<h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p>删除所有（停止状态的）服务容器。推荐先执行 <code>docker compose stop</code> 命令来停止容器。<br>选项：</p>
<ul>
<li><code>-f, --force</code> 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。</li>
<li><code>-v</code> 删除容器所挂载的数据卷。</li>
</ul>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://yeasy.gitbook.io/docker_practice/compose/commands">docker compose 命令说明</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker compose 简介</title>
    <url>/202208301738/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><code>Compose</code> 项目是 <code>Docker</code> 官方的开源项目，负责实现对 <code>Docker 容器集群</code> 的快速编排。</p>
<p><code>Compose</code> 定位是 <strong>「定义和运行多个 <code>Docker</code> 容器的应用（Defining and running multi-container Docker applications）」</strong>，其前身是开源项目 <code>Fig</code>。</p>
<p>使用一个 <a href="/202208050928/" title="Dockerfile">Dockerfile</a> 模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。  </p>
<p><code>Compose</code> 恰好满足了这样的需求。它允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件（<code>YAML</code> 格式）来定义一组相关联的应用容器为一个项目（<code>project</code>）。<br><code>Compose</code> 中有两个重要的概念：</p>
<ul>
<li><code>服务 (service)</code> ： 一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。  </li>
<li><code>项目 (project)</code> ： 由一组关联的应用容器组成的一个完整业务单元，在 <code>docker-compose.yml</code> 文件中定义。</li>
</ul>
<p><code>Compose</code> 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。<br><code>Compose</code> 项目由 <code>Python</code> 编写，实现上调用了 <code>Docker</code> 服务提供的 <code>API</code> 来对容器进行管理。因此，只要所操作的平台支持 <code>Docker API</code>，就可以在其上利用 <code>Compose</code> 来进行编排管理。</p>
<span id="more"></span>
<h3 id="Compose-v2"><a href="#Compose-v2" class="headerlink" title="Compose v2"></a>Compose v2</h3><p>目前 <code>Docker</code> 官方用 <code>GO 语言</code> 重写 了 <code>Docker Compose</code>，并将其作为了 <code>docker cli</code> 的子命令，称为 <code>Compose V2</code>。你可以参照官方文档安装，然后将熟悉的 <code>docker-compose</code> 命令替换为 <a href="/202208311004/" title="docker compose">docker compose</a>，即可使用 <code>Docker Compose</code>。</p>
<h3 id="Compose-模板文件"><a href="#Compose-模板文件" class="headerlink" title="Compose 模板文件"></a>Compose 模板文件</h3><p>模板文件是使用 Compose 的核心，里面大部分指令跟 <code>docker run</code> 相关参数的含义类似。  </p>
<p>默认的模板文件名称为 <code>docker-compose.yml</code>，格式为 YAML 格式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  webapp:</span><br><span class="line">    image: examples/web</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:80&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;/data&quot;</span><br></pre></td></tr></table></figure>

<p>每个服务都必须通过 <code>image</code> 指令指定镜像或 <code>build</code> 指令（需要 <a href="/202208050928/" title="Dockerfile">Dockerfile</a>）等来自动构建生成镜像。  </p>
<p>如果使用 <code>build</code> 指令，在 <code>Dockerfile</code> 中设置的选项(例如：<code>CMD</code>, <code>EXPOSE</code>, <code>VOLUME</code>, <code>ENV</code> 等) 将会自动被获取，无需在 <code>docker-compose.yml</code> 中重复设置。</p>
<p>下面分别介绍各个指令的用法。</p>
<h3 id="docker-compose-yml-中的常用指令"><a href="#docker-compose-yml-中的常用指令" class="headerlink" title="docker-compose.yml 中的常用指令"></a>docker-compose.yml 中的常用指令</h3><h4 id="build"><a href="#build" class="headerlink" title="build"></a>build</h4><p>指定 <code>Dockerfile</code> 所在文件夹的路径（可以是绝对路径，或者相对 <code>docker-compose.yml</code> 文件的路径）。 Compose 将会利用它自动构建这个镜像，然后使用这个镜像。  </p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  webapp:</span><br><span class="line">    build: ./dir</span><br></pre></td></tr></table></figure>
<p>也可以使用 <code>context</code> 指令指定 <code>Dockerfile</code> 所在文件夹的路径。<br>使用 <code>dockerfile</code> 指令指定 <code>Dockerfile</code> 文件名。<br>使用 <code>arg</code> 指令指定构建镜像时的变量。  </p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  webapp:</span><br><span class="line">    build:</span><br><span class="line">      context: ./dir</span><br><span class="line">      dockerfile: Dockerfile-alternate</span><br><span class="line">      args:</span><br><span class="line">        buildno: 1</span><br></pre></td></tr></table></figure>

<h4 id="image"><a href="#image" class="headerlink" title="image"></a>image</h4><p>指定为镜像名称或镜像 ID。如果镜像在本地不存在，Compose 将会尝试拉取这个镜像。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">image: ubuntu</span><br><span class="line">image: orchardup/postgresql</span><br><span class="line">image: a4bc65fd</span><br></pre></td></tr></table></figure>

<h4 id="command"><a href="#command" class="headerlink" title="command"></a>command</h4><p>覆盖容器启动后默认执行的命令  </p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">command: echo &quot;hello world&quot;</span><br></pre></td></tr></table></figure>

<h4 id="entrypoint"><a href="#entrypoint" class="headerlink" title="entrypoint"></a>entrypoint</h4><p>指定服务容器启动后执行的入口文件。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">entrypoint: /code/entrypoint.sh</span><br></pre></td></tr></table></figure>

<h4 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a>container_name</h4><p>指定容器名称。默认将会使用 项目名称_服务名称_序号 这样的格式。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">container_name: docker-web-container</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。</strong></p>
</blockquote>
<h4 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a>depends_on</h4><p>解决容器的依赖、启动先后的问题。以下例子中会先启动 redis db 再启动 web  </p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">      - redis</span><br><span class="line"></span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line"></span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：web 服务不会等待 redis db 「完全启动」之后才启动。</p>
</blockquote>
<h4 id="dns"><a href="#dns" class="headerlink" title="dns"></a>dns</h4><p>自定义 DNS 服务器。可以是一个值，也可以是一个列表。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">dns: 8.8.8.8</span><br><span class="line"></span><br><span class="line">dns:</span><br><span class="line">  - 8.8.8.8</span><br><span class="line">  - 114.114.114.114</span><br></pre></td></tr></table></figure>

<h4 id="dns-search"><a href="#dns-search" class="headerlink" title="dns_search"></a>dns_search</h4><p>配置 DNS 搜索域。可以是一个值，也可以是一个列表。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">dns_search: example.com</span><br><span class="line"></span><br><span class="line">dns_search:</span><br><span class="line">  - domain1.example.com</span><br><span class="line">  - domain2.example.com</span><br></pre></td></tr></table></figure>

<h4 id="extra-hosts"><a href="#extra-hosts" class="headerlink" title="extra_hosts"></a>extra_hosts</h4><p>类似 Docker 中的 <code>--add-host</code> 参数，指定额外的 host 名称映射信息。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">extra_hosts:</span><br><span class="line"> - &quot;googledns:8.8.8.8&quot;</span><br><span class="line"> - &quot;dockerhub:52.1.157.61&quot;</span><br></pre></td></tr></table></figure>
<p>会在启动后的服务容器中 <code>/etc/hosts</code> 文件中添加如下两条条目</p>
<figure class="highlight shell"><figcaption><span>/etc/hosts</span></figcaption><table><tr><td class="code"><pre><span class="line">8.8.8.8 googledns</span><br><span class="line">52.1.157.61 dockerhub</span><br></pre></td></tr></table></figure>

<h4 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h4><p>设置环境变量。可以使用数组或字典两种格式  </p>
<p>只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。  </p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">environment:</span><br><span class="line">  RACK_ENV: development</span><br><span class="line">  SESSION_SECRET:</span><br><span class="line"></span><br><span class="line">environment:</span><br><span class="line">  - RACK_ENV=development</span><br><span class="line">  - SESSION_SECRET</span><br></pre></td></tr></table></figure>

<p>如果变量名称或者值中用到 <code>true</code>|<code>false</code>，<code>yes</code>|<code>no</code> 等表达 布尔 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF</span><br></pre></td></tr></table></figure>

<h4 id="env-file"><a href="#env-file" class="headerlink" title="env_file"></a>env_file</h4><p>从文件中获取环境变量，可以为单独的文件路径或列表。  </p>
<p>如果通过 <code>docker compose -f FILE</code> 方式来指定 Compose 模板文件，则 <code>env_file</code> 中变量的路径会基于模板文件路径。<br>如果有变量名称与 <a href="#environment"><code>environment</code></a> 指令冲突，则按照惯例，以后者为准。  </p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">env_file: .env</span><br><span class="line"></span><br><span class="line">env_file:</span><br><span class="line">  - ./common.env</span><br><span class="line">  - ./apps/web.env</span><br><span class="line">  - /opt/secrets.env</span><br></pre></td></tr></table></figure>
<p>环境变量文件中每一行必须符合格式，支持 # 开头的注释行。</p>
<figure class="highlight shell"><figcaption><span>.env</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">common.env: Set development environment</span></span><br><span class="line">PROG_ENV=development</span><br></pre></td></tr></table></figure>

<h4 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h4><p>暴露端口，但不映射到宿主机，只被连接的服务访问。<br>仅可以指定内部端口为参数</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">expose:</span><br><span class="line"> - &quot;3000&quot;</span><br><span class="line"> - &quot;8000&quot;</span><br></pre></td></tr></table></figure>

<h4 id="healthcheck"><a href="#healthcheck" class="headerlink" title="healthcheck"></a>healthcheck</h4><p>通过命令检查容器是否健康运行</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">healthcheck:</span><br><span class="line">  test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost&quot;]</span><br><span class="line">  interval: 1m30s</span><br><span class="line">  timeout: 10s</span><br><span class="line">  retries: 3</span><br></pre></td></tr></table></figure>

<h4 id="labels"><a href="#labels" class="headerlink" title="labels"></a>labels</h4><p>为容器添加 Docker 元数据（metadata）信息。例如可以为容器添加辅助说明信息。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">labels:</span><br><span class="line">  com.startupteam.description: &quot;webapp for a startup team&quot;</span><br><span class="line">  com.startupteam.department: &quot;devops department&quot;</span><br><span class="line">  com.startupteam.release: &quot;rc3 for v1.0&quot;</span><br></pre></td></tr></table></figure>

<h4 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h4><p>配置日志选项。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">logging:</span><br><span class="line">  driver: syslog</span><br><span class="line">  options:</span><br><span class="line">    syslog-address: &quot;tcp://192.168.0.42:123&quot;</span><br></pre></td></tr></table></figure>
<p>目前支持三种日志驱动类型。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">driver: &quot;json-file&quot;</span><br><span class="line">driver: &quot;syslog&quot;</span><br><span class="line">driver: &quot;none&quot;</span><br></pre></td></tr></table></figure>
<p>options 配置日志驱动的相关参数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">options:</span><br><span class="line">  max-size: &quot;200k&quot;</span><br><span class="line">  max-file: &quot;10&quot;</span><br></pre></td></tr></table></figure>

<h4 id="networks"><a href="#networks" class="headerlink" title="networks"></a>networks</h4><p>配置容器连接的网络。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  some-service:</span><br><span class="line">    networks:</span><br><span class="line">     - some-network</span><br><span class="line">     - other-network</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  some-network:</span><br><span class="line">  other-network:</span><br></pre></td></tr></table></figure>

<h4 id="ports"><a href="#ports" class="headerlink" title="ports"></a>ports</h4><p>暴露端口信息。<br>使用 <code>宿主端口：容器端口 (HOST:CONTAINER)</code> 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">ports:</span><br><span class="line"> - &quot;3000&quot;</span><br><span class="line"> - &quot;8000:8000&quot;</span><br><span class="line"> - &quot;49100:22&quot;</span><br><span class="line"> - &quot;127.0.0.1:8001:8001&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当使用 <code>HOST:CONTAINER</code> 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 YAML 会自动解析 <code>xx:yy</code> 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。</p>
</blockquote>
<h4 id="sysctls"><a href="#sysctls" class="headerlink" title="sysctls"></a>sysctls</h4><p>配置容器内核参数。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">sysctls:</span><br><span class="line">  net.core.somaxconn: 1024</span><br><span class="line">  net.ipv4.tcp_syncookies: 0</span><br><span class="line"></span><br><span class="line">sysctls:</span><br><span class="line">  - net.core.somaxconn=1024</span><br><span class="line">  - net.ipv4.tcp_syncookies=0</span><br></pre></td></tr></table></figure>

<h4 id="ulimits"><a href="#ulimits" class="headerlink" title="ulimits"></a>ulimits</h4><p>指定容器的 ulimits 限制值。<br>例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">ulimits:</span><br><span class="line">  nproc: 65535</span><br><span class="line">  nofile:</span><br><span class="line">    soft: 20000</span><br><span class="line">    hard: 40000</span><br></pre></td></tr></table></figure>

<h4 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a>volumes</h4><p>数据卷所挂载路径设置。可以设置为宿主机路径 (<code>HOST:CONTAINER</code>) 或者数据卷名称( <code>VOLUME:CONTAINER</code> )，并且可以设置访问模式 （ <code>HOST:CONTAINER:ro</code> ）。<br>该指令中路径支持相对路径。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">volumes:</span><br><span class="line"> - /var/lib/mysql</span><br><span class="line"> - cache/:/tmp/cache</span><br><span class="line"> - ~/configs:/etc/configs/:ro</span><br></pre></td></tr></table></figure>
<p>如果路径为数据卷名称，必须在文件中配置数据卷。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  my_src:</span><br><span class="line">    image: mysql:8.0</span><br><span class="line">    volumes:</span><br><span class="line">      - mysql_data:/var/lib/mysql</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  mysql_data:  </span><br></pre></td></tr></table></figure>

<h4 id="user"><a href="#user" class="headerlink" title="user"></a>user</h4><p>指定容器中运行应用的用户名。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">user: nginx</span><br></pre></td></tr></table></figure>
<h4 id="hostname"><a href="#hostname" class="headerlink" title="hostname"></a>hostname</h4><p>指定容器中主机名</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">hostname: test</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="working-dir"><a href="#working-dir" class="headerlink" title="working_dir"></a>working_dir</h4><p>指定容器中工作目录。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">working_dir: /code</span><br></pre></td></tr></table></figure>

<h4 id="restart"><a href="#restart" class="headerlink" title="restart"></a>restart</h4><p>指定容器退出后的重启策略为始终重启。该命令对保持服务始终运行十分有效，在生产环境中推荐配置为 <code>always</code> 或者 <code>unless-stopped</code>。  </p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">restart: always</span><br></pre></td></tr></table></figure>

<h4 id="read-only"><a href="#read-only" class="headerlink" title="read_only"></a>read_only</h4><p>以只读模式挂载容器的 root 文件系统，意味着不能对容器内容进行修改。</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">read_only: true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="读取变量"><a href="#读取变量" class="headerlink" title="读取变量"></a>读取变量</h3><p>Compose 模板文件支持动态读取主机的系统环境变量和当前目录下的 <code>.env</code> 文件中的变量。  </p>
<p>例如，下面的 Compose 文件将从运行它的环境中读取变量 ${MONGO_VERSION} 的值，并写入执行的指令中。 </p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">db:</span><br><span class="line">  image: &quot;mongo:$&#123;MONGO_VERSION&#125;&quot;</span><br></pre></td></tr></table></figure>

<p>如果执行 <code>MONGO_VERSION=3.2 ; docker compose up</code> 则会启动一个 <code>mongo:3.2</code> 镜像的容器；<br>如果执行 <code>MONGO_VERSION=2.8 ; docker compose up</code> 则会启动一个 <code>mongo:2.8</code> 镜像的容器  </p>
<p>若当前目录存在 <code>.env</code> 文件，执行 <code>docker compose</code> 命令时将从该文件中读取变量。  </p>
<p>在当前目录新建 <code>.env</code> 文件并写入以下内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 支持 # 号注释</span><br><span class="line">MONGO_VERSION=3.6</span><br></pre></td></tr></table></figure>
<p>执行 <code>docker compose up</code> 则会启动一个 <code>mongo:3.6</code> 镜像的容器。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://docs.docker.com/compose/">Compose V2 beta</a><br><a href="https://yeasy.gitbook.io/docker_practice/compose/v2">Docker 从入门到实践</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker compose 配置 django mysql 站点</title>
    <url>/202209051137/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文主要记录使用 <code>docker compose</code> 配置 Django + Mysql 的 web 站点的过程。</p>
<h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Centos7</li>
<li>Docker version 20.10.17</li>
</ul>
<h3 id="目录结构及说明"><a href="#目录结构及说明" class="headerlink" title="目录结构及说明"></a>目录结构及说明</h3><p>项目目录结构及简要说明如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── compose</span><br><span class="line">│   └── mysql</span><br><span class="line">│       └── my.cnf</span><br><span class="line">├── django_project</span><br><span class="line">│   ├── db.sqlite3</span><br><span class="line">│   ├── django_app</span><br><span class="line">│   │   ├── admin.py</span><br><span class="line">│   │   ├── apps.py</span><br><span class="line">│   │   ├── __init__.py</span><br><span class="line">│   │   ├── migrations</span><br><span class="line">│   │   ├── models.py</span><br><span class="line">│   │   ├── tests.py</span><br><span class="line">│   │   └── views.py</span><br><span class="line">│   ├── django_project</span><br><span class="line">│   │   ├── asgi.py</span><br><span class="line">│   │   ├── __init__.py</span><br><span class="line">│   │   ├── __pycache__</span><br><span class="line">│   │   ├── settings.py</span><br><span class="line">│   │   ├── urls.py</span><br><span class="line">│   │   └── wsgi.py</span><br><span class="line">│   ├── Dockerfile</span><br><span class="line">│   ├── manage.py</span><br><span class="line">│   └── requirements.txt</span><br><span class="line">├── docker-compose.yml</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><code>compose</code> : 存放应用配置文件，如 mysql 配置文件 <code>compose/mysql/my.cnf</code></li>
<li><code>django_project</code> : Django project 项目目录， <code>django-admin startproject django_project</code> 生成</li>
<li><code>django_project/django_app</code> : Django project 项目下的 app 目录，<code>django-admin startapp django_app</code> 生成</li>
<li><code>docker-compose.yml</code> : 项目的 compose 文件</li>
</ul>
<span id="more"></span>

<h3 id="编写-django-运行镜像的-Dockerfile"><a href="#编写-django-运行镜像的-Dockerfile" class="headerlink" title="编写 django 运行镜像的 Dockerfile"></a>编写 django 运行镜像的 Dockerfile</h3><p>编写构建 django 镜像的 Dockerfile，文件位置 <code>django_project/Dockerfile</code></p>
<figure class="highlight shell"><figcaption><span>django_project/Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line">FROM python:3.10</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将上下文环境中(django_project/)的 requirements.txt 拷贝到镜像的 /code 目录</span></span><br><span class="line">COPY requirements.txt /code/</span><br><span class="line"></span><br><span class="line">WORKDIR /code/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 python 项目依赖</span></span><br><span class="line">RUN pip install -r requirements.txt &amp;&amp; rm -rf requirements.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解决 django 无法加载 MySQLdb 模块的问题</span></span><br><span class="line">RUN echo &quot;import pymysql&quot; &gt; /usr/local/lib/python3.10/site-packages/django/db/backends/mysql/__init__.py &amp;&amp; \</span><br><span class="line">    echo &quot;pymysql.install_as_MySQLdb()&quot; &gt;&gt; /usr/local/lib/python3.10/site-packages/django/db/backends/mysql/__init__.py</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装常用工具，方便容器启动后的调试</span></span><br><span class="line">RUN apt-get update &amp;&amp; apt install -y netcat &amp;&amp; apt install -y vim \</span><br><span class="line">    apt-get install -y iputils-ping \</span><br><span class="line">    apt-get install -y net-tools</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">健康检查，环境变量 <span class="variable">$&#123;DJANGO_SERVER_PORT&#125;</span> 来自 docker-compose.yml 文件</span></span><br><span class="line">HEALTHCHECK CMD curl -fs http://localhost:$&#123;DJANGO_SERVER_PORT&#125;/ || exit 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>构建镜像时，只将构建镜像所需的文件（<code>requirements.txt</code>）拷贝进镜像，使用完成后删除，容器运行时需要的代码文件，通过 <code>docker-compose.yml</code> 中的 <code>volumes</code> 命令进行挂载，这样更新代码时，只需要在宿主机上面更新代码，不用再对镜像进行变更，只有需要更新运行环境时才需要更新镜像  </p>
<p>django 镜像构建文件的 <code>Dockerfile</code> 中先不写 <code>CMD</code> 或者 <code>ENTRYPOINT</code> 启动 web 服务器，因为数据库还没启动，配置 <code>CMD</code> 启动 django 服务会报错（无法连接数据库）</p>
<p>修改 django 工程配置文件 <code>django_project/django_project/settings.py</code>，提前配置好 mysql 配置：</p>
<figure class="highlight shell"><figcaption><span>django_project/django_project/settings.py</span></figcaption><table><tr><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    &#x27;default&#x27;: &#123;</span><br><span class="line">        &#x27;ENGINE&#x27;: &#x27;django.db.backends.mysql&#x27;,</span><br><span class="line">        # 此处 &#x27;HOST&#x27; 配置的主机地址，要和 docker-compose.yml 中配置的 mysql 服务名称一致</span><br><span class="line">        &#x27;HOST&#x27;: &quot;db&quot;,</span><br><span class="line">        &#x27;NAME&#x27;: &quot;ops&quot;,</span><br><span class="line">        &#x27;USER&#x27;: &quot;root&quot;,</span><br><span class="line">        &quot;PASSWORD&quot;: &quot;123456&quot;,</span><br><span class="line">        &quot;PORT&quot;: &#x27;3306&#x27;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编写项目的-docker-compose-yml"><a href="#编写项目的-docker-compose-yml" class="headerlink" title="编写项目的 docker-compose.yml"></a>编写项目的 docker-compose.yml</h3><p>项目的 <code>docker-compose.yml</code> 文件内容及说明如下</p>
<figure class="highlight shell"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  mysql_data_vol:   # mysql datadir 需要挂载的数据卷</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  django_network:    # 本项目使用的 network ，方便项目中的服务容器之间互相通信，直接使用服务名</span><br><span class="line">    </span><br><span class="line">services:</span><br><span class="line">  db:   #  mysql 服务名</span><br><span class="line">    image: mysql:5.7</span><br><span class="line">    env_file:</span><br><span class="line">      - .env   # 服务要加载的环境变量文件，路径为相对于 docker-compose.yml 的路径</span><br><span class="line">    networks:</span><br><span class="line">      - django_network</span><br><span class="line">    volumes:</span><br><span class="line">      - mysql_data_vol:/var/lib/mysql:rw</span><br><span class="line">      - ./compose/mysql/my.cnf:/etc/my.cnf</span><br><span class="line"></span><br><span class="line">    ports:</span><br><span class="line">        - &quot;3307:3306&quot;</span><br><span class="line">    restart: always</span><br><span class="line"></span><br><span class="line">  django_server:</span><br><span class="line">    build: ./django_project/      # 使用 ./django_project/Dockerfile 构建镜像</span><br><span class="line">    env_file:</span><br><span class="line">      - .env  # 加载环境变量，其中的变量可以在 docker-compose.yml 和 Dockerfile 中使用</span><br><span class="line">    # command ： 容器要运行的命令</span><br><span class="line">    command: python manage.py runserver 0.0.0.0:$&#123;DJANGO_SERVER_PORT&#125;</span><br><span class="line">    networks:</span><br><span class="line">      - django_network</span><br><span class="line">    ports:</span><br><span class="line">      - &#x27;$&#123;DJANGO_SERVER_PORT&#125;:$&#123;DJANGO_SERVER_PORT&#125;&#x27;</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">    restart: always</span><br></pre></td></tr></table></figure>

<p>其中使用的 <code>.env</code> 文件内容如下：</p>
<figure class="highlight shell"><figcaption><span>.env</span></figcaption><table><tr><td class="code"><pre><span class="line">MYSQL_ROOT_PASSWORD=123456</span><br><span class="line"></span><br><span class="line">DJANGO_SERVER_PORT=8081</span><br></pre></td></tr></table></figure>

<h3 id="启动-docker-compose-项目"><a href="#启动-docker-compose-项目" class="headerlink" title="启动 docker compose 项目"></a>启动 docker compose 项目</h3><p>使用 <code>docker compose build</code> 之前，可以先检查一下配置，确保配置无误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker compose config</span></span><br><span class="line">name: dockerproject</span><br><span class="line">services:</span><br><span class="line">  db:</span><br><span class="line">    environment:</span><br><span class="line">      DJANGO_SERVER_PORT: &quot;8081&quot;</span><br><span class="line">      MYSQL_ROOT_PASSWORD: 123456</span><br><span class="line">    image: mysql:5.7</span><br><span class="line">    networks:</span><br><span class="line">      django_network: null</span><br><span class="line">    ports:</span><br><span class="line">    - mode: ingress</span><br><span class="line">      target: 3306</span><br><span class="line">      published: &quot;3307&quot;</span><br><span class="line">      protocol: tcp</span><br><span class="line">    restart: always</span><br><span class="line">    volumes:</span><br><span class="line">    - type: volume</span><br><span class="line">      source: mysql_data_vol</span><br><span class="line">      target: /var/lib/mysql</span><br><span class="line">      volume: &#123;&#125;</span><br><span class="line">    - type: bind</span><br><span class="line">      source: /root/dockerProject/compose/mysql/my.cnf</span><br><span class="line">      target: /etc/my.cnf</span><br><span class="line">      bind:</span><br><span class="line">        create_host_path: true</span><br><span class="line">  django_server:</span><br><span class="line">    build:</span><br><span class="line">      context: /root/dockerProject/django_project</span><br><span class="line">      dockerfile: Dockerfile</span><br><span class="line">    command:</span><br><span class="line">    - python</span><br><span class="line">    - manage.py</span><br><span class="line">    - runserver</span><br><span class="line">    - 0.0.0.0:8081</span><br><span class="line">    depends_on:</span><br><span class="line">      db:</span><br><span class="line">        condition: service_started</span><br><span class="line">    environment:</span><br><span class="line">      DJANGO_SERVER_PORT: &quot;8081&quot;</span><br><span class="line">      MYSQL_ROOT_PASSWORD: 123456</span><br><span class="line">    networks:</span><br><span class="line">      django_network: null</span><br><span class="line">    ports:</span><br><span class="line">    - mode: ingress</span><br><span class="line">      target: 8081</span><br><span class="line">      published: &quot;8081&quot;</span><br><span class="line">      protocol: tcp</span><br><span class="line">    restart: always</span><br><span class="line">networks:</span><br><span class="line">  django_network:</span><br><span class="line">    name: dockerproject_django_network</span><br><span class="line">volumes:</span><br><span class="line">  mysql_data_vol:</span><br><span class="line">    name: dockerproject_mysql_data_vol</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>配置无误，<code>docker compose config</code> 命令会输出配置，有错误会显示错误，<a href="/202208311004/" title="docker compose 其他常用命令参考">docker compose 其他常用命令参考</a></p>
<p>使用 <code>docker compose build</code> 命令构建镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker compose build</span></span><br><span class="line">[+] Building 0.1s (11/11) FINISHED                                                                                   </span><br><span class="line"> =&gt; [internal] load build definition from Dockerfile                                                            0.0s</span><br><span class="line"> =&gt; =&gt; transferring dockerfile: 32B                                                                             0.0s</span><br><span class="line"> =&gt; [internal] load .dockerignore                                                                               0.0s</span><br><span class="line"> =&gt; =&gt; transferring context: 2B                                                                                 0.0s</span><br><span class="line"> =&gt; [internal] load metadata for docker.io/library/python:3.10                                                  0.0s</span><br><span class="line"> =&gt; [internal] load build context                                                                               0.0s</span><br><span class="line"> =&gt; =&gt; transferring context: 982B                                                                               0.0s</span><br><span class="line"> =&gt; [1/6] FROM docker.io/library/python:3.10                                                                    0.0s</span><br><span class="line"> =&gt; CACHED [2/6] COPY . /code                                                                                   0.0s</span><br><span class="line"> =&gt; CACHED [3/6] WORKDIR /code                                                                                  0.0s</span><br><span class="line"> =&gt; CACHED [4/6] RUN pip install -r requirements.txt                                                            0.0s</span><br><span class="line"> =&gt; CACHED [5/6] RUN echo &quot;import pymysql&quot; &gt; /usr/local/lib/python3.10/site-packages/django/db/backends/mysql/  0.0s</span><br><span class="line"> =&gt; CACHED [6/6] RUN apt-get update &amp;&amp; apt install -y netcat &amp;&amp; apt install -y vim                              0.0s</span><br><span class="line"> =&gt; exporting to image                                                                                          0.0s</span><br><span class="line"> =&gt; =&gt; exporting layers                                                                                         0.0s</span><br><span class="line"> =&gt; =&gt; writing image sha256:9da868de3de9538931f9d60a7fd40d6197c332f4aadc03c8b8ca8446df7cee23                    0.0s</span><br><span class="line"> =&gt; =&gt; naming to docker.io/library/dockerproject_django_server                                                  0.0s</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也可以直接使用 <code>docker compose up</code>（会先构建镜像，然后启动项目中的所有服务）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker compose up</span></span><br><span class="line">[+] Running 3/2</span><br><span class="line"> ⠿ Network dockerproject_django_network     Created                                                             0.1s</span><br><span class="line"> ⠿ Container dockerproject-db-1             Created                                                             0.0s</span><br><span class="line"> ⠿ Container dockerproject-django_server-1  Created                                                             0.0s</span><br><span class="line">Attaching to dockerproject-db-1, dockerproject-django_server-1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看 compose 项目的状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker compose <span class="built_in">ls</span></span></span><br><span class="line">NAME                STATUS              CONFIG FILES</span><br><span class="line">dockerproject       running(2)          /root/dockerProject/docker-compose.yml</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看 compose 项目中的容器情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker compose ps</span></span><br><span class="line">NAME                            COMMAND                  SERVICE             STATUS              PORTS</span><br><span class="line">dockerproject-db-1              &quot;docker-entrypoint.s…&quot;   db                  running             0.0.0.0:3307-&gt;3306/tcp, :::3307-&gt;3306/tcp</span><br><span class="line">dockerproject-django_server-1   &quot;python manage.py ru…&quot;   django_server       running (healthy)   0.0.0.0:8081-&gt;8081/tcp, :::8081-&gt;8081/tcp</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看 compose 项目中的镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker compose images</span></span><br><span class="line">Container                       Repository                    Tag                 Image Id            Size</span><br><span class="line">dockerproject-db-1              mysql                         5.7                 daff57b7d2d1        430MB</span><br><span class="line">dockerproject-django_server-1   dockerproject_django_server   latest              9da868de3de9        1.02GB</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://csms.tech/categories/Docker/">docker compose 说明</a><br><a href="https://csms.tech/202208311004/">docker compose 常用命令</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>compose</tag>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>docker 安装及常用命令介绍</title>
    <url>/202208041317/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Centos 7.9.2009</li>
<li>docker-ce-19.03.15</li>
</ul>
<h3 id="docker-yum-安装"><a href="#docker-yum-安装" class="headerlink" title="docker yum 安装"></a>docker yum 安装</h3><p>安装 yum 源，<a href="https://docs.docker.com/engine/install/centos/">docker官方 centos 安装文档</a>  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils</span><br><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<p>安装 <code>docker</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure>

<h3 id="docker-离线安装"><a href="#docker-离线安装" class="headerlink" title="docker 离线安装"></a>docker 离线安装</h3><p><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a>下载rpm安装包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-ce-19.03.15-3.el7.x86_64.rpm</span><br><span class="line">wget https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-ce-cli-19.03.15-3.el7.x86_64.rpm</span><br><span class="line">wget https://download.docker.com/linux/centos/7/x86_64/stable/Packages/containerd.io-1.4.13-3.1.el7.x86_64.rpm</span><br><span class="line">wget https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-compose-plugin-2.3.3-3.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>
<p>安装 docker</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum localinstall -y containerd.io-1.4.13-3.1.el7.x86_64.rpm \</span><br><span class="line">                    docker-ce-cli-19.03.15-3.el7.x86_64.rpm \</span><br><span class="line">                    docker-ce-19.03.15-3.el7.x86_64.rpm \</span><br><span class="line">                    docker-compose-plugin-2.3.3-3.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>

<p>以上 2 条命令可以使用以下 1 条命令完成</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum localinstall -y https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-ce-19.03.15-3.el7.x86_64.rpm \</span><br><span class="line">                    https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-ce-cli-19.03.15-3.el7.x86_64.rpm \</span><br><span class="line">                    https://download.docker.com/linux/centos/7/x86_64/stable/Packages/containerd.io-1.4.13-3.1.el7.x86_64.rpm \</span><br><span class="line">                    https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-compose-plugin-2.3.3-3.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>

<p>启动docker</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="docker-镜像管理命令"><a href="#docker-镜像管理命令" class="headerlink" title="docker 镜像管理命令"></a>docker 镜像管理命令</h3><h4 id="获取（下载）镜像"><a href="#获取（下载）镜像" class="headerlink" title="获取（下载）镜像"></a>获取（下载）镜像</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span><br><span class="line">docker pull centos:centos7.9.2009</span><br></pre></td></tr></table></figure>
<blockquote>
<p>未指定地址，默认是从 <a href="https://hub.docker.com/search?q=&type=image">Docker Hub</a> 上面获取镜像，<a href="https://yeasy.gitbook.io/docker_practice/image/pull">参考说明</a><br>标签信息可从 <a href="https://hub.docker.com/search?q=&type=image">Docker Hub</a> 上面查看</p>
</blockquote>
<h4 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h4><p><a href="#%E8%8E%B7%E5%8F%96%EF%BC%88%E4%B8%8B%E8%BD%BD%EF%BC%89%E9%95%9C%E5%83%8F">获取（下载）镜像</a>后，运行镜像并运行镜像中的<code>bash</code>命令进入对应容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it --rm centos:centos7.9.2009 bash</span><br><span class="line">cat /etc/os-release</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>

<p>进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。例如执行 <code>cat /etc/os-release</code>。容器中执行<code>exit</code>命令可以退出容器</p>
<p><img src="https://i.csms.tech/img_35.png"></p>
<p><code>docker run</code> 命令常用选项说明</p>
<style>
table th:nth-of-type(1){
width: 10%;
}
table th:nth-of-type(2){
width: 70%
;
}
table th:nth-of-type(3){
width: 20%;
}

</style>

<table>
<thead>
<tr>
<th align="left">选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-i</code></td>
<td>启用交互式操作</td>
<td></td>
</tr>
<tr>
<td align="left"><code>-t</code></td>
<td>开启终端（输入输出）</td>
<td></td>
</tr>
<tr>
<td align="left"><code>--rm</code></td>
<td>容器退出(<code>exit</code>)后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。</td>
<td></td>
</tr>
<tr>
<td align="left"><code>--name</code></td>
<td>给启动的容器命名</td>
<td><code>docker run -d --name &quot;centos7&quot; centos:centos7.9.2009 bash</code></td>
</tr>
<tr>
<td align="left"><code>-d</code></td>
<td>后台运行，启动后返回容器id，并进入后台运行，容器的输出可使用 <code>docker logs CONTAINER</code> 或 <code>docker container logs CONTAINER</code> 查看</td>
<td></td>
</tr>
<tr>
<td align="left"><code>--entrypoint</code></td>
<td>覆盖（替换）镜像中<a href="https://csms.tech/202208050928/#ENTRYPOINT-容器启动程序指令">默认的<code>ENTRYPOINT</code></a></td>
<td></td>
</tr>
</tbody></table>
<h4 id="列出已下载的镜像"><a href="#列出已下载的镜像" class="headerlink" title="列出已下载的镜像"></a>列出已下载的镜像</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker image <span class="built_in">ls</span></span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE  </span><br><span class="line">centos              centos7.9.2009      eeb6ee3f44bd        10 months ago       204MB</span><br></pre></td></tr></table></figure>



<p>列表包含了 <code>仓库名</code>、<code>标签</code>、<code>镜像 ID</code>、<code>创建时间</code> 以及 <code>所占用的空间</code>。  </p>
<blockquote>
<p><code>IMAGE ID</code> 是镜像的唯一标识，同一个镜像可以有多个标签</p>
</blockquote>
<h4 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker image rm centos:centos7.9.2009</span><br><span class="line"></span><br><span class="line">docker image rm eeb6ee3f44bd</span><br></pre></td></tr></table></figure>

<p>可以用镜像名(<code>&lt;仓库名&gt;:&lt;标签&gt;</code>) ，<code>镜像 ID</code> 删除镜像</p>
<p>也可以使用 <code>镜像摘要</code> 删除镜像<br>查看 <code>镜像摘要</code>  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker image <span class="built_in">ls</span> --digests</span></span><br><span class="line">REPOSITORY          TAG                 DIGEST                      IMAGE ID            CREATED             SIZE</span><br><span class="line">centos              centos7.9.2009      sha256:c73f515d06b0fa0...   eeb6ee3f44bd        10 months ago       204MB</span><br></pre></td></tr></table></figure>


<p>使用 <code>镜像摘要</code> 删除镜像<br>命令格式 <code>docker image rm REPOSITORY@DIGEST</code>  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker image <span class="built_in">rm</span> centos@sha256:c73f515d06b0fa0...</span></span><br><span class="line">Untagged: centos@sha256:c73f515d06b0fa07bb18d8202035e739a494ce760aa73129f60f4bf2bd22b407</span><br></pre></td></tr></table></figure>


<p>删除行为分为两类，一类是 <code>Untagged</code>，另一类是 <code>Deleted</code>。<br>因为一个镜像可以对应多个标签，当我们使用上面命令删除镜像的时候，实际上是在要求删除某个标签的镜像。<br>所以首先需要做的是将满足我们要求的所有镜像标签都取消，这就是我们看到的 <code>Untagged</code> 的信息 ,因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么 <code>Delete</code> 行为就不会发生。<br>所以并非所有的 <code>docker image rm</code> 都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。<br>当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。  </p>
<h3 id="doker-容器管理命令"><a href="#doker-容器管理命令" class="headerlink" title="doker 容器管理命令"></a>doker 容器管理命令</h3><h4 id="启动已终止的容器"><a href="#启动已终止的容器" class="headerlink" title="启动已终止的容器"></a>启动已终止的容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker container start CONTAINER</span><br><span class="line">docker container restart CONTAINER</span><br><span class="line">docker start CONTAINER</span><br></pre></td></tr></table></figure>

<h4 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker attach CONTAINER</span><br><span class="line">docker exec -it CONTAINER bash</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>docker attach</code> 进入容器，如果再从这个 <code>stdin</code> 中 <code>exit</code>，会导致容器的停止<br><code>docker exec</code> 进入容器，如果再从这个 <code>stdin</code> 中 <code>exit</code>，不会导致容器的停止，推荐进入容器使用 <code>docker exec -it CONTAINER bash</code>  </p>
</blockquote>
<h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker container rm CONTAINER</span><br></pre></td></tr></table></figure>

<p><code>docker container rm</code> 可以删除已终止的容器，要强制删除运行中的容器，可以使用选项 <code>-f</code>，Docker 会发送 SIGKILL 信号给容器。  </p>
<p>用 <code>docker container ls -a</code> 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker container prune</span><br></pre></td></tr></table></figure>

<h3 id="docker-数据管理命令"><a href="#docker-数据管理命令" class="headerlink" title="docker 数据管理命令"></a>docker 数据管理命令</h3><h4 id="容器数据卷管理命令"><a href="#容器数据卷管理命令" class="headerlink" title="容器数据卷管理命令"></a>容器数据卷管理命令</h4><p><code>数据卷</code> 的使用，类似于 Linux 下对目录或文件进行 <code>mount</code> ，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。</p>
<p>创建数据卷</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker volume create DOCKERVOLUME</span><br></pre></td></tr></table></figure>

<p>查看数据卷信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker volume <span class="built_in">ls</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker volume inspect DOCKERVOLUME</span></span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;CreatedAt&quot;: &quot;2022-08-10T15:03:13+08:00&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/DOCKERVOLUME/_data&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;DOCKERVOLUME&quot;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>删除不在使用的数据卷</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker volume rm DOCKERVOLUME</span><br></pre></td></tr></table></figure>

<p>挂载使用数据卷</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -it -v DOCKERVOLUME:/data/ --name centos7 centos:centos7</span><br><span class="line">docker run -d -it --mount source=DOCKERVOLUME,target=/data, --name centos7 centos:centos7</span><br></pre></td></tr></table></figure>

<h4 id="挂载宿主机目录-文件"><a href="#挂载宿主机目录-文件" class="headerlink" title="挂载宿主机目录(文件)"></a>挂载宿主机目录(文件)</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -it -v /data/:/data/ --name centos7 centos:centos7</span><br><span class="line">docker run -d -it --mount type=bind,source=/data/,target=/data --name centos7 centos:centos7</span><br></pre></td></tr></table></figure>

<p>本地目录的路径必须是绝对路径，以前使用 <code>-v</code> 参数时如果本地目录不存在 <code>Docker</code> 会自动为你创建一个文件夹，现在使用 <code>--mount</code> 参数时如果本地目录不存在，<code>Docker</code> 会报错。  </p>
<p>挂载权限默认为 <code>rw</code> ，可以通过增加 <code>readonly</code> 指定为 只读</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -it -v /data/:/data/:ro --name centos7 centos:centos7</span><br><span class="line">docker run -d -it --mount type=bind,source=/data/,target=/data,readonly --name centos7 centos:centos7</span><br></pre></td></tr></table></figure>

<blockquote>
<p>挂载本地宿主机目录(文件)，使用选项 <code>--mount</code> 时，需要指定 <code>type=bind</code>, 否则 docker 会将源目录当做 <code>数据卷</code> 处理，可能报以下错误：<br><code>docker: Error response from daemon: create /data/: &quot;/data/&quot; includes invalid characters for a local volume name, only &quot;[a-zA-Z0-9][a-zA-Z0-9_.-]&quot; are allowed. If you intended to pass a host directory, use absolute path.</code></p>
</blockquote>
<h3 id="docker-网络管理命令"><a href="#docker-网络管理命令" class="headerlink" title="docker 网络管理命令"></a>docker 网络管理命令</h3><p>使用 <code>docker run</code> 命令的 <code>-P</code> 选项，<code>Docker</code> 会随机映射一个宿主机端口到内部容器开放的网络端口(<code>Dockerfile</code> 中 <code>EXPOSE</code> 的端口)。  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d -P nginx:alpine</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker container <span class="built_in">ls</span> -l</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                   NAMES</span><br><span class="line">fae320d08268        nginx:alpine        &quot;/docker-entrypoint.…&quot;   24 seconds ago      Up 20 seconds       0.0.0.0:32768-&gt;80/tcp   bold_mcnulty</span><br></pre></td></tr></table></figure>

<p>使用 <code>docker run</code> 命令的 <code>-p</code> 选项，则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有</p>
<ul>
<li><code>hostPort:containerPort</code>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 80:80 nginx:alpine</span><br></pre></td></tr></table></figure>
这样会绑定到宿主机所有接口上的所有 ip 地址</li>
<li><code>ip:hostPort:containerPort</code>    <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 127.0.0.1:80:80 nginx:alpine</span><br></pre></td></tr></table></figure>
此种格式可以指定映射宿主机的一个特定地址（IP），比如 <code>localhost</code> 地址 <code>127.0.0.1</code></li>
<li><code>ip::containerPort</code>    <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 127.0.0.1::80 nginx:alpine</span><br></pre></td></tr></table></figure>
使用 <code>ip::containerPort</code> 会绑定宿主机指定 ip 的任意端口到容器的指定端口，本地宿主机会自动分配一个随机端口。</li>
</ul>
<p><code>-p</code> 选项可以多次使用来绑定多个端口  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">    -p 80:80 \</span><br><span class="line">    -p 443:443 \</span><br><span class="line">    nginx:alpine</span><br></pre></td></tr></table></figure>

<p>还可以使用 <code>udp</code> 标记来指定 <code>udp</code> 端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 127.0.0.1:80:80/udp nginx:alpine</span><br></pre></td></tr></table></figure>

<p>查看容器映射的端口信息可以使用以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker port c8a91c8fafba</span></span><br><span class="line">80/tcp -&gt; 0.0.0.0:81</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker port c8a91c8fafba 80</span></span><br><span class="line">0.0.0.0:81</span><br></pre></td></tr></table></figure>


<h3 id="docker-资源状态命令"><a href="#docker-资源状态命令" class="headerlink" title="docker 资源状态命令"></a>docker 资源状态命令</h3><h4 id="查看-docker-各项功能占用的系统磁盘大小"><a href="#查看-docker-各项功能占用的系统磁盘大小" class="headerlink" title="查看 docker 各项功能占用的系统磁盘大小"></a>查看 docker 各项功能占用的系统磁盘大小</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker system <span class="built_in">df</span></span></span><br><span class="line">TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE</span><br><span class="line">Images              1                   0                   203.9MB             203.9MB (100%)</span><br><span class="line">Containers          0                   0                   0B                  0B</span><br><span class="line">Local Volumes       0                   0                   0B                  0B</span><br><span class="line">Build Cache         0                   0                   0B                  0B</span><br></pre></td></tr></table></figure>



<p>结果中包含了 <code>镜像</code>、<code>容器</code>、<code>数据卷</code> 所占用的空间</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://docs.docker.com/engine/install/centos/">docker官方 centos 安装文档</a>  </p>
<p><a href="https://download.docker.com/linux/centos/">docker 官方 centos 版本下载地址</a></p>
<p><a href="https://mirrors.aliyun.com/docker-ce/linux/centos/7/x86_64/stable/Packages/">docker centos版本 阿里云下载地址</a>  </p>
<p><a href="https://yeasy.gitbook.io/docker_practice/introduction/what">什么是 Docker</a>  </p>
<p><a href="https://yeasy.gitbook.io/docker_practice/introduction/why">为什么要用 Docker</a></p>
<p><a href="https://yeasy.gitbook.io/docker_practice/">docker 从入门到实践</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker 网络</title>
    <url>/202208301536/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Centos 7.9.2009</li>
<li>docker-ce-19.03.15</li>
</ul>
<h3 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h3><p>为了使容器互联，新版本建议将容器加入自定义的<code> Docker 网络</code> 来连接多个容器，而不是使用 <code>--link</code> 参数。</p>
<p>从 Docker 1.10 版本开始，docker daemon 实现了一个内嵌的 DNS server，使容器可以直接通过容器名称通信。方法很简单，只要在创建容器时使用 <code>--name</code> 为容器命名即可。但是使用 Docker DNS 有个限制：只能在 user-defined 网络中使用。也就是说，默认的 bridge 网络是无法使用 DNS 的，所以我们就需要自定义网络。</p>
<p>先创建一个新的 <code>Docker 网络</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker network create -d bridge my-net</span><br></pre></td></tr></table></figure>
<p><code>-d</code> 参数指定 Docker 网络类型，可选 <code>bridge</code> <code>overlay</code>  </p>
<span id="more"></span>
<p>查看 <code>Docker network</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker network <span class="built_in">ls</span></span></span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">1c751b3a52b9   bridge    bridge    local</span><br><span class="line">f8d9861e5797   host      host      local</span><br><span class="line">2e19366fb323   my-net    bridge    local</span><br><span class="line">4c188c59ff20   none      null      local</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>新建容器并连接到刚刚新建的 <code>Docker network</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -it --name c1 --network my-net centos</span><br><span class="line">docker run -d -it --name c2 --network my-net centos</span><br></pre></td></tr></table></figure>
<p>以上命令运行了 2 个 <code>centos</code> 最新版本的容器，并连接到了刚刚创建的网络： <code>--network my-net </code><br>登录到容器 <code>c1</code>的终端，并 <code>ping</code> 容器 <code>c2</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">exec</span> -it c1 bash</span></span><br><span class="line">[root@e520d1c8e30b /]# ping c2</span><br><span class="line">PING c2 (172.18.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from c2.my-net (172.18.0.3): icmp_seq=1 ttl=64 time=0.115 ms</span><br><span class="line">64 bytes from c2.my-net (172.18.0.3): icmp_seq=2 ttl=64 time=0.071 ms</span><br><span class="line">^C</span><br><span class="line">--- c2 ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 1000ms</span><br><span class="line">rtt min/avg/max/mdev = 0.071/0.093/0.115/0.022 ms</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，容器 <code>c1</code> 可以直接使用容器名 <code>c2</code>，来识别容器 <code>c2</code>，同理，容器 <code>c2</code> 也可以使用同样的方式识别到容器 <code>c1</code>，连接到同一个 <code>Docker network</code> 的容器 <code>c1</code>, <code>c2</code> 可以互相连接<br>使用以下命令，可以查看 <code>Docker network</code> 的详细信息，包括 ip 网段，ip 分配信息等</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker network inspect my-net</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;my-net&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;2e19366fb32312235a3571192d1a19e6ebb7adc3e6e25c1f5e6007e8c3315f08&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2022-08-30T15:44:54.241420767+08:00&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;172.18.0.0/16&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.18.0.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;4b6b1159073d3b70312f2b7e5da8c4a36133a6c00c4746fe2c58d37e81a86b12&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;c2&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;0cbe15ff760040d20cd10a04ffed5f4398e1c3c2b597a86461758606ebdc919d&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:12:00:03&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.18.0.3/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;e520d1c8e30bf97ece44fae53840d13e801648ca02899a17416a75563d3a64f6&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;c1&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;214c7596e2610208402cfa55a225fa67c0dd02d4b585c62b43a9a6c42f360147&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:12:00:02&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.18.0.2/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果容器启动时使用了自定义的 <code>Docker network</code>，并且启动过程中挂载了宿主机的 <code>/etc/resolv.conf</code>，则容器启动后无法再使用容器名和其他容器互联，比如使用以下命令启动容器 <code>c3</code>，<code>c3</code> 无法使用容器名和 <code>c1</code>,<code>c2</code> 互联，但是<code>c1</code>,<code>c2</code> 可以使用容器名 <code>c3</code> 连接到容器 <code>c3</code>  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -ti --network my-net -v /etc/resolv.conf:/etc/resolv.conf --name c3 centos</span><br></pre></td></tr></table></figure>
<p>以上示例中，如果登录 <code>c1</code> 终端后，修改 <code>/etc/resolv.conf</code> 文件，再次使用 <code>c2</code> ，会无法连接 <code>c2</code> 容器  </p>
</blockquote>
<p>如果容器启动时，需要为容器指定域名 ip 映射关系，可以使用选项 <code>--add-host host:ip</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --network my-net --add-host db:172.18.0.3 --name c3 centos</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>容器运行过程中，可以直接修改容器内的 <code>/etc/hosts</code> 文件</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>linux fail2ban 详解</title>
    <url>/202208171501/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Centos 7</li>
<li>iptables</li>
</ul>
<p><a href="https://www.fail2ban.org/wiki/index.php/Main_Page">Fail2ban</a> 是 Linux 上的一个著名的入侵保护的开源框架。它通过监视相应服务的日志记录文件，匹配日志记录中的错误信息（正则式匹配），然后与系统的 <code>iptables</code> 联动执行相应的屏蔽动作（一般情况下是调用防火墙屏蔽），比如：当有人在试探你的 <code>HTTP</code>、<code>SSH</code>、<code>SMTP</code>、<code>FTP</code> 密码，只要达到你预设的次数，<code>Fail2ban</code> 就会调用防火墙屏蔽这个 IP，并且可以发送 e-mail 通知系统管理员。</p>
<p>由于 <code>Fail2ban</code> 需要与系统的 <code>iptables</code>、<code>firewalld</code> 等联动来达到封禁 IP 的目的， <code>iptables</code> 使用与 <code>firewalld</code> 有少许不同。  </p>
<p>本文以 <code>iptables</code> 为例</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install epel-release</span><br><span class="line">yum install -y fail2ban</span><br><span class="line">systemctl enable fail2ban</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 Fail2ban 的状态</span></span><br><span class="line">fail2ban-client status   </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 Fai2ban 的版本</span></span><br><span class="line">fail2ban-client version   </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查 Fail2ban 是否正常运行（正常将显示 pong）</span></span><br><span class="line">fail2ban-client ping     </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动 Fail2ban</span></span><br><span class="line">systemctl start fail2ban   </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止 Fail2ban</span>  </span><br><span class="line">systemctl stop fail2ban  </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启 Fail2ban</span>  </span><br><span class="line">systemctl restart fail2ban</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打开 Fail2ban 的日志监控</span>     </span><br><span class="line">tail -f /var/log/fail2ban.log  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="主要文件说明"><a href="#主要文件说明" class="headerlink" title="主要文件说明"></a>主要文件说明</h3><table>
<thead>
<tr>
<th>文件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;etc&#x2F;fail2ban&#x2F;jail.d&#x2F;</td>
<td>配置文件夹。用于定义错误次数、封禁时长、封禁动作等</td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;fail2ban&#x2F;filter.d&#x2F;</td>
<td>条件文件夹。内含默认文件，用于定义日志文件内容的过滤规则</td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;fail2ban&#x2F;action.d</td>
<td>动作文件夹。内含默认文件，用于 iptables 以及 mail 等动作配置</td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;fail2ban&#x2F;fail2ban.conf<br/>&#x2F;etc&#x2F;fail2ban&#x2F;jail.conf</td>
<td><code>*.conf</code> 是主要（默认）配置文件，<strong>不要直接更改 <code>.conf</code> 文件</strong> ，升级后会被覆盖<br/>应该手动创建 <code>fail2ban.local</code> ,<code>jail.local</code>(或者分离 <code>.conf</code> 文件到 <code>jail.d/</code> 目录)</td>
</tr>
</tbody></table>
<h3 id="fail2ban-配置文件说明"><a href="#fail2ban-配置文件说明" class="headerlink" title="fail2ban 配置文件说明"></a>fail2ban 配置文件说明</h3><p><code>/etc/fail2ban/fail2ban.conf</code> 是主配置文件，定义了 <code>fai2ban</code> 默认的日志级别、日志位置及 sock 文件位置。<strong>不要更改此文件</strong>，要更改默认配置，可以复制 <code>fail2ban.conf</code> 成 <code>/etc/fail2ban/fail2ban.local</code> ，更改此 <code>local</code> 文件</p>
<figure class="highlight shell"><figcaption><span>/etc/fail2ban/fail2ban.local</span></figcaption><table><tr><td class="code"><pre><span class="line">[DEFAULT]</span><br><span class="line"></span><br><span class="line">loglevel = INFO</span><br><span class="line"></span><br><span class="line">logtarget = /var/log/fail2ban.log</span><br><span class="line"></span><br><span class="line">syslogsocket = auto</span><br><span class="line"></span><br><span class="line">socket = /var/run/fail2ban/fail2ban.sock</span><br><span class="line"></span><br><span class="line">pidfile = /var/run/fail2ban/fail2ban.pid</span><br><span class="line"></span><br><span class="line">dbfile = /var/lib/fail2ban/fail2ban.sqlite3</span><br><span class="line"></span><br><span class="line">dbpurgeage = 1d</span><br><span class="line"></span><br><span class="line">dbmaxmatches = 10</span><br><span class="line"></span><br><span class="line">[Definition]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Thread]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="jail-配置文件说明"><a href="#jail-配置文件说明" class="headerlink" title="jail 配置文件说明"></a>jail 配置文件说明</h3><p><code>/etc/fail2ban/jail.conf</code> 主要设置启用 <code>ban</code> 动作的服务及动作阀值。<strong>不要更改此文件</strong>，要更改此处的默认配置，可以复制 <code>jail.conf</code> 到 <code>/etc/fail2ban/jail.local</code>，更改此文件中的默认配置</p>
<figure class="highlight shell"><figcaption><span>/etc/fail2ban/jail.local</span></figcaption><table><tr><td class="code"><pre><span class="line">[DEFAULT]</span><br><span class="line">ignorecommand =</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">屏蔽时间，默认单位：秒</span></span><br><span class="line">bantime  = 10m</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这个时间段内超过 maxretry 定义的次数会被 ban 掉</span></span><br><span class="line">findtime  = 10m</span><br><span class="line">maxretry = 5</span><br><span class="line"></span><br><span class="line">maxmatches = %(maxretry)s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">日志修改检测机制(gamin、polling和auto这三种)</span></span><br><span class="line">backend = auto</span><br><span class="line"></span><br><span class="line">usedns = warn</span><br><span class="line">logencoding = auto</span><br><span class="line">enabled = false</span><br><span class="line">mode = normal</span><br><span class="line">filter = %(__name__)s[mode=%(mode)s]</span><br><span class="line">destemail = root@localhost</span><br><span class="line">sender = root@&lt;fq-hostname&gt;</span><br><span class="line">mta = sendmail</span><br><span class="line">protocol = tcp</span><br><span class="line">chain = &lt;known/chain&gt;</span><br><span class="line">port = 0:65535</span><br><span class="line">fail2ban_agent = Fail2Ban/%(fail2ban_version)s</span><br><span class="line">banaction = iptables-multiport</span><br><span class="line">banaction_allports = iptables-allports</span><br><span class="line">action_ = %(banaction)s[port=&quot;%(port)s&quot;, protocol=&quot;%(protocol)s&quot;, chain=&quot;%(chain)s&quot;]</span><br><span class="line">action_mw = %(action_)s</span><br><span class="line">            %(mta)s-whois[sender=&quot;%(sender)s&quot;, dest=&quot;%(destemail)s&quot;, protocol=&quot;%(protocol)s&quot;, chain=&quot;%(chain)s&quot;]</span><br><span class="line">action_mwl = %(action_)s</span><br><span class="line">             %(mta)s-whois-lines[sender=&quot;%(sender)s&quot;, dest=&quot;%(destemail)s&quot;, logpath=&quot;%(logpath)s&quot;, chain=&quot;%(chain)s&quot;]</span><br><span class="line">action_xarf = %(action_)s</span><br><span class="line">             xarf-login-attack[service=%(__name__)s, sender=&quot;%(sender)s&quot;, logpath=&quot;%(logpath)s&quot;, port=&quot;%(port)s&quot;]</span><br><span class="line">action_cf_mwl = cloudflare[cfuser=&quot;%(cfemail)s&quot;, cftoken=&quot;%(cfapikey)s&quot;]</span><br><span class="line">                %(mta)s-whois-lines[sender=&quot;%(sender)s&quot;, dest=&quot;%(destemail)s&quot;, logpath=&quot;%(logpath)s&quot;, chain=&quot;%(chain)s&quot;]</span><br><span class="line">action_blocklist_de  = blocklist_de[email=&quot;%(sender)s&quot;, service=&quot;%(__name__)s&quot;, apikey=&quot;%(blocklist_de_apikey)s&quot;, agent=&quot;%(fail2ban_agent)s&quot;]</span><br><span class="line">action_badips = badips.py[category=&quot;%(__name__)s&quot;, banaction=&quot;%(banaction)s&quot;, agent=&quot;%(fail2ban_agent)s&quot;]</span><br><span class="line">action_badips_report = badips[category=&quot;%(__name__)s&quot;, agent=&quot;%(fail2ban_agent)s&quot;]</span><br><span class="line">action_abuseipdb = abuseipdb</span><br><span class="line">action = %(action_)s</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中 <code>[DEFAULT]</code> 块定义了默认的配置，具体的服务配置中 (如 <code>/etc/fail2ban/jail.d/ssh.local</code>)，可以覆盖默认值。 </p>
<p>针对具体服务配置防护，以 <code>sshd</code> 为例，手动创建配置 <code>/etc/fail2ban/jail.d/sshd.local</code></p>
<figure class="highlight shell"><figcaption><span>/etc/fail2ban/jail.d/sshd.local</span></figcaption><table><tr><td class="code"><pre><span class="line">[sshd]</span><br><span class="line">enabled = true</span><br><span class="line">port = 22</span><br><span class="line">filter = sshd</span><br><span class="line">action = iptables[name=SSH, port=ssh, protocol=tcp]</span><br><span class="line">logpath = /var/log/secure</span><br><span class="line">maxretry = 3</span><br><span class="line">bantime = 43200</span><br><span class="line">findtime = 3600</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>[sshd]</code> : 名称，可以随便填写</li>
<li><code>enabled =true</code> ： 启用此配置</li>
<li><code>port = 22</code> : 服务端口</li>
<li><code>filter = sshd</code> : 应用的 <code>filter</code> 名称，对应的 <a href="#filter-%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E"><code>filter</code> 配置</a> 位于 <code>/etc/fail2ban/filter.d/sshd.conf</code></li>
<li><code>action = iptables[name=SSH, port=ssh, protocol=tcp]</code> : 执行的动作，对应 <code>/etc/fail2ban/action.d/iptables.conf</code> ，并传入 <code>name=SSH, port=ssh, protocol=tcp</code>，此处传入的端口 <code>ssh</code> 默认为 22 ，如果端口不为 22 ，需要更改为对应端口，传入的 <code>name</code> 会在定义防火墙链时被当做链名的一部分</li>
<li><code>logpath = /var/log/secure</code> : 要过滤的日志记录文件路径</li>
<li><code>maxretry = 3</code> ： 执行封禁动作前允许的错误记录数</li>
<li><code>bantime = 43200</code> ： 执行封禁的时长（秒）</li>
<li><code>findtime = 3600</code> ：此时长（秒）内达到 <code>maxretry</code> 次就执行封禁动作</li>
</ul>
<p>配置好之后，重启 <code>fail2ban</code> 使配置生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart fail2ban</span><br></pre></td></tr></table></figure>
<p>或者执行以下命令，在不重启 <code>fail2ban</code> 的情况下重新分析并加载配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fail2ban-client reload</span><br></pre></td></tr></table></figure>

<p>执行以下命令查看 <code>fail2ban</code> 的状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">fail2ban-client status</span></span><br><span class="line">Status</span><br><span class="line">|- Number of jail:	1</span><br><span class="line">`- Jail list:	sshd</span><br></pre></td></tr></table></figure>
<p>可以看到当前只启动了 <code>sshd</code> 这一个 <code>jail</code></p>
<p>执行以下命令查看 <code>sshd</code> 的防护情况，可以看到目前有哪些 ip 被封锁，以及过去总共多少 ip 被封锁</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">fail2ban-client status sshd</span></span><br><span class="line">Status for the jail: sshd</span><br><span class="line">|- Filter</span><br><span class="line">|  |- Currently failed:	0</span><br><span class="line">|  |- Total failed:	0</span><br><span class="line">|  `- Journal matches:	_SYSTEMD_UNIT=sshd.service + _COMM=sshd</span><br><span class="line">`- Actions</span><br><span class="line">   |- Currently banned:	1</span><br><span class="line">   |- Total banned:	1</span><br><span class="line">   `- Banned IP list:	54.193.188.141</span><br></pre></td></tr></table></figure>

<h3 id="filter-配置说明"><a href="#filter-配置说明" class="headerlink" title="filter 配置说明"></a>filter 配置说明</h3><p><code>fail2ban</code> 使用的各个 <code>filter</code> 位于 <code>/etc/fail2ban/filter.d/</code> 下。其中主要配置了日志的过滤规则  </p>
<p>以创建防护 <code>VNC</code> 的 <code>filter</code> 来说明。<code>VNC</code> 的日志中，如果有恶意登录，经常会出现以下日志记录：</p>
<figure class="highlight shell"><figcaption><span>/home/USER1/.vnc/USER1\:1.log</span></figcaption><table><tr><td class="code"><pre><span class="line">Sat Aug 20 10:35:27 2022</span><br><span class="line"> Connections: blacklisted: 185.170.144.226</span><br><span class="line"> Connections: blacklisted: 185.170.144.226</span><br><span class="line"></span><br><span class="line">Sat Aug 20 10:35:28 2022</span><br><span class="line"> Connections: blacklisted: 185.170.144.226</span><br><span class="line"> Connections: blacklisted: 185.170.144.226</span><br><span class="line"></span><br><span class="line">Sat Aug 20 10:35:29 2022</span><br><span class="line"> Connections: blacklisted: 185.170.144.226</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>filter</code> 的匹配规则里面，<strong>行的开头一定要先匹配到时间</strong>，时间格式可以试试系统可以识别的格式，如果开头不能匹配到时间，规则会匹配失败，因此，如果日志开头不是时间格式，需要修改日志格式，本例中，处理 <code>vnc</code> 日志时，会先在行首添加时间    </p>
</blockquote>
<p>可以根据此日志记录，创建针对 <code>VNC</code> 服务的日志过滤规则，手动创建文件 <code>/etc/fail2ban/filter.d/vnc.local</code></p>
<figure class="highlight shell"><figcaption><span>/etc/fail2ban/filter.d/vnc.local</span></figcaption><table><tr><td class="code"><pre><span class="line">[Definition]</span><br><span class="line">failregex = .*Connections: blacklisted: &lt;HOST&gt;</span><br><span class="line">ignoreregex =</span><br></pre></td></tr></table></figure>

<p>创建好配置文件，使配置生效前，一定要对 <code>filter</code> 配置文件的有效性进行测试，<code>fail2ban</code> 提供了命令 <code>fail2ban-regex</code> 用来测试 <code>filter</code> 的正则表达式，使用方法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">fail2ban-regex /home/USER1/.vnc/USER1\:1.<span class="built_in">log</span> vnc</span></span><br><span class="line"></span><br><span class="line">Running tests</span><br><span class="line">=============</span><br><span class="line"></span><br><span class="line">Use   failregex filter file : vnc, basedir: /etc/fail2ban</span><br><span class="line">Use         log file : /home/USER1/.vnc/USER1\:1.log</span><br><span class="line">Use         encoding : UTF-8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Results</span><br><span class="line">=======</span><br><span class="line"></span><br><span class="line">Failregex: 171210 total</span><br><span class="line">|-  #) [# of hits] regular expression</span><br><span class="line">|   1) [171210] .*Connections: blacklisted: &lt;HOST&gt;</span><br><span class="line">`-</span><br><span class="line"></span><br><span class="line">Ignoreregex: 0 total</span><br><span class="line"></span><br><span class="line">Date template hits:</span><br><span class="line">|- [# of hits] date format</span><br><span class="line">|  [377319] &#123;^LN-BEG&#125;(?:DAY )?MON Day %k:Minute:Second(?:\.Microseconds)?(?: ExYear)?</span><br><span class="line">`-</span><br><span class="line"></span><br><span class="line">Lines: 377319 lines, 0 ignored, 171210 matched, 206109 missed</span><br><span class="line">[processed in 23.67 sec]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以上命令使用规则 <code>vnc</code>，匹配日志文件 <code>/home/USER1/.vnc/USER1\:1.log</code>，结果中显示：<code>Lines: 377319 lines, 0 ignored, 171210 matched, 206109 missed</code>，可以说明匹配到了需要的内容  </p>
<p>也可以通过以下命令，验证具体的正则表达式是否能匹配到指定的日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">fail2ban-regex <span class="string">&#x27; Connections: blacklisted: 185.170.144.226&#x27;</span> <span class="string">&#x27;.*Connections: blacklisted: &lt;HOST&gt;&#x27;</span></span></span><br><span class="line"></span><br><span class="line">Running tests</span><br><span class="line">=============</span><br><span class="line"></span><br><span class="line">Use   failregex line : .*Connections: blacklisted: &lt;HOST&gt;</span><br><span class="line">Use      single line :  Connections: blacklisted: 185.170.144.226</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Results</span><br><span class="line">=======</span><br><span class="line"></span><br><span class="line">Failregex: 1 total</span><br><span class="line">|-  #) [# of hits] regular expression</span><br><span class="line">|   1) [1] .*Connections: blacklisted: &lt;HOST&gt;</span><br><span class="line">`-</span><br><span class="line"></span><br><span class="line">Ignoreregex: 0 total</span><br><span class="line"></span><br><span class="line">Date template hits:</span><br><span class="line"></span><br><span class="line">Lines: 1 lines, 0 ignored, 1 matched, 0 missed</span><br><span class="line">[processed in 0.03 sec]</span><br></pre></td></tr></table></figure>
<p>以上结果显示 <code>Lines: 1 lines, 0 ignored, 1 matched, 0 missed</code> , 说明日志被正则表达式匹配到了  </p>
<blockquote>
<p>以上命令中，隐含了日志开始匹配到了时间格式</p>
</blockquote>
<p>创建 <code>ban</code> 配置，手动创建配置文件 <code>/etc/fail2ban/jail.d/vnc.local</code>  </p>
<figure class="highlight shell"><figcaption><span>/etc/fail2ban/jail.d/vnc.local</span></figcaption><table><tr><td class="code"><pre><span class="line">[vnc]</span><br><span class="line">enabled = true</span><br><span class="line">port = 5901</span><br><span class="line">filter = vnc</span><br><span class="line">action = iptables[name=VNC, port=5901, protocol=tcp]</span><br><span class="line">logpath = /home/cosmos/.vnc/cosmos:1.log</span><br><span class="line">maxretry = 3</span><br><span class="line">bantime = 43200</span><br><span class="line">findtime = 3600</span><br></pre></td></tr></table></figure>

<p>配置更改完后，重启 <code>fail2ban</code> 使配置生效  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart fail2ban</span><br></pre></td></tr></table></figure>
<p>重启后，使用以下命令查看 <code>fail2ban</code> 状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">fail2ban-client status</span></span><br><span class="line">Status</span><br><span class="line">|- Number of jail:	2</span><br><span class="line">`- Jail list:	sshd, vnc</span><br></pre></td></tr></table></figure>
<p>如果输出显示 : <code>ERROR   Failed to access socket path: /var/run/fail2ban/fail2ban.sock. Is fail2ban running? </code>，说明 <code>fail2ban</code> 启动失败，可能是配置文件存在问题，比如 <code>fail2ban</code> 服务状态如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl status fail2ban -l</span></span><br><span class="line"> fail2ban.service - Fail2Ban Service</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/fail2ban.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: failed (Result: exit-code) since Sat 2022-08-20 13:33:48 CST; 24s ago</span><br><span class="line">     Docs: man:fail2ban(1)</span><br><span class="line">  Process: 2520 ExecStop=/usr/bin/fail2ban-client stop (code=exited, status=0/SUCCESS)</span><br><span class="line">  Process: 2536 ExecStart=/usr/bin/fail2ban-server -xf start (code=exited, status=255)</span><br><span class="line">  Process: 2533 ExecStartPre=/bin/mkdir -p /run/fail2ban (code=exited, status=0/SUCCESS)</span><br><span class="line"> Main PID: 2536 (code=exited, status=255)</span><br><span class="line"></span><br><span class="line">Aug 20 13:33:47 myserver-cn systemd[1]: Starting Fail2Ban Service...</span><br><span class="line">Aug 20 13:33:47 myserver-cn systemd[1]: Started Fail2Ban Service.</span><br><span class="line">Aug 20 13:33:48 myserver-cn fail2ban-server[2536]: 2022-08-20 13:33:48,058 fail2ban                </span><br><span class="line">    [2536]: ERROR   Failed during configuration: Have not found any log file for vnc jail</span><br><span class="line">Aug 20 13:33:48 myserver-cn fail2ban-server[2536]: 2022-08-20 13:33:48,060 fail2ban               </span><br><span class="line">    [2536]: ERROR   Async configuration of server failed</span><br><span class="line">Aug 20 13:33:48 myserver-cn systemd[1]: fail2ban.service: main process exited, code=exited, status=255/n/a</span><br><span class="line">Aug 20 13:33:48 myserver-cn systemd[1]: Unit fail2ban.service entered failed state.</span><br><span class="line">Aug 20 13:33:48 myserver-cn systemd[1]: fail2ban.service failed.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出中显示 <code>Failed during configuration: Have not found any log file for vnc jail</code>，说明 <code>jail.d/vnc.local</code> 中配置的日志路径或者是权限有问题，需要检查此处配置。  </p>
<blockquote>
<p>此处报错是因为 <code>jail.d/vnc.local</code> 中配置的日志路径如下： </p>
<figure class="highlight shell"><figcaption><span>jail.d/vnc.local</span></figcaption><table><tr><td class="code"><pre><span class="line">logpath = /home/cosmos/.vnc/cosmos\:1.log</span><br></pre></td></tr></table></figure>
<p>配置文件中不需要对 <code>:</code> 进行转义。</p>
</blockquote>
<p>配置无误，重启服务生效后，可以检查 <code>vnc</code> 对应的 <code>ban</code> 的状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">fail2ban-client status vnc</span></span><br><span class="line">Status for the jail: vnc</span><br><span class="line">|- Filter</span><br><span class="line">|  |- Currently failed:	22</span><br><span class="line">|  |- Total failed:	52632</span><br><span class="line">|  `- File list:	/home/cosmos/.vnc/cosmos:1.log.bak</span><br><span class="line">`- Actions</span><br><span class="line">   |- Currently banned:	18</span><br><span class="line">   |- Total banned:	18</span><br><span class="line">   `- Banned IP list:	212.80.219.226 212.80.219.175 175.211.155.52 ...</span><br></pre></td></tr></table></figure>
<p>查看防火墙状态，可以看到被封的 ip ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -L -v -n</span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_42.png"></p>
<p>如果被封禁的 ip 中有被误伤的，需要解禁，使用以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fail2ban-client set vnc  unbanip 45.33.65.249</span><br></pre></td></tr></table></figure>
<p>命令中的 <code>vnc</code> 指 <code>ban</code> 配置文件 <code>/etc/fail2ban/jail.d/vnc.local</code> 中的 <code>[vnc]</code> <a href="#jail-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E">名称</a></p>
<h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p><a href="https://www.fail2ban.org/wiki/index.php/Main_Page">fail2ban 官网</a><br><a href="https://www.fail2ban.org/wiki/index.php/MANUAL_0_8#Filters">fail2ban 配置官网说明</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>fail2ban</tag>
      </tags>
  </entry>
  <entry>
    <title>git 常见错误</title>
    <url>/202209131721/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><h4 id="error-RPC-failed-HTTP-403-curl-22-The-requested-URL-returned-error-403"><a href="#error-RPC-failed-HTTP-403-curl-22-The-requested-URL-returned-error-403" class="headerlink" title="error: RPC failed; HTTP 403 curl 22 The requested URL returned error: 403"></a>error: RPC failed; HTTP 403 curl 22 The requested URL returned error: 403</h4><p><strong>错误场景</strong> ： windows 系统中 <code>git push</code> 报错<br><img src="https://i.csms.tech/img_55.png"></p>
<p><strong>错误原因</strong> ： 大概率为用户密码错误<br><strong>排查步骤</strong> ： </p>
<ol>
<li>清除 windows 凭据管理中的 git 密码，或更改为正确的密码</li>
<li>编辑 <code>.git/config</code> 文件，对 <code>url</code> 按照如下格式配置：<figure class="highlight shell"><figcaption><span>.git/config</span></figcaption><table><tr><td class="code"><pre><span class="line">url = http://USERNAME@git.server.com/test.git</span><br></pre></td></tr></table></figure>
其中 <code>USERNAME</code> 为用户名，重新执行 <code>git push</code>，此时会要求输入用户密码，输入正确的用户密码后，可正常执行</li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>gitlab安装配置</title>
    <url>/8db58ebc/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><a href="https://about.gitlab.com/install/#centos-7">安装步骤</a></p>
<blockquote>
<p>安装完成之后使用gitlab-ctl reconfigure启动服务<br>访问页面，默认使用root登录<br>每次重新更改配置，都需要使用reconfigure重新启动</p>
</blockquote>
<span id="more"></span>

<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>启动所有 gitlab 组件；  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo gitlab-ctl start </span><br></pre></td></tr></table></figure>
<p>停止所有 gitlab 组件；  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo gitlab-ctl stop </span><br></pre></td></tr></table></figure>
<p>重启所有 gitlab 组件；  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo gitlab-ctl restart  </span><br></pre></td></tr></table></figure>
<p>查看服务状态；  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo gitlab-ctl status    </span><br></pre></td></tr></table></figure>
<p>启动服务；  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo gitlab-ctl reconfigure    </span><br></pre></td></tr></table></figure>
<p>修改默认的配置文件；  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/gitlab/gitlab.rb </span><br></pre></td></tr></table></figure>
<p>检查gitlab；  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gitlab-rake gitlab:check SANITIZE=true --trace  </span><br></pre></td></tr></table></figure>
<p>查看日志；  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo gitlab-ctl tail</span><br></pre></td></tr></table></figure>

<h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><h4 id="初始化空目录-通过git-init命令把这个目录变成Git可以管理的仓库"><a href="#初始化空目录-通过git-init命令把这个目录变成Git可以管理的仓库" class="headerlink" title="初始化空目录,通过git init命令把这个目录变成Git可以管理的仓库"></a>初始化空目录,通过<code>git init</code>命令把这个目录变成Git可以管理的仓库</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<h4 id="已有文件的目录创建为git仓库"><a href="#已有文件的目录创建为git仓库" class="headerlink" title="已有文件的目录创建为git仓库"></a>已有文件的目录创建为git仓库</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init </span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;XX&quot;</span><br><span class="line">git remote add origin https://a.com/p.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<h4 id="更改git仓库地址"><a href="#更改git仓库地址" class="headerlink" title="更改git仓库地址"></a>更改git仓库地址</h4><ol>
<li>方法1  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote set-url origin https://a.com/p.git</span><br></pre></td></tr></table></figure></li>
<li>方法2<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote rm origin</span><br><span class="line">git remote add origin https://a.com/p.git</span><br></pre></td></tr></table></figure></li>
<li>方法3<br>编辑<code>.git/config</code>文件, 修改 [remote “origin”]下面的url即可<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[core]</span><br><span class="line">        repositoryformatversion = 0</span><br><span class="line">        filemode = true</span><br><span class="line">        bare = false</span><br><span class="line">        logallrefupdates = true</span><br><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">        url = https://a.com/p.git</span><br><span class="line">        fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">[branch &quot;main&quot;]</span><br><span class="line">        remote = origin</span><br><span class="line">        merge = refs/heads/main</span><br><span class="line">[branch &quot;master&quot;]</span><br><span class="line">        remote = origin</span><br><span class="line">        merge = refs/heads/master</span><br><span class="line">[pull]</span><br><span class="line">        rebase = true</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h4><p>查看当前分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch </span><br></pre></td></tr></table></figure>
<p>查看所有分支，结果中<code>*</code>表示当前分支  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure>

<h4 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h4><p>切换到指定分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -b origin/master-dev</span><br></pre></td></tr></table></figure>
<p>切换主分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure>

<h4 id="撤销当前工作区中对指定文件的修改"><a href="#撤销当前工作区中对指定文件的修改" class="headerlink" title="撤销当前工作区中对指定文件的修改"></a>撤销当前工作区中对指定文件的修改</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout FILE</span><br><span class="line">git checkout .</span><br></pre></td></tr></table></figure>

<h4 id="查看历史记录"><a href="#查看历史记录" class="headerlink" title="查看历史记录"></a>查看历史记录</h4><p>显示当前分支的commit历史</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>
<p>查看git命令记录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reflog --date=iso</span><br></pre></td></tr></table></figure>

<p>查看指定commit的代码变化记录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git show 048bc53e65dda5</span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_2.png"></p>
<h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><blockquote>
<p>Git fatal: Unable to find remote helper for ‘https’</p>
</blockquote>
<p><strong>问题原因</strong>: 未安装curl-devel，安装curl-devel后重新编译<br><strong>解决方法</strong>：安装curl-devel后重新编译</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo Next 添加 canvas-nest 特效</title>
    <url>/b12589273/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>os: linux 3.10.0-1160.62.1.el7.x86_64 CentOS Linux 7 (Core)</li>
<li>hexo: 6.2.0</li>
<li>hexo-cli: 4.3.0</li>
<li>node: 16.16.0</li>
<li>Next 8.12.2</li>
</ul>
<h3 id="安装-canvas-nest"><a href="#安装-canvas-nest" class="headerlink" title="安装 canvas-nest"></a>安装 canvas-nest</h3><p>参考 <a href="https://github.com/hustcc/canvas-nest.js#install">canva-nest 官网</a> 安装</p>
<figure class="highlight shell"><figcaption><span>npm</span></figcaption><table><tr><td class="code"><pre><span class="line">npm install --save canvas-nest.js</span><br></pre></td></tr></table></figure>
<div class="note info"><p>可选操作，主要是为了生成 <code>canvas-nest.js</code> 文件</p>
</div>

<h3 id="配置-Next"><a href="#配置-Next" class="headerlink" title="配置 Next"></a>配置 Next</h3><p>编辑 <code>next配置文件</code>，新增以下配置</p>
<figure class="highlight shell"><figcaption><span>_config.next.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">background settings</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">add canvas-nest effect</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">see detail from https://github.com/hustcc/canvas-nest.js</span></span><br><span class="line">canvas_nest: </span><br><span class="line">  enable: true </span><br><span class="line">  url: https://s.csms.tech/js/canvas-nest.js</span><br><span class="line">  color: 0,0,255</span><br><span class="line">  opacity: 0.7</span><br><span class="line">  zIndex: -2</span><br><span class="line">  count: 99</span><br></pre></td></tr></table></figure>

<h3 id="引入-canvas-nest-js"><a href="#引入-canvas-nest-js" class="headerlink" title="引入 canvas-nest.js"></a>引入 canvas-nest.js</h3><p>编辑文件 <code>themes/next/layout/_layout.njk</code>, 在<code>&lt;/body&gt;</code> 之前新增以下内容</p>
<figure class="highlight shell"><figcaption><span>themes/next/layout/_layout.njk</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;% if theme.canvas_nest.enable %&#125;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot; color=&quot;&#123;&#123; theme.canvas_nest.color &#125;&#125;&quot; opacity=&#x27;&#123;&#123; theme.canvas_nest.opacity &#125;&#125;&#x27; zIndex=&quot;&#123;&#123; theme.canvas_nest.zIndex &#125;&#125;&quot; count=&quot;&#123;&#123; theme.canvas_nest.count &#125;&#125;&quot; src=&quot;&#123;&#123; theme.canvas_nest.url &#125;&#125;&quot;&gt;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>canvas-nest</tag>
      </tags>
  </entry>
  <entry>
    <title>inotify安装使用</title>
    <url>/512c7c5/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul>
<li><p>使用系统软件包管理器安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y inotify-tools</span><br></pre></td></tr></table></figure>
<p>安装后包含2个命令： <code>inotifywait </code>, <code>inotifywatch</code>,较为常用的命令是<code>inotifywait</code></p>
</li>
<li><p>编译安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://github.com/downloads/rvoicilas/inotify-tools/inotify-tools-3.14.tar.gz</span><br><span class="line">tar zxvf inotify-tools-3.14.tar.gz  </span><br><span class="line">cd inotify-tools-3.14</span><br><span class="line">./configure --prefix=/usr/local/inotify </span><br><span class="line">make</span><br><span class="line">make install  </span><br></pre></td></tr></table></figure></li>
</ul>
<span id="more"></span>

<h3 id="inotifywait-参数说明"><a href="#inotifywait-参数说明" class="headerlink" title="inotifywait 参数说明"></a>inotifywait 参数说明</h3><p>语法：<br>inotifywait [-hcmrq] [-e modify,access…] [-t ] [–format ] [–timefmt ] [ … ]</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@</span><br><span class="line">排除不需要监视的文件，可以是相对路径，也可以是绝对路径。</span><br><span class="line"></span><br><span class="line">--fromfile</span><br><span class="line">从文件读取需要监视的文件或排除的文件，一个文件一行，排除的文件以@开头。</span><br><span class="line"></span><br><span class="line">-m|--monitor</span><br><span class="line">接收到一个事情而不退出，无限期地执行。默认的行为是接收到一个事情后立即退出。</span><br><span class="line"></span><br><span class="line">-d|--daemon</span><br><span class="line">跟–monitor一样，除了是在后台运行，需要指定-–outfile把事情输出到一个文件。也意味着使用了–-syslog。</span><br><span class="line"></span><br><span class="line">-o|--outfile</span><br><span class="line">输出事情到一个文件而不是标准输出。</span><br><span class="line"></span><br><span class="line">-s|--syslog</span><br><span class="line">输出错误信息到系统日志</span><br><span class="line"></span><br><span class="line">-r|--recursive</span><br><span class="line">监视一个目录下的所有子目录。</span><br><span class="line"></span><br><span class="line">-q|--quiet</span><br><span class="line">指定一次，不会输出详细信息，指定二次，除了致命错误，不会输出任何信息。</span><br><span class="line"></span><br><span class="line">--exclude</span><br><span class="line">正则匹配需要排除的文件，大小写敏感。</span><br><span class="line"></span><br><span class="line">--excludei</span><br><span class="line">正则匹配需要排除的文件，忽略大小写。</span><br><span class="line"></span><br><span class="line">-t|--timeout</span><br><span class="line">设置超时时间，如果为0，则无限期地执行下去。</span><br><span class="line"></span><br><span class="line">-e|--event</span><br><span class="line">指定监视的事件。</span><br><span class="line"></span><br><span class="line">-c|--csv </span><br><span class="line">输出csv格式。</span><br><span class="line"></span><br><span class="line">--timefmt </span><br><span class="line">指定时间格式，用于–-format选项中的%T格式。</span><br><span class="line"></span><br><span class="line">--format</span><br><span class="line">指定输出格式。</span><br><span class="line">    %w 表示发生事件的目录</span><br><span class="line">    %f 表示发生事件的文件</span><br><span class="line">    %e 表示发生的事件</span><br><span class="line">    %Xe 事件以“X”分隔</span><br><span class="line">    %T 使用由--timefmt 定义的时间格式</span><br></pre></td></tr></table></figure>

<h3 id="可监听事件列表"><a href="#可监听事件列表" class="headerlink" title="可监听事件列表"></a>可监听事件列表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">access	文件读取</span><br><span class="line">modify	文件更改。</span><br><span class="line">attrib	文件属性更改，如权限，时间戳等。</span><br><span class="line">close_write	以可写模式打开的文件被关闭，不代表此文件一定已经写入数据。</span><br><span class="line">close_nowrite	以只读模式打开的文件被关闭。</span><br><span class="line">close	文件被关闭，不管它是如何打开的。</span><br><span class="line">open	文件打开。</span><br><span class="line">moved_to	一个文件或目录移动到监听的目录，即使是在同一目录内移动，此事件也触发。</span><br><span class="line">moved_from	一个文件或目录移出监听的目录，即使是在同一目录内移动，此事件也触发。</span><br><span class="line">move	包括moved_to和 moved_from</span><br><span class="line">move_self	文件或目录被移除，之后不再监听此文件或目录。</span><br><span class="line">create	文件或目录创建</span><br><span class="line">delete	文件或目录删除</span><br><span class="line">delete_self	文件或目录移除，之后不再监听此文件或目录</span><br><span class="line">unmount	文件系统取消挂载，之后不再监听此文件系统。</span><br></pre></td></tr></table></figure>

<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">inotifywait -m -r -e modify /source/ | while read dir action filename</span><br><span class="line">do </span><br><span class="line">  echo $&#123;dir&#125;</span><br><span class="line">  echo $&#123;action&#125;</span><br><span class="line">  echo $&#123;filename&#125;</span><br><span class="line">  rsync -a -u /source/ /dest/</span><br><span class="line">done</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>inotify</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes 常用命令示例</title>
    <url>/202209131536/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Centos-7 3.10.0-1062.9.1</li>
<li>Docker 19.03.15</li>
<li>containerd.io-1.4.13</li>
<li>kubectl-1.25.0</li>
<li>kubeadm-1.25.0</li>
<li>kubelet-1.25.0</li>
</ul>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm init --pod-network-cidr=10.244.0.0/16</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>--pod-network-cidr</code></td>
<td>指定 pod 的 cidr</td>
<td></td>
</tr>
</tbody></table>
<h4 id="添加节点到集群"><a href="#添加节点到集群" class="headerlink" title="添加节点到集群"></a>添加节点到集群</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm join 172.31.10.19:6443 --token 8ca35s.butdpihinkdczvqb --discovery-token-ca-cert-hash sha256:b2793f9a6bea44a64640f99042f11c4ff6 \ </span><br><span class="line">        --cri-socket=unix:///var/run/cri-dockerd.sock</span><br></pre></td></tr></table></figure>
<p>其中的 <code>token</code> 可以在 master 上使用以下命令查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubeadm token list</span></span><br><span class="line">TOKEN                     TTL         EXPIRES                USAGES                   DESCRIPTION                                                EXTRA GROUPS</span><br><span class="line">8ca35s.butdpihinkdczvqb   19h         2022-09-14T02:54:55Z   authentication,signing   The default bootstrap token generated by &#x27;kubeadm init&#x27;.   system:bootstrappers:kubeadm:default-node-token</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>默认情况下，令牌会在 24 小时后过期。如果要在当前令牌过期后将节点加入集群， 则可以通过在控制平面节点上运行以下命令来创建新令牌：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm token create</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果你没有 <code>--discovery-token-ca-cert-hash</code> 的值，则可以通过在控制平面节点上执行以下命令链来获取它<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[使用 kubeadm 创建集群](https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#join-nodes)">[1]</span></a></sup>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | \</span><br><span class="line">   openssl dgst -sha256 -hex | sed &#x27;s/^.* //&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="查看-node-信息"><a href="#查看-node-信息" class="headerlink" title="查看 node 信息"></a>查看 node 信息</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get nodes</span></span><br><span class="line">NAME              STATUS   ROLES           AGE     VERSION</span><br><span class="line">ops-kubernetes1   Ready    control-plane   5h31m   v1.25.0</span><br><span class="line">ops-kubernetes2   Ready    &lt;none&gt;          3h6m    v1.25.0</span><br><span class="line">ops-kubernetes3   Ready    &lt;none&gt;          179m    v1.25.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="查看-pod"><a href="#查看-pod" class="headerlink" title="查看 pod"></a>查看 pod</h4><p>列出所有 pod</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods -A</span></span><br><span class="line">NAMESPACE      NAME                                      READY   STATUS              RESTARTS         AGE</span><br><span class="line">kube-flannel   kube-flannel-ds-7q2hp                     0/1     CrashLoopBackOff    52 (86s ago)     4h3m</span><br><span class="line">kube-flannel   kube-flannel-ds-k8wd6                     0/1     CrashLoopBackOff    47 (16s ago)     135m</span><br><span class="line">kube-flannel   kube-flannel-ds-x6ck2                     0/1     CrashLoopBackOff    29 (3m57s ago)   128m</span><br><span class="line">kube-system    coredns-565d847f94-b4sgn                  0/1     ContainerCreating   0                4h39m</span><br><span class="line">kube-system    coredns-565d847f94-ml6k5                  0/1     ContainerCreating   0                4h39m</span><br><span class="line">kube-system    etcd-ops-kubernetes1                      1/1     Running             0                4h39m</span><br><span class="line">kube-system    kube-apiserver-ops-kubernetes1            1/1     Running             0                4h39m</span><br><span class="line">kube-system    kube-controller-manager-ops-kubernetes1   1/1     Running             0                4h39m</span><br><span class="line">kube-system    kube-proxy-9vwxl                          1/1     Running             0                135m</span><br><span class="line">kube-system    kube-proxy-qxsc7                          1/1     Running             0                128m</span><br><span class="line">kube-system    kube-proxy-v5msf                          1/1     Running             0                4h39m</span><br><span class="line">kube-system    kube-scheduler-ops-kubernetes1            1/1     Running             0                4h39m</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>-A, --all-namespaces</code></td>
<td>列出所有的 pod</td>
<td></td>
</tr>
</tbody></table>
<h4 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h4><p>查看指定 namespace 中的指定 pod 的日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl logs kube-flannel-ds-7q2hp -n kube-flannel</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="使用-kubectl-重启-pod"><a href="#使用-kubectl-重启-pod" class="headerlink" title="使用 kubectl 重启 pod"></a>使用 kubectl 重启 pod</h4><p>以下命令重启 kubernetes-dashboard</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get pod kubernetes-dashboard -n kubernetes-dashboard -o yaml | kubectl replace --force -f -</span><br></pre></td></tr></table></figure>

<p>这条命令的意思是 <code>get</code> 当前运行的 pod 的 yaml 声明，并管道重定向输出到 <code>kubectl replace</code> 命令的标准输入，从而达到重启的目的。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#join-nodes">使用 kubeadm 创建集群</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Docker</category>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes 安装配置</title>
    <url>/202209121102/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="https://kubernetes.io/zh-cn/docs/setup/production-environment/">Kubernetes 官网文档</a></p>
<h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Centos 7 5.4.212-1</li>
<li>Docker 19.03.15</li>
<li>containerd.io-1.4.13</li>
<li>kubectl-1.25.0</li>
<li>kubeadm-1.25.0</li>
<li>kubelet-1.25.0</li>
</ul>
<h3 id="kubernetes-环境安装前配置"><a href="#kubernetes-环境安装前配置" class="headerlink" title="kubernetes 环境安装前配置"></a>kubernetes 环境安装前配置</h3><h4 id="升级内核版本"><a href="#升级内核版本" class="headerlink" title="升级内核版本"></a>升级内核版本</h4><p>Centos 7 默认的内核版本 3.10 在运行 kubernetes 时存在不稳定性，建议升级内核版本到新版本</p>
<a href="/202209140931/" title="Centos 7 升级内核">Centos 7 升级内核</a>

<h4 id="关闭-SELinux"><a href="#关闭-SELinux" class="headerlink" title="关闭 SELinux"></a>关闭 SELinux</h4><p>kubernetes 目前未实现对 SELinux 的支持，因此必须要关闭 SELinux</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo setenforce 0</span><br><span class="line">sudo sed -i &#x27;s/^SELINUX=enforcing$/SELINUX=disabled/&#x27; /etc/selinux/config</span><br></pre></td></tr></table></figure>

<h4 id="集群中所有计算机之间具有完全的网络连接"><a href="#集群中所有计算机之间具有完全的网络连接" class="headerlink" title="集群中所有计算机之间具有完全的网络连接"></a>集群中所有计算机之间具有完全的网络连接</h4><p>配置集群所有节点的防火墙，确保所有集群节点之间具有完全的网络连接。</p>
<h4 id="禁止swap分区"><a href="#禁止swap分区" class="headerlink" title="禁止swap分区"></a>禁止swap分区</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">swapoff -a</span><br></pre></td></tr></table></figure>

<h4 id="配置主机名"><a href="#配置主机名" class="headerlink" title="配置主机名"></a>配置主机名</h4><p>节点之中不可以有重复的主机名、MAC 地址或 product_uuid</p>
<p>配置集群中的 3 台主机名分别为 <code>ops-kubernetes1</code>，<code>ops-kubernetes2</code>，<code>ops-kubernetes3</code>，本示例中 <code>ops-kubernetes1</code> 作为 master </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hostnamectl set-hostname ops-kubernetes1</span><br></pre></td></tr></table></figure>

<p>添加主机名和 ip 解析到 <code>/etc/hosts</code> 文件</p>
<figure class="highlight shell"><figcaption><span>/etc/hosts</span></figcaption><table><tr><td class="code"><pre><span class="line">172.31.10.19 ops-kubernetes1</span><br><span class="line">172.31.9.241 ops-kubernetes2</span><br><span class="line">172.31.14.115 ops-kubernetes3</span><br></pre></td></tr></table></figure>

<h4 id="为-kube-proxy-开启-ipvs"><a href="#为-kube-proxy-开启-ipvs" class="headerlink" title="为 kube-proxy 开启 ipvs"></a>为 kube-proxy 开启 ipvs</h4><p><a href="https://blog.fleeto.us/post/iptables-or-ipvs/">kube-proxy 模式对比：iptables 还是 IPVS</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1890887">kube-proxy中使用ipvs与iptables的比较</a></p>
<p>此配置为<strong>可选操作</strong>，在不启用 ipvs 模式的情况下，kube-proxy 会使用 iptables 模式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &gt; /etc/sysconfig/modules/ipvs.modules &lt;&lt;EOF</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">modprobe -- ip_vs</span><br><span class="line">modprobe -- ip_vs_rr</span><br><span class="line">modprobe -- ip_vs_wrr</span><br><span class="line">modprobe -- ip_vs_sh</span><br><span class="line">modprobe -- nf_conntrack_ipv4</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">chmod 755 /etc/sysconfig/modules/ipvs.modules &amp;&amp; bash /etc/sysconfig/modules/ipvs.modules </span><br></pre></td></tr></table></figure>

<h4 id="转发-IPv4-并让-iptables-看到桥接流量"><a href="#转发-IPv4-并让-iptables-看到桥接流量" class="headerlink" title="转发 IPv4 并让 iptables 看到桥接流量"></a>转发 IPv4 并让 iptables 看到桥接流量</h4><p>以下操作需要在 kubernetes 集群中的所有节点操作<br>通过运行 <code>lsmod | grep br_netfilter</code> 来验证 <code>br_netfilter</code> 模块是否已加载。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">lsmod | grep br_netfilter</span></span><br><span class="line">br_netfilter           22256  0 </span><br><span class="line">bridge                151336  1 br_netfilter</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>若要显式加载此模块，请运行以下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo modprobe overlay</span><br><span class="line">sudo modprobe br_netfilter</span><br></pre></td></tr></table></figure>


<p>为了让 Linux 节点的 iptables 能够正确查看桥接流量，请确认 <code>sysctl</code> 配置中的 <code>net.bridge.bridge-nf-call-iptables</code> 设置为 1</p>
<p>为配置永久生效，可以添加以下配置，<code>/etc/modules-load.d/k8s.conf</code> 中追加要加载的模块</p>
<figure class="highlight shell"><figcaption><span>/etc/modules-load.d/k8s.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">overlay</span><br><span class="line">br_netfilter</span><br></pre></td></tr></table></figure>

<p><code>/etc/sysctl.d/k8s.conf</code> 中追加内核参数</p>
<figure class="highlight shell"><figcaption><span>/etc/sysctl.d/k8s.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">net.bridge.bridge-nf-call-iptables  = 1</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.ipv4.ip_forward                 = 1</span><br></pre></td></tr></table></figure>

<p>执行以下命令重新载入 sysctl 参数而无需重启系统</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo sysctl --system</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h4 id="安装-Docker-Engine"><a href="#安装-Docker-Engine" class="headerlink" title="安装 Docker Engine"></a>安装 Docker Engine</h4><p>以下操作需要在 kubernetes 集群中的所有节点操作<br>参考以下链接，在每个节点上安装 Docker Engine<br><a href="https://docs.docker.com/engine/install/centos/">Centos 安装 Docker Engine 官网参考文档</a></p>
<a href="/202208041317/" title="docker 安装及常用命令介绍">docker 安装及常用命令介绍</a>

<h4 id="安装-cri-dockerd"><a href="#安装-cri-dockerd" class="headerlink" title="安装 cri-dockerd"></a>安装 cri-dockerd</h4><p>Docker Engine 没有实现 CRI，因此 Kubernetes 无法直接使用 Docker Engine，需要先安装 cri-dockerd，以让 Kubernetes 可以通过 Kubernetes 的 CRI 操作 Docker。</p>
<p>以下操作需要在 kubernetes 集群中的所有节点操作 </p>
<p>按照源代码仓库中的说明安装 <a href="https://github.com/Mirantis/cri-dockerd">cri-dockerd</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/Mirantis/cri-dockerd.git</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Run these commands as root</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##Install GO###</span></span></span><br><span class="line">wget https://storage.googleapis.com/golang/getgo/installer_linux</span><br><span class="line">chmod +x ./installer_linux</span><br><span class="line">./installer_linux</span><br><span class="line">source ~/.bash_profile</span><br><span class="line"></span><br><span class="line">cd cri-dockerd</span><br><span class="line">mkdir bin</span><br><span class="line">go build -o bin/cri-dockerd</span><br><span class="line">mkdir -p /usr/local/bin</span><br><span class="line">install -o root -g root -m 0755 bin/cri-dockerd /usr/local/bin/cri-dockerd</span><br><span class="line">cp -a packaging/systemd/* /etc/systemd/system</span><br><span class="line">sed -i -e &#x27;s,/usr/bin/cri-dockerd,/usr/local/bin/cri-dockerd,&#x27; /etc/systemd/system/cri-docker.service</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 使用 iptables 替换 firewalld</span></span></span><br><span class="line">sed -i -e &#x27;s,firewalld.service,iptables.service,&#x27; /etc/systemd/system/cri-docker.service</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable cri-docker.service</span><br><span class="line">systemctl enable --now cri-docker.socket</span><br></pre></td></tr></table></figure>

<p>对于 <code>cri-dockerd</code>，默认情况下，CRI 套接字是 <code>/run/cri-dockerd.sock</code></p>
<h4 id="安装-kubeadm、kubelet-和-kubectl"><a href="#安装-kubeadm、kubelet-和-kubectl" class="headerlink" title="安装 kubeadm、kubelet 和 kubectl"></a>安装 kubeadm、kubelet 和 kubectl</h4><p>需要在每台机器上安装以下的软件包：</p>
<ul>
<li><p><code>kubeadm</code> ： 用来初始化集群的指令。</p>
</li>
<li><p><code>kubelet</code> ： 在集群中的每个节点上用来启动 Pod 和容器等。</p>
</li>
<li><p><code>kubectl</code> ： 用来与集群通信的命令行工具。</p>
</li>
</ul>
<p>添加 <code>yum</code> 源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF | sudo tee /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-\$basearch</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg</span><br><span class="line">exclude=kubelet kubeadm kubectl</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<p>安装软件包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes</span><br></pre></td></tr></table></figure>
<p>启动服务并配置开机启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable --now kubelet</span><br></pre></td></tr></table></figure>
<p>kubelet 现在每隔几秒就会重启，因为它陷入了一个等待 kubeadm 指令的死循环。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl status kubelet</span></span><br><span class="line">● kubelet.service - kubelet: The Kubernetes Node Agent</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/kubelet.service; enabled; vendor preset: disabled)</span><br><span class="line">  Drop-In: /usr/lib/systemd/system/kubelet.service.d</span><br><span class="line">           └─10-kubeadm.conf</span><br><span class="line">   Active: activating (auto-restart) (Result: exit-code) since Mon 2022-09-12 14:35:58 CST; 7s ago</span><br><span class="line">     Docs: https://kubernetes.io/docs/</span><br><span class="line">  Process: 2056 ExecStart=/usr/bin/kubelet $KUBELET_KUBECONFIG_ARGS $KUBELET_CONFIG_ARGS $KUBELET_KUBEADM_ARGS $KUBELET_EXTRA_ARGS (code=exited, status=1/FAILURE)</span><br><span class="line"> Main PID: 2056 (code=exited, status=1/FAILURE)</span><br><span class="line"></span><br><span class="line">Sep 12 14:35:58 ip-172-31-14-115.us-west-1.compute.internal systemd[1]: Unit kubelet.service entered failed state.</span><br><span class="line">Sep 12 14:35:58 ip-172-31-14-115.us-west-1.compute.internal systemd[1]: kubelet.service failed.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="初始化控制平面节点"><a href="#初始化控制平面节点" class="headerlink" title="初始化控制平面节点"></a>初始化控制平面节点</h4><p>控制平面节点是运行控制平面组件的机器， 包括 etcd （集群数据库） 和 API Server （命令行工具 kubectl 与之通信）。</p>
<p>要初始化控制平面节点，请在 master 节点上（<code>ops-kubernetes1</code>）运行命令：</p>
<figure class="highlight shell"><figcaption><span>ops-kubernetes1</span></figcaption><table><tr><td class="code"><pre><span class="line">kubeadm init --pod-network-cidr=10.244.0.0/16</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[init] Using Kubernetes version: v1.25.0</span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">[preflight] Pulling images required for setting up a Kubernetes cluster</span><br><span class="line">[preflight] This might take a minute or two, depending on the speed of your internet connection</span><br><span class="line">[preflight] You can also perform this action in beforehand using &#x27;kubeadm config images pull&#x27;</span><br><span class="line">[certs] Using certificateDir folder &quot;/etc/kubernetes/pki&quot;</span><br><span class="line">[certs] Generating &quot;ca&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;apiserver&quot; certificate and key</span><br><span class="line">[certs] apiserver serving cert is signed for DNS names [kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local ops-kubernetes1] and IPs [10.96.0.1 172.31.10.19]</span><br><span class="line">[certs] Generating &quot;apiserver-kubelet-client&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;front-proxy-ca&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;front-proxy-client&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;etcd/ca&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;etcd/server&quot; certificate and key</span><br><span class="line">[certs] etcd/server serving cert is signed for DNS names [localhost ops-kubernetes1] and IPs [172.31.10.19 127.0.0.1 ::1]</span><br><span class="line">[certs] Generating &quot;etcd/peer&quot; certificate and key</span><br><span class="line">[certs] etcd/peer serving cert is signed for DNS names [localhost ops-kubernetes1] and IPs [172.31.10.19 127.0.0.1 ::1]</span><br><span class="line">[certs] Generating &quot;etcd/healthcheck-client&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;apiserver-etcd-client&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;sa&quot; key and public key</span><br><span class="line">[kubeconfig] Using kubeconfig folder &quot;/etc/kubernetes&quot;</span><br><span class="line">[kubeconfig] Writing &quot;admin.conf&quot; kubeconfig file</span><br><span class="line">[kubeconfig] Writing &quot;kubelet.conf&quot; kubeconfig file</span><br><span class="line">[kubeconfig] Writing &quot;controller-manager.conf&quot; kubeconfig file</span><br><span class="line">[kubeconfig] Writing &quot;scheduler.conf&quot; kubeconfig file</span><br><span class="line">[kubelet-start] Writing kubelet environment file with flags to file &quot;/var/lib/kubelet/kubeadm-flags.env&quot;</span><br><span class="line">[kubelet-start] Writing kubelet configuration to file &quot;/var/lib/kubelet/config.yaml&quot;</span><br><span class="line">[kubelet-start] Starting the kubelet</span><br><span class="line">[control-plane] Using manifest folder &quot;/etc/kubernetes/manifests&quot;</span><br><span class="line">[control-plane] Creating static Pod manifest for &quot;kube-apiserver&quot;</span><br><span class="line">[control-plane] Creating static Pod manifest for &quot;kube-controller-manager&quot;</span><br><span class="line">[control-plane] Creating static Pod manifest for &quot;kube-scheduler&quot;</span><br><span class="line">[etcd] Creating static Pod manifest for local etcd in &quot;/etc/kubernetes/manifests&quot;</span><br><span class="line">[wait-control-plane] Waiting for the kubelet to boot up the control plane as static Pods from directory &quot;/etc/kubernetes/manifests&quot;. This can take up to 4m0s</span><br><span class="line">[apiclient] All control plane components are healthy after 17.003297 seconds</span><br><span class="line">[upload-config] Storing the configuration used in ConfigMap &quot;kubeadm-config&quot; in the &quot;kube-system&quot; Namespace</span><br><span class="line">[kubelet] Creating a ConfigMap &quot;kubelet-config&quot; in namespace kube-system with the configuration for the kubelets in the cluster</span><br><span class="line">[upload-certs] Skipping phase. Please see --upload-certs</span><br><span class="line">[mark-control-plane] Marking the node ops-kubernetes1 as control-plane by adding the labels: [node-role.kubernetes.io/control-plane node.kubernetes.io/exclude-from-external-load-balancers]</span><br><span class="line">[mark-control-plane] Marking the node ops-kubernetes1 as control-plane by adding the taints [node-role.kubernetes.io/control-plane:NoSchedule]</span><br><span class="line">[bootstrap-token] Using token: 8ca35s.butdpihinkdczvqb</span><br><span class="line">[bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles</span><br><span class="line">[bootstrap-token] Configured RBAC rules to allow Node Bootstrap tokens to get nodes</span><br><span class="line">[bootstrap-token] Configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials</span><br><span class="line">[bootstrap-token] Configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token</span><br><span class="line">[bootstrap-token] Configured RBAC rules to allow certificate rotation for all node client certificates in the cluster</span><br><span class="line">[bootstrap-token] Creating the &quot;cluster-info&quot; ConfigMap in the &quot;kube-public&quot; namespace</span><br><span class="line">[kubelet-finalize] Updating &quot;/etc/kubernetes/kubelet.conf&quot; to point to a rotatable kubelet client certificate and key</span><br><span class="line">[addons] Applied essential addon: CoreDNS</span><br><span class="line">[addons] Applied essential addon: kube-proxy</span><br><span class="line"></span><br><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p $HOME/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line">Alternatively, if you are the root user, you can run:</span><br><span class="line"></span><br><span class="line">  export KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">  beadm join 172.31.10.19:6443 --token 8ca35s.butdpihinkdczvqb \</span><br><span class="line">	--discovery-token-ca-cert-hash sha256:b2793f9a6bea44a64640f99042f11c4ff6e4fef99fa2407241e1a0e8ea652149 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>根据 <code>kubeadm init</code> 输出提示，配置 <code>kubectl</code> 需要的环境变量，root 用户执行以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export KUBECONFIG=/etc/kubernetes/admin.conf</span><br></pre></td></tr></table></figure>
<p>为永久生效，可将其添加到 <code>~/.bash_profile</code></p>
<h4 id="安装-kube-flannel"><a href="#安装-kube-flannel" class="headerlink" title="安装 kube-flannel"></a>安装 kube-flannel</h4><p>所有节点上执行以下命令安装 <code>flannel</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y flannel</span><br></pre></td></tr></table></figure>
<p>请在 master 节点上（<code>ops-kubernetes1</code>）运行命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl apply -f https://raw.githubusercontent.com/flannel-io/flannel/master/Documentation/kube-flannel.yml</span></span><br><span class="line"></span><br><span class="line">namespace/kube-flannel created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/flannel created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/flannel created</span><br><span class="line">serviceaccount/flannel created</span><br><span class="line">configmap/kube-flannel-cfg created</span><br><span class="line">daemonset.apps/kube-flannel-ds created</span><br></pre></td></tr></table></figure>
<p>使用默认的 <code>kube-flannel.yml</code>，默认的 Network 为 <code>10.244.0.0/16</code>，要变更默认网段，更改 <code>kube-flannel.yml</code> 中的以下内容即可：</p>
<figure class="highlight shell"><figcaption><span>kube-flannel.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">net-conf.json: |</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;Network&quot;: &quot;10.244.0.0/16&quot;,</span><br><span class="line">    &quot;Backend&quot;: &#123;</span><br><span class="line">      &quot;Type&quot;: &quot;vxlan&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="将节点加入集群"><a href="#将节点加入集群" class="headerlink" title="将节点加入集群"></a>将节点加入集群</h4><p>在 work 节点上执行以下命令加入集群</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm join 172.31.10.19:6443 --token 8ca35s.butdpihinkdczvqb --discovery-token-ca-cert-hash sha256:b2793f9a6bea44a64640f99042f11c4ff6 \ </span><br><span class="line">        --cri-socket=unix:///var/run/cri-dockerd.sock</span><br></pre></td></tr></table></figure>

<h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><h4 id="Found-multiple-CRI-endpoints-on-the-host"><a href="#Found-multiple-CRI-endpoints-on-the-host" class="headerlink" title="Found multiple CRI endpoints on the host"></a>Found multiple CRI endpoints on the host</h4><p><strong>错误场景</strong> ： 执行以下命令将节点加入集群时报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubeadm <span class="built_in">join</span> 172.31.10.19:6443 --token 8ca35s.butdpihinkdczvqb --discovery-token-ca-cert-hash sha256:b2793f9a6bea44a64640f99042</span></span><br><span class="line"></span><br><span class="line">Found multiple CRI endpoints on the host. Please define which one do you wish to use by setting the &#x27;criSocket&#x27; field in the kubeadm configuration file: unix:///var/run/containerd/containerd.sock, unix:///var/run/cri-dockerd.sock</span><br><span class="line">To see the stack trace of this error execute with --v=5 or higher</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>报错原因</strong> ： 在没有明确指定 Kubernetes 要使用的 CRI 情况下，会自动扫描主机上面安装的 CRI，如果出现多个可用的 CRI，会报错并提示确定使用哪个 CRI。</p>
<p><strong>解决方法</strong> ： 使用如下命令，指定要使用的 CRI</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm join 172.31.10.19:6443 --token 8ca35s.butdpihinkdczvqb --discovery-token-ca-cert-hash sha256:b2793f9a6bea44a64640f99042f11c4ff6 \ </span><br><span class="line">        --cri-socket=unix:///var/run/cri-dockerd.sock</span><br></pre></td></tr></table></figure>

<h4 id="kube-flannel-状态为-CrashLoopBackOff"><a href="#kube-flannel-状态为-CrashLoopBackOff" class="headerlink" title="kube-flannel 状态为 CrashLoopBackOff"></a>kube-flannel 状态为 CrashLoopBackOff</h4><p><strong>错误场景</strong> ：<br><code>kube-flannel</code> 一直重启，状态为 <code>CrashLoopBackOff</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods --all-namespaces</span></span><br><span class="line">NAMESPACE      NAME                                      READY   STATUS              RESTARTS         AGE</span><br><span class="line">kube-flannel   kube-flannel-ds-7q2hp                     0/1     CrashLoopBackOff    40 (3m39s ago)   3h4m</span><br><span class="line">kube-flannel   kube-flannel-ds-k8wd6                     0/1     CrashLoopBackOff    35 (53s ago)     76m</span><br><span class="line">kube-flannel   kube-flannel-ds-x6ck2                     0/1     CrashLoopBackOff    18 (106s ago)    69m</span><br><span class="line">kube-system    coredns-565d847f94-b4sgn                  0/1     ContainerCreating   0                3h40m</span><br><span class="line">kube-system    coredns-565d847f94-ml6k5                  0/1     ContainerCreating   0                3h40m</span><br><span class="line">kube-system    etcd-ops-kubernetes1                      1/1     Running             0                3h40m</span><br><span class="line">kube-system    kube-apiserver-ops-kubernetes1            1/1     Running             0                3h40m</span><br><span class="line">kube-system    kube-controller-manager-ops-kubernetes1   1/1     Running             0                3h40m</span><br><span class="line">kube-system    kube-proxy-9vwxl                          1/1     Running             0                76m</span><br><span class="line">kube-system    kube-proxy-qxsc7                          1/1     Running             0                69m</span><br><span class="line">kube-system    kube-proxy-v5msf                          1/1     Running             0                3h40m</span><br><span class="line">kube-system    kube-scheduler-ops-kubernetes1            1/1     Running             0                3h40m</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>排查步骤</strong> ：<br>查看日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl logs kube-flannel-ds-7q2hp -n kube-flannel</span></span><br><span class="line">Defaulted container &quot;kube-flannel&quot; out of: kube-flannel, install-cni-plugin (init), install-cni (init)</span><br><span class="line">I0913 06:42:19.799473       1 main.go:207] CLI flags config: &#123;etcdEndpoints:http://127.0.0.1:4001,http://127.0.0.1:2379 etcdPrefix:/coreos.com/network etcdKeyfile: etcdCertfile: etcdCAFile: etcdUsername: etcdPassword: version:false kubeSubnetMgr:true kubeApiUrl: kubeAnnotationPrefix:flannel.alpha.coreos.com kubeConfigFile: iface:[] ifaceRegex:[] ipMasq:true ifaceCanReach: subnetFile:/run/flannel/subnet.env publicIP: publicIPv6: subnetLeaseRenewMargin:60 healthzIP:0.0.0.0 healthzPort:0 iptablesResyncSeconds:5 iptablesForwardRules:true netConfPath:/etc/kube-flannel/net-conf.json setNodeNetworkUnavailable:true&#125;</span><br><span class="line">W0913 06:42:19.799563       1 client_config.go:614] Neither --kubeconfig nor --master was specified.  Using the inClusterConfig.  This might not work.</span><br><span class="line">I0913 06:42:19.903750       1 kube.go:120] Waiting 10m0s for node controller to sync</span><br><span class="line">I0913 06:42:19.903882       1 kube.go:401] Starting kube subnet manager</span><br><span class="line">I0913 06:42:20.903967       1 kube.go:127] Node controller sync successful</span><br><span class="line">I0913 06:42:20.903995       1 main.go:227] Created subnet manager: Kubernetes Subnet Manager - ops-kubernetes1</span><br><span class="line">I0913 06:42:20.904004       1 main.go:230] Installing signal handlers</span><br><span class="line">I0913 06:42:20.904152       1 main.go:467] Found network config - Backend type: vxlan</span><br><span class="line">I0913 06:42:20.904195       1 match.go:206] Determining IP address of default interface</span><br><span class="line">I0913 06:42:20.904542       1 match.go:259] Using interface with name eth0 and address 172.31.10.19</span><br><span class="line">I0913 06:42:20.904570       1 match.go:281] Defaulting external address to interface address (172.31.10.19)</span><br><span class="line">I0913 06:42:20.904651       1 vxlan.go:138] VXLAN config: VNI=1 Port=0 GBP=false Learning=false DirectRouting=false</span><br><span class="line">E0913 06:42:20.904962       1 main.go:330] Error registering network: failed to acquire lease: node &quot;ops-kubernetes1&quot; pod cidr not assigned</span><br><span class="line">I0913 06:42:20.905100       1 main.go:447] Stopping shutdownHandler...</span><br><span class="line">W0913 06:42:20.905251       1 reflector.go:436] github.com/flannel-io/flannel/subnet/kube/kube.go:402: watch of *v1.Node ended with: an error on the server (&quot;unable to decode an event from the watch stream: context canceled&quot;) has prevented the request from succeeding</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>关键日志： <code>Error registering network: failed to acquire lease: node &quot;ops-kubernetes1&quot; pod cidr not assigned</code></p>
<p><strong>问题原因</strong> ： worker 节点的 flannel 组件无法正常获取 podCIDR 的定义</p>
<p><strong>解决方法</strong> ： 编辑控制节点上的配置文件 <code>/etc/kubernetes/manifests/kube-controller-manager.yaml</code>，在 <code>- command</code> 下添加以下内容：</p>
<figure class="highlight shell"><figcaption><span>/etc/kubernetes/manifests/kube-controller-manager.yaml</span></figcaption><table><tr><td class="code"><pre><span class="line">- --allocate-node-cidrs=true</span><br><span class="line">- --cluster-cidr=10.244.0.0/16</span><br></pre></td></tr></table></figure>
<p>如果内容已存在的话，更改 cidr 的网段和 <a href="#%E5%AE%89%E8%A3%85-kube-flannel"><code>kube-flannel.yml</code> 中的 cidr</a> 一致</p>
<p>更改配置后，重启所有节点的 <code>kubelet</code> 服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart kubelet</span><br></pre></td></tr></table></figure>
<p>重新查看所有 pod 状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods -A</span></span><br><span class="line">NAMESPACE      NAME                                      READY   STATUS    RESTARTS         AGE</span><br><span class="line">kube-flannel   kube-flannel-ds-7q2hp                     1/1     Running   62 (2m20s ago)   4h43m</span><br><span class="line">kube-flannel   kube-flannel-ds-k8wd6                     1/1     Running   55 (4m33s ago)   175m</span><br><span class="line">kube-flannel   kube-flannel-ds-x6ck2                     1/1     Running   38 (2m43s ago)   168m</span><br><span class="line">kube-system    coredns-565d847f94-b4sgn                  0/1     Running   0                5h19m</span><br><span class="line">kube-system    coredns-565d847f94-ml6k5                  0/1     Running   0                5h19m</span><br><span class="line">kube-system    etcd-ops-kubernetes1                      1/1     Running   0                5h19m</span><br><span class="line">kube-system    kube-apiserver-ops-kubernetes1            1/1     Running   0                5h19m</span><br><span class="line">kube-system    kube-controller-manager-ops-kubernetes1   1/1     Running   0                2m39s</span><br><span class="line">kube-system    kube-proxy-9vwxl                          1/1     Running   0                175m</span><br><span class="line">kube-system    kube-proxy-qxsc7                          1/1     Running   0                168m</span><br><span class="line">kube-system    kube-proxy-v5msf                          1/1     Running   0                5h19m</span><br><span class="line">kube-system    kube-scheduler-ops-kubernetes1            1/1     Running   0                5h19m</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="其他常用配置"><a href="#其他常用配置" class="headerlink" title="其他常用配置"></a>其他常用配置</h3><h4 id="将-CRI-由-containerd-变更为-Docker"><a href="#将-CRI-由-containerd-变更为-Docker" class="headerlink" title="将 CRI 由 containerd 变更为 Docker"></a>将 CRI 由 <code>containerd</code> 变更为 <code>Docker</code></h4><p>编辑 <code>/etc/sysconfig/kubelet</code> 文件，在该文件中可以添加 kubelet 启动参数</p>
<figure class="highlight shell"><figcaption><span>/etc/sysconfig/kubelet</span></figcaption><table><tr><td class="code"><pre><span class="line">KUBELET_EXTRA_ARGS=&quot;--container-runtime=docker --container-runtime-endpoint=unix:///var/run/cri-dockerd.sock</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>或者修改服务启动文件 <code>/usr/lib/systemd/system/kubelet.service.d/10-kubeadm.conf</code>，在 <code>[Service]</code> 模块中添加以下内容</p>
<figure class="highlight shell"><figcaption><span>/usr/lib/systemd/system/kubelet.service.d/10-kubeadm.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">Environment=&quot;KUBELET_EXTRA_ARGS=--container-runtime=docker --runtime-request-timeout=15m</span><br></pre></td></tr></table></figure>

<ul>
<li><code>--container-runtime</code> ：指定使用的容器运行时，可选值为 <code>docker</code> 或者 <code>remote</code>，默认是 <code>docker</code>，除 <code>docker</code> 之外的容器运行时都应该指定为 <code>remote</code>。</li>
<li><code>--container-runtime-endpoint</code> ： 是用来指定远程的运行时服务的 endpiont 地址的，在 Linux 系统中一般都是使用 unix 套接字的形式，<code>unix:///run/containerd/containerd.sock</code>。</li>
<li><code>--image-service-endpoint</code> ： 指定远程 CRI 的镜像服务地址，如果没有指定则默认使用 <code>--container-runtime-endpoint</code> 的值了，因为 CRI 都会实现容器和镜像服务的。</li>
</ul>
<p>配置完成后，重启 kubelet</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart kubelet </span><br></pre></td></tr></table></figure>

<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://kubernetes.io/zh-cn/docs/setup/production-environment/">Kubernetes 官网文档</a><br><a href="https://github.com/Mirantis/cri-dockerd">cri-dockerd 安装链接</a></p>
]]></content>
      <categories>
        <category>Docker</category>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 常用文件说明</title>
    <url>/202208180923/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Centos 7</li>
</ul>
<span id="more"></span>

<h3 id="常用文件说明"><a href="#常用文件说明" class="headerlink" title="常用文件说明"></a>常用文件说明</h3><table>
<thead>
<tr>
<th>文件路径</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;etc&#x2F;motd</td>
<td>登录成功后的欢迎信息，ssh 登录和 console 登录成功后都会显示</td>
<td></td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;issue</td>
<td>在登录系统输入用户名之前显示的信息，远程 ssh 连接的时候并不会显示此信息</td>
<td><a href="#x2F-etc-x2F-issue">说明示例</a></td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;services</td>
<td>记录网络服务名和它们对应使用的端口号及协议</td>
<td></td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;protocols</td>
<td>该文件是网络协议定义文件，里面记录了 <code>TCP/IP</code> 协议族的所有协议类型。文件中的每一行对应一个协议类型，它有3个字段，分别表示 <code>协议名称</code>、<code>协议号</code> 和 <code>协议别名</code></td>
<td></td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;vimrc<br/>~&#x2F;.vimrc</td>
<td><code>vim</code> 启动时会读取 <code>/etc/vimrc</code>（全局配置） 和 <code>~/.vimrc</code> （用户配置）</td>
<td><a href="/202208181117/" title="vim">vim</a></td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;passwd<br/>&#x2F;etc&#x2F;shadow<br/>&#x2F;etc&#x2F;group</td>
<td>用户数据库，其中记录了 <code>用户名</code>，<code>id</code>，<code>用户家目录</code>，<code>shell</code> 等<br/>用户密码文件<br/>组信息</td>
<td></td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;fstab</td>
<td>系统启动时需要自动挂载的文件系统列表</td>
<td></td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;mtab</td>
<td>当前系统已挂载的文件系统，并由 <code>mount</code> 命令自动更新。当需要当前挂载的文件系统的列表时使用(例如df命令)</td>
<td></td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;shells</td>
<td>系统可使用的 <code>shell</code></td>
<td></td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;filesystems</td>
<td>系统可使用的 <code>文件系统</code></td>
<td></td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;hostname</td>
<td>存放这主机名</td>
<td></td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;hosts</td>
<td>主机名查询静态表，域名和 ip 本地静态表</td>
<td></td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;nsswitch.conf</td>
<td>它规定通过哪些途径以及按照什么顺序以及通过这些途径来查找特定类型的信息，还可以指定某个方法奏效或失效时系统将采取什么动作</td>
<td><code>hosts:      files dns myhostname</code><br/>此配置设定：在查找域名解析的时候，先查找本地 <code>/etc/hosts</code>，再发送给 DNS 服务器查询</td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;rsyslog.conf</td>
<td><code>rsyslog</code> 服务的配置文件，用来托管其他服务的日志</td>
<td><a href="/202208191014/" title="linux rsyslog 服务">linux rsyslog 服务</a></td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;logrotate.conf</td>
<td>linux 日志切割工具</td>
<td><a href="/202208191317/" title="linux logrotate 服务">linux logrotate 服务</a></td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;rsyncd.conf</td>
<td><code>rsync</code> 服务的配置文件</td>
<td><a href="/36f703dc/" title="rsyncd 服务">rsyncd 服务</a></td>
</tr>
</tbody></table>
<h3 id="说明示例"><a href="#说明示例" class="headerlink" title="说明示例"></a>说明示例</h3><h4 id="x2F-etc-x2F-issue"><a href="#x2F-etc-x2F-issue" class="headerlink" title="&#x2F;etc&#x2F;issue"></a>&#x2F;etc&#x2F;issue</h4><p><img src="https://i.csms.tech/img_40.png"></p>
<p>文件内容可使用的各个变量说明如下</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>\d</td>
<td>显示当前日期</td>
</tr>
<tr>
<td>\l</td>
<td>显示虚拟控制台号</td>
</tr>
<tr>
<td>\m</td>
<td>显示机器类型，即 CPU 架构，如 i386 或 x86_64 等（相当于 uname -m）</td>
</tr>
<tr>
<td>\n</td>
<td>显示主机的网络名（相当于 uname -n）</td>
</tr>
<tr>
<td>\o</td>
<td>显示域名</td>
</tr>
<tr>
<td>\r</td>
<td>显示 Kernel 内核版本号（相当于 uname -r）</td>
</tr>
<tr>
<td>\t</td>
<td>显示当前时间</td>
</tr>
<tr>
<td>\s</td>
<td>显示当前操作系统名称</td>
</tr>
<tr>
<td>\u</td>
<td>显示当前登录用户的编号</td>
</tr>
<tr>
<td>\U</td>
<td>显示当前登录用户的编号和用户</td>
</tr>
<tr>
<td>\v</td>
<td>显示当前操作系统的版本日期</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux find 命令</title>
    <url>/202208180949/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Centos 7</li>
</ul>
<h3 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h3><p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find   path   -option   [ -print ]   [ -exec   -ok   command ]   &#123;&#125; \;</span><br></pre></td></tr></table></figure>
<p>常用查找选项（<code>-option</code>）：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>-amin n<br/>-amin +n<br/>-amin -n</td>
<td>在过去 n 分钟内被读取过<br/>更改时间超过 n<br/>更改时间在 n 以内</td>
<td></td>
</tr>
<tr>
<td>-anewer file</td>
<td>比文件 file 更晚被读取过的文件</td>
<td></td>
</tr>
<tr>
<td>-atime n</td>
<td>在过去 n 天内被读取过的文件</td>
<td></td>
</tr>
<tr>
<td>-cmin n</td>
<td>在过去 n 分钟内被修改过</td>
<td></td>
</tr>
<tr>
<td>-cnewer file</td>
<td>比文件 file 更新的文件</td>
<td></td>
</tr>
<tr>
<td>-ctime n</td>
<td>在过去 n 天内创建的文件</td>
<td></td>
</tr>
<tr>
<td>-mtime n</td>
<td>在过去 n 天内修改过的文件</td>
<td></td>
</tr>
<tr>
<td>-empty</td>
<td>空的文件</td>
<td></td>
</tr>
<tr>
<td>-gid n<br/>-group name</td>
<td>gid 是 n<br/>group 名称是 name</td>
<td></td>
</tr>
<tr>
<td>-user u</td>
<td>根据用户名查找</td>
<td></td>
</tr>
<tr>
<td>-nouser</td>
<td>属主不存在</td>
<td></td>
</tr>
<tr>
<td>-ipath p<br/>-path p</td>
<td>路径名称符合 p 的文件，ipath 会忽略大小写</td>
<td></td>
</tr>
<tr>
<td>-name name<br/> -iname name</td>
<td>文件名称符合 name 的文件。iname 会忽略大小写</td>
<td></td>
</tr>
<tr>
<td>-size n <br/>-size +n<br/>-size -n</td>
<td>文件大小 是 n 单位，b 代表 512 位元组的区块，c 表示字元数，k 表示 kilo bytes，w 是二个位元组。<br/>文件大小大于 n<br/>文件大小小于 n</td>
<td></td>
</tr>
<tr>
<td>-type c</td>
<td>文件类型是 c 的文件，c 包括：<br/>d : 目录<br/>c : 字符设备<br/>b : 块设备<br/> p : 通道设备<br/>f : 文件<br/>l : 链接文件<br/>s : socker</td>
<td></td>
</tr>
<tr>
<td>-pid n</td>
<td>process id 是 n 的文件</td>
<td></td>
</tr>
<tr>
<td>-perm 0644</td>
<td>权限</td>
<td></td>
</tr>
<tr>
<td>-maxdepth<br/>-mindepth</td>
<td>查找深度</td>
<td></td>
</tr>
</tbody></table>
<span id="more"></span>

<p>常用运算符：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>()</code></td>
<td>将运算表达式组合起来</td>
<td></td>
</tr>
<tr>
<td><code>-and</code></td>
<td>与</td>
<td></td>
</tr>
<tr>
<td><code>-or</code></td>
<td>或</td>
<td></td>
</tr>
<tr>
<td><code>-not</code></td>
<td>取反</td>
<td></td>
</tr>
<tr>
<td><code>!</code></td>
<td>非</td>
<td><code>find . ! -type f -print</code><br/><code>find . -anewer FILE1 ! -anewer FILE2</code></td>
</tr>
</tbody></table>
<p>常用子命令：</p>
<table>
<thead>
<tr>
<th>子命令</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>-print &#123;&#125; \;</code></td>
<td>默认命令，输出查找到的目标到标准输出</td>
<td></td>
</tr>
<tr>
<td><code>-exec command &#123;&#125; \;</code></td>
<td>对查找到的目标执行命令</td>
<td></td>
</tr>
<tr>
<td><code>-ok   command &#123;&#125; \;</code></td>
<td>和 <code>-exec</code> 一样，不过执行前先询问是否执行</td>
<td></td>
</tr>
</tbody></table>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>查找读取时间比文件 <code>FILE1</code> 晚，但又比文件 <code>FILE2</code> 早的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">`find . -anewer FILE1 ! -anewer FILE2`</span><br></pre></td></tr></table></figure>

<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3>]]></content>
      <categories>
        <category>Linux</category>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux logrotate 服务</title>
    <url>/202208191317/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Centos 7</li>
</ul>
<p><code>logrotate</code> 程序是一个日志文件管理工具。用于分割日志文件，压缩转存、删除旧的日志文件，并创建新的日志文件  </p>
<p><code>logrotate</code> 是基于 <code>crond</code> 来运行的，其脚本是 <code>/etc/cron.daily/logrotate</code>，日志轮转是系统自动完成的。<br>实际运行时，<code>logrotate</code> 会调用配置文件 <code>/etc/logrotate.conf</code>。<br><code>/etc/cron.daily/logrotate</code> 文件内容如下：</p>
<figure class="highlight shell"><figcaption><span>/etc/cron.daily/logrotate</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">/usr/sbin/logrotate -s /var/lib/logrotate/logrotate.status /etc/logrotate.conf</span><br><span class="line">EXITVALUE=$?</span><br><span class="line">if [ $EXITVALUE != 0 ]; then</span><br><span class="line">    /usr/bin/logger -t logrotate &quot;ALERT exited abnormally with [$EXITVALUE]&quot;</span><br><span class="line">fi</span><br><span class="line">exit 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以执行以下命令手动执行日志切割：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">logrotate -f /etc/logrotate.conf</span><br></pre></td></tr></table></figure>
<p>以下命令可以检测配置文件是否正确：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">logrotate -d /etc/logrotate.conf</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h3><p><code>logrotate</code> 的主配置文件默认为 <code>/etc/logrotate.conf</code>，默认配置如下：</p>
<figure class="highlight shell"><figcaption><span>/etc/logrotate.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认每一周执行一次 rotate 轮转工作</span></span><br><span class="line">weekly</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">保留多少个日志文件(轮转几次).默认保留四个.0 指没有备份</span></span><br><span class="line">rotate 4</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">自动创建新的日志文件，新的日志文件具有和原来的文件相同的权限；</span></span><br><span class="line">create</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这个参数很重要！就是切割后的日志文件以当前日期为格式结尾，如xxx.log-20131216这样,</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果注释掉,切割出来是按数字递增,即 xxx.log-1这种格式</span></span><br><span class="line">dateext</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">包含 /etc/logrotate.d 下的其他配置文件 ，用于隔离出各个服务的配置</span></span><br><span class="line">include /etc/logrotate.d</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">是否通过gzip压缩转储以后的日志文件，如xxx.log-20131216.gz ；如果不需要压缩，注释掉就行</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">compress</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">nocompress</span> </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">针对指定的文件做轮转切割</span></span><br><span class="line">/var/log/wtmp &#123;</span><br><span class="line">    # 每月轮转一次，取代全局默认值</span><br><span class="line">    monthly</span><br><span class="line">    </span><br><span class="line">    # 创建新文件，并指定权限，用户和组</span><br><span class="line">    create 0664 root utmp</span><br><span class="line">    </span><br><span class="line">    # 文件大小超过 1m 后才进行切割，到了 1 个月，文件大小小于 1m，不会进行切割</span><br><span class="line">	minsize 1M</span><br><span class="line">	</span><br><span class="line">    rotate 1</span><br><span class="line">&#125;</span><br><span class="line">/var/log/btmp &#123;</span><br><span class="line">    # 如果日志丢失，不报错继续滚动下一个日志</span><br><span class="line">    missingok</span><br><span class="line">    </span><br><span class="line">    monthly</span><br><span class="line">    create 0600 root utmp</span><br><span class="line">    rotate 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他常用选项说明如下：</p>
<figure class="highlight shell"><figcaption><span>/etc/logrotate.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定转储周期为每天</span></span><br><span class="line">daily </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">即使日志文件为空文件也做轮转，这个是 logrotate 的缺省选项。</span></span><br><span class="line">ifempty </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当日志文件为空时，不进行轮转</span></span><br><span class="line">notifempty </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当日志文件大于指定大小后就轮转，支持的单位： k，K，m，M</span></span><br><span class="line">size 5M</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用于还在打开中的日志文件，把当前日志备份并截断；</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">是先拷贝再清空的方式，拷贝和清空之间有一个时间差，可能会丢失部分日志数据。</span></span><br><span class="line">copytruncate</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行 postrotate 脚本，作用是在所有日志都轮转后统一执行一次脚本。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果没有配置这个，那么每个日志轮转后都会执行一次脚本</span></span><br><span class="line">sharedscripts                      </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 logrotate 转储之后需要执行的指令，例如重新启动 (<span class="built_in">kill</span> -HUP) 某个服务！必须独立成行</span></span><br><span class="line">postrotate                         </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 logrotate 转储之前需要执行的指令，例如修改文件的属性等动作；必须独立成行</span></span><br><span class="line">prerotate      </span><br><span class="line">                    </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将轮转的日志保存到指定路径下，默认保存在日志文件同一目录下</span></span><br><span class="line">olddir /data/logs/</span><br></pre></td></tr></table></figure>

<h3 id="配置示例"><a href="#配置示例" class="headerlink" title="配置示例"></a>配置示例</h3><p><code>nginx</code> 日志切割配置文件示例，创建 <code>/etc/logrotate.d/nginx</code>:</p>
<figure class="highlight shell"><figcaption><span>/etc/logrotate.d/nginx</span></figcaption><table><tr><td class="code"><pre><span class="line">/logs/nginx/access/*.log</span><br><span class="line">/logs/bginx/error/*.log &#123;</span><br><span class="line">    daily</span><br><span class="line">    compress</span><br><span class="line">    rotate 7</span><br><span class="line">    missingok</span><br><span class="line">    notifempty</span><br><span class="line">    dateext</span><br><span class="line">    sharedscripts</span><br><span class="line">    postrotate</span><br><span class="line">        if [ -f /run/nginx.pid ]; then</span><br><span class="line">                    kill -USR1 `cat /run/nginx.pid`</span><br><span class="line">        fi</span><br><span class="line">    endscript</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用 <code>copytruncate</code> 方式切割 <code>nginx</code> 日志，此种方式不需要重启 <code>nginx</code> 服务<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[logrotate 原理介绍和配置详解](https://wsgzao.github.io/post/logrotate/)
">[1]</span></a></sup></p>
<figure class="highlight shell"><figcaption><span>/etc/logrotate.d/nginx</span></figcaption><table><tr><td class="code"><pre><span class="line">/logs/nginx/access/*.log</span><br><span class="line">/logs/bginx/error/*.log &#123;</span><br><span class="line">    copytruncate</span><br><span class="line">    daily</span><br><span class="line">    compress</span><br><span class="line">    rotate 7</span><br><span class="line">    missingok</span><br><span class="line">    notifempty</span><br><span class="line">    dateext</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://wsgzao.github.io/post/logrotate/">logrotate 原理介绍和配置详解</a></p>
<h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://wsgzao.github.io/post/logrotate/">logrotate 原理介绍和配置详解</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>logrotate</tag>
      </tags>
  </entry>
  <entry>
    <title>linux rsyslog 服务</title>
    <url>/202208191014/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Centos 7</li>
</ul>
<p>系统默认的日志托管服务，部分系统服务（如 <code>crond</code>, 邮件系统，安全审计等）会将日志发送给 <code>rsyslog</code> 服务来进行日志管理。</p>
<p><code>rsyslog</code> 服务是依赖其配置文件 <code>/etc/rsyslog.conf</code> 来确定哪个服务的什么等级的日志信息会被记录在哪个位置的。也就是说，日志服务的配置文件中主要定义了服务的名称、日志等级和日志记录位置。</p>
<span id="more"></span>

<h3 id="配置文件说明"><a href="#配置文件说明" class="headerlink" title="配置文件说明"></a>配置文件说明</h3><p>默认配置文件(<code>/etc/rsyslog.conf</code>)内容如下</p>
<figure class="highlight shell"><figcaption><span>/etc/rsyslog.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载指定模块</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">ModLoad imuxsock <span class="comment"># provides support for local system logging (e.g. via logger command)</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">ModLoad imjournal <span class="comment"># provides access to the systemd journal</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">放置 rsyslog 辅助文件的路径</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">WorkDirectory /var/lib/rsyslog</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">时间格式</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">ActionFileDefaultTemplate RSYSLOG_TraditionalFileFormat</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">包含其他配置</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">IncludeConfig /etc/rsyslog.d/*.conf</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">OmitLocalLogging on</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">IMJournalStateFile imjournal.state</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">日志记录规则</span></span><br><span class="line">*.info;mail.none;authpriv.none;cron.none                /var/log/messages</span><br><span class="line">authpriv.*                                              /var/log/secure</span><br><span class="line">mail.*                                                  -/var/log/maillog</span><br><span class="line">cron.*                                                  /var/log/cron</span><br><span class="line">*.emerg                                                 :omusrmsg:*</span><br><span class="line">uucp,news.crit                                          /var/log/spooler</span><br><span class="line">local7.*                                                /var/log/boot.log</span><br></pre></td></tr></table></figure>

<p>其中最为关键的部分是日志记录规则，其配置格式如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务名称 连接符号 日志等级               日志记录位置</span></span><br><span class="line">authpriv.*                                              /var/log/secure</span><br></pre></td></tr></table></figure>
<p>以上配置，指定认证相关服务 (<code>authpriv</code>) 的所有等级的日志，记录在 <code>/var/log/secure</code> 日志中</p>
<p>多个服务可以指定同一个<code>日志记录位置</code>，多个 <code>服务名称 连接符号 日志等级</code> 中间使用 <code>;</code> 分割  </p>
<figure class="highlight shell"><figcaption><span>/etc/rsyslog.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">*.info;mail.none;authpriv.none;cron.none                /var/log/messages</span><br></pre></td></tr></table></figure>
<p>多个服务也可以共用同一个 <code>日志等级</code>，格式如下，多个 <code>服务名称</code> 使用 <code>,</code> 分割</p>
<figure class="highlight shell"><figcaption><span>/etc/rsyslog.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">uucp,news.crit                                          /var/log/spooler</span><br></pre></td></tr></table></figure>

<p><code>rsyslog</code> 服务可识别的服务如下</p>
<table>
<thead>
<tr>
<th>服务</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>auth</td>
<td>安全和认证相关消息 (不推荐使用 <code>authpriv</code> 替代）</td>
</tr>
<tr>
<td>authpirv</td>
<td>安全和认证相关信息（私有的）</td>
</tr>
<tr>
<td>cron</td>
<td>系统定时任务 <code>cront</code> 和 <code>at</code> 产生的日志</td>
</tr>
<tr>
<td>daemon</td>
<td>和各个守护进程相关的日志</td>
</tr>
<tr>
<td>ftp</td>
<td>ftp守护进程产生的日志</td>
</tr>
<tr>
<td>kern</td>
<td>内核产生的日志（不是用户进程产生的）</td>
</tr>
<tr>
<td>local0-local7</td>
<td>为本地使用预留的服务</td>
</tr>
<tr>
<td>lpr</td>
<td>打印机产生的日志</td>
</tr>
<tr>
<td>mail</td>
<td>邮件收发信息</td>
</tr>
<tr>
<td>news</td>
<td>与新闻服务器相关的日志</td>
</tr>
<tr>
<td>syslog</td>
<td>有 <code>rsyslog</code> 服务产生的日志信息（虽然服务名称已经改为 <code>rsyslog</code> 服务，但是很多配置都还是沿用了 <code>syslogd</code> 的，这里并没有修改服务名）</td>
</tr>
<tr>
<td>user</td>
<td>用户等级类别的日志信息</td>
</tr>
<tr>
<td>uucp</td>
<td><code>uucp</code> 子系统的日志信息，<code>uucp</code> 是早期 Linux 系统进行数据传递的协议，后来也经常用在新闻组服务中。</td>
</tr>
</tbody></table>
<p><code>rsyslog</code> 服务配置中可使用的连接符号如下</p>
<table>
<thead>
<tr>
<th>连接符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>.</code></td>
<td>代表只要比后面的等级高的（包含该等级）日志都记录下来。比如： <code>cron.info</code> 代表 <code>crond</code> 服务产生的日志，只要日志等级大于等于 <code>info</code> 级别，就记录。</td>
</tr>
<tr>
<td><code>.=</code></td>
<td>代表只记录所需等级的日志，其他等级的都不记录。比如： <code>*.=emerg</code> 代表任何日志服务产生的日志，只要等级是 <code>emerg</code> 等级就记录。</td>
</tr>
<tr>
<td><code>.!</code></td>
<td>代表不等于，也就是除了该等级的日志外，其他等级的日志都记录。</td>
</tr>
</tbody></table>
<p><code>rsyslog</code> 服务配置中可使用的日志等级如下</p>
<table>
<thead>
<tr>
<th>日志等级</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>debug</td>
<td>一般的调试信息说明</td>
</tr>
<tr>
<td>info</td>
<td>基本的通知信息</td>
</tr>
<tr>
<td>notice</td>
<td>普通信息，但是有一定的重要性</td>
</tr>
<tr>
<td>warning</td>
<td>警告信息，但是还不会影响到服务或系统的运行</td>
</tr>
<tr>
<td>err</td>
<td>错误信息，一般达到 <code>err</code> 等级的信息以及可以影响到服务或系统的运行了</td>
</tr>
<tr>
<td>crit</td>
<td>临界状况信息，比 <code>err</code> 等级还要严重</td>
</tr>
<tr>
<td>alert</td>
<td>警告状态信息，比 <code>crit</code> 还要严重。必须立即采取行动</td>
</tr>
<tr>
<td>emerg</td>
<td>致命（毁灭）等级信息，系统已经无法使用了</td>
</tr>
<tr>
<td>*</td>
<td>代表所有等级的日志</td>
</tr>
<tr>
<td>none</td>
<td>忽略这个日志服务，该服务的所有日志都不再记录</td>
</tr>
</tbody></table>
<p>可用的 <code>日志记录位置</code> 如下</p>
<table>
<thead>
<tr>
<th>日志记录位置</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>/var/log/secure</code></td>
<td>日志文件的绝对路径</td>
<td><code>/var/log/secure</code></td>
</tr>
<tr>
<td><code>/dev/lp0</code></td>
<td>系统设备文件</td>
<td>如 <code>/dev/lp0</code> 代表第一台打印机，如果日志保存位置是打印机设备，当有日志时就会在打印机上打印。</td>
</tr>
<tr>
<td>远程主机</td>
<td>可以选择使用 <code>TCP</code> (<code>@@192.168.0.210：514</code>) 和 <code>UDP</code> (<code>@192.168.0.210：514</code>) 协议传输日志信息</td>
<td></td>
</tr>
</tbody></table>
<p><code>日志记录位置</code> 之前可以加以下符号：</p>
<ul>
<li><code>-</code>  ： 表示延迟写入</li>
</ul>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3>]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>rsyslog</tag>
      </tags>
  </entry>
  <entry>
    <title>linux tcp_wrappers 详解</title>
    <url>/202208171106/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Centos 7</li>
</ul>
<p><code>TCP_wrappers</code> 主要是工作在应用层的一个安全工具，使用访问控制列表（<code>ACL</code>）来防止主机名和主机地址的欺骗，用于过滤对 <code>类 Unix</code> 系统的网络访问。  </p>
<p>在一个安全的系统中，<code>Linux</code> 自身具有两层安全的防火墙。第一层是通过 IP&#x2F;Port 过滤机制的 <code>iptables</code> 来实现，第二层，也就是 <code>TCP_wrappers</code> 了，它主要是通过对系统中的某些服务进行开放与关闭，允许和禁止来有效保证系统安全运行。<br>可以简单理解为 <code>Linux</code> 系统访问控制的流程：  </p>
<blockquote>
<p>Client -&gt; iptables -&gt; TCP_wrappers -&gt; Server 的访问控制</p>
</blockquote>
<ul>
<li>iptables ：基于源 IP&#x2F;端口、目的 IP&#x2F;端口进行访问控制</li>
<li>TCP_wrappers：基于服务自身运行情况进行访问控制</li>
<li>Server：基于服务器本身行为包括文件、目录等权限进行访问控制</li>
</ul>
<span id="more"></span>

<h3 id="TCP-wrappers-的工作原理"><a href="#TCP-wrappers-的工作原理" class="headerlink" title="TCP_wrappers 的工作原理"></a>TCP_wrappers 的工作原理</h3><p><code>TCP_wrappers</code> 通过访问控制列表来提供保护机制，同时依赖 <code>/etc/hosts.allow</code> 和 <code>/etc/hosts.deny</code> 配置文件所设定的规则转交给相应的守护进程进行处理，同时记录请求过程。</p>
<p><code>TCP_wrappers</code> 在对报文做过滤操作的过程中，会链接到 <code>TCP_wrappers</code> 的函数库， <code>TCP_wrappers</code> 的主要功能是来自于 <code>libwrap.a</code> 这个静态库。</p>
<p>服务是否可以使用 <code>TCP_wrappers</code> 进行安全防护，取决于服务程序在编译时是否针对 <code>libwrap</code> 进行编译，如果库文件中有 <code>libwrap.so</code> 文件，就可以实现访问控制</p>
<p>可以通过下面的命令来确定要过滤的服务是否已经链接到了 <code>libwrap</code> 这个函数库中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ldd /usr/sbin/sshd | grep libwrap</span></span><br><span class="line">	libwrap.so.0 =&gt; /lib64/libwrap.so.0 (0x00007f283cdf1000)</span><br></pre></td></tr></table></figure>

<p>当客户端的 IP 通过了安全系统中第一层（iptables 防火墙），想要进一步访问服务器资源时，系统就会由 <code>TCP_wrappers</code> 来对请求进行分析处理，根据服务设定的规则来查看这个请求是否存在于 <code>/etc/hosts.allow</code> 列表中，如果存在就接受；如果不存在就继续对比 <code>/etc/hosts/deny</code> 列表，如果存在于 <code>hosts.deny</code> 中就拒绝 IP 请求，反之则接受请求。  </p>
<p><strong>判断规则的文件顺序必须严格按照先 <code>hosts.allow</code> 再 <code>hosts.deny</code> 的顺序进行判断。同时，<code>TCP_wrappers</code> 不会缓存 <code>hosts.allow</code> 和 <code>hosts.deny</code> 中的规则，所以针对 <code>hosts.allow</code> 和 <code>hosts.deny</code> 中规则的更改是立即生效的。</strong></p>
<h3 id="TCP-wrappers-的配置"><a href="#TCP-wrappers-的配置" class="headerlink" title="TCP_wrappers 的配置"></a>TCP_wrappers 的配置</h3><p><code>TCP_wrappers</code> 实现防火墙的功能主要是依靠 <code>/etc/hosts.allow</code> 和 <code>/etc/hosts.deny</code> 这两个文件的。<code>/etc/hosts.allow</code> 主要是定义允许访问，<code>/etc/hosts.deny</code> 用来定义拒绝访问。  </p>
<p>配置文件中的配置格式如下，格式说明可以参考 <code>man 5 hosts_options</code></p>
<figure class="highlight shell"><figcaption><span>/etc/hosts.allow</span></figcaption><table><tr><td class="code"><pre><span class="line">daemon_list[@host] : client_list : option : option ...</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>daemon_list</code> ： 服务名，例如：sshd、vsftpd、sendmail 等，多个服务之间使用逗号分割。</li>
<li><code>client_list</code> : IP 或 IP 段或主机名。（列表中存在多个服务或者主机的时候用 , 逗号分隔开）</li>
<li><code>option</code> : 包括对匹配规则的 <code>action</code>， 最主要的有 <code>allow</code> 或 <code>deny</code>（这个可以忽略不写）</li>
</ul>
<p>例如，配置限制 <code>192.168.0.0/16</code> 网段不能 <code>ssh</code> 到本机的 <code>sshd</code> 服务</p>
<figure class="highlight shell"><figcaption><span>/etc/hosts.deny</span></figcaption><table><tr><td class="code"><pre><span class="line">sshd:192.168.</span><br></pre></td></tr></table></figure>
<p>如上配置后，指定网段不能 <code>ssh</code> 到本机  </p>
<p>配置后有问题，可以查看日志文件 <code>/var/log/secure</code>，如配置有问题，日志中会记录相关日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /var/log/secure</span></span><br><span class="line">sshd[7699]: error: /etc/hosts.allow, line 12: bad option name: &quot;%d&quot;&quot;</span><br></pre></td></tr></table></figure>

<h4 id="配置文件中-daemon-list-常用格式"><a href="#配置文件中-daemon-list-常用格式" class="headerlink" title="配置文件中 daemon_list 常用格式"></a>配置文件中 daemon_list 常用格式</h4><table>
<thead>
<tr>
<th>格式</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>ALL</code></td>
<td>完全匹配，适配所有接受 <code>TCP_wrappers</code> 防护的服务</td>
<td></td>
</tr>
<tr>
<td><code>service1</code><br/><code>service1,service2</code><br/><code>service1@172.16.1.2</code></td>
<td>指定服务<br/>多个服务使用逗号分割<br/>针对本机的某个 ip 做限制</td>
<td><code>sshd,vsftpd:192.168.1.:allow</code></td>
</tr>
</tbody></table>
<h4 id="配置文件中-client-list-常用格式"><a href="#配置文件中-client-list-常用格式" class="headerlink" title="配置文件中 client_list 常用格式"></a>配置文件中 client_list 常用格式</h4><table>
<thead>
<tr>
<th>格式</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>ALL</code></td>
<td>完全匹配，适配所有客户端</td>
<td></td>
</tr>
<tr>
<td><code>.HOSTNAME</code></td>
<td>适配整个域</td>
<td><code>sshd:.csms.tech:allow</code>，允许 <a href="https://csms.tech/"><code>csms.tech</code></a> 内的所有主机访问</td>
</tr>
<tr>
<td><code>192.168.</code><br/><code>192.168.0.0/255.255.0.0</code><br/><code>192.168.0.0/16</code></td>
<td>适配整个网段，会匹配到 <code>192.168.0.0/16</code> 网段</td>
<td></td>
</tr>
<tr>
<td><code>172.16. EXCEPT 172.16.100.0/24</code></td>
<td>排除部分客户端</td>
<td><code>172.16. EXCEPT 172.16.100.0/24 EXCEPT 172.16.10.1</code></td>
</tr>
</tbody></table>
<h4 id="配置文件中-option-常用格式"><a href="#配置文件中-option-常用格式" class="headerlink" title="配置文件中 option 常用格式"></a>配置文件中 option 常用格式</h4><table>
<thead>
<tr>
<th>格式</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>allow</code></td>
<td>主要用在 <code>/etc/hosts.deny</code> 定义 <code>允许</code> 规则</td>
<td></td>
</tr>
<tr>
<td><code>deny</code></td>
<td>主要用在 <code>/etc/hosts.allow</code> 定义 <code>拒绝</code> 规则</td>
<td></td>
</tr>
<tr>
<td><code>spawn</code></td>
<td>启动一个外部程序(<code>shell</code>)完成指定的命令</td>
<td></td>
</tr>
<tr>
<td><code>twist</code></td>
<td>替换客户端的请求成我们指定的命令，会导致服务拒绝，即使写在 <code>/etc/hosts.allow</code></td>
<td></td>
</tr>
</tbody></table>
<h5 id="spawn-示例"><a href="#spawn-示例" class="headerlink" title="spawn 示例"></a>spawn 示例</h5><p>在 <code>/etc/hosts.allow</code> 中添加以下内容</p>
<figure class="highlight shell"><figcaption><span>/etc/hosts.allow</span></figcaption><table><tr><td class="code"><pre><span class="line">sshd: ALL :\</span><br><span class="line">         spawn echo $(date +%%F) login attempt from %c to %s,%d &gt;&gt;/var/log/sshd.log</span><br></pre></td></tr></table></figure>
<p>以上配置，会在客户端 ssh 登录时记录日志  </p>
<p>其中，可以变量包含以下</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>%a</code></td>
<td>客户端的 IP 地址</td>
</tr>
<tr>
<td><code>%A</code></td>
<td>服务端的 IP 地址</td>
</tr>
<tr>
<td><code>%d	</code></td>
<td>守护进程的名字</td>
</tr>
<tr>
<td><code>%h</code></td>
<td>客户端的主机名</td>
</tr>
<tr>
<td><code>%H</code></td>
<td>服务端的主机名</td>
</tr>
<tr>
<td><code>%p</code></td>
<td>守护进程的 pid</td>
</tr>
<tr>
<td><code>%u</code></td>
<td>客户端的用户名</td>
</tr>
</tbody></table>
<h5 id="twist-示例"><a href="#twist-示例" class="headerlink" title="twist 示例"></a>twist 示例</h5><p>在 <code>/etc/hosts.allow</code> 中添加以下内容</p>
<figure class="highlight shell"><figcaption><span>/etc/hosts.allow</span></figcaption><table><tr><td class="code"><pre><span class="line">vsftpd: 172.16.0.1 :twist /bin/echo “connection prohibited”</span><br></pre></td></tr></table></figure>

<p>以上配置会将客户端的请求替换成 <code>twist</code> 指定的命令，因此客户端无法使用指定的服务，即使配置在 <code>/etc/hosts.allow</code> 中</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://m-zhoujie2.gitbooks.io/-linux-devops-2/content/chapter3-5.html">TCP wrappers</a></p>
<p><a href="https://www.cnblogs.com/duzhaoqi/p/7607801.html">TCP_Wrappers</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>tcp_wrappers</tag>
      </tags>
  </entry>
  <entry>
    <title>LVM 逻辑卷管理</title>
    <url>/202208021256/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>LVM是 Logical Volume Manager(逻辑卷管理)的简写,LVM将一个或多个硬盘或分区在逻辑上集合，相当于一个大硬盘来使用，当硬盘的空间不够使用的时候，可以继续将其它的硬盘或分区加入其中，这样可以实现磁盘空间的动态管理，相对于普通的磁盘分区有很大的灵活性。与传统的磁盘与分区相比，LVM为计算机提供了更高层次的磁盘存储。它使系统管理员可以更方便的为应用与用户分配存储空间。  </p>
<blockquote>
<p><strong><code>/boot</code> 分区不可以在逻辑卷组上,否则bootloader会无法读取.</strong></p>
</blockquote>
<span id="more"></span>

<h3 id="LVM-原理简介"><a href="#LVM-原理简介" class="headerlink" title="LVM 原理简介"></a>LVM 原理简介</h3><p>单一硬盘系统的 LVM 基本原理如下图所示<br><img src="https://i.csms.tech/img_23.png"></p>
<p>多硬盘系统的 LVM 基本原理如下图所示<br><img src="https://i.csms.tech/img_24.png"><br><img src="https://i.csms.tech/img_25.png"></p>
<h4 id="基本概念说明"><a href="#基本概念说明" class="headerlink" title="基本概念说明"></a>基本概念说明</h4><h5 id="PV（Physical-Volume）-物理卷"><a href="#PV（Physical-Volume）-物理卷" class="headerlink" title="PV（Physical Volume）- 物理卷"></a>PV（Physical Volume）- 物理卷</h5><p>物理卷在逻辑卷管理中处于最底层，它可以是实际物理硬盘上的分区，也可以是整个物理硬盘，也可以是raid设备,是LVM的基本存储逻辑块，但和基本的物理存储介质(如分区、磁盘等)比较，却包含有与LVM相关的管理参数。  </p>
<p>PE（physical extent）：每一个物理卷被划分为称为PE(Physical Extents)的基本单元，具有唯一编号的PE是可以被LVM寻址的最小单元。PE的大小是在VG过程中配置的，默认为4MB。</p>
<h5 id="VG（Volumne-Group）-卷组"><a href="#VG（Volumne-Group）-卷组" class="headerlink" title="VG（Volumne Group）- 卷组"></a>VG（Volumne Group）- 卷组</h5><p>卷组建立在物理卷之上，一个卷组中至少要包括一个物理卷，在卷组建立之后可动态添加物理卷到卷组中。一个逻辑卷管理系统工程中可以只有一个卷组，也可以拥有多个卷组。  </p>
<h5 id="LV（Logical-Volume）-逻辑卷"><a href="#LV（Logical-Volume）-逻辑卷" class="headerlink" title="LV（Logical Volume）- 逻辑卷"></a>LV（Logical Volume）- 逻辑卷</h5><p>逻辑卷建立在卷组之上，卷组中的未分配空间可以用于建立新的逻辑卷，逻辑卷建立后可以动态地扩展和缩小空间。系统中的多个逻辑卷可以属于同一个卷组，也可以属于不同的多个卷组。</p>
<h3 id="LVM-基本操作"><a href="#LVM-基本操作" class="headerlink" title="LVM 基本操作"></a>LVM 基本操作</h3><h4 id="创建-PV-常用操作命令"><a href="#创建-PV-常用操作命令" class="headerlink" title="创建 PV 常用操作命令"></a>创建 PV 常用操作命令</h4><p>将空闲分区 <code>/dev/vdb1</code> 配置为可用的 PV（Physical Volume）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pvcreate /dev/vdb1</span><br></pre></td></tr></table></figure>
<p>将空闲磁盘 <code>/dev/vdd</code> 配置为可用的 PV（Physical Volume）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pvcreate /dev/vdd </span><br></pre></td></tr></table></figure>
<p>查看 PV 的信息，常用以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pvs</span><br><span class="line">pvscan</span><br><span class="line">pvdisplay</span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_26.png"><br><img src="https://i.csms.tech/img_27.png"></p>
<h4 id="创建-VG-常用操作命令"><a href="#创建-VG-常用操作命令" class="headerlink" title="创建 VG 常用操作命令"></a>创建 VG 常用操作命令</h4><p>使用已有的PV ，创建卷组（Volumne Group）名为 <code>VG1</code> 的 VG</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vgcreate VG1 /dev/vdb1 /dev/vdd</span><br></pre></td></tr></table></figure>

<p>查看 VG 的信息，常用以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vgs</span><br><span class="line">vgscan</span><br><span class="line">vgdisplay</span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_28.png"><br><img src="https://i.csms.tech/img_29.png"></p>
<h4 id="创建-LV-常用操作命令"><a href="#创建-LV-常用操作命令" class="headerlink" title="创建 LV 常用操作命令"></a>创建 LV 常用操作命令</h4><p>使用已有的卷组 VG1 ，创建逻辑卷（Logical Volume）名为 <code>data</code> 的 LV，并配置 <code>data</code> 逻辑卷的大小为1000m</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lvcreate -L 1000M -n data VG1</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>-L|--size</code>  指定逻辑卷的大小</p>
</blockquote>
<p>查看 LV 的信息，常用以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lvs</span><br><span class="line">lvscan</span><br><span class="line">lvdisplay</span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_30.png"><br><img src="https://i.csms.tech/img_31.png"></p>
<blockquote>
<p><strong>逻辑卷无法直接使用，必须格式化挂载之后才能使用</strong><br>逻辑卷的引用需要逻辑卷的设备文件, 逻辑卷的设备文件有两种书写形式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/dev/vg_name/lv_name</span><br><span class="line">/dev/mapper/vg_name-lv_name</span><br></pre></td></tr></table></figure>
<p>格式化 LV 并挂载，正确的挂载后，可正常使用新加的磁盘空间</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkfs.xfs /dev/VG1/data</span><br><span class="line">mount /dev/VG1/data /data</span><br></pre></td></tr></table></figure>
<p>为了防止系统重启后挂载失效，需要将挂载信息写入配置文件 <code>/etc/fstab</code></p>
<figure class="highlight shell"><figcaption><span>/etc/fstab</span></figcaption><table><tr><td class="code"><pre><span class="line">/dev/VG1/data /data xfs defaults 0 0</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="LVM-扩容操作"><a href="#LVM-扩容操作" class="headerlink" title="LVM 扩容操作"></a>LVM 扩容操作</h4><h5 id="VG-扩容"><a href="#VG-扩容" class="headerlink" title="VG 扩容"></a>VG 扩容</h5><p>使用已有的 PV ，或者 <a href="#%E5%88%9B%E5%BB%BA-PV-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4">新建 PV</a> 来扩容已有的 VG, 假设用来扩容的 PV 为 <code>/dev/vde</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vgextend VG1 /dev/vde</span><br></pre></td></tr></table></figure>

<h5 id="LV-扩容"><a href="#LV-扩容" class="headerlink" title="LV 扩容"></a>LV 扩容</h5><p>使用 VG 的空闲空间扩容 LV<br>指定要扩容的大小</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lvextend -L +100m /dev/VG1/data</span><br></pre></td></tr></table></figure>
<p>或者直接通过指定 PV 扩容 LV， 整个 PV 的空间被扩容到 LV， 前提是 PV 已被扩容到了 VG</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lvextend /dev/VG1/data /dev/vde</span><br></pre></td></tr></table></figure>
<p>其他扩容方式可查看命令帮助 <code>lvextend -h</code>  </p>
<p>扩容 LV 后需要重新调整分区文件系统大小</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">resize2fs /dev/VG1/data</span><br></pre></td></tr></table></figure>
<p><code>xfs</code> 文件系统需要使用以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xfs_growfs /dev/VG1/data</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>LVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql常见错误</title>
    <url>/22072111/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息说明"><a href="#环境信息说明" class="headerlink" title="环境信息说明"></a>环境信息说明</h3><ul>
<li>默认mysql版本5.7</li>
<li>Centos 7</li>
</ul>
<span id="more"></span>

<h3 id="错误集锦"><a href="#错误集锦" class="headerlink" title="错误集锦"></a>错误集锦</h3><h4 id="MySQL主从不同步，尝试跳过执行错误的事务"><a href="#MySQL主从不同步，尝试跳过执行错误的事务" class="headerlink" title="MySQL主从不同步，尝试跳过执行错误的事务"></a>MySQL主从不同步，尝试跳过执行错误的事务</h4><p>执行以下命令，可跳过对应的slave事务</p>
<figure class="highlight shell"><figcaption><span>slave</span></figcaption><table><tr><td class="code"><pre><span class="line">stop slave;</span><br><span class="line">SET GLOBAL SQL_SLAVE_SKIP_COUNTER = 1;</span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure>
<p>可以通过分析主库日志中的事务，来确定 <code>SQL_SLAVE_SKIP_COUNTER</code> 的合适值。<br>具体步骤如下：<br>在slave库中执行 <code>show slave status\G</code> ，确认以下两个参数:<br>    - Relay_Master_Log_File<br>    - Exec_Master_Log_Pos<br>或者以下2个参数：<br>    - Master_Log_File<br>    - Read_Master_Log_Pos<br><img src="https://i.csms.tech/img_11.png"></p>
<blockquote>
<p>通过以上2个值，可以知道当前slave执行到了master对应的哪个binlog文件(Relay_Master_Log_File)以及文件中的对应位置(Exec_Master_Log_Pos )</p>
</blockquote>
<p>根据上述两个参数的值，在master中可以查看当前阻碍从库复制的事务以及之后的事务。可以执行以下命令查看</p>
<figure class="highlight shell"><figcaption><span>master</span></figcaption><table><tr><td class="code"><pre><span class="line">SHOW BINLOG EVENTS in &#x27;mysql-bin.001015&#x27; from 366269088;</span><br></pre></td></tr></table></figure>
<p>这个可以查看到对应日志文件mysql-bin.001015中，事务ID为366269088之后的所有事务，<br>以下命令可以限制查询条数</p>
<figure class="highlight shell"><figcaption><span>master</span></figcaption><table><tr><td class="code"><pre><span class="line">SHOW BINLOG EVENTS in &#x27;mysql-bin.001015&#x27; from 366269088 limit 10;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="主从具有相同的server-uuid"><a href="#主从具有相同的server-uuid" class="headerlink" title="主从具有相同的server-uuid"></a>主从具有相同的server-uuid</h4><p><strong>报错信息</strong>：</p>
<blockquote>
<p>Fatal error: The slave I&#x2F;O thread stops because master and slave have equal MySQL server UUIDs; these UUIDs must be different for replication to work</p>
</blockquote>
<p><strong>问题原因</strong>： 主从数据目录(默认<code>/var/lib/mysql/</code>)都有一个auto.cnf文件，里面记录的server-uuid是相同的，在云主机clone的场景可能会出现此问题。</p>
<p><strong>解决方法</strong>： 修改auto.cnf文件中<code>uuid</code>的值，重启Mysql服务即可</p>
<p>查询uuid的方式，登录mysql，执行以下命令查看</p>
<figure class="highlight shell"><figcaption><span>mysql</span></figcaption><table><tr><td class="code"><pre><span class="line">select uuid();</span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_12.png"></p>
<hr>
<h4 id="主从具有相同的server-id"><a href="#主从具有相同的server-id" class="headerlink" title="主从具有相同的server-id"></a>主从具有相同的server-id</h4><p><strong>报错信息</strong>：</p>
<blockquote>
<p>Fatal error: The slave I&#x2F;O thread stops because master and slave have equal MySQL server ids; </p>
</blockquote>
<p><strong>问题原因</strong>： 主从配置文件中配置了同样的 <code>server-id</code></p>
<p><strong>解决方法</strong>： 修改<code>my.cnf</code>， 主从配置不同的<code>server-id</code></p>
<hr>
<h4 id="主从同步错误-1032"><a href="#主从同步错误-1032" class="headerlink" title="主从同步错误 1032"></a>主从同步错误 1032</h4><p><strong>报错信息</strong>：</p>
<blockquote>
<p>Could not execute Update_rows event on table ceshi.bbs_online; Can’t find record in ‘bbs_online’, Error_code: 1032; handler error HA_ERR_KEY_NOT_FOUND; the event’s master log mysql-bin.001423, end_log_pos 866646715</p>
</blockquote>
<p><strong>问题原因</strong>： 主从不同步，从数据库中记录被删除或者未同步到从库，主数据库中存在记录，主DB更新后，从无法同步</p>
<p><strong>解决方法1</strong>： 重新备份 master DB，恢复到slave，重新<a href="/94ee2c23/" title="恢复主从">恢复主从</a></p>
<p><strong>解决方法2</strong>： 找出丢失的数据在slave上插入。可以通过<a href="#MySQL%E4%B8%BB%E4%BB%8E%E4%B8%8D%E5%90%8C%E6%AD%A5%EF%BC%8C%E5%B0%9D%E8%AF%95%E8%B7%B3%E8%BF%87%E6%89%A7%E8%A1%8C%E9%94%99%E8%AF%AF%E7%9A%84%E4%BA%8B%E5%8A%A1">分析出错的binlog找出丢失的记录</a></p>
<hr>
<h4 id="主从同步错误-1396"><a href="#主从同步错误-1396" class="headerlink" title="主从同步错误 1396"></a>主从同步错误 1396</h4><p><strong>报错信息</strong>：</p>
<blockquote>
<p>ERROR 1396 (HY000): Operation CREATE USER failed for ‘XXXX‘@’XXXX’</p>
</blockquote>
<p><strong>问题原因</strong>： slave同步时，从数据库中已存在用户</p>
<p><strong>解决方法</strong>： slave上删除已存在的用户</p>
<hr>
<h4 id="主从同步错误-1062"><a href="#主从同步错误-1062" class="headerlink" title="主从同步错误 1062"></a>主从同步错误 1062</h4><p><strong>报错信息</strong>：</p>
<blockquote>
<p>Last_SQL_Error: Could not execute Write_rows event on table *;<br>    Duplicate entry ‘2’ for key ‘PRIMARY’,<br>Error_code: 1062;<br>handler error HA_ERR_FOUND_DUPP_KEY; the event’s master log mysql-bin.000006, end_log_pos 924</p>
</blockquote>
<p><strong>问题原因</strong>： slave上已有该记录，master上又插入，可能存在主从数据不一致</p>
<p><strong>解决方法</strong>： 删除slave上重复的主键记录</p>
<hr>
<h4 id="主从同步错误-1042"><a href="#主从同步错误-1042" class="headerlink" title="主从同步错误 1042"></a>主从同步错误 1042</h4><p><strong>报错信息</strong>：</p>
<blockquote>
<p>error code 1042 (ER_BAD_HOST_ERROR): Can’t get hostname for your address</p>
</blockquote>
<p><strong>问题原因</strong>： 解析主机名失败</p>
<p><strong>解决方法</strong>： mysql配置（<code>my.cnf</code>）中设置 <code>skip-name-resolve</code></p>
<p>使用以下命令解析mysql错误码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">perror 1042</span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_13.png"></p>
<hr>
<h4 id="导出导入数据错误-1290"><a href="#导出导入数据错误-1290" class="headerlink" title="导出导入数据错误 1290"></a>导出导入数据错误 1290</h4><p><strong>报错场景</strong>： 使用select&#x2F;insert 导出&#x2F;导入 时报错</p>
<p><strong>报错信息</strong>：</p>
<blockquote>
<p>ERROR 1290 (HY000): The MySQL server is running with the –secure-file-priv option so it cannot execute this statement</p>
</blockquote>
<p><strong>问题原因</strong>： secure_file_priv参数用于限制LOAD DATA, SELECT …OUTFILE, LOAD_FILE()传到哪个指定目录。  </p>
<ul>
<li>secure_file_priv 为 NULL 时，表示限制mysqld不允许导入或导出。</li>
<li>secure_file_priv 为 &#x2F;tmp 时，表示限制mysqld只能在&#x2F;tmp目录中执行导入导出，其他目录不能执行。</li>
<li>secure_file_priv 没有值时，表示不限制mysqld在任意目录的导入导出。</li>
</ul>
<p>可以通过以下命令，查看当前的配置  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> &quot;%secure_file_priv%&quot;;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.csms.tech/img_18.png"></p>
<p><strong>解决方法</strong>： 因为secure_file_priv参数是只读参数，不能使用set global命令修改。<br><img src="https://i.csms.tech/img_19.png"></p>
<p>需要修改配置文件，添加以下内容</p>
<figure class="highlight shell"><figcaption><span>my.cnf</span></figcaption><table><tr><td class="code"><pre><span class="line">secure_file_priv = &#x27;&#x27;</span><br></pre></td></tr></table></figure>

<p>修改配置后，重启mysql服务生效</p>
<h4 id="xtrbackup-备份时被阻塞，一直显示-log-scanned-up-to"><a href="#xtrbackup-备份时被阻塞，一直显示-log-scanned-up-to" class="headerlink" title="xtrbackup 备份时被阻塞，一直显示 log scanned up to"></a>xtrbackup 备份时被阻塞，一直显示 <code>log scanned up to</code></h4><p><strong>报错场景</strong>: xtrbackup 备份时间过长，一直输出 <code>log scanned up to</code><br><img src="https://i.csms.tech/img_20.png"></p>
<p><strong>可能原因</strong>： 备份在等待锁<br><img src="https://i.csms.tech/img_21.png"></p>
<p><strong>解决方法</strong>： 如果对业务无影响，可以重启mysql服务后重新备份，或者根据ID kill掉对应的线程</p>
<figure class="highlight shell"><figcaption><span>mysql</span></figcaption><table><tr><td class="code"><pre><span class="line">show processlist;</span><br><span class="line">kill ID;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql 常用sql</title>
    <url>/2207221611/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Mysql 5.7</li>
</ul>
<h3 id="常用sql"><a href="#常用sql" class="headerlink" title="常用sql"></a>常用sql</h3><h4 id="导出到文件"><a href="#导出到文件" class="headerlink" title="导出到文件"></a>导出到文件</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> [<span class="keyword">TABLE</span>] </span><br><span class="line">    <span class="keyword">INTO</span> OUTFILE <span class="string">&#x27;[FILE]&#x27;</span> </span><br><span class="line">    FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;,&#x27;</span> </span><br><span class="line">    OPTIONALLY ENCLOSED <span class="keyword">BY</span> <span class="string">&#x27;&quot;&#x27;</span> </span><br><span class="line">    LINES TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\n&#x27;</span>；</span><br></pre></td></tr></table></figure>
<blockquote>
<p>into outfile ‘导出的目录和文件名’<br>fields terminated by ‘字段间分隔符’<br>optionally enclosed by ‘字段包围符’   </p>
<blockquote>
<p>数值型字段无效  </p>
</blockquote>
<p>lines terminated by ‘行间分隔符’ </p>
</blockquote>
<p>产生报错可参考 <a href="https://csms.tech/22072111/#导出导入数据错误-1290">Mysql常见错误</a></p>
<h4 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb(c1,c2) <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<h4 id="翻页查看输出"><a href="#翻页查看输出" class="headerlink" title="翻页查看输出"></a>翻页查看输出</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">pager less <span class="operator">-</span>S</span><br></pre></td></tr></table></figure>
<blockquote>
<p>之后的输出可以使用和less命令一样的参数</p>
</blockquote>
<h4 id="mysqldump导出时排除某些表"><a href="#mysqldump导出时排除某些表" class="headerlink" title="mysqldump导出时排除某些表"></a>mysqldump导出时排除某些表</h4><blockquote>
<p><code>--ignore-table=database.table</code> 导出时排除指定的表</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p database --ignore-table=database.table1 --ignore-table=database.table2 &gt; backup.sql</span><br></pre></td></tr></table></figure>

<h4 id="mysqldump导出表结构"><a href="#mysqldump导出表结构" class="headerlink" title="mysqldump导出表结构"></a>mysqldump导出表结构</h4><blockquote>
<p><code>-d</code> 选项，只导出表结构，不导出数据</p>
</blockquote>
<p>导出整个数据库表结构（不包含数据）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p -d DB &gt; db.sql</span><br></pre></td></tr></table></figure>

<p>导出单个数据表结构（不包含数据）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p -d DB TABLE &gt; table.sql</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 常用配置说明</title>
    <url>/22721459/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>默认配置文件路径: <code>/etc/my.cnf</code></p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##############通用配置##############</span><br><span class="line">user = mysql</span><br><span class="line">port = 3306</span><br><span class="line">default_storage_engine = InnoDB</span><br><span class="line">## 只读</span><br><span class="line">read_only=1  </span><br><span class="line">             </span><br><span class="line">## 跳过域名解析参数，禁止MySQL对外部连接进行DNS解析，使用这一选项可以消除MySQL进行DNS解析的时间。</span><br><span class="line">## 但需要注意，如果开启该选项，则所有远程主机连接授权都要使用IP地址方式，否则MySQL将无法正常处理连接请求！</span><br><span class="line">skip-name-resolve  </span><br><span class="line"></span><br><span class="line">## 跳过授权，重置密码时需要</span><br><span class="line">## 重置密码：update mysql.user set authentication_string=password(&#x27;AynT7ZD5eGzk@dzO@JvjDY@Q&#x27;) where user=&#x27;root&#x27;;          </span><br><span class="line">skip-grant-tables   </span><br><span class="line">          </span><br><span class="line">datadir=/var/lib/mysql</span><br><span class="line">socket=/var/lib/mysql/mysql.sock</span><br><span class="line"></span><br><span class="line">## 解决日志中因wait-timeout的报错：</span><br><span class="line">## Aborted connection 40476 to db: &#x27;&#x27; user: &#x27;&#x27; host: &#x27;&#x27; (Got an error reading communication packets)</span><br><span class="line">log_warnings=1  </span><br><span class="line">                 </span><br><span class="line">### 连接错误超过此值，客户端无法连接，即拉黑</span><br><span class="line">max_connect_errors = 1000      </span><br><span class="line"></span><br><span class="line">###########主从配置选项###########</span><br><span class="line">server-id = 1</span><br><span class="line"># 主库要生成的二进制日志文件名称</span><br><span class="line">log-bin = mysql-bin    </span><br><span class="line">    </span><br><span class="line">## 从库中继日志名称</span><br><span class="line">relay-log = mysql-relay-bin    </span><br><span class="line"></span><br><span class="line">################</span><br><span class="line">## sync_binlog = 0    表示MySQL 不控制binlog的刷新，由文件系统自己控制它的缓存的刷新。</span><br><span class="line">## 这时候的性能是最好的，但是风险也是最大的。因为一旦系统Crash，在binlog_cache中的所有binlog信息都会被丢失。</span><br><span class="line">## sync_binlog&gt;0    表示每N个sync_binlog次事务提交，MySQL调用文件系统的刷新操作将缓存刷下去。</span><br><span class="line">## 最安全的就是sync_binlog=1了，表示每次事务提交，MySQL都会把binlog刷下去，是最安全但是性能损耗最大的设置。这样的话，在数据库所在的主机操作系统损坏或者突然掉电的情况下，系统才有可能丢失1个事务的数据。 </span><br><span class="line">## 但是binlog虽然是顺序IO，但是设置sync_binlog=1，多个事务同时提交，同样很大的影响MySQL和IO性能。</span><br><span class="line">## 对于高并发事务的系统来说，“sync_binlog”设置为0和设置为1的系统写入性能差距可能高达5倍甚至更多。</span><br><span class="line">## 只适用于主库的二进制日志，不适用中继日志</span><br><span class="line">################</span><br><span class="line">sync_binlog=0</span><br><span class="line"></span><br><span class="line">## 要同步的库.应该在从库上尽可能的使用replicate_wild_*，不建议在主库上使用</span><br><span class="line">binlog-do-db = rtzc_pnc_base       </span><br><span class="line"></span><br><span class="line"># 不同步的数据库,应该在从库上尽可能的使用replicate_wild_*</span><br><span class="line">binlog-ignore-db = mysql</span><br><span class="line"></span><br><span class="line">### 应该在从库上尽可能的使用replicate_wild_*              </span><br><span class="line">#replicate-wild-ignore-table=db.*               </span><br><span class="line">#replicate-wild-ignore-table=mysql.*</span><br><span class="line">#replicate-wild-ignore-table=information_schema.*</span><br><span class="line">#replicate-wild-ignore-table=performance_schema.*</span><br><span class="line">#replicate-wild-ignore-table=sys.*</span><br><span class="line">#replicate_wild_do_table=DB_NAME.%</span><br><span class="line">#replicate_ignore_db=test</span><br><span class="line"></span><br><span class="line">###复制实现模式/级别</span><br><span class="line">binlog_format=statement/row/mixed   </span><br><span class="line"></span><br><span class="line"># binlog日志大于此值是重新生成新的日志，默认(最大)1G，若使用大事务，日志可能会超过此值     </span><br><span class="line">max_binlog_size = 100M        </span><br><span class="line"></span><br><span class="line"># bilog日志保存天数，过期后清除</span><br><span class="line">expire_logs_days = 7   </span><br><span class="line"></span><br><span class="line"># 跳过某些同步错误号</span><br><span class="line">slave-skip-errors = 1032,1062  </span><br><span class="line"></span><br><span class="line">### 从库需要记录binlog，如级联从库场景，级联从库必须有此参数</span><br><span class="line">log-slave-updates=1          </span><br><span class="line"></span><br><span class="line"># 阻止slave自动启动复制</span><br><span class="line">skip_slave_start     </span><br><span class="line"></span><br><span class="line"># 从库发现和主库连接失败后，重连等待的时间，默认1小时       </span><br><span class="line">slave_net_timeout = 1        </span><br><span class="line"></span><br><span class="line"># 在从库上同步状态文件到磁盘，默认10000，表示在10000个事务执行完成后，将信息同步到磁盘</span><br><span class="line"># 打开后，可能会降低IO性能，设置为1最安全，但是IO性能最差；设置为0，由OS控制刷新</span><br><span class="line">sync_master_info | sync_relay_log | sync_relay_log_info  = 1      </span><br><span class="line"></span><br><span class="line"># SQL线程重放完一个中继日志后尽快将其删除</span><br><span class="line">relay_log_purge = 1         </span><br><span class="line"></span><br><span class="line"># 所有中继日志大小和的最大值。可防止主从延迟很大时，IO线程写relay log，导致磁盘空间不足。中继日志总和超过此值，IO线程会停止，等待SQL线程释放空间；</span><br><span class="line"># 风险是从库未从主库读取所有relaylog，这些日志可能在主库崩溃时丢失，磁盘空间足够的情况下，不推荐配置  </span><br><span class="line">relay_log_space_limit = 1G       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#########日志选项###########</span><br><span class="line">slow_query_log =1   </span><br><span class="line">long_query_time=2     </span><br><span class="line">slow_query_log_file=/var/lib/mysql/slow.log</span><br><span class="line"></span><br><span class="line">log-error=/var/log/mysqld.log</span><br><span class="line"></span><br><span class="line">##########编码选项######</span><br><span class="line">character-set-server = utf8</span><br><span class="line">collation-server=utf8_general_ci </span><br><span class="line"></span><br><span class="line">#############连接选项#############</span><br><span class="line"></span><br><span class="line"># 客户端的连接闲置的最大时间，默认8小时，设置非交互模式(jdbc)时的超时时间</span><br><span class="line">wait-timeout = 60      </span><br><span class="line"></span><br><span class="line"># 交互模式超时时间      </span><br><span class="line">interactive_timeout = 60    </span><br><span class="line"></span><br><span class="line"># 并发连接数,最终值由open_files_limit共同决定</span><br><span class="line">max_connections=65535    </span><br><span class="line"></span><br><span class="line"># 一个账号最大可发起多少并发连接                </span><br><span class="line">max_user_connections=65535            </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#############性能选项#############</span><br><span class="line"></span><br><span class="line"># 缓存的表个数，可以观察Opened_tables状态变量值，若很大(若经常需要创建/删除临时表，该计数器也会不停增长)，建议增加此配置值，由OS rlimit共同决定</span><br><span class="line">table_open_cache = 65535  </span><br><span class="line"></span><br><span class="line"># 缓存的线程个数，具体配置值可以观察Threads_created状态变量，如果此值较大，可加大thread_cache_size,建议此值保持足够大    </span><br><span class="line">thread_cache_size = 5000   </span><br><span class="line"></span><br><span class="line"># 查询缓存使用的内存大小，启动时，一次性分配</span><br><span class="line">query_cache_size = 1024M      </span><br><span class="line"></span><br><span class="line"># 查询需排序时分配内存，立即分配指定的全部内存，无论是否需要这么多</span><br><span class="line">sort_buffer_size = 10k            </span><br><span class="line"></span><br><span class="line"># 需要在服务启动程序(/usr/lib/systemd/system/mysqld.service)中配置：LimitNOFILE = 65535</span><br><span class="line">open_files_limit = 65535</span><br><span class="line">     </span><br><span class="line">max_allowed_packet = 200M</span><br><span class="line">innodb_open_files = 65535      </span><br><span class="line"></span><br><span class="line"># 默认值一般都太小，此值建议配置为os和其他应用消耗的内存除外的内存大小</span><br><span class="line"># 配置太大也会导致预热和关闭花费较多时间</span><br><span class="line">innodb_buffer_pool_size = 20G       </span><br><span class="line"></span><br><span class="line"># 事务日志的文件大小，太小，InnoDB必须做更多检查点，导致更多日志写，不利于IO。日志缓存满，事务提交或每秒，会刷新缓存到磁盘;</span><br><span class="line"># 可以观察show innodb status中log部分，Innodb_os_log_written查看写入了多少数据</span><br><span class="line">innodb_log_file_size = (32-128)M</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">innodb_flush_log_at_trx_commit = N</span><br><span class="line">########## innodb特有参数，事务日志用于在mysql崩溃后的恢复</span><br><span class="line"># N=0   每隔一秒，把事务日志缓存区的数据写到日志文件中，以及把日志文件的数据刷新到磁盘上；</span><br><span class="line"># 在这种情况下，MySQL性能最好，但如果 mysqld 进程崩溃，通常会导致最后 1s 的日志丢失。</span><br><span class="line"></span><br><span class="line"># N=1   每个事务提交时候，把事务日志从缓存区写到日志文件中，并且刷新日志文件的数据到磁盘上；每次事务提交时，log buffer 会被写入到日志文件并刷写到磁盘。 </span><br><span class="line"># 这也是默认值。这是最安全的配置，但由于每次事务都需要进行磁盘I/O，所以也最慢。</span><br><span class="line"></span><br><span class="line"># N=2    当取值为2 时，每次事务提交会写入日志文件，但并不会立即刷写到磁盘，日志文件会每秒刷写一次到磁盘。</span><br><span class="line"># 这时如果 mysqld 进程崩溃，由于日志已经写入到系统缓存，所以并不会丢失数据；在操作系统崩溃的情况下，通常会导致最后 1s 的日志丢失。</span><br><span class="line"># 对于一些数据一致性和完整性要求不高的应用，配置为 2 就足够了；如果为了最高性能，可以设置为 0。有些应用，如支付服务，对一致性和完整性要求很高，所以即使最慢，也最好设置为 1.</span><br><span class="line">##########</span><br><span class="line"></span><br><span class="line"># 限制一次性可以有多少线程进入内核，建议值：cpu数量* 磁盘数量* 2,进入内核的线程超过此值，新线程无法进入。</span><br><span class="line"># 为使线程高效进入内核，线程第一次休眠innodb_thread_sleep_delay(默认10000)微秒，然后重试，若依然不能进入内核，则放入一个等待线程队列，由OS内核处理。</span><br><span class="line"># 在高并发环境或大量小查询时，可减小此值。</span><br><span class="line">innodb_thread_concurrency = 64</span><br><span class="line"></span><br><span class="line"># 一旦线程进入内核，可以有指定数量的tickents，再次进入内核时，可不在做并发检查，按照查询授权，而非事务            </span><br><span class="line">innodb_concurrency_tickets = 10</span><br><span class="line"></span><br><span class="line"># 多少个线程可以在同一时间提交事务，太小会有线程冲突      </span><br><span class="line">innodb_commit_concurrency = 100   </span><br><span class="line"></span><br><span class="line"># 指定磁盘IO能力，默认为100，使用SSD或IO性能好的磁盘时，建议提高此值</span><br><span class="line">innodb_io_capacity = 1000     </span><br><span class="line"></span><br><span class="line"># 控制后台由多少线程负责IO操作，默认为4</span><br><span class="line">innodb_read_io_threads | innodb_write_io_threads = 10             </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 主从恢复</title>
    <url>/94ee2c23/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Centos 7</li>
<li>Mysql 5.7</li>
<li>Percona-XtraBackup-2.4.4</li>
</ul>
<h3 id="恢复方法1：mysqldump主库锁表备份恢复"><a href="#恢复方法1：mysqldump主库锁表备份恢复" class="headerlink" title="恢复方法1：mysqldump主库锁表备份恢复"></a>恢复方法1：mysqldump主库锁表备份恢复</h3><p><strong>前提</strong> ： 接受主库锁表操作，备份恢复过程中主库无法写入数据</p>
<h4 id="从库停止slave进程"><a href="#从库停止slave进程" class="headerlink" title="从库停止slave进程"></a>从库停止slave进程</h4><p>登录mysql从库，执行以下命令，停止slave进程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">stop slave;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h4 id="主库锁表"><a href="#主库锁表" class="headerlink" title="主库锁表"></a>主库锁表</h4><p>登录mysql主库，执行以下命令，对主库进行锁表操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FLUSH TABLES WITH READ LOCK;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行锁表操作后，不要退出mysql命令行，否则会自动解锁。</p>
</blockquote>
<p>执行以下命令，查看主库锁表后的binlog位置信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SHOW MASTER STATUS\G</span><br></pre></td></tr></table></figure>
<p><img src="https://i.csms.tech/img_3.png"></p>
<h4 id="备份主库数据库数据"><a href="#备份主库数据库数据" class="headerlink" title="备份主库数据库数据"></a>备份主库数据库数据</h4><p>执行以下命令备份数据库db1</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p --master-data=2 --databases db1 &gt; db1.sql</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>--master-data=2</code>  将日志名和位置写入到备份结果并注释，可以从备份文件中搜索<code>change master to</code>  查看binlog文件名和position</p>
</blockquote>
<p>主库备份完成后，可以解锁：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure>

<h4 id="从库恢复主库的备份数据"><a href="#从库恢复主库的备份数据" class="headerlink" title="从库恢复主库的备份数据"></a>从库恢复主库的备份数据</h4><p>将主库的备份数据拷贝到从库，使用备份数据覆盖恢复从库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p db1 &lt; db1.sql</span><br></pre></td></tr></table></figure>
<p>从库恢复备份完成后，和主库建立主从连接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">change master to master_host=&#x27;1.1.1.1&#x27;,master_user=&#x27;repl&#x27;,master_password=&#x27;pswd&#x27;,master_port=3306,master_log_file=&#x27;mysql-bin.000196&#x27;,master_log_pos=1037640668;</span><br><span class="line">start slave</span><br></pre></td></tr></table></figure>
<p>配置完成后，通过以下命令，查看主从状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">show slave status\G</span><br></pre></td></tr></table></figure>
<blockquote>
<p>主要关注以下项：<br>Slave_IO_Running: Yes<br>Slave_SQL_Running: Yes<br>Seconds_Behind_Master: 0  </p>
</blockquote>
<p><img src="https://i.csms.tech/img_5.png"></p>
<h3 id="恢复方法2：mysqldump主库不锁表备份恢复"><a href="#恢复方法2：mysqldump主库不锁表备份恢复" class="headerlink" title="恢复方法2：mysqldump主库不锁表备份恢复"></a>恢复方法2：mysqldump主库不锁表备份恢复</h3><h4 id="从库停止slave进程-1"><a href="#从库停止slave进程-1" class="headerlink" title="从库停止slave进程"></a>从库停止slave进程</h4><p>登录mysql从库，执行以下命令，停止slave进程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">stop slave;</span><br></pre></td></tr></table></figure>
<h4 id="备份主库数据库数据-1"><a href="#备份主库数据库数据-1" class="headerlink" title="备份主库数据库数据"></a>备份主库数据库数据</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p --master-data=2 --single-transaction -R --databases db01 &gt; db01.sql</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>--master-data=2</code> : 实现将日志名和位置写入到备份结果并注释,db01.sql中会包含当前日志的文件名以及位置<br><code>--routines, -R</code>：导出存储过程和函数</p>
</blockquote>
<h4 id="从库导入备份"><a href="#从库导入备份" class="headerlink" title="从库导入备份"></a>从库导入备份</h4><p>将主库的备份数据拷贝到从库，并进行恢复</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p db01 &lt; db01.sql</span><br></pre></td></tr></table></figure>
<h4 id="备份文件中查看binlog日志文件名和position"><a href="#备份文件中查看binlog日志文件名和position" class="headerlink" title="备份文件中查看binlog日志文件名和position"></a>备份文件中查看binlog日志文件名和position</h4><p>在备份文件(<code>db01.sql</code>)中搜索<code>CHANGE MASTER TO </code>, 结果中可以获取到binlog日志文件名和position</p>
<h4 id="建立主从连接"><a href="#建立主从连接" class="headerlink" title="建立主从连接"></a>建立主从连接</h4><p>根据上一步获取到的binlog文件名和position信息，建立主从连接并启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">change master to master_host=&#x27;1.1.1.1&#x27;,master_user=&#x27;repl&#x27;,master_password=&#x27;pswd&#x27;,master_port=3306,master_log_file=&#x27;mysql-bin.000196&#x27;,master_log_pos=1037640668;</span><br><span class="line">start slave</span><br></pre></td></tr></table></figure>
<p>通过命令<code>show slave status\G</code> 检查主从同步状态</p>
<h3 id="恢复方法3：-xbackup整库备份恢复"><a href="#恢复方法3：-xbackup整库备份恢复" class="headerlink" title="恢复方法3： xbackup整库备份恢复"></a>恢复方法3： xbackup整库备份恢复</h3><h4 id="xbackup安装"><a href="#xbackup安装" class="headerlink" title="xbackup安装"></a>xbackup安装</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y libaio-devel.x86_64 bzip2</span><br><span class="line">wget https://www.percona.com/downloads/XtraBackup/Percona-XtraBackup-2.4.4/binary/tarball/percona-xtrabackup-2.4.4-Linux-x86_64.tar.gz</span><br><span class="line">tar -zxf percona-xtrabackup-2.4.4-Linux-x86_64.tar.gz</span><br><span class="line">cp percona-xtrabackup-2.4.4-Linux-x86_64/bin/* /usr/bin</span><br></pre></td></tr></table></figure>

<h4 id="主库整库备份"><a href="#主库整库备份" class="headerlink" title="主库整库备份"></a>主库整库备份</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">innobackupex --defaults-file=/etc/my.cnf --user=root --password=PASSWD --port=3306 --socket=/var/lib/mysql/mysql.sock  [--databases  &quot;db1 db2 &quot;] $&#123;backup_data_dir&#125;</span><br></pre></td></tr></table></figure>

<h4 id="从库整库恢复"><a href="#从库整库恢复" class="headerlink" title="从库整库恢复"></a>从库整库恢复</h4><p>拷贝主库备份数据到从库,在从库上执行以下命令恢复数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd $&#123;backup_data_dir&#125;</span><br><span class="line"></span><br><span class="line">innobackupex --defaults-file=/etc/my.cnf --apply-log --use-memory=20000M $&#123;backup_data_dir&#125;</span><br><span class="line"></span><br><span class="line">cp -r $&#123;backup_data_dir&#125;/* $&#123;mysql_base_dir&#125;/data/</span><br></pre></td></tr></table></figure>

<h4 id="建立主从连接-1"><a href="#建立主从连接-1" class="headerlink" title="建立主从连接"></a>建立主从连接</h4><p>备份数据中的<code>xtrabackup_binlog_info</code>文件包含了从库建立主从连接时需要的binlog信息，根据此文件中的信息，在从库执行命令，建立主从连接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">change master to master_host=&#x27;1.1.1.1&#x27;,master_user=&#x27;repl&#x27;,master_password=&#x27;pswd&#x27;,master_port=3306,master_log_file=&#x27;mysql-bin.000196&#x27;,master_log_pos=1037640668;</span><br><span class="line">start slave</span><br></pre></td></tr></table></figure>
<p>通过命令<code>show slave status\G</code> 检查主从同步状态</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql多主一从即多源复制</title>
    <url>/2207210946/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Mysql 5.7 之后版本支持多主一从</li>
</ul>
<h3 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h3><h4 id="分别在Master-1和Master-2上导出需要同步的数据库"><a href="#分别在Master-1和Master-2上导出需要同步的数据库" class="headerlink" title="分别在Master_1和Master_2上导出需要同步的数据库"></a>分别在Master_1和Master_2上导出需要同步的数据库</h4><p>分别在Master_1和Master_2上执行以下命令，导出需要同步的数据库备份</p>
<figure class="highlight shell"><figcaption><span>Master_1</span></figcaption><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p123456 --master-data=2 --single-transaction --databases  --add-drop-database  db1  &gt; db1.sql</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><figcaption><span>Master_2</span></figcaption><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p123456 --master-data=2 --single-transaction --databases  --add-drop-database  db2  &gt; db2.sql</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>备份完成后，将备份数据拷贝到从库服务器上面</p>
<span id="more"></span>

<h4 id="在Master-1和Master-2上创建复制账号"><a href="#在Master-1和Master-2上创建复制账号" class="headerlink" title="在Master_1和Master_2上创建复制账号"></a>在Master_1和Master_2上创建复制账号</h4><div class="note info"><p>如果已有复制账号，跳过此步骤</p>
</div>
<p>分别在Master_1和Master_2上执行以下命令，创建复制账号</p>
<figure class="highlight shell"><figcaption><span>Master_1 Master_2</span></figcaption><table><tr><td class="code"><pre><span class="line">grant replication slave on *.* to &#x27;repl&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27;;</span><br></pre></td></tr></table></figure>
<h4 id="更改slave配置以支持多主一从"><a href="#更改slave配置以支持多主一从" class="headerlink" title="更改slave配置以支持多主一从"></a>更改slave配置以支持多主一从</h4><div class="note primary"><p>mysql支持多主一从(多源复制)的关键配置。<br>要配置mysql支持多源复制，必须配置mysql存储同步信息的方式，主要有以下2种方式 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[存储同步信息的方式说明](https://dev.mysql.com/doc/refman/5.7/en/replication-multi-source-configuration.html)
">[1]</span></a></sup></p>
<ul>
<li>FILE  默认配置，此时同步信息存储在文件master.info和relay-log.info</li>
<li>TABLE  同步信息存储在mysql.slave_master_info和mysql.slave_relay_log_info</li>
</ul>
</div>

<p>更改mysql配置文件(默认&#x2F;etc&#x2F;my.cnf)，配置存储同步信息的方式</p>
<figure class="highlight shell"><figcaption><span>/etc/my.cnf</span></figcaption><table><tr><td class="code"><pre><span class="line">master_info_repository=TABLE</span><br><span class="line">relay_log_info_repository=TABLE</span><br></pre></td></tr></table></figure>
<p>更改配置后，重启mysql生效</p>
<h4 id="slave上恢复Master-1和Master-2的备份数据"><a href="#slave上恢复Master-1和Master-2的备份数据" class="headerlink" title="slave上恢复Master_1和Master_2的备份数据"></a>slave上恢复Master_1和Master_2的备份数据</h4><figure class="highlight shell"><figcaption><span>slave</span></figcaption><table><tr><td class="code"><pre><span class="line">mysql -uroot -p  &lt; db1.sql</span><br><span class="line">mysql -uroot -p  &lt; db2.sql</span><br></pre></td></tr></table></figure>
<div class="note info"><p>因为在 <code>mysqldump</code> 备份时，使用了选项 <code>--add-drop-database</code>，slave导入备份时，无需指定db</p>
</div>

<h4 id="slave上配置多源复制"><a href="#slave上配置多源复制" class="headerlink" title="slave上配置多源复制"></a>slave上配置多源复制</h4><h5 id="找到配置主从需要的binlog位置和Pos位置"><a href="#找到配置主从需要的binlog位置和Pos位置" class="headerlink" title="找到配置主从需要的binlog位置和Pos位置"></a>找到配置主从需要的binlog位置和Pos位置</h5><p>分别在Master_1和Master_2的备份数据中，查找以下内容，找到需要的binlog位置和Pos位置</p>
<figure class="highlight shell"><figcaption><span>slave</span></figcaption><table><tr><td class="code"><pre><span class="line">cat db1.sql |grep &quot; CHANGE MASTER&quot;</span><br><span class="line">cat db2.sql |grep &quot; CHANGE MASTER&quot;</span><br></pre></td></tr></table></figure>
<div class="note info"><p>这些信息是由  <code>mysqldump</code> 的选项 <code>--master-data=2</code>提供 <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[--master-data=2说明](https://dev.mysql.com/doc/mysql-replication-excerpt/5.7/en/replication-howto-mysqldump.html)">[2]</span></a></sup> </p>
</div>
<p>结果中包含以下类似内容：</p>
<blockquote>
<p>CHANGE MASTER TO MASTER_LOG_FILE&#x3D;’log-bin.000001’, MASTER_LOG_POS&#x3D;1539;</p>
</blockquote>
<h5 id="登录salve数据库配置多源复制"><a href="#登录salve数据库配置多源复制" class="headerlink" title="登录salve数据库配置多源复制"></a>登录salve数据库配置多源复制</h5><p>登录slave数据库，分别执行以下命令，创建到Master_1和Master_2的复制</p>
<figure class="highlight shell"><figcaption><span>slave</span></figcaption><table><tr><td class="code"><pre><span class="line">CHANGE MASTER TO MASTER_HOST=&#x27;Master_1&#x27;,MASTER_USER=&#x27;repl&#x27;, MASTER_PASSWORD=&#x27;123456&#x27;,MASTER_LOG_FILE=&#x27;log-bin.000001&#x27;,MASTER_LOG_POS=1539 FOR CHANNEL &#x27;Master_1&#x27;;</span><br><span class="line">CHANGE MASTER TO MASTER_HOST=&#x27;Master_2&#x27;,MASTER_USER=&#x27;repl&#x27;, MASTER_PASSWORD=&#x27;123456&#x27;,MASTER_LOG_FILE=&#x27;log-bin.000001&#x27;,MASTER_LOG_POS=1539 FOR CHANNEL &#x27;Master_2&#x27;; </span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<div class="note info"><p>不同的主从复制以最后的 <code>FOR CHANNEL</code> 来区分</p>
</div>

<h5 id="启动主从复制"><a href="#启动主从复制" class="headerlink" title="启动主从复制"></a>启动主从复制</h5><p>在slave数据库中执行以下命令分别启动复制</p>
<figure class="highlight shell"><figcaption><span>slave</span></figcaption><table><tr><td class="code"><pre><span class="line">start slave for channel &quot;Master_1&quot;;</span><br><span class="line">start slave for channel &quot;Master_1&quot;;</span><br></pre></td></tr></table></figure>
<p>也可以通过 <code>start slave;</code> 启动所有的复制</p>
<p>可以通过以下命令查看启动复制后的状态</p>
<figure class="highlight shell"><figcaption><span>slave</span></figcaption><table><tr><td class="code"><pre><span class="line">SHOW SLAVE STATUS FOR CHANNEL &#x27;Master_1&#x27;\G</span><br><span class="line">SHOW SLAVE STATUS FOR CHANNEL &#x27;Master_2&#x27;\G</span><br><span class="line">SHOW SLAVE STATUS\G</span><br></pre></td></tr></table></figure>

<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://dev.mysql.com/doc/">Mysql 官网</a></p>
<h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://dev.mysql.com/doc/refman/5.7/en/replication-multi-source-configuration.html">存储同步信息的方式说明</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://dev.mysql.com/doc/mysql-replication-excerpt/5.7/en/replication-howto-mysqldump.html">--master-data=2说明</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql 主从复制相关原理简述</title>
    <url>/2207211114/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<h2 id="Mysql-主从同步基本原理"><a href="#Mysql-主从同步基本原理" class="headerlink" title="Mysql 主从同步基本原理"></a>Mysql 主从同步基本原理</h2></blockquote>
<p>复制的基本过程如下：  </p>
<ol>
<li><p>Slave上面的IO进程连接上Master，并请求从指定日志文件的指定位置（或者从最开始的日志）之后的日志内容；</p>
</li>
<li><p>Master接收到来自Slave的IO进程的请求后，通过负责复制的IO进程,根据请求信息,读取指定日志指定位置之后的日志信息，返回给Slave 的IO进程。返回信息中除了日志所包含的信息之外，还包括本次返回的信息已经到Master端的bin-log文件的名称以及bin-log的位置；</p>
</li>
<li><p>Slave的IO进程接收到信息后，将接收到的日志内容依次添加到Slave端的relay-log文件的最末端，并将读取到的Master端的 bin-log的文件名和位置记录到master-info文件中，以便在下一次读取的时候能够清楚的告诉Master“我需要从某个bin-log的哪个位置开始往后的日志内容，请发给我”；</p>
</li>
<li><p>Slave的Sql进程检测到relay-log中新增加了内容后，会马上解析relay-log的内容，获得在Master端真实执行的那些可执行的内容，并在自身执行。</p>
</li>
</ol>
<p>双主情况下，禁止同时写入，建议还是按照主从的方式工作，防止数据冲突。双主场景下，主要是切换主备方便。</p>
<span id="more"></span>

<blockquote>
<h2 id="Mysql-复制方式"><a href="#Mysql-复制方式" class="headerlink" title="Mysql 复制方式"></a>Mysql 复制方式</h2></blockquote>
<blockquote>
<h3 id="异步复制（Asynchronous-replication）"><a href="#异步复制（Asynchronous-replication）" class="headerlink" title="异步复制（Asynchronous replication）"></a>异步复制（Asynchronous replication）</h3></blockquote>
<p>MySQL默认的复制即是异步的，主库在执行完客户端提交的事务后会立即将结果返给给客户端，并不关心从库是否已经接收并处理，这样就会有一个问题，主如果crash掉了，此时主上已经提交的事务可能并没有传到从上，如果此时，强行将从提升为主，可能导致新主上的数据不完整。</p>
<blockquote>
<h3 id="全同步复制（Fully-synchronous-replication）"><a href="#全同步复制（Fully-synchronous-replication）" class="headerlink" title="全同步复制（Fully synchronous replication）"></a>全同步复制（Fully synchronous replication）</h3></blockquote>
<p>指当主库执行完一个事务，所有的从库都执行了该事务才返回给客户端。因为需要等待所有从库执行完该事务才能返回，所以全同步复制的性能必然会收到严重的影响。</p>
<blockquote>
<h3 id="半同步复制（Semisynchronous-replication）"><a href="#半同步复制（Semisynchronous-replication）" class="headerlink" title="半同步复制（Semisynchronous replication）"></a>半同步复制（Semisynchronous replication）</h3></blockquote>
<p>介于异步复制和全同步复制之间，主库在执行完客户端提交的事务后不是立刻返回给客户端，而是等待至少一个从库接收到并写到relay log中才返回给客户端。相对于异步复制，半同步复制提高了数据的安全性，同时它也造成了一定程度的延迟，这个延迟最少是一个TCP&#x2F;IP往返的时间。所以，半同步复制最好在低延时的网络中使用。半同步复制失败(配置超时时间)，自动转为异步复制  </p>
<h4 id="半同步复制配置步骤"><a href="#半同步复制配置步骤" class="headerlink" title="半同步复制配置步骤"></a>半同步复制配置步骤</h4><ol>
<li><p>加载使用的插件<br>主库执行以下命令</p>
<figure class="highlight shell"><figcaption><span>master</span></figcaption><table><tr><td class="code"><pre><span class="line">INSTALL PLUGIN rpl_semi_sync_master SONAME &#x27;semisync_master.so&#x27;;</span><br></pre></td></tr></table></figure>
<p>从库执行以下命令</p>
<figure class="highlight shell"><figcaption><span>slave</span></figcaption><table><tr><td class="code"><pre><span class="line">INSTALL PLUGIN rpl_semi_sync_slave SONAME &#x27;semisync_slave.so&#x27;;</span><br></pre></td></tr></table></figure>
<p>通过 <code>show plugins;</code> 可查看已加载的插件</p>
</li>
<li><p>启动半同步复制<br>主库执行以下命令</p>
<figure class="highlight shell"><figcaption><span>master</span></figcaption><table><tr><td class="code"><pre><span class="line">SET GLOBAL rpl_semi_sync_master_enabled = 1;</span><br></pre></td></tr></table></figure>
<p>从库执行以下命令</p>
<figure class="highlight shell"><figcaption><span>slave</span></figcaption><table><tr><td class="code"><pre><span class="line">SET GLOBAL rpl_semi_sync_slave_enabled = 1;</span><br></pre></td></tr></table></figure>
<p>执行以下命令重启从库上的IO线程</p>
<figure class="highlight shell"><figcaption><span>slave</span></figcaption><table><tr><td class="code"><pre><span class="line">STOP SLAVE IO_THREAD;</span><br><span class="line">START SLAVE IO_THREAD;</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查半同步复制插件是否在运行<br>主库执行以下命令</p>
<figure class="highlight shell"><figcaption><span>master</span></figcaption><table><tr><td class="code"><pre><span class="line">show status like &#x27;Rpl_semi_sync_master_status&#x27;;</span><br></pre></td></tr></table></figure>
<p>从库执行以下命令</p>
<figure class="highlight shell"><figcaption><span>slave</span></figcaption><table><tr><td class="code"><pre><span class="line">show status like &#x27;Rpl_semi_sync_slave_status&#x27;;</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<h2 id="Mysql-复制级别说明"><a href="#Mysql-复制级别说明" class="headerlink" title="Mysql 复制级别说明"></a>Mysql 复制级别说明</h2></blockquote>
<p>不同复制级别的设置会影响到Master端的bin-log记录成不同的形式。<br>配置方式:</p>
<figure class="highlight shell"><figcaption><span>/etc/my.cnf</span></figcaption><table><tr><td class="code"><pre><span class="line">binlog_format=&#x27;row&#x27;</span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="基于sql语句（Statement-level）"><a href="#基于sql语句（Statement-level）" class="headerlink" title="基于sql语句（Statement level）"></a>基于sql语句（Statement level）</h3></blockquote>
<p>每一条会修改数据的sql都会记录到 master的bin-log中。slave在复制的时候，sql进程会解析成和原来master端执行过的相同的sql来再次执行。</p>
<p><strong>优点</strong>：statement level下的优点首先就是解决了<a href="#%E5%9F%BA%E4%BA%8E%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95%EF%BC%88Row-level%EF%BC%89">row level</a>下的缺点，不需要记录每一行数据的变化，减少bin-log日志量，节约IO，提高性能。因为他只需要记录在Master上所执行的语句的细节，以及执行语句时候的上下文的信息。</p>
<p><strong>缺点</strong>：由于他是记录的执行语句，所以，为了让这些语句在slave端也能正确执行，那么他还必须记录每条语句在执行的时候的一些相关信息，也就是上下文信息，以保证所有语句在slave端被执行的时候能够得到和在master端执行时候相同的结果。<br>另外就是，由于Mysql现在发展比较快，很多的新功能不断的加入，使mysql的复制遇到了不小的挑战，复制的时候涉及到越复杂的内容，bug也就越容易出现。在statement level下，目前已经发现的就有不少情况会造成mysql的复制出现问题，主要是修改数据的时候使用了某些特定的函数或者功能的时候会出现，比如：sleep()函数在有些版本中就不能真确复制，在存储过程中使用了last_insert_id()函数，可能会使slave和master上得到不一致的id等等。<br>由于row level是基于每一行来记录的变化，所以不会出现类似的问题。</p>
<blockquote>
<h3 id="基于一条记录（Row-level）"><a href="#基于一条记录（Row-level）" class="headerlink" title="基于一条记录（Row level）"></a>基于一条记录（Row level）</h3></blockquote>
<p>日志中会记录成每一行数据被修改的形式，然后在slave端再对相同的数据进行修改</p>
<p><strong>优点</strong>： 在row level模式下，bin-log中可以不记录执行的sql语句的上下文相关的信息，仅仅只需要记录那一条记录被修改了，修改成什么样了。所以row level的日志内容会非常清楚的记录下每一行数据修改的细节，非常容易理解。而且不会出现某些特定情况下的存储过程，或function，以及 trigger的调用和触发无法被正确复制的问题。<br>任何情况都可以被复制，这对复制来说是最安全可靠的；和其他大多数数据库系统的复制技术一样；多数情况下，从服务器上的表如果有主键的话，复制就会快了很多,更少的锁</p>
<p><strong>缺点</strong>： row level下，所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容，比如有这样一条update语句：update product set owner_member_id &#x3D; ‘b’ where owner_member_id &#x3D; ‘a’，执行之后，日志中记录的不是这条update语句所对应的事件（mysql以事件的形式来记录bin-log日志），而是这条语句所更新的每一条记录的变化情况，这样就记录成很多条记录被更新的很多个事件。自然，bin-log日志的量就会很大。尤其是当执行alter table之类的语句的时候，产生的日志量是惊人的。因为Mysql对于alter table之类的表结构变更语句的处理方式是整个表的每一条记录都需要变动，实际上就是重建了整个表。那么该表的每一条记录都会被记录到日志中。</p>
<blockquote>
<h3 id="Mixed"><a href="#Mixed" class="headerlink" title="Mixed"></a>Mixed</h3></blockquote>
<p>在Mixed模式下，Mysql会根据执行的每一条具体的sql语句,来区分对待记录的日志形式，也就是在Statement和Row之间选择一种。新版本中的Statment level还是和以前一样，仅仅记录执行的语句。而新版本的Mysql中对row level模式也被做了优化，并不是所有的修改都会以row level来记录，像遇到表结构变更的时候就会以statement模式来记录，如果sql语句确实就是update或者delete等修改数据的语句，那么还是会记录所有行的变更。</p>
<blockquote>
<h3 id="GTID模式"><a href="#GTID模式" class="headerlink" title="GTID模式"></a>GTID模式</h3></blockquote>
<p>需要基于row模式，mysql-5.6.2支持,mysql5.6.10后完善</p>
<figure class="highlight shell"><figcaption><span>/etc/my.cnf</span></figcaption><table><tr><td class="code"><pre><span class="line">log_bin=on</span><br><span class="line">binlog_format=&#x27;row&#x27;</span><br><span class="line">gtid_mode=on</span><br><span class="line">enforce-gtid-consistency=on</span><br><span class="line">log-slave-updates=1</span><br></pre></td></tr></table></figure>
<p>限制：</p>
<ol>
<li>不支持非事务引擎(从库报错, stop slave; start slave ; 忽略)</li>
<li>不支持create table … select语句(主库直接报错)</li>
<li>不支持一个sql同时更新一个事务引擎和非事务引擎的表</li>
<li>在一个复制组中,必须要求统一开启gtid或是关闭gtid</li>
<li>开启gtid需要重启</li>
<li>开启gtid后,就不在使用原来传统的复制方式</li>
<li>对于create temporary table和drop temporary table语句不支持</li>
<li>不支持sql_slave_skip_counter</li>
</ol>
<blockquote>
<h2 id="MySQL（主从）配置相关参数"><a href="#MySQL（主从）配置相关参数" class="headerlink" title="MySQL（主从）配置相关参数"></a>MySQL（主从）配置相关参数</h2></blockquote>
<p>master相关配置  </p>
<figure class="highlight shell"><figcaption><span>master my.cnf</span></figcaption><table><tr><td class="code"><pre><span class="line">server-id = 1</span><br><span class="line">log-bin = mysql-bin    #要生成的二进制日志文件名称</span><br><span class="line">binlog_format=statement/row/mixed        ###复制实现模式/级别</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">binlog-do-db = rtzc_pnc_base       <span class="comment">##要同步的库.应该尽可能的在从库上使用replicate_wild_*，不建议在主库上使用</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">binlog-ignore-db = mysql   <span class="comment">#不同步的数据库,应该在从库上尽可能的使用replicate_wild_*</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#### 一般不再主服务器上过滤，虽然可以减少主的开销，但这样会导致二进制日志不完整</span></span></span><br><span class="line">sync_binlog=0</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#######</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">0      表示MySQL 不控制binlog的刷新，由文件系统自己控制它的缓存的刷新。这时候的性能是最好的，但是风险也是最大的。因为一旦系统Crash，在binlog_cache中的所有binlog信息都会被丢失。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sync_binlog&gt;0    表示每N个sync_binlog次事务提交，MySQL调用文件系统的刷新操作将缓存刷下去。最安全的就是sync_binlog=1了，表示每次事务提交，MySQL都会把binlog刷下去，是最安全但是性能损耗最大的设置。这样的话，在数据库所在的主机操作系统损坏或者突然掉电的情况下，系统才有可能丢失1个事务的数据。但是binlog虽然是顺序IO，但是设置sync_binlog=1，多个事务同时提交，同样很大的影响MySQL和IO性能。对于高并发事务的系统来说，“sync_binlog”设置为0和设置为1的系统写入性能差距可能高达5倍甚至更多。</span></span><br><span class="line"></span><br><span class="line">innodb_flush_log_at_trx_commit = 1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##########innodb特有参数</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">N=0     每隔一秒，把事务日志缓存区的数据写到日志文件中，以及把日志文件的数据刷新到磁盘上；在这种情况下，MySQL性能最好，但如果 mysqld 进程崩溃，通常会导致最后 1s 的日志丢失。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">N=1     每个事务提交时候，把事务日志从缓存区写到日志文件中，并且刷新日志文件的数据到磁盘上；每次事务提交时，<span class="built_in">log</span> buffer 会被写入到日志文件并刷写到磁盘。这也是默认值。这是最安全的配置，但由于每次事务都需要进行磁盘I/O，所以也最慢。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">N=2    当取值为 2 时，每次事务提交会写入日志文件，但并不会立即刷写到磁盘，日志文件会每秒刷写一次到磁盘。这时如果 mysqld 进程崩溃，由于日志已经写入到系统缓存，所以并不会丢失数据；在操作系统崩溃的情况下，通常会导致最后 1s 的日志丢失。 对于一些数据一致性和完整性要求不高的应用，配置为 2 就足够了；如果为了最高性能，可以设置为 0。有些应用，如支付服务，对一致性和完整性要求很高，所以即使最慢，也最好设置为 1.</span> </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">replicate-wild-ignore-table=db.*               <span class="comment">###应该在从库上尽可能的使用replicate_wild_</span></span></span><br><span class="line"></span><br><span class="line">max_binlog_size</span><br><span class="line">expire_logs_days = 7          ##日志保存天数</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>slave相关配置</p>
<figure class="highlight shell"><figcaption><span>my.cnf</span></figcaption><table><tr><td class="code"><pre><span class="line">server-id = 2</span><br><span class="line">relay-log = mysql-relay-bin</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">replicate-do-db = rtzc_pnc_base     <span class="comment">##应该在从库上尽可能的使用replicate_wild_*，并不会减少主往从复制数据占用带宽</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">replicate-do-table = db.table      <span class="comment">##表级过滤</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#replicate-ignore-table = db.table</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">replicate_ignore_db=<span class="built_in">test</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">replicate_wild_do_table=DB_NAME.%</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">replicate_wild_ignore_table=DB_NAME.%</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">slave-skip-errors = 1032,1062     <span class="comment">###跳过某些同步错误号</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">log-slave-updates=1          <span class="comment">###从库需要记录binlog，如级联从库场景，级联从库必须有此参数</span></span></span><br><span class="line">log-bin = mysql-bin</span><br><span class="line"></span><br><span class="line">expire_logs_days = 7</span><br><span class="line"></span><br><span class="line">read-only         ###从库Slave中使用read-only参数，确保从库数据不被非法更新。</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">innodb_read_only = 1         <span class="comment">###控制root用户，慎用</span></span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx 服务常用配置说明</title>
    <url>/202207261420/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<h3 id="全局通用配置"><a href="#全局通用配置" class="headerlink" title="全局通用配置"></a>全局通用配置</h3></blockquote>
<figure class="highlight shell"><figcaption><span>nginx.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">user nginx nginx;    </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">建议设置为cpu核心数或者cpu核心数的2倍，进程会包含一个`master process`，多个`worker process`</span>  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">master process负责绑定端口、调度进程等，不负责业务的处理</span>  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">worker process是业务进程，负责业务的处理</span></span><br><span class="line">worker_processes auto;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一个worker进程可以打开的最大的fd个数，受Linux内核限制</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">理论值应该是系统最多打开文件数（<span class="built_in">ulimit</span> -n）与nginx进程数相除</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可通过<span class="built_in">ulimit</span>设置或修改系统文件：`/etc/securit/limits.conf`</span></span><br><span class="line">worker_rlimit_nofile 1024；</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">cpu亲和性设置</span> </span><br><span class="line">worker_cpu_affinity    0001 0010 0100 1000;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">工作进程调度优先级，-20到19之间的值，值越小越优先调用。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果系统同时运行多个任务，你可能需要提高nginx的工作进程的优先级</span> </span><br><span class="line">worker_priority 0；              </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ssl硬件加速服务器，需要硬件支持</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ssl_engine ssl_engine device;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">nginx是否以守护进程运行，是否让nignx运行于后台；调试时可为off，使得所有信息直接输出在控制台</span></span><br><span class="line">daemon      on | off;         </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">events模块中包含nginx中所有处理连接的设置。</span></span><br><span class="line">events &#123;</span><br><span class="line">    # 每个worker进程允许的最多连接数, </span><br><span class="line">    # nginx服务最大连接数：worker_processes * worker_connections (受worker_rlimit_nofile限制)</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">    use epoll;</span><br><span class="line">    </span><br><span class="line">    # 是否允许一次性地响应多个用户请求</span><br><span class="line">    multi_accept on;                    </span><br><span class="line"></span><br><span class="line">    # 是否打开nginx的accept锁；此锁能够让多个worker进行轮流地、序列化地与新的客户端建立连接；</span><br><span class="line">    # 而通常当一个worker进程的负载达到其上限的7/8，master就尽可能不将请求调度至worker.</span><br><span class="line">	accept_mutex on | off;              </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">HTTP模块控制着nginx http处理的所有核心特性</span></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    # 是否在错误页面中显示和响应头字段中发出nginx版本号。</span><br><span class="line">    # 安全考虑建议关闭</span><br><span class="line">    server_tokens on | off | string; </span><br><span class="line">    </span><br><span class="line">    # 是否启用sendfile内核复制模式功能。作为静态服务器可以提供最大的IO访问速度。</span><br><span class="line">    sendfile on | off; </span><br><span class="line">    </span><br><span class="line">    # 尽快发送数据，否则会在数据包达到一定大小后再发送数据。这样会减少网络通信次数，降低阻塞概率，但也会影响响应及时性。</span><br><span class="line">    # 比较适合于文件下载这类的大数据通信场景。</span><br><span class="line">    tcp_nodelay on|off; </span><br><span class="line">    </span><br><span class="line">    # 单位s，适当降低此值可以提高响应连接数量</span><br><span class="line">    keepalive_timeout  65; </span><br><span class="line">    </span><br><span class="line">    # 一次长连接上允许的最大请求数</span><br><span class="line">    keepalive_requests 100；       </span><br><span class="line">    </span><br><span class="line">    # 禁止指定浏览器使用keepalive</span><br><span class="line">    keepalive_disable msie6|none；    </span><br><span class="line">    </span><br><span class="line">    # 读取http请求首部的超时时长。如果客户端在此时间内未传输整个头，则会向客户端返回408（请求超时）错误</span><br><span class="line">    client_header_timeout 1;     </span><br><span class="line">    </span><br><span class="line">    # 读取http请求包体的超时时间。</span><br><span class="line">    client_body_timeout 2;</span><br><span class="line">    </span><br><span class="line">    # 发送响应的超时时长。超时后连接将关闭。</span><br><span class="line">    send_timeout 5;  </span><br><span class="line">    </span><br><span class="line">    #http请求包体的最大值，常用于限定客户端所能够请求的最大包体，根据请求首部中的Content-Length来检查，以避免无用的传输。</span><br><span class="line">    client_max_body_size 1m;</span><br><span class="line">    </span><br><span class="line">    # 限制客户端每秒传输的字节数，默认为0，表示没有限制。单位Byte/s</span><br><span class="line">    limit_rate 0;</span><br><span class="line">    </span><br><span class="line">    # nginx向客户端发送响应报文时，如果大小超过了此处指定的值，则后续的发送过程开始限速，单位Byte</span><br><span class="line">    limit_rate_after 0;</span><br><span class="line">    </span><br><span class="line">    # 是否忽略不合法的http首部，默认为on，off意味着请求首部中出现不合规的首部将拒绝响应。</span><br><span class="line">    ignore_invalid_headers on|off;</span><br><span class="line">    </span><br><span class="line">    # 用户访问的文件不存在时，是否将其记录到错误日志中。</span><br><span class="line">    log_not_found on|off;   </span><br><span class="line">    </span><br><span class="line">    # nginx使用的dns地址，及缓存解析结果的时间               </span><br><span class="line">    resolver 8.8.8.8 [valid=time] [ipv6=on|off];</span><br><span class="line">    </span><br><span class="line">    # dns解析超时时间 </span><br><span class="line">    resolver_timeout 2；     </span><br><span class="line">    </span><br><span class="line">    # 是否打开文件缓存功能，max：用于缓存条目的最大值，</span><br><span class="line">    # inactive：某缓存条目在指定时长内没有被访问过时，将自动被删除，即缓存有效期，通常默认为60s。</span><br><span class="line">    open_file_cache off;  </span><br><span class="line">    open_file_cache max=N [inactive=time];    </span><br><span class="line">    </span><br><span class="line">    # 是否缓存文件找不到或没有权限访问等相关信息。</span><br><span class="line">    open_file_cache_errors on | off; </span><br><span class="line">    </span><br><span class="line">    # 多长时间检查一次缓存中的条目是否超出非活动时长。</span><br><span class="line">    # 建议值：小于等于open_file_cache inactive</span><br><span class="line">    open_file_cache_valid 60;   </span><br><span class="line">    </span><br><span class="line">    # 在open_file_cache inactive指定的时长内被访问超过此处指定的次数时，才不会被删除（删除低命中率的缓存）。</span><br><span class="line">    open_file_cache_min_uses 2;     </span><br><span class="line">    </span><br><span class="line">    # 开启内容压缩，可以有效降低客户端的访问流量和网络带宽</span><br><span class="line">    gzip on | off;</span><br><span class="line">    </span><br><span class="line">    # 内容超过最少长度后才开启压缩，太短的内容压缩效果不佳，且会浪费系统资源。</span><br><span class="line">    # 压缩长度会作为http响应头Content-Length字段返回给客户端。 建议值：64</span><br><span class="line">    gzip_min_length length;</span><br><span class="line">    </span><br><span class="line">    # 压缩级别，默认值为1。范围为1～9级，压缩级别越高压缩率越高，但对系统性能要求越高。建议值：4</span><br><span class="line">    gzip_comp_level 1~9;</span><br><span class="line">    </span><br><span class="line">    # 压缩内容类型，默认为text/html;。只压缩html文本，一般我们都会压缩js、css、json之类的，可以把这些常见的文本数据都配上。</span><br><span class="line">    如：text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;</span><br><span class="line">    gzip_types mime-type …;     </span><br><span class="line">    </span><br><span class="line">    # 定义日志格式</span><br><span class="line">    log_format main &#x27;&#123; time: $time_iso8601|&#x27;</span><br><span class="line">                    &#x27;http_host:$http_host|&#x27;</span><br><span class="line">                    &#x27;cdn_ip:$remote_addr|&#x27;</span><br><span class="line">                    &#x27;request:$request|&#x27;</span><br><span class="line">                    &#x27;request_method:$request_method|&#x27;</span><br><span class="line">                    &#x27;http_user_agent:$http_user_agent|&#x27;</span><br><span class="line">                    &#x27;size:$body_bytes_sent|&#x27;</span><br><span class="line">                    &#x27;responsetime:$request_time|&#x27;</span><br><span class="line">                    &#x27;upstreamtime:$upstream_response_time|&#x27;</span><br><span class="line">                    &#x27;upstreamhost:$upstream_addr|&#x27;</span><br><span class="line">                    &#x27;upstreamstatus:$upstream_status|&#x27;</span><br><span class="line">                    &#x27;url:$http_host$uri|&#x27;</span><br><span class="line">                    &#x27;http_x_forwarded_for:$clientRealIp|&#x27;</span><br><span class="line">                    &#x27;status:$status&#125;&#x27;;</span><br><span class="line">    </span><br><span class="line">    # server负责具体的http服务器实现</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80 [default_server]  [rcvbuf=SIZE]  [sndbuf=SIZE] [ssl];</span><br><span class="line">        </span><br><span class="line">        # 可使用通配符*或正则表达式(~开头)，多个域名先精确匹配，再通配，再正则,&#x27;_&#x27;表示空主机头</span><br><span class="line">        server_name  _  ;</span><br><span class="line">        </span><br><span class="line">        access_log logs/access.log main;</span><br><span class="line">        error_log logs/access.err.log;</span><br><span class="line">        </span><br><span class="line">        # 跨域配置</span><br><span class="line">        add_header Access-Control-Allow-Origin *;</span><br><span class="line">        add_header Access-Control-Allow-Headers &#x27;Origin, No-Cache, X-Requested-With, If-Modified-Since, Pragma, Last-Modified, Cache-Control, Expires, Content-Type, X-E4M-With&#x27;;</span><br><span class="line">        add_header Access-Control-Allow-Methods GET,POST,OPTIONS;</span><br><span class="line">        add_header Access-Control-Allow-Credentials: true;</span><br><span class="line">        </span><br><span class="line">        location / &#123;       </span><br><span class="line">            # web资源路径             </span><br><span class="line">            root   html;          </span><br><span class="line">            </span><br><span class="line">            # 定义默认页面，从左往右匹配           </span><br><span class="line">            index  index.html index.htm;   </span><br><span class="line">            </span><br><span class="line">            # 自左向右读取指定路径，找到即停止，如果都不存在，返回一个错误码</span><br><span class="line">            try_files $uri $uri.html $uri/index.html =404;        </span><br><span class="line">            </span><br><span class="line">            # 自左向右读取指定路径，找到即停止，如果都不存在，返回一个uri</span><br><span class="line">            try_files $uri $uri.html $uri/index.html /404.html; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        location /i/ &#123; </span><br><span class="line">            # 路径别名，只能用于location中。</span><br><span class="line">            # 访问 http://a.com/i/a.html, 资源路径为：/data/www/html/a.html</span><br><span class="line">            # 若是root指令，访问 http://a.com/i/a.html，资源路径为：/data/www/html/i/a.html</span><br><span class="line">		    alias /data/www/html/;          </span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">	    # 对于某个请求发生错误，如果匹配到错误码，重定向到新的url</span><br><span class="line">	    error_page  404              /404.html; </span><br><span class="line">	    error_page   500 502 503 504  /50x.html;</span><br><span class="line">	    </span><br><span class="line">	    # 对于某个请求发生错误，如果匹配到错误码，重定向到新的url,同时可以更改返回码</span><br><span class="line">	    error_page 404 =200 /404.html;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    # 包含其他配置文件</span><br><span class="line">    include vhosts/*.conf;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>

<blockquote>
<h3 id="Server-常用配置"><a href="#Server-常用配置" class="headerlink" title="Server 常用配置"></a>Server 常用配置</h3></blockquote>
<h4 id="nginx-代理php"><a href="#nginx-代理php" class="headerlink" title="nginx 代理php"></a>nginx 代理php</h4><figure class="highlight shell"><figcaption><span>vhosts/web.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name  _  ;</span><br><span class="line">    root           html;</span><br><span class="line">    </span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        fastcgi_index  index.php;</span><br><span class="line">        fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;          ###fastcgi程序的页面文件位置，$document_root = 之前配置的root           html;</span><br><span class="line">        ##include        fastcgi_params;</span><br><span class="line">	    fastcgi_param  QUERY_STRING       $query_string;                  ###将请求中的参数透传</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="nginx-状态监控"><a href="#nginx-状态监控" class="headerlink" title="nginx 状态监控"></a>nginx 状态监控</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置访问路径，即uri</span></span><br><span class="line">location = /nginx_status&#123;  </span><br><span class="line">  </span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">开启该模块</span></span><br><span class="line">  stub_status on;    </span><br><span class="line">  </span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">关闭日志</span>  </span><br><span class="line">  access_log off;   </span><br><span class="line">        </span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">允许访问的ip，即白名单ip</span> </span><br><span class="line">  allow 101.106.102.129;        </span><br><span class="line">  allow 127.0.0.1;</span><br><span class="line">  </span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">拒绝白名单ip以外的ip访问</span></span><br><span class="line">  deny all;               </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="ssl-配置"><a href="#ssl-配置" class="headerlink" title="ssl 配置"></a>ssl 配置</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name csms.tech;</span><br><span class="line">  </span><br><span class="line">    ssl_certificate /path/to/your_certificate.pem;</span><br><span class="line">    ssl_certificate_key /path/to/your_key.key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">强制跳转https</span></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name csms.tech;</span><br><span class="line">    rewrite ^(.*)$  https://$host$1 permanent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用pem类型证书链：可将中间证书导入pem文件，再将私钥导入pem文件，ssl_certificate和ssl_certificate_key都使用pem文件，可解决以下报错：<br>SSL_CTX_use_PrivateKey_file(“pri.key”) failed  (SSL: error:0906D06C:PEM routines:PEM_read_bio:no start line:Expecting: ANY PRIVATE KEY error:140B0009:SSL routines:SSL_CTX_use_PrivateKey_file:PEM lib</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat gd_bundle-g2-g1.crt &gt;&gt; f549150b196cd59e.pem</span><br><span class="line">cat f549150b196cd59e.key &gt;&gt; f549150b196cd59e.pem</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><figcaption><span>nginx.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">ssl_certificate f549150b196cd59e.pem;</span><br><span class="line">ssl_certificate_key  f549150b196cd59e.pem;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="配置-upstream-代理"><a href="#配置-upstream-代理" class="headerlink" title="配置 upstream 代理"></a>配置 upstream 代理</h4><figure class="highlight shell"><figcaption><span>upstream.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">upstream myserver &#123;</span><br><span class="line">    # 调度策略,默认为轮询</span><br><span class="line">    ip_hash | url_hash ...</span><br><span class="line">    </span><br><span class="line">    # 后端服务器列表</span><br><span class="line">    # backup:其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。</span><br><span class="line">    # max_fails:允许请求失败的次数，默认为1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误.</span><br><span class="line">    # fail_timeout : max_fails次失败后，暂停的时间。 </span><br><span class="line">    server 10.0.0.1:8080 [weight=1] [backup] [down] [max_fails] [fail_timeout];</span><br><span class="line">    server 10.0.0.2:8080 [weight=1] [backup] [down] [max_fails] [fail_timeout];</span><br><span class="line"></span><br><span class="line">    keepalive 2000;</span><br><span class="line">    </span><br><span class="line">    # 后端健康检测，需要第三方插件ngx_http_healthcheck_module</span><br><span class="line">    # healthcheck_enabled;         </span><br><span class="line">    # healthcheck_delay 3000;</span><br><span class="line">    # healthcheck_timeout 1000;</span><br><span class="line">    # healthcheck_failcount 2;</span><br><span class="line">    # healthcheck_send &#x27;GET /healthcheck.html HTTP/1.0&#x27; &#x27;Host: local.com&#x27; &#x27;Connection: close&#x27;;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;                                                         </span><br><span class="line">    server_name  csms.tech;                                               </span><br><span class="line">    client_max_body_size 1024M;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        # 指定协议、主机名、端口</span><br><span class="line">        proxy_pass http://myserver/uri;</span><br><span class="line">                     </span><br><span class="line">        [proxy_set_header Host $host:$server_port;]</span><br><span class="line">        [proxy_redirect     off;]</span><br><span class="line">        [proxy_set_header X-Real-IP $remote_addr;]</span><br><span class="line">        [proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;]</span><br><span class="line">        [proxy_set_header X-Forwarded-Proto https;]</span><br><span class="line">        [proxy_ignore_client_abort on;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ip-限制"><a href="#ip-限制" class="headerlink" title="ip 限制"></a>ip 限制</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;                                                         </span><br><span class="line">    server_name  csms.tech;</span><br><span class="line">    </span><br><span class="line">    root html;</span><br><span class="line">    </span><br><span class="line">    if ($http_x_forwarded_for !~ (1.1.1.1|1.1.1.2)) &#123;</span><br><span class="line">        return 403;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="地区限制"><a href="#地区限制" class="headerlink" title="地区限制"></a>地区限制</h4><p>依赖nginx 的<code>http_geoip_module</code> 模块，检查<code>GeoIP</code>是否安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./sbin/nginx -V </span><br></pre></td></tr></table></figure>
<p>输出结果中如果不包含：<code>--with-http_geoip_module</code>，说明未安装，重新编译安装nginx<br>安装<code>http_geoip_module</code>模块后使用以下配置</p>
<figure class="highlight shell"><figcaption><span>nginx.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    geoip_country /usr/share/GeoIP/GeoIP.dat;</span><br><span class="line">    </span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name csms.tech;</span><br><span class="line">        </span><br><span class="line">        location / &#123;</span><br><span class="line">            if ($geoip_country_code != CN) &#123;</span><br><span class="line">                root outChina;</span><br><span class="line">            &#125;</span><br><span class="line">            root China;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="server-中location优先级"><a href="#server-中location优先级" class="headerlink" title="server 中location优先级"></a>server 中<code>location</code>优先级</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    # 精确匹配，最高优先级</span><br><span class="line">    location = /url  &#123;&#125;        </span><br><span class="line"></span><br><span class="line">    # 从前往后匹配，匹配到即停止继续匹配，不是正则匹配，第二优先级</span><br><span class="line">    location ^~ /uri  &#123;&#125;          </span><br><span class="line"></span><br><span class="line">    # 正则匹配，~ 区分大小写， ~* 不区分大小写，第三优先级</span><br><span class="line">    location ~ ^/url$ &#123;&#125;    </span><br><span class="line">    location ~* ^/url$ &#123;&#125;    </span><br><span class="line">	</span><br><span class="line">    # / 会匹配到所有未被匹配到的url</span><br><span class="line">    location /documents/ &#123;&#125; </span><br><span class="line">    location / &#123;&#125; </span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="301-跳转配置"><a href="#301-跳转配置" class="headerlink" title="301 跳转配置"></a>301 跳转配置</h4><p>如下配置，使用 <code>rewrite</code> 或 <code>return</code> 指令，所有 <a href="https://csms.tech/"><code>csms.tech</code></a> 的请求都会 <code>301</code> 重定向到 <a href="https://csms.tech/"><code>www.csms.tech</code></a>，并携带原来的 <code>uri</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name csms.tech;</span><br><span class="line">    </span><br><span class="line">    rewrite ^/(.*)$ https://www.csms.tech$1 permanent;</span><br><span class="line">    </span><br><span class="line">    # return 301 https://www.csms.tech$request_uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3></blockquote>
<h4 id="worker-connections-exceed-open-file-resource-limit"><a href="#worker-connections-exceed-open-file-resource-limit" class="headerlink" title="worker_connections exceed open file resource limit"></a>worker_connections exceed open file resource limit</h4><p><strong>问题原因</strong>： worker_rlimit_nofile的值小于worker_connections的值，参数说明可参考<a href="#%E5%85%A8%E5%B1%80%E9%80%9A%E7%94%A8%E9%85%8D%E7%BD%AE">全局通用配置</a>  </p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>nodejs安装配置</title>
    <url>/647e4c1a/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://nodejs.org/dist/latest/node-v15.12.0-linux-x64.tar.gz</span><br><span class="line">tar -xf node-v15.12.0-linux-x64.tar.gz -C /usr/local</span><br><span class="line">ln -s /usr/local/node-v15.12.0-linux-x64/bin/* /bin/</span><br></pre></td></tr></table></figure>

<p>安装pm2</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install pm2 -g</span><br><span class="line">npm install -g pm2@3.5.1    # 安装指定版本</span><br></pre></td></tr></table></figure>

<h4 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h4><blockquote>
<p>WARN EACCES user “root” does not have permission to access the dev dir “&#x2F;root&#x2F;.node-gyp&#x2F;11.15.0”<br>ERR! stack Error: EACCES: permission denied, mkdir ‘node_modules&#x2F;sqlite3&#x2F;.node-gyp’</p>
<p>[解决方法]：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --unsafe-perm</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>php 编译安装配置</title>
    <url>/202207301722/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Centos 7</li>
<li>Php 7.2</li>
</ul>
<span id="more"></span>

<h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><p>安装依赖包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y gcc libxml2-devel libjpeg-turbo-devel libpng-devel libxslt libxslt-devel libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel libxml2 libxml2-devel zlib zlib-devel curl curl-devel openssl openssl-devel  bzip2  bzip2-devel  libxslt libxslt-devel  libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel libxml2 libxml2-devel zlib zlib-devel curl curl-devel openssl openssl-devel perl perl-devel httpd-devel readline-devel autoconf</span><br></pre></td></tr></table></figure>
<p>下载安装包，编译安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://am1.php.net/distributions/php-7.2.0.tar.bz2</span><br><span class="line">tar -xf php-7.2.0.tar.bz2</span><br><span class="line">cd php-7.2.0</span><br><span class="line"></span><br><span class="line">./configure --prefix=/usr/local/php7/ \</span><br><span class="line">--with-fpm-user=nginx \</span><br><span class="line">--with-curl  --with-gd --with-gettext --with-iconv-dir --with-kerberos --with-libdir=lib64 \</span><br><span class="line">--with-libxml-dir --with-mysqli --with-openssl --with-pcre-regex --with-pdo-mysql \</span><br><span class="line">--with-pdo-sqlite --with-pear --with-png-dir --with-xmlrpc --with-xsl --with-zlib \</span><br><span class="line">--enable-fpm --enable-bcmath -enable-inline-optimization  --enable-mbregex --enable-mbstring \</span><br><span class="line">--enable-opcache --enable-pcntl --enable-shmop --enable-soap --enable-sockets --enable-sysvsem \</span><br><span class="line">--enable-xml --enable-zip --enable-pcntl --with-curl  --enable-ftp --enable-session --enable-xml \</span><br><span class="line">--with-freetype-dir --with-jpeg-dir --enable-calendar --enable-exif --with-readline --enable-sysvshm --enable-wddx</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>安装完成后，拷贝配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp php.ini-production /usr/local/php7/etc/php.ini</span><br><span class="line">cd /usr/local/php7/etc</span><br><span class="line">mv php-fpm.conf.default php-fpm.conf</span><br></pre></td></tr></table></figure>
<p>php编译好之后，提供了一个php-fpm的程序作为服务管理程序，位置在编译后的源码目录：<code>php-7.2.0/sapi/fpm/</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp php-fpm.service /usr/lib/systemd/system/</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start php-fpm</span><br></pre></td></tr></table></figure>

<h3 id="php-常用扩展安装方法"><a href="#php-常用扩展安装方法" class="headerlink" title="php 常用扩展安装方法"></a>php 常用扩展安装方法</h3><p>php 扩展优先选择使用 <code>pecl</code> 命令安装，需要特殊配置时再选择编译安装， <code>pecl</code> 安装 <code>redis</code> 扩展示例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pecl install redis</span><br></pre></td></tr></table></figure>

<h4 id="yac-扩展安装"><a href="#yac-扩展安装" class="headerlink" title="yac 扩展安装"></a>yac 扩展安装</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/laruence/yac</span><br><span class="line">cd yac</span><br><span class="line">phpize</span><br><span class="line">./configure --with-php-config=/usr/local/php7/bin/php-config</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h4 id="composer-安装"><a href="#composer-安装" class="headerlink" title="composer 安装"></a>composer 安装</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">php -r &quot;readfile(&#x27;https://getcomposer.org/installer&#x27;);&quot; | php</span><br><span class="line">mv composer.phar /usr/local/bin/composer</span><br></pre></td></tr></table></figure>

<h4 id="inotify-安装"><a href="#inotify-安装" class="headerlink" title="inotify 安装"></a>inotify 安装</h4><p>扩展<a href="http://pecl.php.net/package/inotify">下载地址</a><br>比如安装2.0.0版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://pecl.php.net/get/inotify-2.0.0.tgz</span><br><span class="line">tar -xf inotify-2.0.0.tgz</span><br><span class="line">phpize</span><br><span class="line">./configure --with-php-config=/usr/local/php7/bin/php-config --enable-inotify</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h4 id="memcache-扩展安装"><a href="#memcache-扩展安装" class="headerlink" title="memcache 扩展安装"></a>memcache 扩展安装</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install libmemcached libmemcached-devel     ##先按照依赖，否则make报错</span><br><span class="line">git clone https://github.com/php-memcached-dev/php-memcached.git php-memcache</span><br><span class="line">cd php-memcache/</span><br><span class="line">git checkout php7</span><br><span class="line">phpize</span><br><span class="line">./configure --enable-memcached --with-php-config=/usr/local/php7/bin/php-config</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p><code>php.ini</code> 中添加配置 <code>extension=memcached.so</code></p>
<h4 id="gd-扩展安装"><a href="#gd-扩展安装" class="headerlink" title="gd 扩展安装"></a>gd 扩展安装</h4><p>进入到php的源码目录下的ext&#x2F;gd目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd php-7.2.0/ext/gd</span><br><span class="line">yum -y install libjpeglibjpeg-devel libpng libpng-devel freetype freetype-devel</span><br><span class="line">make clean</span><br><span class="line">phpize</span><br><span class="line">./configure --with-png-dir --with-freetype-dir --with-jpeg-dir --with-gd --with-php-config=/usr/local/php7/bin/php-config</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p><code>php.ini</code> 中添加配置 <code>extension=gd.so</code></p>
<h4 id="mongodb-扩展安装"><a href="#mongodb-扩展安装" class="headerlink" title="mongodb 扩展安装"></a>mongodb 扩展安装</h4><p>扩展<a href="http://pecl.php.net/package/mongodb">下载地址</a>  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://pecl.php.net/get/mongodb-1.14.0.tgz</span><br><span class="line">tar -xf mongodb-1.14.0.tgz</span><br><span class="line">cd mongodb-1.14.0</span><br><span class="line">/usr/local/php7/bin/phpize</span><br><span class="line">./configure --with-php-config=/usr/local/php7/bin/php-config</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h4 id="imagick-扩展安装"><a href="#imagick-扩展安装" class="headerlink" title="imagick 扩展安装"></a>imagick 扩展安装</h4><p>首先安装ImageMagick</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://imagemagick.org/download/ImageMagick.tar.gz</span><br><span class="line">tar -xf ImageMagick.tar.gz</span><br><span class="line">cd ImageMagick</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>安装 <code>imagick</code> 扩展</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://pecl.php.net/get/imagick-3.4.4.tgz</span><br><span class="line">/usr/local/php7/bin/phpize </span><br><span class="line">./configure --with-php-config=/usr/local/php7/bin/php-config</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h4 id="trie-filter-扩展安装"><a href="#trie-filter-扩展安装" class="headerlink" title="trie_filter 扩展安装"></a>trie_filter 扩展安装</h4><p>安装依赖 <code>libdatrie</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -O ftp://linux.thai.net/pub/ThaiLinux/software/libthai/libdatrie-0.2.4.tar.gz</span><br><span class="line">tar zxvf libdatrie-0.2.4.tar.gz</span><br><span class="line">cd libdatrie-0.2.4</span><br><span class="line">make clean</span><br><span class="line">./configure --prefix=/usr/local/libdatrie</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>安装扩展 <code>trie_filter</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://github.com/jiopuud/trie_filter/archive/master.zip</span><br><span class="line">unzip master.zip</span><br><span class="line">cd trie_filter-master</span><br><span class="line">phpize</span><br><span class="line">./configure --with-php-config=/usr/local/php7/bin/php-config --with-trie_filter=/usr/local/libdatrie</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="swoole-扩展安装"><a href="#swoole-扩展安装" class="headerlink" title="swoole 扩展安装"></a>swoole 扩展安装</h4><p>安装依赖 <code>hiredis</code>（可选操作）<br><a href="https://github.com/redis/hiredis/releases">下载链接</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>安装 <code>woole</code> 扩展<br><a href="https://github.com/swoole/swoole-src/releases">下载地址</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xf swoole-src-1.9.15.tar.gz</span><br><span class="line">cd swoole-src-1.9.15</span><br><span class="line">phpize</span><br><span class="line">./configure --enable-openssl --enable-async-redis --with-php-config=/usr/local/php7/bin/php-config</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>--enable-async-redis</code> 依赖<code>hiredis</code>， 需要先安装 <code>hiredis</code><br>编译安装过程中，可能出现找不到动态链接库的问题，可将 <code>/usr/local/lib</code> 添加到共享的动态库，<br>编辑 <code>ldconfig</code> 配置文件 <code>/etc/ld.so.conf</code>，追加以下内容</p>
<figure class="highlight shell"><figcaption><span>/etc/ld.so.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">/usr/local/lib</span><br></pre></td></tr></table></figure>
<p>修改 <code>ldconfig</code> 配置后，执行以下命令使新配置生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ldconfig</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="phpredis-扩展安装"><a href="#phpredis-扩展安装" class="headerlink" title="phpredis 扩展安装"></a>phpredis 扩展安装</h4><p><a href="https://github.com/phpredis/phpredis/releases">下载地址</a>  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd phpredis/</span><br><span class="line">phpize</span><br><span class="line">./configure --with-php-config=/usr/local/php7/bin/php-config</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>predixy 安装配置</title>
    <url>/202207271506/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3></blockquote>
<ul>
<li>Centos 7</li>
<li>predixy-1.0.5</li>
</ul>
<blockquote>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3></blockquote>
<p><a href="https://github.com/joyieldInc/predixy">下载地址</a>, clone或下载最新的版本或指定版本下载后解压</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install libstdc++-static -y</span><br><span class="line">cd predixy-1.0.5</span><br><span class="line">make</span><br><span class="line">cp src/predixy /usr/local/bin/</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要依赖 <code>libstdc++-static</code>, 否则make会报错：<br>&#x2F;bin&#x2F;ld: cannot find -lstdc++<br>collect2: error: ld returned 1 exit status<br>make[1]: *** [predixy] Error 1<br>make[1]: Leaving directory &#96;&#x2F;root&#x2F;predixy-1.0.5&#x2F;src’<br>make: *** [default] Error 2</p>
</blockquote>
<blockquote>
<h3 id="配置文件说明"><a href="#配置文件说明" class="headerlink" title="配置文件说明"></a>配置文件说明</h3></blockquote>
<ul>
<li><p>predixy.conf，整体配置文件，会引用下面的配置文件</p>
</li>
<li><p>cluster.conf，用于Redis Cluster时，配置后端redis信息</p>
</li>
<li><p>sentinel.conf，用于Redis Sentinel时，配置后端redis信息</p>
</li>
<li><p>auth.conf，访问权限控制配置，可以定义多个验证密码，可每个密码指定读、写、管理权限，以及定义可访问的健空间</p>
</li>
<li><p>dc.conf，多数据中心支持，可以定义读写分离规则，读流量权重分配</p>
</li>
<li><p>latency.conf， 延迟监控规则定义，可以指定需要监控的命令以及延时时间间隔</p>
</li>
</ul>
<blockquote>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3></blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">predixy /predixy/conf/predixy.conf</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用默认的配置文件predixy.conf， predixy将监听地址0.0.0.0:7617，后端的redis是Redis Cluster 127.0.0.1:6379  </p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Predixy</tag>
      </tags>
  </entry>
  <entry>
    <title>Pycharm 快速插入时间</title>
    <url>/202208041319/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>PyCharm 2022.1 (Professional Edition)</li>
</ul>
<h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><p>通过配置 <code>Live Template</code> 实现快速插入时间  </p>
<ol>
<li><p>打开 File &gt; Setting &gt; Editor: Live Templates</p>
</li>
<li><p>选中常用的语言，比如 <code>Python</code>，点击右上角的 <code>+</code>，添加 <code>Live Template</code><br> <code>Abbreviation</code> 输入快捷输入的名称，比如 <code>currentTime</code><br> <code>Description</code> 输入描述信息<br> <code>Template Text</code> 输入 <code>$time$</code><br> <img src="https://i.csms.tech/img_32.png"></p>
</li>
<li><p>点击 <code>Edit Variables</code> 配置命令及格式<br> <img src="https://i.csms.tech/img_33.png"></p>
</li>
<li><p><code>Define</code> 选择 <code>Everywhere</code>，<code>Apply</code>让配置生效</p>
</li>
<li><p>编辑时输入 <code>currentTime</code>,可以直接插入当前时间<br> <img src="https://i.csms.tech/img_34.png"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>PyCharm</category>
      </categories>
      <tags>
        <tag>PyCharm</tag>
      </tags>
  </entry>
  <entry>
    <title>python requirements 的创建及使用</title>
    <url>/202208161710/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Python 3.10</li>
</ul>
<p><code>python</code> 项目中最好包含一个 <code>requirements.txt</code> 文件，用于记录所有依赖包及其精确的版本号。以便新环境部署。</p>
<span id="more"></span>

<h3 id="requirements-生成和使用"><a href="#requirements-生成和使用" class="headerlink" title="requirements 生成和使用"></a>requirements 生成和使用</h3><p>在项目中安装新的包之后，可以运行以下命令更新 <code>requirements</code> 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure>
<p><code>requirements.txt</code> 文件内容示例：</p>
<figure class="highlight shell"><figcaption><span>requirements.txt</span></figcaption><table><tr><td class="code"><pre><span class="line">asgiref==3.5.2</span><br><span class="line">Django==4.0</span><br><span class="line">django-mdeditor==0.1.20</span><br><span class="line">Markdown==3.3.7</span><br><span class="line">Pillow==9.2.0</span><br><span class="line">Pygments==2.12.0</span><br><span class="line">PyMySQL==1.0.2</span><br><span class="line">sqlparse==0.4.2</span><br><span class="line">uWSGI==2.0.20</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>生成的文件中会包含项目需要的所有包以及精确的版本号信息，新环境部署时，可使用以下命令安装依赖包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python 虚拟环境</title>
    <url>/202208161730/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Python 3.10</li>
</ul>
<h3 id="虚拟环境创建步骤"><a href="#虚拟环境创建步骤" class="headerlink" title="虚拟环境创建步骤"></a>虚拟环境创建步骤</h3><p>假定项目名为 <code>project01</code>, 目录名为 <code>project01</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir project01</span><br><span class="line">cd project01</span><br><span class="line">python3 -m venv .</span><br></pre></td></tr></table></figure>
<p>以上命令会在目录 <code>project01</code> 中创建虚拟环境，查看当前目录，会产生以下目录和文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">bin  include  lib  lib64  pyvenv.cfg</span><br></pre></td></tr></table></figure>
<p>观察 <code>bin</code> 目录的内容，里面有 <code>python3</code>、<code>pip3</code> 等可执行文件，实际上是链接到 <code>Python</code> 系统目录的软链接。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l bin/</span></span><br><span class="line">total 36</span><br><span class="line">-rw-r--r-- 1 root root 1991 Aug 16 17:35 activate</span><br><span class="line">-rw-r--r-- 1 root root  917 Aug 16 17:35 activate.csh</span><br><span class="line">-rw-r--r-- 1 root root 2059 Aug 16 17:35 activate.fish</span><br><span class="line">-rw-r--r-- 1 root root 9033 Aug 16 17:35 Activate.ps1</span><br><span class="line">-rwxr-xr-x 1 root root  234 Aug 16 17:35 pip</span><br><span class="line">-rwxr-xr-x 1 root root  234 Aug 16 17:35 pip3</span><br><span class="line">-rwxr-xr-x 1 root root  234 Aug 16 17:35 pip3.10</span><br><span class="line">lrwxrwxrwx 1 root root   10 Aug 16 17:35 python -&gt; python3.10</span><br><span class="line">lrwxrwxrwx 1 root root   10 Aug 16 17:35 python3 -&gt; python3.10</span><br><span class="line">lrwxrwxrwx 1 root root   25 Aug 16 17:35 python3.10 -&gt; /usr/local/bin/python3.10</span><br></pre></td></tr></table></figure>

<p><code>Linux</code> 环境使用以下命令激活虚拟环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">source</span> bin/activate</span></span><br><span class="line">(project01) [root@localhost project01]#</span><br></pre></td></tr></table></figure>
<p>命令提示符变了，有个 <code>(project01)</code> 前缀，表示当前环境是一个名为 <code>project01</code> 的 Python 环境。<br>在此虚拟环境中安装包，都会被安装到 <code>(project01)</code> 环境下，具体目录为 <code>project01/lib/python3.10/site-packages/</code>，系统 Python 环境不受任何影响，也就是说，<code>project01</code> 这个环境是专门针对 <code>project01</code> 应用（项目）创建的，和系统 python 环境或其他应用互不影响。  </p>
<p>要退出当前虚拟环境，可以执行以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure>
<p>退出虚拟环境后，再执行如 <code>pip3 install</code> 命令安装的包，会安装到系统 Python 环境。<br>完全可以针对每个应用创建独立的Python运行环境，这样就可以对每个应用的Python环境进行隔离。</p>
<p>如果不再使用某个 <code>venv</code> ，例如 <code>project01</code>，删除它也很简单。首先确认该 <code>venv</code> 没有处于 <code>激活</code> 状态，然后直接把整个目录 <code>project01</code> 删掉就行。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>rsyncd 服务</title>
    <url>/36f703dc/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync [OPTION]... SRC DEST</span><br><span class="line">rsync [OPTION]... SRC [USER@]host:DEST</span><br><span class="line">rsync [OPTION]... [USER@]HOST:SRC DEST</span><br><span class="line">rsync [OPTION]... [USER@]HOST::SRC DEST</span><br><span class="line">rsync [OPTION]... SRC [USER@]HOST::DEST</span><br><span class="line">rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST]</span><br></pre></td></tr></table></figure>

<p><code>:</code>   ssh 方式进行备份，ssh 非默认端口使用选项 <code>-e</code> 指定端口, <code>-e &#39;ssh -p 30000&#39;</code></p>
<p><code>::</code>   socket 方式进行备份，<code>rsync</code> 以服务方式监听，<code>SRC/DEST</code> 为配置中定义的模块 <code>[]</code></p>
<blockquote>
<ul>
<li><code>rsync</code> 命令使用中，如果源参数的末尾有斜线，只会复制指定目录的内容，而不复制目录本身，没有斜线，则会复制目录本身，包括目录</li>
<li>客户端免密登录时，需要在客户端建立密码文件： <code>/etc/rsync.passwd</code>，文件中只保存密码，权限为600，用选项 <code>--password-file</code> 指明存放密码的文件位置</li>
</ul>
</blockquote>
<span id="more"></span>

<h3 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h3><table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>-v, --verbose </code></td>
<td>详细模式输出。</td>
<td></td>
</tr>
<tr>
<td><code>-q, --quiet </code></td>
<td>精简输出模式。</td>
<td></td>
</tr>
<tr>
<td><code>-c, --checksum </code></td>
<td>打开校验开关，强制对文件传输进行校验。</td>
<td></td>
</tr>
<tr>
<td><code>-a, --archive</code></td>
<td>归档模式，表示以递归方式传输文件，并保持所有文件属性，等于 <code>-rlptgoD</code>。</td>
<td></td>
</tr>
<tr>
<td><code>-r, --recursive</code></td>
<td>对子目录以递归模式处理。</td>
<td></td>
</tr>
<tr>
<td><code>-R, --relative</code></td>
<td>使用相对路径信息。</td>
<td></td>
</tr>
<tr>
<td><code>-b, --backup</code></td>
<td>创建备份，也就是对于目的已经存在有同样的文件名时，将老的文件重新命名为 <code>~filename</code> 。可以使用 <code>--suffix</code> 选项来指定不同的备份文件前缀。</td>
<td></td>
</tr>
<tr>
<td><code> --backup-dir</code></td>
<td>将备份文件(如 <code>~filename</code>)存放在在目录下。</td>
<td></td>
</tr>
<tr>
<td><code>--suffix=SUFFIX </code></td>
<td>定义备份文件前缀。</td>
<td></td>
</tr>
<tr>
<td><code>-u, --update  </code></td>
<td>仅仅进行更新，也就是跳过所有已经存在于 DST，并且文件时间晚于要备份的文件，不覆盖更新的文件。</td>
<td></td>
</tr>
<tr>
<td><code>-l, --links</code></td>
<td>保留软链结。</td>
<td></td>
</tr>
<tr>
<td><code>-L, --copy-links</code></td>
<td>想对待常规文件一样处理软链结。</td>
<td></td>
</tr>
<tr>
<td><code>--copy-unsafe-links  </code></td>
<td>仅仅拷贝指向SRC路径目录树以外的链结。</td>
<td></td>
</tr>
<tr>
<td><code>--safe-links   </code></td>
<td>忽略指向SRC路径目录树以外的链结。</td>
<td></td>
</tr>
<tr>
<td><code>-H, --hard-links</code></td>
<td>保留硬链结。</td>
<td></td>
</tr>
<tr>
<td><code>-p, --perms </code></td>
<td>保持文件权限。</td>
<td></td>
</tr>
<tr>
<td><code>-o, --owner </code></td>
<td>保持文件属主信息。</td>
<td></td>
</tr>
<tr>
<td><code>-g, --group</code></td>
<td>保持文件属组信息。</td>
<td></td>
</tr>
<tr>
<td><code>-D, --devices</code></td>
<td>保持设备文件信息。</td>
<td></td>
</tr>
<tr>
<td><code>-t, --times  </code></td>
<td>保持文件时间信息。</td>
<td></td>
</tr>
<tr>
<td><code>-S, --sparse  </code></td>
<td>对稀疏文件进行特殊处理以节省DST的空间。</td>
<td></td>
</tr>
<tr>
<td><code>-n, --dry-run </code></td>
<td>只显示哪些文件将被传输，不进行真正的传输。</td>
<td></td>
</tr>
<tr>
<td><code>-w, --whole-file </code></td>
<td>拷贝文件，不进行增量检测。</td>
<td></td>
</tr>
<tr>
<td><code>-x, --one-file-system </code></td>
<td>不要跨越文件系统边界。</td>
<td></td>
</tr>
<tr>
<td><code>-B, --block-size=SIZE</code></td>
<td>检验算法使用的块尺寸，默认是700字节。</td>
<td></td>
</tr>
<tr>
<td><code>-e, --rsh=command</code></td>
<td>指定使用rsh、ssh方式进行数据同步。</td>
<td></td>
</tr>
<tr>
<td><code>--rsync-path=PATH</code></td>
<td>指定远程服务器上的rsync命令所在路径信息。</td>
<td></td>
</tr>
<tr>
<td><code>-C, --cvs-exclude </code></td>
<td>使用和CVS一样的方法自动忽略文件，用来排除那些不希望传输的文件。</td>
<td></td>
</tr>
<tr>
<td><code>--existing </code></td>
<td>仅仅更新那些已经存在于DST的文件，而不备份那些新创建的文件。</td>
<td></td>
</tr>
<tr>
<td><code>--delete</code></td>
<td>删除那些DST中存在，而SRC没有的文件。</td>
<td></td>
</tr>
<tr>
<td><code>--delete-excluded  </code></td>
<td>同样删除接收端那些被该选项指定排除的文件。</td>
<td></td>
</tr>
<tr>
<td><code>--delete-after   </code></td>
<td>传输结束以后再删除。</td>
<td></td>
</tr>
<tr>
<td><code>--ignore-errors  </code></td>
<td>及时出现IO错误也进行删除。</td>
<td></td>
</tr>
<tr>
<td><code>--max-delete=NUM </code></td>
<td>最多删除NUM个文件。</td>
<td></td>
</tr>
<tr>
<td><code>--partial</code></td>
<td>保留那些因故没有完全传输的文件，以是加快随后的再次传输。</td>
<td></td>
</tr>
<tr>
<td><code>--force </code></td>
<td>强制删除目录，即使不为空。</td>
<td></td>
</tr>
<tr>
<td><code>--numeric-ids</code></td>
<td>不将数字的用户和组 id 匹配为用户名和组名。</td>
<td></td>
</tr>
<tr>
<td><code>--timeout=time</code></td>
<td>ip 超时时间，单位为秒。</td>
<td></td>
</tr>
<tr>
<td><code>-I, --ignore-times</code></td>
<td>不跳过那些有同样的时间和长度的文件。</td>
<td></td>
</tr>
<tr>
<td><code>--size-only</code></td>
<td>当决定是否要备份文件时，仅仅察看文件大小而不考虑文件时间。</td>
<td></td>
</tr>
<tr>
<td><code>--modify-window=NUM</code></td>
<td>决定文件是否时间相同时使用的时间戳窗口，默认为0。</td>
<td></td>
</tr>
<tr>
<td><code>-T ,--temp-dir=DIR</code></td>
<td>在DIR中创建临时文件。</td>
<td></td>
</tr>
<tr>
<td><code>--compare-dest=DIR</code></td>
<td>同样比较DIR中的文件来决定是否需要备份。</td>
<td></td>
</tr>
<tr>
<td><code>-P</code></td>
<td>等同于 <code>--partial</code>。</td>
<td></td>
</tr>
<tr>
<td><code>--progress</code></td>
<td>显示传输过程。</td>
<td></td>
</tr>
<tr>
<td><code>-z, --compress</code></td>
<td>对备份的文件在传输时进行压缩处理。</td>
<td></td>
</tr>
<tr>
<td><code>--exclude PATTERN  </code></td>
<td>指定排除不需要传输的文件模式。支持通配符</td>
<td></td>
</tr>
<tr>
<td><code>--include PATTERN</code></td>
<td>指定不排除而需要传输的文件模式。</td>
<td></td>
</tr>
<tr>
<td><code>--exclude-from=FILE</code></td>
<td>排除FILE中指定模式的文件。</td>
<td></td>
</tr>
<tr>
<td><code>--include-from=FILE</code></td>
<td>不排除FILE指定模式匹配的文件。</td>
<td></td>
</tr>
<tr>
<td><code>--version</code></td>
<td>打印版本信息。</td>
<td></td>
</tr>
<tr>
<td><code>--address</code></td>
<td>绑定到特定的地址。</td>
<td></td>
</tr>
<tr>
<td><code>--config=FILE</code></td>
<td>指定其他的配置文件，不使用默认的 <code>rsyncd.conf</code> 文件。</td>
<td></td>
</tr>
<tr>
<td><code>--port=PORT</code></td>
<td>指定其他的 rsync 服务端口。</td>
<td></td>
</tr>
<tr>
<td><code>--blocking-io</code></td>
<td>对远程shell使用阻塞IO。</td>
<td></td>
</tr>
<tr>
<td><code>--stats </code></td>
<td>给出某些文件的传输状态。</td>
<td></td>
</tr>
<tr>
<td><code>--log-format=formAT </code></td>
<td>指定日志文件格式。</td>
<td></td>
</tr>
<tr>
<td><code>--password-file=FILE </code></td>
<td>从FILE中得到密码。</td>
<td></td>
</tr>
<tr>
<td><code>--bwlimit=KBPS </code></td>
<td>限制I&#x2F;O带宽，KBytes per second。</td>
<td></td>
</tr>
<tr>
<td><code>-h, --help</code></td>
<td>显示帮助信息。</td>
<td></td>
</tr>
</tbody></table>
<h3 id="rsyncd-配置文件示例"><a href="#rsyncd-配置文件示例" class="headerlink" title="rsyncd 配置文件示例"></a>rsyncd 配置文件示例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">&lt;==该选项指定当模块传输文件时守护进程应该具有的uid、gid</span></span><br><span class="line">uid =root  </span><br><span class="line">gid = root</span><br><span class="line">port = 873</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#消息文件，客户端连接服务器的时显示给客户端</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">motd file = /etc/rsyncd.motd</span>  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">&lt;==安全相关</span></span><br><span class="line">use chroot = no  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">&lt;==设置最大连接数</span></span><br><span class="line">max connections = 200  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">&lt;==设置超时时间</span></span><br><span class="line">timeout = 300   </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">&lt;==定义进程文件</span></span><br><span class="line">pid file = /var/run/rsyncd.pid </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">&lt;==定义锁文件</span>  </span><br><span class="line">lock file = /var/run/rsync.lock </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">&lt;==定义日志文件</span> </span><br><span class="line">log file = /var/log/rsyncd.log  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#关闭解析</span></span> </span><br><span class="line">reverse lookup = no  </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">&lt;==配置一个数据存储的模块</span></span><br><span class="line">[backup]      </span><br><span class="line">    #&lt;==模块备份数据路径</span><br><span class="line">    path = /data/www/videos/  </span><br><span class="line">    ignore errors</span><br><span class="line">    read only = false</span><br><span class="line">    list = false</span><br><span class="line">    #&lt;==配置登录权限，可以多个IP网段用逗号隔开</span><br><span class="line">    #hosts allow = 172.16.1.0/24,172.25.1.0/24  </span><br><span class="line">    #hosts deny = 0.0.0.0/32</span><br><span class="line">    #&lt;==配置服务登录用户（访问服务的权限）</span><br><span class="line">    auth users = rsync        </span><br><span class="line">    #&lt;==配置用户和密码文件,权限必须600，用户名:密码格式 </span><br><span class="line">    secrets file = /etc/rsync.server.password  </span><br><span class="line">    ##是否检查secrets file的权限</span><br><span class="line">    strict modes = yes </span><br></pre></td></tr></table></figure>

<h3 id="rsync-的过滤规则说明"><a href="#rsync-的过滤规则说明" class="headerlink" title="rsync 的过滤规则说明"></a>rsync 的过滤规则说明</h3><p>rsync 过滤规则是用于定义哪些文件要传输（包含某些文件）哪些文件不要传输（排除某些文件）的一些规则。这些规则可以直接写在命令参数里，也可以写在规则文件里，然后由命令引用</p>
<p>与过滤规则有关的选项主要有：</p>
<ul>
<li><code>--include=PATTERN</code> ： 设定一条包含规则，如： <code>--include=&quot;*.php&quot;</code></li>
<li><code>--exclude=PATTERN</code> ： 设定一条排除规则，如：<code>--exclude=&quot;*&quot;</code></li>
<li><code>--include-from=FILE</code> ： 指定一个文件，文件中一行一条包含规则，以 <code>;</code> 或 <code>#</code> 开头的行为注释，空行被忽略</li>
<li><code>--exclude-from=FILE</code> ： 指定一个文件，文件中一行一条排除规则，以 <code>;</code> 或 <code>#</code> 开头的行为注释，空行被忽略</li>
<li><code>--filter=RULE, -f</code> ： 设定一条过滤规则，可能是排除或包含规则（如：<code>-f &quot;- *.php&quot;</code> ），也可能其它类型的规则（如包含一个规则文件 <code>-f &quot;. ./rsync.rules&quot;</code>）</li>
</ul>
<p>这些选项配置的规则，其本质是一样，只是描述方式有些差异。其中 <code>--filter=RULE, -f</code> 选项支持完整的规则表达语法，其它的选项都可以转化为此选项的表达。举例如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -av --include=&quot;*.php&quot; --exclude=&quot;*&quot; src_dir/ dst_dir/</span><br><span class="line">rsync -av -filter &quot;+ *.php&quot; -filter &quot;- *&quot; src_dir/ dst_dir/</span><br><span class="line">rsync -av -f &quot;+ *.php&quot; -f &quot;- *&quot; src_dir/ dst_dir/</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上的命令是完全等价的，<code>-f</code> 方式更简单<br><code>--include=&quot;xxx&quot;</code> 等价于 <code>-f &quot;+ xxx&quot;</code><br><code>--exclude=&quot;xxx&quot;</code> 等价于 <code>-f &quot;- xxx&quot;</code></p>
</blockquote>
<p>由 <code>--include-from</code> 或 <code>--exclude-from</code> 选项引入的规则文件，相当于每个规则前面自动加了 <code>+</code> 或 <code>-</code>。其规则文件内容举例如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--include-from 或 --exclude-from 引用的规则文件，开头没有 + 或 -</span></span><br><span class="line">*.php</span><br><span class="line">*</span><br></pre></td></tr></table></figure>

<h4 id="过滤规则的工作方式"><a href="#过滤规则的工作方式" class="headerlink" title="过滤规则的工作方式"></a>过滤规则的工作方式</h4><p>所有的过滤规则配置最终在 rsync 内部会形成一个有序的规则列表，在命令行中靠前选项，其规则的排序也靠前。随着要传输的（文件&#x2F;目录路径）列表的构建，针对每个路径，rsync 会依次读取有序规则列表中的规则进行检查。当第一个规则匹配成功后，立即进行操作（包含或排除），并停止后面规则的检查；若所有规则都不不匹配，此路径默认为包含。若有递归选项时（如 <code>-r -a</code>），如果子目录被规则排除，那么 rsync 不会递归检查此目录的内容了，也就是此目录下的文件和目录不会进行规则过滤也不会传输，相当于整个子目录都排除了。简单总结如下：</p>
<ol>
<li>规则有顺序，顺序同命令中参数配置顺序（从左到右）</li>
<li>扫描文件系统，读取（目录或文件的）路径后马上进行规则检查，确定包含还是排除</li>
<li>规则检查按序进行，若有命中立即包含或排除，并停止后续规则检查；若无规则命中，默认为包含</li>
<li>目录被排除时，其下所有子目录和文件都被排除</li>
</ol>
<p>此命令会同步 src_dir 目录下的所有 php 文件（<strong>不包含子目录的</strong>）<br>因为 src_dir 目录下每个文件和目录路径都会先由 <code>-f &quot;+ *.php&quot;</code> 规则检查，php 文件符合此规则就被包含了，后面的 <code>-f &quot;- *&quot;</code> 规则不会检查了<br>其余类型的文件和子目录，不符合第一个规则，继续检查第二个规则时，都被排除了<br>子目录被排除后，其中即使有 php 文件，也不会被检查，所以此命令不会同步 src_dir 目录下子目录中的 php 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -av -f &quot;+ *.php&quot; -f &quot;- *&quot; src_dir/ dst_dir/</span><br></pre></td></tr></table></figure>

<p>调换两个参数的顺序，则完全不一样了<br>此命令将不会同步任何文件和目录<br>因为第一条规则把所有文件和目录到排除了，第二条规则没有机会生效  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rsync -av -f &quot;- *&quot; -f &quot;+ *.php&quot; src_dir/ dst_dir/</span><br></pre></td></tr></table></figure>

<p>此命令会同步 src_dir 目录下的所有 php 文件（<strong>包含子目录的</strong>）<br>规则 <code>-f &quot;+ */&quot;</code> 会匹配并包含所有子目录路径，所以 rsync 会检查所有的子目录，然后其中的 php 文件被包含了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rsync -av -f &quot;+ *.php&quot; -f &quot;+ */&quot; -f &quot;- *&quot; src_dir/ dst_dir/</span><br></pre></td></tr></table></figure>
<h4 id="过滤规则的配置语法"><a href="#过滤规则的配置语法" class="headerlink" title="过滤规则的配置语法"></a>过滤规则的配置语法</h4><p>过滤规则的配置语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">操作 [匹配模式]</span><br><span class="line">操作,修饰符 [匹配模式]</span><br></pre></td></tr></table></figure>
<p>常用操作：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>+</code></td>
<td>包含</td>
<td><code>-f &quot;+ *.php&quot;</code></td>
</tr>
<tr>
<td><code>-</code></td>
<td>排除</td>
<td><code>-f &quot;- *.php&quot;</code></td>
</tr>
<tr>
<td><code>.</code></td>
<td>包含规则文件</td>
<td><code>-f &quot;. ./rsync.rules&quot;</code></td>
</tr>
</tbody></table>
<p>常用修饰符：</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>!</code></td>
<td>否定，对匹配结果进行取反，把匹配成功当做匹配失败，把匹配失败当做匹配成功</td>
<td><code>-f &quot;-! *.php&quot;</code></td>
</tr>
</tbody></table>
<p>常见匹配模式：</p>
<table>
<thead>
<tr>
<th>匹配模式</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>/*.php</code></td>
<td>模式以 <code>/</code> 开头时，表示模式必须匹配路径的开始；否则可以匹配路径中任意一层名称</td>
<td></td>
</tr>
<tr>
<td><code>config/</code></td>
<td>模式以 <code>/</code> 结尾时，表示模式只匹配目录，否则可以匹配目录或文件</td>
<td></td>
</tr>
<tr>
<td><code>subdir/view.php</code></td>
<td>模式中间的 <code>/</code> 表示路径分隔符</td>
<td></td>
</tr>
<tr>
<td><code>*</code></td>
<td>匹配任意长度的任意字符，但不匹配 <code>/</code></td>
<td></td>
</tr>
<tr>
<td><code>**</code></td>
<td>结尾时匹配任意长度的任意字符（包括 <code>/</code>）</td>
<td><code>app/**</code> 匹配路径 <code>app/xx/xx/a.txt</code></td>
</tr>
<tr>
<td><code>***</code></td>
<td>结尾时匹配任意长度的任意字符（包括 <code>/</code>），还包括目录本身。</td>
<td><code>app/***</code> 匹配路径 <code>app</code> 和 <code>xxx/app</code></td>
</tr>
<tr>
<td><code>?</code></td>
<td>匹配 <code>/</code> 以外的任意一个字符</td>
<td></td>
</tr>
<tr>
<td><code>[]</code></td>
<td>匹配一个某一类字符</td>
<td><code>[a-z]</code> 匹配一个小写字母，<code>[0-9]</code> 匹配一个数字</td>
</tr>
</tbody></table>
<blockquote>
<p>模式默认必须匹配到路径的末尾。如：<code>foo</code> 匹配 <code>foo</code> 和 <code>xx/foo</code>，但不匹配 <code>xx/foo1</code> 和 <code>foo/xx</code><br>路径被匹配的部分必须是包含完整的（目录或文件）名称，不可从名称中间切开。如：<code>foo</code> 不匹配 <code>xxx/afoo</code> ，<code>abc/foo</code> 不匹配 <code>subdir/aabc/foo</code><br>默认是包含所有文件和目录  </p>
</blockquote>
<h3 id="常用命令示例"><a href="#常用命令示例" class="headerlink" title="常用命令示例"></a>常用命令示例</h3><h4 id="测试同步结果"><a href="#测试同步结果" class="headerlink" title="测试同步结果"></a>测试同步结果</h4><p>如果不确定 <code>rsync</code> 执行的结果，可以不写目标目录，这样不会同步数据，只会输出要同步的目录和文件列表。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -a --exclude &#x27;file.txt&#x27; src_dir/</span><br></pre></td></tr></table></figure>
<p>或者使用选项 <code>--dry-run, -n</code>，模拟实际的运行效果，但不真的执行同步  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -a --dry-run --exclude &#x27;file.txt&#x27; src_dir/ dst_dir/</span><br></pre></td></tr></table></figure>

<h4 id="ssh-模式同步，默认-ssh-端口非-22-时指定-ssh-端口，使用-e-39-ssh-p-222-39-选项"><a href="#ssh-模式同步，默认-ssh-端口非-22-时指定-ssh-端口，使用-e-39-ssh-p-222-39-选项" class="headerlink" title="ssh 模式同步，默认 ssh 端口非 22 时指定 ssh 端口，使用 -e &#39;ssh -p 222&#39; 选项"></a>ssh 模式同步，默认 ssh 端口非 22 时指定 ssh 端口，使用 <code>-e &#39;ssh -p 222&#39;</code> 选项</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -e &#x27;ssh -p 222&#x27; /data/wwwroot/  rsync@9.9.9.9:/home/wwwroot/</span><br></pre></td></tr></table></figure>

<h4 id="Windows-中使用方式，以类似-cygdrive-d-的方式指定-d-盘"><a href="#Windows-中使用方式，以类似-cygdrive-d-的方式指定-d-盘" class="headerlink" title="Windows 中使用方式，以类似 /cygdrive/d/ 的方式指定 d 盘"></a>Windows 中使用方式，以类似 <code>/cygdrive/d/</code> 的方式指定 d 盘</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -c -r -u -t --timeout=300 -z --password-file C:\rsyncPasswd.txt /cygdrive/d/DATA/ rsync@0.0.0.0::zy/</span><br></pre></td></tr></table></figure>

<h4 id="同步过程中忽略-跳过-指定文件-目录"><a href="#同步过程中忽略-跳过-指定文件-目录" class="headerlink" title="同步过程中忽略(跳过)指定文件(目录)"></a>同步过程中忽略(跳过)指定文件(目录)</h4><p>要排除特定文件，请将文件的相对路径传递给 <code>--exclude</code> 选项</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -a --exclude &#x27;file.txt&#x27; src_dir/ dst_dir/</span><br><span class="line">rsync -a -f &#x27;- file.txt&#x27; src_dir/ dst_dir/</span><br></pre></td></tr></table></figure>

<p>排除特定目录与排除文件相同，只需将目录的相对路径传递给 <code>--exclude</code> 选项</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -a --exclude &#x27;dir1&#x27; src_dir/ dst_dir/</span><br><span class="line">rsync -a -f &#x27;- dir1&#x27; src_dir/ dst_dir/</span><br></pre></td></tr></table></figure>
<p>如果要排除目录内容，但不排除目录本身，请使用 <code>dir1/*</code> 而不是 <code>dir1</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -a --exclude &#x27;dir1/*&#x27; src_dir/ dst_dir/</span><br><span class="line">rsync -a -f &#x27;- dir1/*&#x27; src_dir/ dst_dir/</span><br></pre></td></tr></table></figure>
<p>要排除多个文件或目录，只需指定多个 <code>--exclude</code> 选项, 或使用 <code>&#123;&#125;</code> 包含多个目标项</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -a --exclude &#x27;f1.txt&#x27; --exclude &#x27;dir1/*&#x27; --exclude &#x27;dir2&#x27; src_dir/ dst_dir/</span><br><span class="line">rsync -a --exclude=&#123;&#x27;f1.txt&#x27;,&#x27;dir1/*&#x27;,&#x27;dir2&#x27;&#125; src_dir/ dst_dir/</span><br><span class="line">rsync -a -f &#x27;- f1.txt&#x27; -f &#x27;- dir1/*&#x27; -f &#x27;- dir2&#x27; src_dir/ dst_dir/</span><br></pre></td></tr></table></figure>

<p>通配符排除多个文件，例如要排除所有 <code>jpg</code> 类型的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -a --exclude &#x27;*.jpg*&#x27; src_dir/ dst_dir/</span><br><span class="line">rsync -a -f &#x27;- *.jpg*&#x27; src_dir/ dst_dir/</span><br></pre></td></tr></table></figure>



<h3 id="windows-安装-rsync-客户端"><a href="#windows-安装-rsync-客户端" class="headerlink" title="windows 安装 rsync 客户端"></a>windows 安装 rsync 客户端</h3><p>windows 下 rsync客户端使用 <code>cwRsync</code><br>下载地址：<br><a href="https://www.itefix.net/cwrsync?spm=a2c6h.12873639.article-detail.6.58dd67f17cs3Ta">官网链接</a><br><a href="https://s.csms.tech/file/cwrsync_6.2.4_x64_free.zip">其他地址</a></p>
<p>下载解压安装包后，目录内容如下：<br><img src="https://i.csms.tech/img_22.png"></p>
<p><code>bin</code> 目录下包含常用命令，其中 <code>rsync</code> 命令和 linux 中使用方法相同</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://zhuanlan.zhihu.com/p/441161884">rsync命令过滤规则入门教程</a><br><a href="https://iguoli.github.io/2017/07/03/Rsync.html">Rsync 命令</a></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Rsync</tag>
      </tags>
  </entry>
  <entry>
    <title>sed 命令使用示例</title>
    <url>/202207291520/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="常用选项说明"><a href="#常用选项说明" class="headerlink" title="常用选项说明"></a>常用选项说明</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-n    使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN （例如文件内容）的内容一般都会被列出到屏幕上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来。</span><br><span class="line">-i    直接修改读取的内容，而不是由屏幕输出。</span><br><span class="line">-f    直接将 sed 的动作写在一个文件内， -f filename 则可以执行 filename 内的sed 动作；</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a    追加， a 的后面可以接字符串，而这些字串会在新的一行出现(当前行的下一行)</span><br><span class="line">i    插入， i 的后面可以接字符串，而这些字串会在新的一行出现(目前行的上一行)；</span><br><span class="line">c    替代， c 的后面可以接字符串，替换整行</span><br><span class="line">s    替换， s/a/b/，a 替换成 b</span><br><span class="line">d    删除</span><br><span class="line">p    打印指定行</span><br></pre></td></tr></table></figure>

<h3 id="行定位方法"><a href="#行定位方法" class="headerlink" title="行定位方法"></a>行定位方法</h3><p>根据行号打印出指定行，<code>$</code> 表示最后一行，<code>!</code> 取反，排除行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -n &#x27;1p&#x27; file</span><br><span class="line">sed -n &#x27;1,10p&#x27; file</span><br><span class="line">sed -n &#x27;2,$p&#x27; file</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印除最后一行之外的其他行</span></span><br><span class="line">sed -n &#x27;$!p&#x27; file</span><br></pre></td></tr></table></figure>
<p>打印出搜索匹配到的行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -n &#x27;/root/p&#x27; file</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印出匹配<span class="string">&#x27;begin&#x27;</span>开始的行，到匹配到<span class="string">&#x27;end&#x27;</span>的行结束</span></span><br><span class="line">sed -n &#x27;/begin/,/end/p&#x27;</span><br><span class="line">sed -n &#x27;/begin/,/end/!p&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="常用示例"><a href="#常用示例" class="headerlink" title="常用示例"></a>常用示例</h3><h4 id="搜索包含指定内容的行，并替换整行内容"><a href="#搜索包含指定内容的行，并替换整行内容" class="headerlink" title="搜索包含指定内容的行，并替换整行内容"></a>搜索包含指定内容的行，并替换整行内容</h4><p>使用 <code>c</code> 命令，替换整行内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;/^updated/cupdate=1&#x27; file</span><br></pre></td></tr></table></figure>

<h4 id="每行的行首或行位添加内容"><a href="#每行的行首或行位添加内容" class="headerlink" title="每行的行首或行位添加内容"></a>每行的行首或行位添加内容</h4><p><code>^</code>，<code>$</code> 匹配行首和行尾  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i `s/^/添加内容/g` file</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>sed</tag>
      </tags>
  </entry>
  <entry>
    <title>sftp 服务常用配置说明</title>
    <url>/202207301332/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>sftp 是 Secure File Transfer Protocol 的缩写，安全文件传送协议。可以为传输文件提供一种安全的加密方法。SFTP 为 SSH 的一部分，由于这种传输方式使用了加密&#x2F;解密技术，所以传输效率比普通的 FTP 要低得多，如果您对网络安全性要求更高时，可以使用 SFTP 代替 FTP。默认ssh启用了sftp，只要可登陆系统的用户（&#x2F;bin&#x2F;bash）就可登陆,登陆后目录无限制，可任意切换其他目录。为了安全起见，可以配置sshd以限制sftp登录用户的权限。最好将登陆后用户限制在指定目录，无法切换到外部目录  </p>
<span id="more"></span>

<h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p><strong><code>ChrootDirectory</code> 配置前提</strong>:<br><code>ChrootDirectory</code> 设置的目录权限及其所有的上级文件夹权限，属主和属组必须是 root；<br><code>ChrootDirectory</code> 设置的目录权限及其所有的上级文件夹权限，只有属主能拥有写权限，权限最大设置只能是 755。</p>
<blockquote>
<p><strong>如果权限配置不对，会导致无法登录</strong><br>如果上级目录无法设置为root权限，可以通过<code>ln</code>链接的方式实现<br>限制后的用户无法 <code>ssh</code> 登录系统</p>
</blockquote>
<p>创建相关用户和组</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groupadd sftp</span><br><span class="line">useradd -g sftp -d /data/sftp/sftpuser1 -s /sbin/nologin sftpuser1</span><br><span class="line">echo 123456 | passwd --stdin sftpuser1</span><br><span class="line"></span><br><span class="line">chown root:root /data/sftp/sftpuser1</span><br><span class="line">chmod 755 /data/sftp/sftpuser1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">因为 /data/sftp/sftpuser1 属主和属组都为root，其他用户无写入权限，需要创建sftpuser1可写入的目录</span></span><br><span class="line">mkdir -p /data/sftp/sftpuser1/upload</span><br><span class="line">chown sftpuser1:sftp /data/sftp/sftpuser/upload</span><br><span class="line">chmod 755 /data/sftp/sftpuser1/upload</span><br></pre></td></tr></table></figure>

<p>修改 <code>sshd_config</code> 配置</p>
<figure class="highlight shell"><figcaption><span>/etc/ssh/sshd_config</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Subsystem      sftp    /usr/libexec/openssh/sftp-server</span></span><br><span class="line">Subsystem sftp internal-sftp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拒绝指定用户登录,不能放在Match user中</span></span><br><span class="line">DenyUsers user1 user2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">maxsessions 10</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">针对用户配置sftp, 多个用户可重复配置以下内容，或者通过针对组配置sftp</span></span><br><span class="line">Match user sftpuser1,sftpuser2</span><br><span class="line">    # 该行强制执行内部 sftp，并忽略任何 ~/.ssh/rc 文件中的命令。</span><br><span class="line">   ForceCommand internal-sftp</span><br><span class="line">	</span><br><span class="line">   ChrootDirectory /data/sftp/sftpuser1</span><br><span class="line">	</span><br><span class="line"><span class="meta prompt_">   # </span><span class="language-bash">下面两项是与安全有关</span></span><br><span class="line">    AllowTcpForwarding no</span><br><span class="line">    X11Forwarding no</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">针对用户组配置sftp</span></span><br><span class="line">Match Group sftp,sftp1</span><br><span class="line">    ForceCommand internal-sftp</span><br><span class="line">    </span><br><span class="line">    # %h 代表用户 home 目录，%u 代表用户名。</span><br><span class="line">    ChrootDirectory /data/sftp/%u</span><br></pre></td></tr></table></figure>
<blockquote>
<p>修改配置后，重启 <code>sshd</code> 服务生效<br><code>systemctl restart sshd</code></p>
</blockquote>
<h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><h4 id="Unable-to-open-permission-denied"><a href="#Unable-to-open-permission-denied" class="headerlink" title="Unable to open .: permission denied"></a>Unable to open .: permission denied</h4><p><strong>解决方法</strong>： 如果启动了 <code>selinux</code>， 关闭 <code>selinux</code></p>
<h4 id="Couldn’t-read-packet-Connection-reset-by-peer"><a href="#Couldn’t-read-packet-Connection-reset-by-peer" class="headerlink" title="Couldn’t read packet: Connection reset by peer"></a>Couldn’t read packet: Connection reset by peer</h4><p><strong>问题原因</strong>: <code>ChrootDirectory (/data/sftp/sftpuser1)</code> 目录及所有上级目录的用户和组必须为 <code>root</code>，权限最多为 755, <a href="#%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE">参考说明</a></p>
<h4 id="remote-readdir-“-x2F-“-Permission-denied"><a href="#remote-readdir-“-x2F-“-Permission-denied" class="headerlink" title="remote readdir(“&#x2F;“): Permission denied"></a>remote readdir(“&#x2F;“): Permission denied</h4><p><strong>问题原因</strong>: sftp 用户对 <code>ChrootDirectory (/data/sftp/sftpuser1)</code> 目录要有读取权限，<a href="#%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE">参考说明</a></p>
<h3 id="禁用-sftp-功能"><a href="#禁用-sftp-功能" class="headerlink" title="禁用 sftp 功能"></a>禁用 sftp 功能</h3><p>修改 <code>sshd</code> 配置文件 <code>/etc/ssh/sshd_config</code>,注释以下内容</p>
<figure class="highlight shell"><figcaption><span>/etc/ssh/sshd_config</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Subsystem sftp /usr/libexec/openssh/sftp-server</span></span><br></pre></td></tr></table></figure>
<p>修改配置文件后重启 <code>sshd</code> 服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure>
<p>使用<code>sftp</code>登录时会报错 ： <code>Error:	Could not connect to server</code></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>sftp</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh 安全防护</title>
    <url>/202208171033/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Centos 7</li>
</ul>
<p>登录服务器，经常遇见以下提示信息，说明有主机一直在尝试暴力破解用户名密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">There were 696 failed login attempts since the last successful login.</span><br></pre></td></tr></table></figure>

<p>查看登录失败的用户名和 ip 地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep <span class="string">&quot;Failed password for invalid user &quot;</span> /var/log/secure | awk <span class="string">&#x27;&#123;print $11,$13&#125;&#x27;</span> | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c | <span class="built_in">sort</span> -k1 -n</span></span><br><span class="line">      3 wangli 47.74.0.77</span><br><span class="line">      3 work 47.74.0.77</span><br><span class="line">      3 yt 47.74.0.77</span><br><span class="line">      3 yx 47.74.0.77</span><br><span class="line">      3 yyz 47.74.0.77</span><br><span class="line">      3 zabbix 47.74.0.77</span><br><span class="line">      3 zd 47.74.0.77</span><br><span class="line">      3 zhangfan 47.74.0.77</span><br><span class="line">      3 zxy 47.74.0.77</span><br><span class="line">      4 client003 47.74.0.77</span><br><span class="line">      4 client004 47.74.0.77</span><br><span class="line">      4 dell 47.74.0.77</span><br><span class="line">      4 ftpuser 47.74.0.77</span><br><span class="line">      4 inspur 47.74.0.77</span><br><span class="line">      4 wang 47.74.0.77</span><br><span class="line">      5 git 47.74.0.77</span><br><span class="line">      5 nagios 47.74.0.77</span><br><span class="line">      5 testuser 47.74.0.77</span><br><span class="line">      6 omnisky 47.74.0.77</span><br><span class="line">      7 oracle 47.74.0.77</span><br><span class="line">      8 jenkins 47.74.0.77</span><br><span class="line">     10 hadoop 47.74.0.77</span><br><span class="line">     10 postgres 47.74.0.77</span><br><span class="line">     11 ubuntu 47.74.0.77</span><br><span class="line">     11 user 47.74.0.77</span><br><span class="line">     12 admin 47.74.0.77</span><br><span class="line">     15 test 47.74.0.77</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="sshd-加固配置"><a href="#sshd-加固配置" class="headerlink" title="sshd 加固配置"></a>sshd 加固配置</h3><p>修改 <code>sshd</code> 配置文件 <code>/etc/ssh/sshd_config</code>，更改以下配置</p>
<ul>
<li><code>sshd</code> 默认端口 22 改为其他端口</li>
<li>禁止 <code>root</code> 用户登录，创建其他普通用户以登录系统，普通用户登录后有需要再切换到 <code>root</code></li>
</ul>
<figure class="highlight shell"><figcaption><span>/etc/ssh/sshd_config</span></figcaption><table><tr><td class="code"><pre><span class="line">Port 30000</span><br><span class="line">PermitRootLogin no</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>修改配置后重启 <code>sshd</code> 服务生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure>

<p>如果可以安全的保存秘钥，也可以使用秘钥登录，禁止用户名密码登录，具体配置可参考：<a href="https://blog.51cto.com/u_15061935/2652298">ssh 秘钥登录</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>windows 中的 zip 类型压缩文件，linux 中 unzip 解压后文件名乱码</title>
    <url>/202208240911/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>centos 7</li>
</ul>
<p>在 windows 系统添加到 zip 类型的压缩文件，上传到 Linux，使用 <code>unzip</code> 解压后，文件名乱码  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">unzip 测试文档.zip</span></span><br><span class="line">Archive:  测试文档.zip</span><br><span class="line">  inflating: ═°╦▐╫╩╘┤╬┤╝╙├▄├╗╙╨╙├╡╜╡─┴╨▒э.csv</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>主要的原因是因为 <code>unzip</code> 在解压的时候会将编码转化为其内部默认的编码，而默认的编码根本不支持中文 <code>CP936</code> 编码。因此我们需要在解压的时候明确的指定需要使用的编码。  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">unzip -O CP936 测试文档.zip</span> </span><br><span class="line">Archive:  测试文档.zip</span><br><span class="line">  inflating: 测试文档.csv  </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>unzip</tag>
      </tags>
  </entry>
  <entry>
    <title>vim</title>
    <url>/202208181117/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>Centos 7</li>
</ul>
<h3 id="vim-配置"><a href="#vim-配置" class="headerlink" title="vim 配置"></a>vim 配置</h3><p><code>vim</code> 启动时会读取 <code>/etc/vimrc</code>（全局配置） 和 <code>~/.vimrc</code> （用户配置）</p>
<p>常用配置如下，使用 <code>&quot;</code> 注释</p>
<figure class="highlight shell"><figcaption><span>/etc/vimrc</span></figcaption><table><tr><td class="code"><pre><span class="line">&quot; 自动缩进 </span><br><span class="line">set ai</span><br><span class="line">set autoindent</span><br><span class="line"></span><br><span class="line">&quot; 保存历史命令数量</span><br><span class="line">set history=50</span><br><span class="line"></span><br><span class="line">&quot; 右下角显示当前鼠标位置（行列数）</span><br><span class="line">set ruler</span><br><span class="line"></span><br><span class="line">&quot; 鼠标位置所在行显示下划线</span><br><span class="line">set cursorline</span><br><span class="line"></span><br><span class="line">&quot; 开启语法高亮</span><br><span class="line">syntax on</span><br><span class="line"></span><br><span class="line">&quot; 高亮搜索结果</span><br><span class="line">set hlsearch</span><br><span class="line"></span><br><span class="line">&quot; 搜索时不区分大小写</span><br><span class="line">set ignorecase</span><br><span class="line"></span><br><span class="line">&quot; 将 tab 转换为空格</span><br><span class="line">set expandtab</span><br><span class="line"></span><br><span class="line">&quot; tab 转换为4个空格</span><br><span class="line">set tabstop=4</span><br><span class="line"></span><br><span class="line">&quot; 删除时，可以一次删除4个空格</span><br><span class="line">set softtabstop=4</span><br><span class="line"></span><br><span class="line">&quot; 显示行数</span><br><span class="line">set nu</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h3 id="vim-常见用法"><a href="#vim-常见用法" class="headerlink" title="vim 常见用法"></a>vim 常见用法</h3><h4 id="读写加解密文件"><a href="#读写加解密文件" class="headerlink" title="读写加解密文件"></a>读写加解密文件</h4><h5 id="创建新的加密文件"><a href="#创建新的加密文件" class="headerlink" title="创建新的加密文件"></a>创建新的加密文件</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim -x mysecfile</span><br></pre></td></tr></table></figure>
<p>使用 <code>vim</code> 的 <code>-x</code> 选项，将创建一个新的文件，并提示需要设置加密密码，输入 2 次密码后，将进入 <code>vim</code> 界面，编辑完内容，保存后，产生的文件为 <code>vim</code> 加密的文件，使用 <code>file</code> 命令查看，显示如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">file mysecfile</span></span><br><span class="line">mysecfile: Vim encrypted file data</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>之后要使用 <code>vim</code> 编辑此文件，都要按照提示输入密码，如果未输入密码或者输入的密码错误，打开的文件内容将显示为乱码，只有输入正确的密码，才能看到正确的文件内容，如果使用其他编辑器，可以直接打开文件，但是内容乱码  </p>
<h5 id="加密已有文件"><a href="#加密已有文件" class="headerlink" title="加密已有文件"></a>加密已有文件</h5><p>对于已经存在的未加密文件，使用 <code>vim</code> 的 <code>-x</code> 选项时，会要求输入密码，此时不输入密码，或者随便输入，都会打开正确的文件内容(因为文件并未被 <code>vim</code> 加密保护)  </p>
<p>对于已经存在的未加密文件，若要使用 <code>vim</code> 进行加密，可以在 <code>vim</code> 打开文件后，使用 <code>vim</code> 的 <code>X</code> 命令对文件进行加密。具体操作为： 在 <code>vim</code> 的一般模式下（按 <code>Esc</code> 进入），输入 </p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">X</span></span><br></pre></td></tr></table></figure>
<p>确定后 <code>vim</code> 会提示输入 2 次密码，完成加密，最后保存文件</p>
<figure class="highlight shell"><figcaption><span>vim</span></figcaption><table><tr><td class="code"><pre><span class="line">:wq</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>对于 <code>vim</code> 已经加密的文件，如果使用 <code>vim</code> 打开时输入错误的密码或者未输入密码，打开文件显示乱码，此时如果对文件进行了保存，会导致乱码被保存为文件内容，导致文件内容丢失</strong></p>
</blockquote>
<h5 id="文件解密"><a href="#文件解密" class="headerlink" title="文件解密"></a>文件解密</h5><p>对 <code>vim</code> 已加密的文件，需要解密的话，在正确打开文件后，可以通过 <a href="#%E5%8A%A0%E5%AF%86%E5%B7%B2%E6%9C%89%E6%96%87%E4%BB%B6">加密已有文件</a> 中的步骤，将文件密码设置为空即可<br>或者正确打开加密文件后，进入一般模式下，执行以下命令</p>
<figure class="highlight shell"><figcaption><span>vim</span></figcaption><table><tr><td class="code"><pre><span class="line">:set key=</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>vsftpd 服务常见错误</title>
    <url>/202207261304/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="530-Login-incorrect"><a href="#530-Login-incorrect" class="headerlink" title="530 Login incorrect"></a>530 Login incorrect</h3><p><strong>报错信息</strong>： 登录时报错 <code>530 Login incorrect</code><br><strong>错误原因</strong>：</p>
<figure class="highlight shell"><figcaption><span>/etc/pam.d/vsftpd</span></figcaption><table><tr><td class="code"><pre><span class="line">auth  required pam_listfile.so item=user sense=deny file=/etc/vsftpd/ftpusers onerr=succeed </span><br></pre></td></tr></table></figure>
<p>默认情况下，&#x2F;etc&#x2F;vsftpd&#x2F;ftpusers里面的用户是被拒绝登录的，确保要登录的用户不在此文件中</p>
<figure class="highlight shell"><figcaption><span>/etc/pam.d/vsftpd</span></figcaption><table><tr><td class="code"><pre><span class="line">auth       required    pam_shells.so  </span><br></pre></td></tr></table></figure>
<p>此配置指定，只允许登录shell为<code>/etc/shells</code>中的shell的用户登录<br>如果用户shell为<code>/sbin/nologin</code>，则不允许登录，可改为<code>pam_nologin.so</code></p>
<span id="more"></span>

<h3 id="500-OOPS-vsftpd-refusing-to-run-with-writable-root-inside-chroot"><a href="#500-OOPS-vsftpd-refusing-to-run-with-writable-root-inside-chroot" class="headerlink" title="500 OOPS: vsftpd: refusing to run with writable root inside chroot()"></a>500 OOPS: vsftpd: refusing to run with writable root inside chroot()</h3><p><strong>错误原因</strong>: 从2.3.5之后，vsftpd增强了安全检查，如果用户被限定在了其主目录下，则该用户的主目录不能再具有写权限了！如果检查发现还有写权限，就会报该错误。<br><strong>解决方法1</strong>： 用户主目录取消写权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod a-w /data/ftpdir</span><br></pre></td></tr></table></figure>

<p><strong>解决方法2</strong>： 配置文件中增加以下配置</p>
<figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">allow_writeable_chroot=YES</span><br></pre></td></tr></table></figure>

<h3 id="500-OOPS-vsftpd-cannot-locate-user-specified-in-‘guest-username’-ftp"><a href="#500-OOPS-vsftpd-cannot-locate-user-specified-in-‘guest-username’-ftp" class="headerlink" title="500 OOPS: vsftpd: cannot locate user specified in ‘guest_username’:ftp"></a>500 OOPS: vsftpd: cannot locate user specified in ‘guest_username’:ftp</h3><p><strong>错误原因</strong>: 配置文件中启用了匿名用户登录，系统中没有ftp的匿名用户ftp<br><strong>解决方法1</strong>：<br>配置文件中禁用匿名用户登录，同时指定用户</p>
<figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">anonymous_enable=NO</span><br><span class="line">ftp_username=nobody</span><br></pre></td></tr></table></figure>

<h3 id="550-Create-directory-operation-failed"><a href="#550-Create-directory-operation-failed" class="headerlink" title="550 Create directory operation failed"></a>550 Create directory operation failed</h3><p><strong>错误原因</strong>: 匿名登录的用户不允许在ftp根目录下面新建对象，可以在根目录下面创建文件夹，如pub，并给ftp为属主，在pub下面新建文件</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a href="/202207231311/" title="vsftpd 服务常用配置说明">vsftpd 服务常用配置说明</a>  
</li>
<li><a href="/202207251638/" title="vsftpd 虚拟用户配置说明">vsftpd 虚拟用户配置说明</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>Vsftpd</tag>
      </tags>
  </entry>
  <entry>
    <title>vsftpd 服务常用配置说明</title>
    <url>/202207231311/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3></blockquote>
<ul>
<li>Centos 7</li>
<li>vsftpd 3.0.2</li>
</ul>
<span id="more"></span>

<blockquote>
<h3 id="通用配置"><a href="#通用配置" class="headerlink" title="通用配置"></a>通用配置</h3></blockquote>
<figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">匿名用户和本地用户是否能登录，匿名用户使用的登陆名为ftp或anonymous，口令为空，匿名用户不能离开匿名 用户家目录/var/ftp,且只能下载不能上传。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">本地用户的登录名为本地用户名，口令为此本地用户的口令；本地用户可以在自己家目录中进行读写操作；本地用户可以离开自家目录切换至有权限访问的其他目录，并在权限允许的情况下进行上传/下载。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认写在文件/etc/vsftpd.ftpusers中的本地用户禁止登陆。</span></span><br><span class="line">anonymous_enable=YES </span><br><span class="line">local_enable=YES </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">否允许登录用户有写权限。属于全局设置，默认值为YES。</span></span><br><span class="line">write_enable=YES</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果设置为NO，所有的文件都不能下载到本地，文件夹不受影响。默认值为YES。</span></span><br><span class="line">download_enable=YES/NO</span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="匿名用户（anonymous）设置"><a href="#匿名用户（anonymous）设置" class="headerlink" title="匿名用户（anonymous）设置"></a>匿名用户（anonymous）设置</h3></blockquote>
<figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">若是启动这项功能，则使用匿名登入时，不会询问密码。默认值为NO。</span></span><br><span class="line">no_anon_password=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义匿名登入的使用者名称。默认值为ftp。</span></span><br><span class="line">ftp_username=ftp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用匿名登入时，所登入的目录。默认值为/var/ftp。注意ftp目录不能是777的权限属性，即匿名用户的家目录不能有777的权限。</span></span><br><span class="line">anon_root=/var/ftp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果设为YES，则允许匿名登入者有上传文件（非目录）的权限，只有在write_enable=YES时，此项才有效。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当然，匿名用户必须要有对上层目录的写入权。默认值为NO。</span></span><br><span class="line">anon_upload_enable=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果设为YES，则允许匿名登入者下载可阅读的档案（可以下载到本机阅读，不能直接在FTP服务器中打开阅读）。默认值为YES。</span></span><br><span class="line">anon_world_readable_only=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果设为YES，则允许匿名登入者有新增目录的权限，只有在write_enable=YES时，此项才有效。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当然，匿名用户必须要有对上层目录的写入权。默认值为NO。</span></span><br><span class="line">anon_mkdir_write_enable=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果设为YES，则允许匿名登入者更多于上传或者建立目录之外的权限，譬如删除或者重命名。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果anon_upload_enable=NO，则匿名用户 不能上传文件，但可以删除或者重命名已经存在的文件；</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果anon_mkdir_write_enable=NO，则匿名用户不能上传或者新建文件夹，但 可以删除或者重命名已经存在的文件夹。）默认值为NO。</span></span><br><span class="line">anon_other_write_enable=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置是否改变匿名用户上传文件（非目录）的属主。默认值为NO。</span></span><br><span class="line">chown_uploads=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置匿名用户上传文件（非目录）的属主名。建议不要设置为root。</span></span><br><span class="line">chown_username=username</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置匿名登入者新增或上传档案时的<span class="built_in">umask</span> 值。默认值为077，则新建档案的对应权限为700。</span></span><br><span class="line">anon_umask=077</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">若是启动这项功能，则必须提供一个档案/etc/vsftpd/banner_emails，内容为email address。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">若是使用匿名登入，则会要求输入email address，若输入的email address 在此档案内，则不允许进入。默认值为NO。</span></span><br><span class="line">deny_email_enable=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此文件用来输入email address，只有在deny_email_enable=YES时，才会使用到此档案。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">若是使用匿名登入，则会要求输入email address，若输入的email address 在此档案内，则不允许进入。</span></span><br><span class="line">banned_email_file=/etc/vsftpd/banner_emails</span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="本地用户-设置"><a href="#本地用户-设置" class="headerlink" title="本地用户 设置"></a>本地用户 设置</h3></blockquote>
<figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">控制是否允许本地用户登入，默认值为YES。</span></span><br><span class="line">local_enable=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当本地用户登入时，将被更换到定义的目录下。默认值为各用户的家目录</span></span><br><span class="line">local_root=/home/username</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">本地用户新增档案时的<span class="built_in">umask</span> 值。默认值为077。</span></span><br><span class="line">local_umask=022</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">本地用户上传档案后的档案权限，与<span class="built_in">chmod</span> 所使用的数值相同。默认值为0666。</span></span><br><span class="line">file_open_mode=0755</span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="欢迎语设置"><a href="#欢迎语设置" class="headerlink" title="欢迎语设置"></a>欢迎语设置</h3></blockquote>
<figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果启动这个选项，那么使用者第一次进入一个目录时，会检查该目录下是否有.message这个档案</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果有，则会出现此档案的内容，通常这个档案会放置欢迎话语，或是对该目录的说明。默认值为开启。</span></span><br><span class="line">dirmessage_enable=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置目录消息文件，可将要显示的信息写入该文件。默认值为.message。</span></span><br><span class="line">message_file=.message</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当使用者登入时，会显示此设定所在的档案内容，通常为欢迎话语或是说明。默认值为无。如果欢迎信息较多，则使用该配置项。</span></span><br><span class="line">banner_file=/etc/vsftpd/banner</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里用来定义欢迎话语的字符串，banner_file是档案的形式，而ftpd_banner 则是字符串的形式。预设为无。</span></span><br><span class="line">ftpd_banner=Welcome to BOB&#x27;s FTP server</span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="控制用户是否允许切换到上级目录"><a href="#控制用户是否允许切换到上级目录" class="headerlink" title="控制用户是否允许切换到上级目录"></a>控制用户是否允许切换到上级目录</h3></blockquote>
<figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">是否将用户限制在用户主目录。默认值为NO。</span></span><br><span class="line">chroot_local_user=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在默认配置下(chroot_local_user=NO)，本地用户登入FTP后可以使用<span class="built_in">cd</span>命令切换到其他目录，这样会对系统带来安全隐患。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置是否启用chroot_list_file配置项指定的用户列表文件。默认值为NO。</span></span><br><span class="line">chroot_list_enable=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用于指定用户列表文件，该文件用于控制哪些用户可以切换到用户家目录的上级目录。</span></span><br><span class="line">chroot_list_file=/etc/vsftpd.chroot_list</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 通过搭配能实现以下几种效果：</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 当chroot_local_user=YES, chroot_list_enable=YES时，</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在/etc/vsftpd.chroot_list文件中列出的用户，可以切换到其他目录；未在文件中列出的用户，不能切换到其他目录。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. 当chroot_local_user=YES, chroot_list_enable=NO时，</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">所有用户被限制在主目录，不启用chroot_list_file白名单，没有例外</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3. 当chroot_local_user=NO， chroot_list_enable=YES时</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">所有用户不限制在主目录，chroot_list_file中的用户例外，限制切换到主目录之外</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4. 当chroot_local_user=NO， chroot_list_enable=NO时</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">所有用户不限制在主目录,不启用chroot_list_file，没有任何例外</span></span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="数据传输模式设置"><a href="#数据传输模式设置" class="headerlink" title="数据传输模式设置"></a>数据传输模式设置</h3></blockquote>
<figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">FTP在传输数据时，可以使用二进制方式，也可以使用ASCII模式来上传或下载数据。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置是否启用ASCII 模式上传数据。默认值为NO。</span></span><br><span class="line">ascii_upload_enable=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置是否启用ASCII 模式下载数据。默认值为NO。</span></span><br><span class="line">ascii_download_enable=YES/NO</span><br></pre></td></tr></table></figure>
<blockquote>
<h3 id="访问控制设置"><a href="#访问控制设置" class="headerlink" title="访问控制设置"></a>访问控制设置</h3></blockquote>
<figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">两种控制方式：一种控制主机访问，另一种控制用户访问。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置vsftpd是否与tcp wrapper相结合来进行主机的访问控制。默认值为YES。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果启用，则vsftpd服务器会检查/etc/hosts.allow 和/etc/hosts.deny 中的设置，来决定请求连接的主机，是否允许访问该FTP服务器。这两个文件可以起到简易的防火墙功能。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">比如：若要仅允许192.168.0.1—192.168.0.254的用户可以连接FTP服务器，则在/etc/hosts.allow文件中添加以下内容：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">vsftpd:192.168.0. :allow</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">all:all :deny</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">对于用户的访问控制可以通过/etc目录下的vsftpd.user_list和ftpusers文件来实现。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">控制用户访问FTP的文件，里面写着用户名称。一个用户名称一行。</span></span><br><span class="line">userlist_file=/etc/vsftpd.user_list</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">是否启用vsftpd.user_list文件。</span></span><br><span class="line">userlist_enable=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">决定vsftpd.user_list文件中的用户是否能够访问FTP服务器。userlist_enable=YES 才有效</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">若设置为YES，则vsftpd.user_list文件中的用户不允许访问FTP，为黑名单，其他用户可以访问</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">若设置为NO，则vsftpd.user_list文件中的用户能访问FTP，为白名单，其他用户不能访问</span></span><br><span class="line">userlist_deny=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/etc/vsftpd/ftpusers文件专门用于定义不允许访问FTP服务器的用户列表，不受任何配置文件影响，里面的用户始终不允许方法vsftpd</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认情况下vsftpd.user_list和ftpusers，这两个 文件已经预设置了一些不允许访问FTP服务器的系统内部账户。如果系统没有这两个文件，那么新建这两个文件，将用户添加进去即可。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="访问速率设置"><a href="#访问速率设置" class="headerlink" title="访问速率设置"></a>访问速率设置</h3></blockquote>
<figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置匿名登入者使用的最大传输速度，单位为B/s，0 表示不限制速度。默认值为0。</span></span><br><span class="line">anon_max_rate=0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">本地用户使用的最大传输速度，单位为B/s，0 表示不限制速度。预设值为0。</span></span><br><span class="line">local_max_rate=0</span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="超时时间设置"><a href="#超时时间设置" class="headerlink" title="超时时间设置"></a>超时时间设置</h3></blockquote>
<figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置建立FTP连接的超时时间，单位为秒。默认值为60。</span></span><br><span class="line">accept_timeout=60</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">PORT 方式下建立数据连接的超时时间，单位为秒。默认值为60。</span></span><br><span class="line">connect_timeout=60</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置建立FTP数据连接的超时时间，单位为秒。默认值为120。</span></span><br><span class="line">data_connection_timeout=120</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置多长时间不对FTP服务器进行任何操作，则断开该FTP连接，单位为秒。默认值为300 。</span></span><br><span class="line">idle_session_timeout=300</span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="日志文件设置"><a href="#日志文件设置" class="headerlink" title="日志文件设置"></a>日志文件设置</h3></blockquote>
<figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">是否启用上传/下载日志记录。如果启用，则上传与下载的信息将被完整纪录在xferlog_file 所定义的档案中。预设为开启</span></span><br><span class="line">xferlog_enable= YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置日志文件名和路径，默认值为/var/log/vsftpd.log。</span></span><br><span class="line">xferlog_file=/var/log/vsftpd.log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果启用，则日志文件将会写成xferlog的标准格式，如同wu-ftpd 一般。默认值为关闭。</span></span><br><span class="line">xferlog_std_format=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果启用此选项，所有的FTP请求和响应都会被记录到日志中，默认日志文件在/var/log/vsftpd.log。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启用此选项时，xferlog_std_format不能被激活。这个选项有助于调试。默认值为NO。</span></span><br><span class="line">log_ftp_protocol=YES|NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">登录日志</span></span><br><span class="line">dual_log_enable=YES</span><br><span class="line">vsftpd_log_file=/var/log/vsftpd.log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">日志中的时间与系统时间保持一致</span></span><br><span class="line">use_localtime=YES</span><br></pre></td></tr></table></figure>
<blockquote>
<h3 id="FTP的工作方式与端口设置"><a href="#FTP的工作方式与端口设置" class="headerlink" title="FTP的工作方式与端口设置"></a>FTP的工作方式与端口设置</h3></blockquote>
<figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">FTP有两种工作方式：PORT FTP（主动模式）和 PASV FTP（被动模式）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置FTP服务器建立连接所监听的端口，默认值为21。</span></span><br><span class="line">listen_port=21</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定FTP使用20端口进行数据传输，默认值为YES。</span></span><br><span class="line">connect_from_port_20=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置在PORT方式下，FTP数据连接使用的端口，默认值为20。</span></span><br><span class="line">ftp_data_port=20</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">若设置为YES，则使用PASV工作模式；若设置为NO，则使用PORT模式。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认值为YES，即使用PASV工作模式。</span></span><br><span class="line">pasv_enable=YES/NO（YES）</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在PASV工作模式下，数据连接可以使用的端口范围的最大端口，0 表示任意端口。默认值为0。</span></span><br><span class="line">pasv_max_port=0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在PASV工作模式下，数据连接可以使用的端口范围的最小端口，0 表示任意端口。默认值为0。</span></span><br><span class="line">pasv_min_port=0</span><br></pre></td></tr></table></figure>
<blockquote>
<h3 id="与连接相关的设置"><a href="#与连接相关的设置" class="headerlink" title="与连接相关的设置"></a>与连接相关的设置</h3></blockquote>
<figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置vsftpd服务器是否以standalone模式运行。以standalone模式运行是一种较好的方式，此时listen必须设置为YES，此为默认值。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">建议不要更改，有很多与服务器运行相关的配置命令，需要在此模式下才有效。若设置为NO，则vsftpd不是以独立的服务运行，要受到xinetd 服务的管控，功能上会受到限制。</span></span><br><span class="line">listen=YES/NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置vsftpd允许的最大连接数，默认值为0，表示不受限制。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">若设置为100时，则同时允许有100个连接，超出的将被拒绝。只有在standalone模式运行才有效。</span></span><br><span class="line">max_clients=0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置每个IP允许与FTP服务器同时建立连接的数目。默认值为0，表示不受限制。只有在standalone模式运行才有效。</span></span><br><span class="line">max_per_ip=0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置FTP服务器在指定的IP地址上侦听用户的FTP请求。若不设置，则对服务器绑定的所有IP地址进行侦听。只有在standalone模式运行才有效。</span></span><br><span class="line">listen_address=IP地址</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置每个与FTP服务器的连接，是否以不同的进程表现出来。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认值为NO，此时使用ps aux |grep ftp只会有一个vsftpd的进程。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">若设置为YES，则每个连接都会有一个vsftpd的进程。</span></span><br><span class="line">setproctitle_enable=YES/NO</span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="虚拟用户相关配置"><a href="#虚拟用户相关配置" class="headerlink" title="虚拟用户相关配置"></a>虚拟用户相关配置</h3></blockquote>
<a href="/202207251638/" title="vsftpd虚拟用户配置过程参考">vsftpd虚拟用户配置过程参考</a>

<figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用虚拟用户功能，必须允许本地用户登录</span></span><br><span class="line">local_enable=YES</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启用虚拟用户配置，所有非匿名用户登录将视为游客，将被映射为guest_username</span></span><br><span class="line">guest_enable=YES</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">虚拟用户映射的本地用户</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">主配置文件中必需有，否则报错</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">500 OOPS: vsftpd: cannot locate user specified <span class="keyword">in</span> <span class="string">&#x27;guest_username&#x27;</span>:ftp</span></span><br><span class="line">guest_username=virftp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">虚拟用户独立配置文件目录</span></span><br><span class="line">user_config_dir=/etc/vsftpd/virtual_user_conf          </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">虚拟用户使用本地用户的权限</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认为NO，虚拟用户具有和匿名用户一样的权限</span></span><br><span class="line">virtual_use_local_privs=YES | NO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">虚拟用户加载的pam模块，默认为`/etc/pam.d/vsftpd`</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pam_service_name=vsftpd_vu</span></span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="虚拟用户配置文件"><a href="#虚拟用户配置文件" class="headerlink" title="虚拟用户配置文件"></a>虚拟用户配置文件</h3></blockquote>
<p>每个虚拟用户都需要一个单独的配置文件，虚拟用户配置文件在vsftpd配置中 <code>user_config_dir</code> 对应的目录(<code>/etc/vsftpd/virtual_user_conf</code>)下<br>文件名必须和用户名一样</p>
<figure class="highlight shell"><figcaption><span>user1</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定虚拟用户根目录</span></span><br><span class="line">local_root=/home/ftpsite/user1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">虚拟用户是和本地用户有相同权限;NO：虚拟用户和匿名用户权限相同</span></span><br><span class="line">virtual_use_local_privs=YES</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">虚拟用户对应的系统用户</span></span><br><span class="line">guest_username=virftp</span><br><span class="line"></span><br><span class="line">write_enable=YES</span><br><span class="line">lock_upload_files=NO</span><br><span class="line">anon_umask=022</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">download_enable=NO</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">anon_upload_enable=YES</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">anon_mkdir_write_enable=YES</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">anon_other_write_enable=YES</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">chown_uploads=YES</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">chown_username=nono</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">allow_anon_ssl=YES</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">force_anon_logins_ssl=YES</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">force_anon_data_ssl=YES</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">cmds_allowed=CWD,LIST,MDTM,MKD,NLST,PASS,PASV,PORT,PWD,QUIT,RMD,RETR,SIZE,STOR,TYPE,USER,ACCT,APPE,CDUP,HELP,MODE,NOOP,REIN,STAT,STOU,STRU,SYST</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">虚拟用户将被锁定在自己的宿主目录</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">chroot_local_user=YES</span>            </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>Vsftpd</tag>
      </tags>
  </entry>
  <entry>
    <title>vsftpd 虚拟用户配置说明</title>
    <url>/202207251638/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3></blockquote>
<ul>
<li>Centos 7</li>
<li>Vsftpd 3.0.2</li>
</ul>
<p>vsftpd虚拟用户通过映射系统用户权限的方式，使虚拟用户具有和本地系统用户一样的权限，或者灵活的控制虚拟用户的权限(不和本地用户权限相同，不能高于本地权限)，达到访问权限的灵活控制，同时防止大批vsftpd用户添加到系统账号库中，使系统用户管理变动臃肿。</p>
<span id="more"></span>

<h3 id="创建虚拟用户映射的系统用户"><a href="#创建虚拟用户映射的系统用户" class="headerlink" title="创建虚拟用户映射的系统用户"></a>创建虚拟用户映射的系统用户</h3><p>系统用户virtftp拥有对ftp的读写权限，假设ftp根目录为&#x2F;data&#x2F;vsftpd&#x2F;<br>创建ftp用户组和用户virtftp，ftp相关系统账号属于ftp组  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groupadd ftp</span><br><span class="line">useradd -d /data/vsftpd -M -s /sbin/nologin -g ftp virtftp</span><br><span class="line">mkdir /data/vsftpd</span><br><span class="line">chown -R virtftp:ftp /data/vsftpd</span><br><span class="line">chmod -R 750 /data/vsftpd</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ftp根目录属于用户virtftp,用户组为ftp，设置权限750，使virtftp用户拥有读写权限</p>
</blockquote>
<h3 id="创建虚拟用户的口令库"><a href="#创建虚拟用户的口令库" class="headerlink" title="创建虚拟用户的口令库"></a>创建虚拟用户的口令库</h3><p>需要使用db_load命令根据原始口令文件(<code>/etc/vsftpd/passwd.txt</code>)生成db口令库文件，原始文件中奇数行为用户名，偶数行为密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db_load -T -t hash -f /etc/vsftpd/passwd.txt /etc/vsftpd/passwd.db</span><br><span class="line">chmod 600 /etc/vsftpd/passwd.db</span><br></pre></td></tr></table></figure>
<p>修改pam认证文件&#x2F;etc&#x2F;pam.d&#x2F;vsftpd,只保留以下2行<br>或者重新创建文件&#x2F;etc&#x2F;pam.d&#x2F;vsftpd_vu,并在<code>vsftpd.conf</code>中配置<code>pam_service_name=vsftpd_vu</code>)</p>
<figure class="highlight shell"><figcaption><span>vsftpd_vu</span></figcaption><table><tr><td class="code"><pre><span class="line">auth required /lib64/security/pam_userdb.so db=/etc/vsftpd/passwd</span><br><span class="line">account required /lib64/security/pam_userdb.so db=/etc/vsftpd/passwd  </span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>db=/etc/vsftpd/passwd</code> 为<code>db_load</code>生产的文件，不要带后缀 <code>.db</code><br>如果认证发生错误，可检查日志文件：<code>/var/log/secure</code></p>
</blockquote>
<h3 id="配置-vsftpd-启用虚拟用户"><a href="#配置-vsftpd-启用虚拟用户" class="headerlink" title="配置 vsftpd 启用虚拟用户"></a>配置 vsftpd 启用虚拟用户</h3><p>修改vsftpd配置文件，默认为<code>/etc/vsftpd/vsftpd.conf</code> <a href="/202207231311/" title="vsftpd.conf常用配置文件说明">vsftpd.conf常用配置文件说明</a></p>
<figure class="highlight shell"><figcaption><span>vsftpd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用虚拟用户功能，必须允许本地用户</span></span><br><span class="line">local_enable=YES     </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启用虚拟用户配置，所有非匿名用户登录将视为游客，将被映射为guest_username</span>     </span><br><span class="line">guest_enable=YES     </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">主配置文件中必需有，否则报错</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">500 OOPS: vsftpd: cannot locate user specified <span class="keyword">in</span> <span class="string">&#x27;guest_username&#x27;</span>:ftp</span></span><br><span class="line">guest_username=virtftp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">虚拟用户独立配置文件目录,每个虚拟用户有一个同名的配置文件于此目录下</span></span><br><span class="line">user_config_dir=/etc/vsftpd/virtual_user_conf          </span><br><span class="line">                        </span><br></pre></td></tr></table></figure>

<h3 id="配置虚拟用户配置文件"><a href="#配置虚拟用户配置文件" class="headerlink" title="配置虚拟用户配置文件"></a>配置虚拟用户配置文件</h3><p>虚拟用户配置文件位于 <code>vsftpd.conf</code> 配置 <code>user_config_dir</code> 指定的目录下，每个用户一个配置文件，配置文件和用户名同名<br>用户名，配置文件名，必须和口令文件中的用户名保持一致  </p>
<figure class="highlight shell"><figcaption><span>user1</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定虚拟用户根目录</span></span><br><span class="line">local_root=/home/ftpsite/user1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">虚拟用户是和本地用户有相同权限;NO：虚拟用户和匿名用户权限相同</span>        </span><br><span class="line">virtual_use_local_privs=YES         </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">虚拟用户对应的系统用户</span></span><br><span class="line">guest_username=virtftp   </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">虚拟用户将被锁定在自己的宿主目录</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">chroot_local_user=YES</span>    </span><br><span class="line">         </span><br><span class="line">write_enable=YES                               </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">lock_upload_files=NO</span></span><br><span class="line">anon_umask=022</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">download_enable=NO</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">anon_upload_enable=YES</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">anon_mkdir_write_enable=YES</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">anon_other_write_enable=YES</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">chown_uploads=YES</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">chown_username=nono</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">allow_anon_ssl=YES</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">force_anon_logins_ssl=YES</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">force_anon_data_ssl=YES</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">cmds_allowed=CWD,LIST,MDTM,MKD,NLST,PASS,PASV,PORT,PWD,QUIT,RMD,RETR,SIZE,STOR,TYPE,USER,ACCT,APPE,CDUP,HELP,MODE,NOOP,REIN,STAT,STOU,STRU,SYST</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="常用配置说明"><a href="#常用配置说明" class="headerlink" title="常用配置说明"></a>常用配置说明</h3><p>virtual_use_local_privs参数说明<br>当<code>virtual_use_local_privs=YES</code>时，虚拟用户和本地用户有相同的权限；<br>当<code>virtual_use_local_privs=NO</code> 时，虚拟用户和匿名用户有相同的权限，默认是NO。<br>当<code>virtual_use_local_privs=YES</code>，<code>write_enable=YES</code>时，虚拟用户具有写权限（上传、下载、删除、重命名）。<br>当<code>virtual_use_local_privs=NO</code>，<code>write_enable=YES</code>，<code>anon_world_readable_only=YES</code>，<code>anon_upload_enable=YES</code> 时，虚拟用户不能浏览目录，只能上传文件，无其他权限。<br>当<code>virtual_use_local_privs=NO</code>，<code>write_enable=YES</code>，<code>anon_world_readable_only=NO</code>，<code>anon_upload_enable=NO</code> 时，虚拟用户只能下载文件，无其他权限。<br>当<code>virtual_use_local_privs=NO</code>，<code>write_enable=YES</code>，<code>anon_world_readable_only=NO</code>，<code>anon_upload_enable=YES</code> 时，虚拟用户只能上传和下载文件，无其他权限。<br>当<code>virtual_use_local_privs=NO</code>，<code>write_enable=YES</code>，<code>anon_world_readable_only=NO</code>，<code>anon_mkdir_write_enable=YES</code> 时，虚拟用户只能下载文件和创建文件夹，无其他权限。<br>当<code>virtual_use_local_privs=NO</code>，<code>write_enable=YES</code>，<code>anon_world_readable_only=NO</code>，<code>anon_other_write_enable=YES</code> 时，虚拟用户只能下载、删除和重命名文件，无其他权限。  </p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>常用服务</category>
      </categories>
      <tags>
        <tag>Vsftpd</tag>
      </tags>
  </entry>
  <entry>
    <title>网宿云 cdn 预热脚本</title>
    <url>/202207251026/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>将源站的内容主动预取到 CDN 节点，用户首次访问可直接命中缓存，即提升首次访问速度，又能有效缓解源站压力。</p>
<ul>
<li>数据格式：请求和响应都支持 json&#x2F;xml，xml 的参数与 json 的参数基本一致，json 的参数是驼峰分隔，xml 的参数是“-”分隔，详见示例。</li>
<li>限制说明：每个账号的预取并发是 10，调高并发会增加回源的压力，请联系技术支持人员评估。</li>
</ul>
<span id="more"></span>

<h3 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h3><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">类型</th>
<th align="center">是否必填</th>
<th align="left">说明</th>
<th align="left">内部备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">urls</td>
<td align="center">Array</td>
<td align="center">是</td>
<td align="left">要预取到 CDN 节点的 url 集合，url 格式说明：<br/>1）URL 必须以’http:&#x2F;&#x2F;‘ 或 ‘https:&#x2F;&#x2F;‘ 开头，输入示例：<a href="http://www.a.com/image/test.png%E3%80%82">http://www.a.com/image/test.png。</a> <br/>2）每个 url 最大长度 2000 字符。<br/>3）每个 url 所在的域名必须是在我司加速的域名且有预取权限。<br/>4）url 中如果包含中文字符，则提交的 url 需要是中文转义后的url，采用 utf-8 方式转义。<br/>5）每日不超过 20000 条，不超过 200G 文件大小（账号粒度可调，联系技术支持人员调整）。<br/>6）每次接口调用 url 的总数不超过 400 条。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">isRange</td>
<td align="center">Int</td>
<td align="center">否</td>
<td align="left">是否需要预取 range 段。<br/>1）默认为 0，表示预取完整的文件；<br/>2）1 表示预取文件 0~512KB 的 range 段（账号粒度可调，联系技术支持人员调整）。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">aliasDomain</td>
<td align="center">String</td>
<td align="center">否</td>
<td align="left">账号开启 ts 解析<br/>有值的话，m3u8 和生成的 ts 文件需要同时生成一份带别名的url</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">parentDir</td>
<td align="center">String</td>
<td align="center">否</td>
<td align="left">一级目录，该参数和 aliasDomain 一起使用<br/>如果有值的话，是做为别名的一级目录</td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="响应参数"><a href="#响应参数" class="headerlink" title="响应参数"></a>响应参数</h3><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">x-cnc-request-id</td>
<td align="center">String</td>
<td align="left">本次请求的唯一标识,当接口调用异常时，可将 requestID 提供给网宿技术支持，便于排查接口的访问日志。</td>
</tr>
<tr>
<td align="center">Code</td>
<td align="center">Int</td>
<td align="left">表示任务创建结果的状态码，1 表示任务提交成功，0 表示任务提交失败</td>
</tr>
<tr>
<td align="center">Message</td>
<td align="center">String</td>
<td align="left">表示任务提交后，系统的响应消息</td>
</tr>
<tr>
<td align="center">itemId</td>
<td align="center">String</td>
<td align="left">调用一次接口并提交任务成功后，将返回一个 itemId，是当次提交任务的唯一标识，通过 itemId 可批量查询任务的状态（成功&#x2F;失败）。</td>
</tr>
</tbody></table>
<h3 id="请求示例"><a href="#请求示例" class="headerlink" title="请求示例"></a>请求示例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">username=&quot;username&quot;</span><br><span class="line">apiKey=&quot;apiKey&quot;</span><br><span class="line">date=`env LANG=&quot;en_US.UTF-8&quot; date -u &quot;+%a, %d %b %Y %H:%M:%S GMT&quot;`</span><br><span class="line">password=`echo -en &quot;$date&quot; | openssl dgst -sha1 -hmac $apiKey -binary | </span><br><span class="line">openssl enc -base64`</span><br><span class="line">curl -i --url &quot;https://open.chinanetcenter.com/ccm/fetch/ItemIdReceiver&quot; -X &quot;POST&quot; -u &quot;$username:$password&quot; \</span><br><span class="line"> -H &quot;Date:$date&quot; -H &quot;Content-Type: application/json&quot; -d &#x27;&#123;</span><br><span class="line"> &quot;urls&quot;: [</span><br><span class="line"> &quot;http://www.testb.com/test/test1.txt&quot;,</span><br><span class="line"> &quot;http://www.testb.com/test/test2.txt&quot;</span><br><span class="line"> ],</span><br><span class="line">&quot;isRange&quot;:0</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://wcs.chinanetcenter.com/document/Tools/GenerateUploadToken"><code>apiKey</code> 生成链接</a></p>
</blockquote>
<p>正确的响应示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Fri, 26 Oct 2012 06:33:26 GMT</span><br><span class="line">Content-Type: application/json;charset=UTF-8 x-cnc-request-id:&#123;id string auto generated by cloud server&#125;</span><br><span class="line">&#123;</span><br><span class="line"> &quot;Code&quot;: 1,</span><br><span class="line"> &quot;Message&quot;: &quot;success&quot;,</span><br><span class="line"> &quot;itemId&quot;: &quot;a2cfcc6fe79c4a8abcab806578f9bada&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://wcs.chinanetcenter.com/document/Tools/GenerateUploadToken">官网说明</a><br><a href="https://s.csms.tech/file/01%E6%8E%A8%E8%8D%90-%E9%A2%84%E5%8F%96%E6%96%87%E4%BB%B6.pdf">网宿cdn预热完整文档</a></p>
]]></content>
      <categories>
        <category>云平台</category>
        <category>网宿</category>
      </categories>
      <tags>
        <tag>云平台</tag>
        <tag>网宿</tag>
      </tags>
  </entry>
  <entry>
    <title>网宿云存储 python sdk 常用操作</title>
    <url>/f63bf868/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li><p>Centos7</p>
</li>
<li><p>Python3</p>
</li>
<li><p>wcs-python3-sdk (5.0.35)</p>
</li>
</ul>
<p># 网宿云python sdk, <code>pip3 install wcs-python3-sdk</code>， 安装后包含cli工具<code>wcscmd</code></p>
<h3 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wcscmd --configure [--config=FILE] </span><br></pre></td></tr></table></figure>

<p><code>--config=FILE  </code>配置文件存储路径，默认<code>~/.wcscfg</code> <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[参考链接](https://github.com/Wangsu-Cloud-Storage/wcs-python-sdk)">[1]</span></a></sup></p>
<h3 id="wcscmd-常用操作"><a href="#wcscmd-常用操作" class="headerlink" title="wcscmd 常用操作"></a>wcscmd 常用操作</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wcscmd listbucket </span><br><span class="line">wcscmd stat wcs://BUCKET/OBJECT  \# 查询文件信息</span><br><span class="line">wcscmd deletePrefix wcs://BUCKET PREFIX  \# 根据前缀（文件路径，必须从头开始匹配，不需要最前面的/）删除目录或文件</span><br><span class="line">wcscmd put wcs://BUCKET/file file</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="python3-sdk-操作"><a href="#python3-sdk-操作" class="headerlink" title="python3 sdk 操作"></a>python3 sdk 操作</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> wcs.commons.config <span class="keyword">import</span> Config</span><br><span class="line"><span class="keyword">from</span> wcs.services.client <span class="keyword">import</span> Client</span><br><span class="line"></span><br><span class="line">config_file = <span class="string">&quot;/root/.wcscfg&quot;</span></span><br><span class="line">cfg = Config(config_file)</span><br><span class="line">cli = Client(cfg)</span><br><span class="line">bucketName = <span class="string">&quot;TestBucket&quot;</span></span><br><span class="line">buckList = cli.bucket_list(bucketName, marker=<span class="string">&#x27;&#x27;</span>)    <span class="comment"># 列出bucket中的文件列表，每次最多获取1000个，第一页 `marker=&#x27;&#x27;`, 请求第一页的响应中marker的值为新的页的marker，可通过新的marker继续发起请求</span></span><br></pre></td></tr></table></figure>

<h4 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h4><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://github.com/Wangsu-Cloud-Storage/wcs-python-sdk">参考链接</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>云平台</category>
        <category>网宿</category>
      </categories>
      <tags>
        <tag>云平台</tag>
        <tag>网宿</tag>
      </tags>
  </entry>
  <entry>
    <title>windows 远程登录失败</title>
    <url>/f5e030ac/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>远程登录 windows 失败，报错:</p>
<blockquote>
<p>由于没有远程桌面授权服务器可以提供许可证，远程会话连接已断开，请跟服务器管理员联系</p>
</blockquote>
<p><img src="https://i.csms.tech/img.png"></p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ol>
<li>打开 cmd，执行以下命令远程登录无法登录的 Windows 主机<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">mstsc /v:<span class="number">1</span>.<span class="number">1</span>.<span class="number">1</span>.<span class="number">1</span> /admin</span><br></pre></td></tr></table></figure></li>
<li>打开注册表</li>
</ol>
<p><img src="https://i.csms.tech/img_1.png"><br>3. 找到路径： HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\RCM\GracePeriod.如果超过120天后RCM下面会有一个GracePeriod,先备份这项注册表，再删除除了默认的的注册表项。</p>
<ol start="4">
<li>重启电脑后生效.</li>
</ol>
]]></content>
      <categories>
        <category>Window</category>
        <category>常见错误</category>
      </categories>
      <tags>
        <tag>Window</tag>
      </tags>
  </entry>
  <entry>
    <title>xshell 常用配置</title>
    <url>/202208101059/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>xshell7</li>
</ul>
<h3 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h3><h4 id="字体配置"><a href="#字体配置" class="headerlink" title="字体配置"></a>字体配置</h4><p>(菜单栏)查看 &gt; 工具栏 &gt; 标准按钮  </p>
<p><img src="https://i.csms.tech/img_36.png"></p>
<span id="more"></span>

<h4 id="Meta-键配置"><a href="#Meta-键配置" class="headerlink" title="Meta 键配置"></a>Meta 键配置</h4><p>(菜单栏)文件 &gt; 当前会话属性:<br><img src="https://i.csms.tech/img_37.png"></p>
<p>终端中使用 <code>Alt .</code> 可自动补齐上一条命令的最后一个参数  </p>
<h4 id="配置-选中即复制"><a href="#配置-选中即复制" class="headerlink" title="配置 选中即复制"></a>配置 选中即复制</h4><p>工具-&gt;选项<br><img src="https://i.csms.tech/img_38.png"></p>
<p>选择 <code>键盘和鼠标</code><br><img src="https://i.csms.tech/img_39.png"></p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>xshell</category>
      </categories>
      <tags>
        <tag>xshell</tag>
      </tags>
  </entry>
  <entry>
    <title>yum</title>
    <url>/202208111442/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>CentOS Linux release 7.9.2009 (Core)</li>
<li>yum-3.4.3</li>
</ul>
<h3 id="yum-命令示例"><a href="#yum-命令示例" class="headerlink" title="yum 命令示例"></a>yum 命令示例</h3><h4 id="查询指定命令来自哪个安装包"><a href="#查询指定命令来自哪个安装包" class="headerlink" title="查询指定命令来自哪个安装包"></a>查询指定命令来自哪个安装包</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum whatprovides ip</span></span><br><span class="line">iproute-4.11.0-30.el7.x86_64 : Advanced IP routing and network device configuration tools</span><br><span class="line">Repo        : base</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : /sbin/ip</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>rpm</code> 查询已安装文件来自哪个安装包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rpm -qf /sbin/ip</span></span><br><span class="line">iproute-4.11.0-30.el7.x86_64</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
