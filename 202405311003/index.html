<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="../images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="../images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="../images/favicon-16x16-next.png">
  <link rel="mask-icon" href="../images/logo.svg" color="#222">

<link rel="stylesheet" href="../css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"csms.tech","root":"/","images":"../images","scheme":"Gemini","darkmode":true,"version":"8.14.2","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeIn","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"../search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="../js/config.js"></script>

    <meta name="description" content="本文档中的内容主要源于以下书籍：  Operating System Concepts v10 Online(操作系统导论第10版) Systems Performance: Enterprise and the Cloud v2  MemoryMain MemoryMain Memory 通常是 CPU 可以直接定位和访问的唯一的大存储设备。如果 CPU 要处理磁盘上的数据，数据必须首先被传输到">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统导论">
<meta property="og:url" content="http://csms.tech/202405311003/index.html">
<meta property="og:site_name" content="L B T">
<meta property="og:description" content="本文档中的内容主要源于以下书籍：  Operating System Concepts v10 Online(操作系统导论第10版) Systems Performance: Enterprise and the Cloud v2  MemoryMain MemoryMain Memory 通常是 CPU 可以直接定位和访问的唯一的大存储设备。如果 CPU 要处理磁盘上的数据，数据必须首先被传输到">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.csms.tech/img_243.png">
<meta property="og:image" content="https://i.csms.tech/img_244.png">
<meta property="og:image" content="https://i.csms.tech/img_271.png">
<meta property="og:image" content="https://i.csms.tech/img_246.png">
<meta property="og:image" content="https://i.csms.tech/img_236.png">
<meta property="og:image" content="https://i.csms.tech/img_240.png">
<meta property="og:image" content="https://i.csms.tech/img_269.png">
<meta property="og:image" content="https://i.csms.tech/img_241.png">
<meta property="og:image" content="https://i.csms.tech/img_242.png">
<meta property="og:image" content="https://i.csms.tech/img_247.png">
<meta property="og:image" content="https://i.csms.tech/img_248.png">
<meta property="og:image" content="https://i.csms.tech/img_258.png">
<meta property="og:image" content="https://i.csms.tech/img_272.png">
<meta property="og:image" content="https://i.csms.tech/img_273.png">
<meta property="article:published_time" content="2024-05-31T02:03:37.000Z">
<meta property="article:modified_time" content="2024-11-19T03:11:00.000Z">
<meta property="article:author" content="COSMOS">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.csms.tech/img_243.png">


<link rel="canonical" href="http://csms.tech/202405311003/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://csms.tech/202405311003/","path":"202405311003/","title":"操作系统导论"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>操作系统导论 | L B T</title>
  








  <noscript>
    <link rel="stylesheet" href="../css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">L B T</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">记 录 过 去 的 经 验</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="../index.html" rel="section"><i class="fa fa-earth-americas fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="../categories/" rel="section"><i class="fa fa-folder-tree fa-fw"></i>总目录<span class="badge">51</span></a></li><li class="menu-item menu-item-linux"><a href="../categories/Linux" rel="section"><i class="fa fa-brands fa-linux fa-fw"></i>Linux</a></li><li class="menu-item menu-item-python"><a href="../categories/Python" rel="section"><i class="fa fa-brands fa-python fa-fw"></i>Python</a></li><li class="menu-item menu-item-docker"><a href="../categories/Docker" rel="section"><i class="fa fa-brands fa-docker fa-fw"></i>Docker</a></li><li class="menu-item menu-item-kubernetes"><a href="../categories/Kubernetes" rel="section"><i class="fa fa-dharmachakra fa-fw"></i>Kubernetes</a></li><li class="menu-item menu-item-tags"><a href="../tags/" rel="section"><i class="fa fa-tornado fa-fw"></i>标签<span class="badge">78</span></a></li><li class="menu-item menu-item-archives"><a href="../archives/" rel="section"><i class="fa fa-rectangle-list fa-fw"></i>列表<span class="badge">252</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章总目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Memory"><span class="nav-number">1.</span> <span class="nav-text">Memory</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Main-Memory"><span class="nav-number">1.1.</span> <span class="nav-text">Main Memory</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Logical-Memory-Address-and-Virtual-Memory-Address"><span class="nav-number">1.2.</span> <span class="nav-text">Logical Memory Address and Virtual Memory Address</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DMA"><span class="nav-number">1.3.</span> <span class="nav-text">DMA</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dynamic-Linking-and-Shared-Libraries"><span class="nav-number">1.4.</span> <span class="nav-text">Dynamic Linking and Shared Libraries</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Memory-Allocation"><span class="nav-number">1.5.</span> <span class="nav-text">Memory Allocation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Fragmentation"><span class="nav-number">1.5.1.</span> <span class="nav-text">Fragmentation</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Paging"><span class="nav-number">1.6.</span> <span class="nav-text">Paging</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Virtual-Memory"><span class="nav-number">1.7.</span> <span class="nav-text">Virtual Memory</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Page-Fault"><span class="nav-number">1.8.</span> <span class="nav-text">Page Fault</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Major-Page-Fault"><span class="nav-number">1.8.1.</span> <span class="nav-text">Major Page Fault</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Minor-Page-Fault"><span class="nav-number">1.8.2.</span> <span class="nav-text">Minor Page Fault</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Page-Replacement"><span class="nav-number">1.9.</span> <span class="nav-text">Page Replacement</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Memory-Compression"><span class="nav-number">1.10.</span> <span class="nav-text">Memory Compression</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kernel-Memory"><span class="nav-number">1.11.</span> <span class="nav-text">Kernel Memory</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CPU"><span class="nav-number">2.</span> <span class="nav-text">CPU</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#SMP"><span class="nav-number">2.1.</span> <span class="nav-text">SMP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NUMA"><span class="nav-number">2.2.</span> <span class="nav-text">NUMA</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Program-and-Process"><span class="nav-number">2.3.</span> <span class="nav-text">Program and Process</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Process-Control-Block"><span class="nav-number">2.3.1.</span> <span class="nav-text">Process Control Block</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Scheduling-Queues"><span class="nav-number">2.4.</span> <span class="nav-text">Scheduling Queues</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Context-Switch"><span class="nav-number">2.5.</span> <span class="nav-text">Context Switch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Processor-Affinity"><span class="nav-number">2.6.</span> <span class="nav-text">Processor Affinity</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Disk"><span class="nav-number">3.</span> <span class="nav-text">Disk</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#HDD"><span class="nav-number">3.1.</span> <span class="nav-text">HDD</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NVM"><span class="nav-number">3.2.</span> <span class="nav-text">NVM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Error-Detection-and-Correction"><span class="nav-number">3.3.</span> <span class="nav-text">Error Detection and Correction</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Parity-Bit"><span class="nav-number">3.3.1.</span> <span class="nav-text">Parity Bit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CRCs"><span class="nav-number">3.3.2.</span> <span class="nav-text">CRCs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ECC"><span class="nav-number">3.3.3.</span> <span class="nav-text">ECC</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#EEPROM"><span class="nav-number">3.4.</span> <span class="nav-text">EEPROM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RAID"><span class="nav-number">3.5.</span> <span class="nav-text">RAID</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RAID-0-Striping-Volume"><span class="nav-number">3.5.1.</span> <span class="nav-text">RAID 0: Striping Volume</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RAID-1-Mirrored-Volume"><span class="nav-number">3.5.2.</span> <span class="nav-text">RAID 1: Mirrored Volume</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RAID-4-Block-Interleaved-Parity"><span class="nav-number">3.5.3.</span> <span class="nav-text">RAID 4: Block-Interleaved Parity</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RAID-5-Block-Interleaved-Distributed-Parity"><span class="nav-number">3.5.4.</span> <span class="nav-text">RAID 5: Block-Interleaved Distributed Parity</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RAID-6-P-Q-redundancy-scheme"><span class="nav-number">3.5.5.</span> <span class="nav-text">RAID 6: P + Q redundancy scheme</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RAID-10"><span class="nav-number">3.5.6.</span> <span class="nav-text">RAID 10</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RAID-01"><span class="nav-number">3.5.7.</span> <span class="nav-text">RAID 01</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#File-System"><span class="nav-number">4.</span> <span class="nav-text">File System</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#VFS"><span class="nav-number">4.1.</span> <span class="nav-text">VFS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO-Stack"><span class="nav-number">4.2.</span> <span class="nav-text">IO Stack</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Caching"><span class="nav-number">4.3.</span> <span class="nav-text">Caching</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#system-wide-open-file-table-And-per-process-open-file-table"><span class="nav-number">4.4.</span> <span class="nav-text">system-wide open-file table And per-process open-file table</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Security"><span class="nav-number">5.</span> <span class="nav-text">Security</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Encryption"><span class="nav-number">5.1.</span> <span class="nav-text">Encryption</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Symmetric-Encryption"><span class="nav-number">5.1.1.</span> <span class="nav-text">Symmetric Encryption</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Glossary"><span class="nav-number">6.</span> <span class="nav-text">Glossary</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5-Bibliography"><span class="nav-number">7.</span> <span class="nav-text">参考链接|Bibliography</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%84%9A%E6%B3%A8"><span class="nav-number">8.</span> <span class="nav-text">脚注</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">COSMOS</p>
  <div class="site-description" itemprop="description">得 能 莫 忘</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="../archives/">
          <span class="site-state-item-count">252</span>
          <span class="site-state-item-name">文章</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="../categories/">
        <span class="site-state-item-count">51</span>
        <span class="site-state-item-name">目录</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="../tags/">
        <span class="site-state-item-count">78</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://csms.tech/202405311003/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="../images/avatar.gif">
      <meta itemprop="name" content="COSMOS">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="L B T">
      <meta itemprop="description" content="得 能 莫 忘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="操作系统导论 | L B T">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          操作系统导论
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-31 10:03:37" itemprop="dateCreated datePublished" datetime="2024-05-31T10:03:37+08:00">2024-05-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-11-19 11:11:00" itemprop="dateModified" datetime="2024-11-19T11:11:00+08:00">2024-11-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">上层目录</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="../categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="../categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="../categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/OS/Operating-System-Concepts-v10/" itemprop="url" rel="index"><span itemprop="name">Operating System Concepts v10</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文档中的内容主要源于以下书籍：</p>
<ul>
<li><strong><a target="_blank" rel="noopener" href="https://os.ecci.ucr.ac.cr/slides/Abraham-Silberschatz-Operating-System-Concepts-10th-2018.pdf">Operating System Concepts v10 Online(操作系统导论第10版)</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://s.csms.tech/file/Systems.Performance.Enterprise.and.the.Cloud.2nd.Edition.2020.12.pdf">Systems Performance: Enterprise and the Cloud v2</a></strong></li>
</ul>
<h1 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h1><h2 id="Main-Memory"><a href="#Main-Memory" class="headerlink" title="Main Memory"></a>Main Memory</h2><p><strong>Main Memory</strong> 通常是 CPU 可以直接定位和访问的唯一的大存储设备。如果 CPU 要处理磁盘上的数据，数据必须首先被传输到 <strong>Main Memory</strong>，指令要能被 CPU 执行，也必须首先载入内存中。</p>
<p><strong><code>Program</code></strong> 要能被运行，首先必须载入到内存中，并提供内存绝对地址给 CPU 以供加载指令和数据。</p>
<h2 id="Logical-Memory-Address-and-Virtual-Memory-Address"><a href="#Logical-Memory-Address-and-Virtual-Memory-Address" class="headerlink" title="Logical Memory Address and Virtual Memory Address"></a>Logical Memory Address and Virtual Memory Address</h2><p>通常情况下，CPU 生成的内存地址被称为 <code>Logical Memory Address</code>，也称为 <code>Virtual Memory Address</code>。</p>
<p>Memory-address 注册器（memory-address register）加载的地址通常称为 <code>Physical Memory Address</code>。</p>
<p>程序运行过程中，CPU 操作的是 <code>Virtual Memory Address</code>，需要由硬件设备 MMU（Memory Management Unit）负责将 <code>Virtual Memory Address space</code> 映射到对应的 <code>Physical Memory Address space</code>。程序或者是 CPU 运行过程中，不会直接操作（访问&#x2F;access）物理内存地址空间。</p>
<p><img src="https://i.csms.tech/img_243.png"></p>
<span id="more"></span>

<h2 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h2><p><code>Direct Memory Access (DMA)</code> 在 CPU 需要从存储读写大量数据到内存时，如果数据通过 CPU 中转，成本太高，为了解决这个问题，DMA 被采用，在传输大块数据时，首先在 CPU 中为数据设置好必要的 buffer、指针、计数器等资源，设备控制器（DMA Controller）直接（在磁盘和内存中）传输数据块而无须 CPU 参与实际的数据传输，只需要在数据块传输完成时，向 CPU 产生中断以指示设备控制器（DMA Controller）数据传输已完成。在 DMA 过程中，CPU 依旧可以做其他工作。 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Operating System Concepts v10 Online](https://os.ecci.ucr.ac.cr/slides/Abraham-Silberschatz-Operating-System-Concepts-10th-2018.pdf) 1.2.3 I/O Structure">[1]</span></a></sup></p>
<h2 id="Dynamic-Linking-and-Shared-Libraries"><a href="#Dynamic-Linking-and-Shared-Libraries" class="headerlink" title="Dynamic Linking and Shared Libraries"></a>Dynamic Linking and Shared Libraries</h2><p>DLLs(Dynamic Linked Libraries) 是程序运行期间需要链接的系统库文件（system libraries）。<sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Operating System Concepts v10 Online](https://os.ecci.ucr.ac.cr/slides/Abraham-Silberschatz-Operating-System-Concepts-10th-2018.pdf) 9.1.5 Dynamic Linking and Shared Libraries">[6]</span></a></sup> </p>
<p>部分操作系统不支持 DLLs 机制，只能使用 <strong>静态链接</strong>（<code>static linking</code>），在这种情况下，应用程序运行过程中需要使用的系统库文件必须和应用程序一起编译进应用程序镜像（program image）中。假如多个应用程序使用了同样的库文件，那么这些库文件会同时存在于这些应用程序的程序镜像文件中，这些应用程序运行过程中也会在内存中加载多份同样的库文件。这可能会产生以下缺点：</p>
<ul>
<li>应用程序镜像较大，占用更多磁盘空间</li>
<li>应用程序运行时，因为要加载多个同样的库文件，会占用更多的内存</li>
<li>库文件升级不灵活，要升级某个库文件，要重新编译所有使用此库文件的应用程序。</li>
</ul>
<p>DLLs(Dynamic Linked Libraries) 是在运行过程中，动态加载库文件。这个特性在系统库文件（如 standard C language library）中很常用。程序编译过程中及运行过程中动态加载系统库文件，无需将系统库文件打包进应用程序镜像中，应用程序运行过程中动态加载系统库文件，如果要加载的目标系统库文件已经存在于内存中，则无需重复加载，直接共享使用即可。DLLs 有以下优势：</p>
<ul>
<li>应用程序镜像无需包含常用的库文件，减少了磁盘使用量</li>
<li>应用程序运行时，可以在多个进程中共享库文件，无需重复加载（只存在一个库实例即可），减少了内存使用率并提升了内存效率</li>
<li>共享库文件升级后，所有加载此库文件的应用程序都可以直接使用更新后的新版本。<strong>应用程序和库文件中都包含了相应的版本信息，会防止应用程序使用错误的库版本</strong></li>
<li>内存中可以加载多个版本的共享库文件，应用程序会使用自己的库文件版本信息加载正确的库文件</li>
</ul>
<h2 id="Memory-Allocation"><a href="#Memory-Allocation" class="headerlink" title="Memory Allocation"></a>Memory Allocation</h2><h3 id="Fragmentation"><a href="#Fragmentation" class="headerlink" title="Fragmentation"></a>Fragmentation</h3><p>假设在一个全新的未运行任何应用程序的操作系统中，初始情况下内存中存在一整块连续的可用地址范围（one large block of available memory），或者叫一个 <code>Hole</code>。</p>
<p>假设如下图所示情况，系统中运行了 processes 5, 8, and 2 并且占用了所有的内存地址范围。之后 process 8 退出，其所使用的内存释放，形成了一个 <code>Hole</code>，随后 process 9 开始运行并申请了一段内存，随后 process 5 退出并释放内存，导致内存中出现了 2 个地址非连续（noncontigous）的 <code>Hole</code>。<strong>随着系统中进程的运行和退出，内存中可能会存在很多大小不一，地址范围不连续的 Hole</strong>，这些 <code>Hole</code> 既是 <strong>外部内存碎片（<code>External Memory Fragmentation</code>）</strong></p>
<p><img src="https://i.csms.tech/img_244.png"></p>
<p><strong>外部内存碎片（<code>External Memory Fragmentation</code>）</strong> 存在时，可能出现系统有足够多的空闲内存（非连续的地址空间，内存碎片）但是这些内存都是内存碎片。</p>
<p>在现代的内存管理中，内存的分配一般是以 <code>block</code> 为单位进行分配，<code>block</code> 是一个固定大小的内存。在这种情况下，假如 <code>block</code> 大小为 512 bytes，应用程序申请了 600 bytes 内存，那么需要分配 2 个 <code>block</code> 给应用程序，实际分配了 1024 bytes 。申请的内存（600 bytes）和实际分配的内存（2 blocks &#x3D; 1024 bytes）之间的差值被称为 <strong><code>内部内存碎片</code>（Internal Memory Fragmentation）</strong></p>
<h2 id="Paging"><a href="#Paging" class="headerlink" title="Paging"></a>Paging</h2><p>在当前的操作系统中，解决 <strong>外部内存碎片（<code>External Memory Fragmentation</code>）</strong> 的问题，通用解决方法是采用 <strong>内存页（Memory Paging）</strong> 技术： <strong>应用程序申请的 Logical 内存&#x2F;Physical 内存地址非连续（横跨多个 Hole）</strong></p>
<p>Paging 解决了 <strong>外部内存碎片（<code>External Memory Fragmentation</code>）</strong> 的问题，没有解决 <strong><code>内部内存碎片</code>（Internal Memory Fragmentation）</strong></p>
<h2 id="Virtual-Memory"><a href="#Virtual-Memory" class="headerlink" title="Virtual Memory"></a>Virtual Memory</h2><p>Virtual Memory 是 Main Memory 的一个抽象层，它将 Main Memory 抽象为一个近乎无限大的（Almost Infinite）拥有独立视图(Private View)的内存空间。</p>
<p>Virtual Memory 实现了了 <strong>允许程序运行过程中，无需将整个程序内容全部加载到内存中的技术</strong> <sup id="fnref:7"><a href="#fn:7" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Operating System Concepts v10 Online](https://os.ecci.ucr.ac.cr/slides/Abraham-Silberschatz-Operating-System-Concepts-10th-2018.pdf) CHAPTER 10 Virtual Memory">[7]</span></a></sup></p>
<p>主要有以下优势：</p>
<ul>
<li>Processes&#x2F;Kernel 都在自己独立的地址空间中（Private Address Spaces）运行，不用担心地址争用（Contention）</li>
<li>支持内存地址超分配（Oversubscription&#x2F;Overcommit）</li>
<li>通过 Virtual Memory，OS 可以将按需 Virtual Memory 映射（Map）到 Main Memory 和 Secondary Storage（Disks）上</li>
<li>程序大小可以大于物理内存空间。开发者不必再关注物理内存是否足够。</li>
<li>Virtual Memory 将 Main Memory 抽象成一个统一的大存储阵列，基于此，程序开发者可以不用关注物理内存的差异和限制。</li>
<li>允许进程共享文件和库，并实现了共享内存（Shared Memory）。</li>
</ul>
<p><img src="https://i.csms.tech/img_271.png"></p>
<h2 id="Page-Fault"><a href="#Page-Fault" class="headerlink" title="Page Fault"></a>Page Fault</h2><p>Virtual Memory 提供了 <strong>允许程序运行过程中，无需将整个程序内容全部加载到内存中的技术</strong>，实现此技术主要使用了 <code>Demand Paging</code> 技术，使用 <code>demand-paged virtual memory</code>，可以实现程序运行过程中，仅仅在 <strong>运行过程中必须的 pages 才会被加载到内存中，那些没有用到的 pages 永远不会加载到物理内存中</strong>，<code>Demand Pageing</code> 也是 Virtual Memory 的一个主要优势。</p>
<p><code>Demand Paging</code> 技术的实现依赖于硬件的支持和 <code>Page Fault</code> 技术。</p>
<p>根据 <code>Demand Paging</code> 方案的原则，<strong>程序运行过程中用不到的 Pages 不应该被加载到内存中</strong>。因此，当一个程序刚刚启动时，它之后运行过程中所需的 Pages 理论上都不在内存中，而是存在于次级存储（secondary storage，如磁盘或者 swap）中，如果 <strong>程序运行过程中需要内存中不存在的 Pages，这时就要有机制确保实现将程序运行所需的 Pages 加载到内存中来，并且只是加载程序运行所需的 Pages，而不会加载用不到的 Pages</strong>，实现此机制的技术叫 <code>Page Fault</code>。</p>
<p><code>Page Fault</code> 需要硬件支持，主要是内存组件中的硬件设备（Paging Hardware，负责 page table 内存地址转换），当程序运行过程中需要不存在于内存中的 Pages 时，会向 OS 产生一个 <code>Page Fault</code> 的 trap，此 trap 是一个 OS Failure（指示所需 Pages 不在内存中），硬件会注意到此 OS Failure 并进行相应处理。</p>
<p>操作系统处理 <code>Page Fault</code> 的简要工作流程如下：</p>
<ol>
<li>检查并确保此内存请求合法后，如果所需的 pages 不在内存中，开始将其加载入内存（page in）</li>
<li>在物理内存中找到空闲的 frame（free frame）</li>
<li>向次级存储（secondary storage，如磁盘或者 swap）发送读取所需 Pages 到新分配的 frame 的请求</li>
<li>当存储（Pages）读取到内存完毕后，修改程序所属的 internal table 和 page table 以指示所需的 Pages 已经在内存中 </li>
<li>重新启动因为缺少所需 Pages 而被中断（interrupted）的指令（instruction）</li>
</ol>
<p><img src="https://i.csms.tech/img_246.png"></p>
<h3 id="Major-Page-Fault"><a href="#Major-Page-Fault" class="headerlink" title="Major Page Fault"></a>Major Page Fault</h3><p><code>Major Page Fault</code> 发生于所需要的 Page 不在内存中，这是系统需要在物理内存中找到可用的 Frames，然后将数据从 <strong>次级存储（secondary storage，如磁盘或者 swap）</strong> 读取到内存中并更新对应的  <code>internal table</code> 和 <code>page table</code> 以指示所需的 Pages 已经在内存中</p>
<h3 id="Minor-Page-Fault"><a href="#Minor-Page-Fault" class="headerlink" title="Minor Page Fault"></a>Minor Page Fault</h3><p><code>Minor Page Fault</code> 发生在以下 2 中情况：</p>
<ol>
<li>应用程序需要引用共享库，此共享库已经在内存中，但是应用程序的 <code>page table</code> 中没有到此共享库所在内存页的 mapping。此种情况下，只需要更新应用程序的 <code>page table</code>，向其中添加到共享内存库所在内存页的引用。</li>
<li>Virtual Memory 中的 Page 被应用程序释放（reclaimed），对应物理内存 Frame 被标记为 <code>free-frame</code>，但是上面的数据未被 <code>zeroed out</code>，此时 Page 被分配给其他应用程序。</li>
</ol>
<p>Linux 系统中，使用 <code>ps</code> 命令的 <code>-eo min_flt,maj_flt,cmd</code> 参数可以查看进程相关的 major 和 minor page fault。</p>
<h2 id="Page-Replacement"><a href="#Page-Replacement" class="headerlink" title="Page Replacement"></a>Page Replacement</h2><p>现代的操作系统内存，一般都允许 <strong>超分配（over-allocating）</strong>，即允许操作系统分配比实际的物理内存更多的内存给应用程序，当一个应用程序运行过程中，因为 Page Fault 要 Page In 时，可能会出现物理内存不足（no free frames on the free-frame list）的情况，此时操作系统会尽最大可能的满足应用程序对内存的申请。以前的操作系统大都采用 Swap 来实现，即将当前未在 CPU 上运行的应用程序使用的内存 swap out 到 Swap 中，并将空余出来的内存分配给要运行的程序使用。<strong>Swap 技术已被当前大多数操作系统摈弃，因为其在内存和 Swap 中拷贝数据成本太高</strong>，取而代之的技术是 <code>Page Repalcement</code>。</p>
<p>使用 Page Replacement 技术，在物理内存不足时，使用 page-replacement 算法找到物理内存中的 Frames（victim frames），将其上的内容写入（<strong>如果其上内容未改变，不用执行写入操作，如果内容改变，执行写操作</strong>）到次级存储（secondary storage），如果之后的运行过程中，应用程序需要这些数据，它会产生 Page Fault，这些数据会被重新加载回内存中。 </p>
<h2 id="Memory-Compression"><a href="#Memory-Compression" class="headerlink" title="Memory Compression"></a>Memory Compression</h2><p><code>Memory Compression</code> 是在物理内存不够时，使用的一种可替代 <code>Page Repacement</code> 的技术。在系统内存不足时，系统不执行 <code>Page Replacement</code>，而是先对选择出的 <code>victim frames</code> 执行内存压缩，将多个 frames 压缩成一个 frame 进而降低内存使用率，而无需进行 <code>Page Swapping out</code> 操作。</p>
<blockquote>
<p>移动设备操作系统，包括 Android 和 IOS 都不支持 <code>Swap</code> 和 <code>Page Repalcement</code>，都采用了 <code>Memory Compression</code> 技术作为 Memory Management strategy 的一部分</p>
<p><strong>在性能方面，<code>Memory Compression</code> 拥有比 <code>Page Repalcement</code> 更快的速度。</strong></p>
</blockquote>
<h2 id="Kernel-Memory"><a href="#Kernel-Memory" class="headerlink" title="Kernel Memory"></a>Kernel Memory</h2><p>内核（kernel）使用的内存和用户模式（user mode space）中的应用程序使用的内存分配机制不同。主要基于以下原因： <sup id="fnref:8"><a href="#fn:8" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Operating System Concepts v10 Online](https://os.ecci.ucr.ac.cr/slides/Abraham-Silberschatz-Operating-System-Concepts-10th-2018.pdf) 10.8 Allocating Kernel Memory">[8]</span></a></sup></p>
<ul>
<li>Kernel 中的数据结构大小差异很大，很多都比 Page Size 要小，内存使用不当会导致非常多的 <code>internal fragmentation</code>，导致内存严重浪费。而且很多操作系统并未将内核代码放置到 Paging Memory 中。</li>
<li><code>user-mode</code> 中的应用程序分配的内存在物理内存地址上没必要是连续地址空间，然而内核中包含的很多硬件设备都需要直接通过物理内存进行交互，无法使用 <code>Virtual Memory Interface</code>，因此需要内存中连续的地址空间（contiguous pages）分配</li>
</ul>
<h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1><h2 id="SMP"><a href="#SMP" class="headerlink" title="SMP"></a>SMP</h2><p><code>Symmetric Multiprocessing (SMP)</code>，对称处理系统，在系统中存在多个处理器，每个处理器中包含一个或多个 CPU，每个 CPU 有自己的 L1 Cache （CPU 独享）和 Register，每个处理器有 L2 Cache（处理器中的多个 CPU 共享 L2 cache），同一个处理器中的 CPU 使用处理器内部通信系统通信，跨处理器的 CPU 之间通过系统总线（Bus）通信。 <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Operating System Concepts v10 Online](https://os.ecci.ucr.ac.cr/slides/Abraham-Silberschatz-Operating-System-Concepts-10th-2018.pdf) 1.3.2 Multiprocessor Systems">[2]</span></a></sup></p>
<h2 id="NUMA"><a href="#NUMA" class="headerlink" title="NUMA"></a>NUMA</h2><p><strong>系统中的处理器不宜太多，多处理器可以提高系统的任务处理能力，但是当 CPU 过高时，对系统总线的争抢会成为系统瓶颈。</strong></p>
<p>为了避免太多 Processors 争抢系统总线造成的性能下降，一个可选的 方法是为每个 CPU（或 CPU 集）提供专用的本地内存，CPU 通过一个更小更快的本地 bus 连接专用的本地内存。所有的 CPU 通过一个 <strong>内部通信系统</strong> 进行连接，所有 CPU 共享同一个物理地址空间，这种架构被称为 <code>Non-uniform Memory Access (NUMA)</code></p>
<p><img src="https://i.csms.tech/img_236.png"></p>
<p>在 NUMA 系统中，内存访问分为两种类型：</p>
<ul>
<li><p><strong>本地内存访问（Local Memory Access）</strong> ： 处理器访问其自身所在节点的内存。访问本地内存的延迟较低，带宽较高。</p>
</li>
<li><p><strong>远程内存访问（Remote Memory Access）</strong> ： 处理器访问其他节点的内存。由于访问的是远程内存，延迟较高，带宽较低。</p>
</li>
</ul>
<p>NUMA 节点通过高带宽的互联技术（如 <code>QuickPath Interconnect</code>，<code>HyperTransport</code>，<code>InfiniBand</code>）来实现不同节点之间的通信，但这种通信仍然比本地内存访问要慢。</p>
<p><strong>NUMA 的优势</strong>  </p>
<ul>
<li><p><strong>提高并行处理能力</strong> ：每个处理器拥有自己的本地内存，这使得 NUMA 能够处理更多的并发任务，并且避免了在 SMP 系统中由于内存共享而产生的瓶颈。</p>
</li>
<li><p><strong>优化内存访问</strong> ：由于每个处理器有自己的本地内存，处理器能够更高效地访问本地内存，从而减少内存访问的延迟。</p>
</li>
<li><p><strong>适应多核和大规模计算</strong> ：在多核处理器和大规模计算环境中，NUMA 提供了更高的扩展性，允许系统能够容纳更多的处理器和内存节点。</p>
</li>
<li><p><strong>优化内存分配策略</strong> ：NUMA 系统可以根据负载和内存访问模式智能地分配内存，减少远程内存访问的需求。</p>
</li>
</ul>
<p><strong>NUMA 的挑战</strong></p>
<ul>
<li><p><strong>内存访问延迟差异</strong> ： 访问远程内存比访问本地内存慢得多，因此如何优化内存访问模式是一个挑战。程序需要特别设计，以避免频繁访问远程内存。</p>
</li>
<li><p><strong>复杂的内存管理</strong> ： 操作系统和应用程序需要考虑 NUMA 的架构，避免内存分配和处理器调度不当造成性能下降。</p>
</li>
<li><p><strong>负载均衡问题</strong> ： 如果某个 NUMA 节点的负载过重，而其他节点的负载较轻，可能会导致性能不均衡。操作系统需要具备有效的负载均衡机制。</p>
</li>
</ul>
<p>现代操作系统（如 Linux、Windows）都支持 NUMA，并提供了一些功能来优化 NUMA 系统的性能：</p>
<ul>
<li><p><strong>NUMA-aware memory allocation</strong> ： 操作系统可以根据当前任务的 CPU 核心来分配本地内存，避免远程内存访问。例如，Linux 使用 <code>numactrl</code> 工具来控制 NUMA 节点的内存分配。</p>
</li>
<li><p><strong>CPU 亲和性（CPU Affinity）</strong> ： 操作系统可以将进程或线程绑定到特定的 NUMA 节点上，以减少远程内存访问。</p>
</li>
<li><p><strong>NUMA-aware scheduling</strong> ： 操作系统可以根据每个 NUMA 节点的负载和内存访问模式进行任务调度，以平衡系统的负载。</p>
</li>
</ul>
<p><a href="https://csms.tech/202306021537/#NUMA-架构及其性能统计数据"><code>numastat</code> 命令使用参考</a></p>
<h2 id="Program-and-Process"><a href="#Program-and-Process" class="headerlink" title="Program and Process"></a>Program and Process</h2><p><strong><code>Program</code></strong> 是一个静态实体，只是存储在操作系统中的文件（集合）</p>
<p><strong><code>Process</code></strong> 是操作系统上的活动（Active）实体，是 <strong><code>Program</code></strong> 由操作系统加载运行之后的实体。</p>
<p><strong><code>Process</code></strong> 运行过程中需要操作系统为其分配各种资源，如 CPU、Memory、Files、IO 等来完成其运行。</p>
<p>如果一个 <strong><code>Program</code></strong> 被操作系统运行（启动）了多次，那么其产生的多个 <strong><code>Process</code></strong>  属于分割（单独）的实体。</p>
<h3 id="Process-Control-Block"><a href="#Process-Control-Block" class="headerlink" title="Process Control Block"></a>Process Control Block</h3><p>PCB (<code>Process Control Block</code>) 代表了 OS 中进程（Process）的各种信息，包括</p>
<ul>
<li><code>Process State</code> : 进程当前的状态</li>
<li><code>Program counter</code> : 程序计数器指针。指向了当前进程中下一个要执行的指令的地址。</li>
<li><code>CPU registers</code> : 根据计算机架构的不同，可能包括计数器、栈指针（stack pointers）、通用指针（general-purpose registers）等。</li>
<li><code>CPU-scheduling information</code> : 包括进程优先级（process priority）信息、调度队列指针（pointers to scheduling queues）以及其他调度参数等。</li>
<li><code>Memory-management information</code> : 进程使用的内存信息</li>
<li><code>Accounting information</code> : CPU 数量和 CPU 使用时间，CPU 使用限制，进程数量等信息</li>
<li><code>I/O status information</code> : 分配给进程的 IO 设备，打开的文件列表等。</li>
</ul>
<p><img src="https://i.csms.tech/img_240.png"></p>
<p>PCB 也可以称为 Process environment，从 User Space 和 Kernel Space 的角度，可以将其分为 <code>User Address Space</code> 和 <code>Kernel Context</code>。 <sup id="fnref:11"><a href="#fn:11" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Systems Performance: Enterprise and the Cloud v2](https://s.csms.tech/file/Systems.Performance.Enterprise.and.the.Cloud.2nd.Edition.2020.12.pdf) 3.2.6 Processes">[11]</span></a></sup></p>
<ul>
<li><code>Kernel Context</code> 包含了 Process 的各种属性和状态，如 PID、PPID、UID 、打开的文件描述符（File Descriptors）等</li>
<li><code>User Address Space</code> 主要包含了 Process 的内存信息（Memory Segments）<br><img src="https://i.csms.tech/img_269.png"></li>
</ul>
<p>上图中的进程（Process）中包含了 2 个线程（Threads），每个线程包含自己的一些元数据（Metadata），如调度优先级（Schedule Priority），线程（Thread）包含的元数据（Metadata）远小于进程的地址空间（Process Address Space）</p>
<h2 id="Scheduling-Queues"><a href="#Scheduling-Queues" class="headerlink" title="Scheduling Queues"></a>Scheduling Queues</h2><p><img src="https://i.csms.tech/img_241.png"></p>
<ul>
<li><code>ready queue</code> : 进程开始后，会被放入 <code>ready queue</code>，等待 CPU 被分配给它。<code>ready queue</code> 是一个 <strong>链接队列</strong>，其首部包含一个指向队列中第一个 PCB 的指针，每个 PCB 都包含一个指针，指向 <code>ready queue</code> 中的下一个 PCB。</li>
<li><code>wait queue</code> : 当 <code>ready queue</code> 中的进程被分配了 CPU 后，其执行一段时间后会中止或者是等待特殊事件，如 IO，在起等待的过程中会被放入 <code>wait queue</code></li>
</ul>
<blockquote>
<p><strong>操作系统负载（system load）</strong> 衡量的就是 <strong>正在 CPU 上运行的任务加正在 Scheduling Queues 中的任务（线程&#x2F;进程）的数量</strong> 。</p>
</blockquote>
<h2 id="Context-Switch"><a href="#Context-Switch" class="headerlink" title="Context Switch"></a>Context Switch</h2><p>CPU 会频繁的调度（因为 CPU Schedule 或 Interrupts）不同的进程来执行，当调度发生，OS 需要保存当前进程的上下文信息（Context）以备当前进程再次开始执行时恢复 Context，Context 信息保存在 <a href="#Process-Control-Block">PCB</a> 中</p>
<p>切换 CPU core 要保存当前进程的 Context (到 PCB)并恢复另一个进程的 Context（从 PCB），这个过程被称为 <code>Context Switch</code></p>
<p><img src="https://i.csms.tech/img_242.png"></p>
<blockquote>
<p>在现代化的操作系统上，OS 调度的更多的是 <code>kernel-level threads</code>，而不是 <strong>processes （进程）</strong></p>
</blockquote>
<h2 id="Processor-Affinity"><a href="#Processor-Affinity" class="headerlink" title="Processor Affinity"></a>Processor Affinity</h2><p>Processes 在指定的 CPU 上运行的过程中，一般会加载数据到 CPU 的 cache 中，下一次调度到同一个 CPU 运行时，仍然可以使用 Cache 中的数据（称为 <code>warm cache</code>）。 <sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Operating System Concepts v10 Online](https://os.ecci.ucr.ac.cr/slides/Abraham-Silberschatz-Operating-System-Concepts-10th-2018.pdf) 5.5.4 Processor Affinity ">[5]</span></a></sup></p>
<p>假如后续 CPU 调度时，此进程被调度到了另一个 CPU，那么原来 CPU Cache 中的数据就要失效，新的 CPU 必须从新加载数据到 Cache 中。<strong>因为让 CPU Cache 中的数据失效和加载 Memroy 中的数据到 Cache 中是一个成本较高的操作，现代的 SMP 操作系统都会避免这类缓存迁移操作，会尽量将进程调度到同一个 CPU 以使用 <code>warm cache</code> 数据</strong>，这就是 <code>Processor Affinity</code>，一个进程对其正在运行的 CPU 拥有亲和性。</p>
<p>常见的 CPU 亲和性（Processor Affinity）有两类：</p>
<ul>
<li><code>soft affinity</code> : 尽量保证一个进程被调度到同一个 CPU，但是不保证一定，尽最大可能</li>
<li><code>hard affinity</code> : 允许配置进程只运行在选定的 CPU 集（subset of processors）</li>
</ul>
<p>大多数系统同时实现了以上两种类型。 </p>
<h1 id="Disk"><a href="#Disk" class="headerlink" title="Disk"></a>Disk</h1><p>可以将 NVS （<code>Nonvolatile Storage (NVS)</code>）根据硬盘组成划分成 2 大类</p>
<ul>
<li>机械硬盘（Mechanical）： HDDs，Optical Disks，Holographic storage，Magnetic Tape。</li>
<li>Electrical（NVM）： Flash Memory，FRAM，NRAM，SSD</li>
</ul>
<h2 id="HDD"><a href="#HDD" class="headerlink" title="HDD"></a>HDD</h2><p><img src="https://i.csms.tech/img_247.png"><br>HDD （Hard Disk Driver）的主要组成如上图。主要包括以下主要组件： <sup id="fnref:9"><a href="#fn:9" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Operating System Concepts v10 Online](https://os.ecci.ucr.ac.cr/slides/Abraham-Silberschatz-Operating-System-Concepts-10th-2018.pdf) 11.1.1 Hard Disk Drives">[9]</span></a></sup></p>
<ul>
<li><p><code>Platter</code><br>  Platter 的两面由磁性材料（magnetic material）覆盖组成。</p>
</li>
<li><p><code>Read-Write Head</code><br>  Platter 的两面分别有个 <code>Read-Write Head</code> (读写磁头) 负责在磁碟（Platter）上写入&#x2F;读取数据。磁头和 Platters 之间一般由一层非常薄的气体作为保护层，如氦气（helium），磁头和 Platter 表面接触会造成 Platter 表面的磁性材料损坏，这被称为 <code>Head Crash</code>，一般无法修复，磁盘上面数据会丢失。</p>
</li>
<li><p><code>Disk Arm</code><br>  Disk Arm 连接了 <code>Read-Write Head</code> (读写磁头) 和 <code>Arm Assembly</code>，<code>Read-Write Head</code> (读写磁头) 通过 Disk Arm 的移动来寻址到不同的存储单元。</p>
</li>
<li><p><code>Tracks</code><br>  Platter 的面被（逻辑&#x2F;Logically）分割成圆弧形（两个不同半径的圆分割组成的部分）</p>
</li>
<li><p><code>Sectors</code><br>  <code>Tracks</code> 被逻辑（Logically） 分割成 <code>Sectors</code>  （扇形），Sectors 是 HDD 磁盘上最小的传输单元，一般有固定大小的存储空间（2010 年前一般是 512 bytes，之后大多升级到了 4KB）。每个 Track 上面包含多个 Sectors。</p>
</li>
<li><p><code>Cylinder</code><br>  每个 Platter 上面，固定位置的 <code>Disk Arm</code> &#x2F; <code>Read-Write Head</code> 垂直组成的存储单元组成一个 <code>Cylinder</code> 。每个磁盘上面会包含很多个同心的（Concentric） Cylinder</p>
</li>
</ul>
<p>HDD 磁盘中包含一个高速旋转的 <strong>马达（disk driver motor）</strong>，HDD 磁盘的传输速度（<code>Transfer Rate</code>）和马达的旋转速度相关，通常使用 <strong><code>RPM(Rotations Per Minute)</code></strong> 来衡量 HDD 磁盘的转速，通常在 5400&#x2F;7200&#x2F;15000 RPM。有些 HDD 磁盘在电量不足或者使用频率低时会降低 RPM 来节能和提高磁盘使用寿命。</p>
<p><code>Transfer Rate</code> 是衡量数据在 HDD 磁盘和操作系统之间传输速度的指标。这个性能指标主要受到 <strong>寻址时间（Positioning Time）</strong> 或者叫 <code>Random-Access Time</code> 的影响，这个时间主要由 2 部分组成，一般在 <strong>几毫秒（several milliseconds）</strong></p>
<ol>
<li><code>Seek Time</code> : Disk Arm 移动到目标 Cylinder 的时间</li>
<li><code>Rotational Latency</code> : 目标 Sector 移动到 Disk Read Wirte Head 的延迟。</li>
</ol>
<h2 id="NVM"><a href="#NVM" class="headerlink" title="NVM"></a>NVM</h2><p> <code>Nonvolatile Memory Devices (NVM)</code> 使用电特性（Electrical）存储，而不是机械（mechanical）特性，相比 HDD，其拥有更高的可靠性和性能（没有 Seek Time 和 Rotational Latency），更加的省电，劣势是他们价格相对 HDD 更贵并且存储空间相对较小，但是随着时间推移，这些劣势也会逐渐消弭。</p>
<p>NVM 存储的 <strong>写入性能</strong> 通常和其存储可用大小相关，因为 NVM 设备内部通常会保留部分空间用于 <code>Garbage Collection</code> 和 <code>Over-Provisioning</code>（通常为 20%），如果可用空间小，会导致 <strong>写性能</strong> 下降。</p>
<p><strong>NVM 设备的寿命和其 Erase 的次数正相关</strong></p>
<h2 id="Error-Detection-and-Correction"><a href="#Error-Detection-and-Correction" class="headerlink" title="Error Detection and Correction"></a>Error Detection and Correction</h2><p><strong>Error Detection</strong> 是计算机系统中最基础的功能之一，普遍用于 Memory、Network、Storage 系统中。Error Detection 的常见功能包括：</p>
<ul>
<li>检测存储中存储的数据是否发生了（错误&#x2F;非自发&#x2F;无意的）改变，比如某个数据位由 0 变为了 1</li>
<li>网络数据在传输过程中发生了改变</li>
<li>存储设备上的数据读写不一致。<br>通过检测这些错误，可以防止在使用这些错误数据之前对其进行修正或者是发送通知给使用者。</li>
</ul>
<h3 id="Parity-Bit"><a href="#Parity-Bit" class="headerlink" title="Parity Bit"></a>Parity Bit</h3><p>Memory 长使用 <code>Parity Bit (奇偶校验位)</code> 算法进行 Error Detection，Memory 系统中的每个 Byte 都有一个对应的 <code>Parity Bit</code>，此 <code>Parity Bit</code> 记录了对应的 byte 中 <code>1</code> 出现的次数是 <strong>偶数（even，<code>Parity Bit = 0</code>）</strong> 还是 <strong>奇数(odd, <code>Parity Bit = 1</code>)</strong></p>
<p>根据 <code>Parity Bit</code> 算法的计算结果，会出现以下情况：</p>
<ul>
<li>Memory 中的一个 byte 中的一个 bit 位发生了改变，那么此 byte 计算出的 Parity Bit 值和保存的 Parity Bit 值不一样，<strong>说明数据不可靠</strong></li>
<li>Memory 中的一个 byte 中的任何 bit 都正常，但是保存的 Parity Bit 值发生了变化，那么此 byte 计算出的 Parity Bit 值和保存的 Parity Bit 值不一样，<strong>说明数据不可靠</strong></li>
<li>Memory 中的一个 byte 计算出的 Parity Bit 值和保存的 Parity Bit 值一致，<strong>说明数据可靠</strong></li>
</ul>
<p><strong>Parity Bit 无法检测 2 个 bit 位的错误，因为 2 个 bit 位的数据错误，其正确计算出来 Parity Bit 的值不变。</strong></p>
<p><strong>Parity Bit 容易实现并且计算起来非常的快，但是因为 Parity Bit 的存在，会为每个 byte 增加一个 bit 的大小</strong></p>
<h3 id="CRCs"><a href="#CRCs" class="headerlink" title="CRCs"></a>CRCs</h3><p>CRCs (Cyclic Redundancy Check) 是网络传输中常用的 Error Detection 算法。可以检测到多个 bit 位的错误。</p>
<h3 id="ECC"><a href="#ECC" class="headerlink" title="ECC"></a>ECC</h3><p>ECC (Error Correction Code) 算法不仅可以检测到数据错误，并且可以尝试恢复数据。</p>
<h2 id="EEPROM"><a href="#EEPROM" class="headerlink" title="EEPROM"></a>EEPROM</h2><p><code>EEPROM(Electrically Erasable Programmable Read-Only Memory)</code> 是主板上的一个 NVM Flash Memory Firmware。</p>
<p>服务器上电运行后启动的第一个程序是 <code>bootstrap loader program</code> （操作系统启动引导程序，如 Linux 中的 <code>grub2</code>，其启动之后会加载操作系统）。RAM 是易失性存储，不能将 <code>bootstrap program</code> 放置到 RAM 中，当下主机会使用 EEPROM 放置 <code>bootstrap program</code>。<code>bootstrap program</code> 可以被修改，但是不能频繁修改，它属于慢速存储，其中包含了不经常会使用的静态程序和数据。比如 iPhone 使用了 EEPROM 存储了设备 <code>serial numbers</code> 和 <code>hardware information</code></p>
<h2 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h2><p><code>RAID (Redundant Arrays of Independent Disks)</code> 。</p>
<h3 id="RAID-0-Striping-Volume"><a href="#RAID-0-Striping-Volume" class="headerlink" title="RAID 0: Striping Volume"></a>RAID 0: Striping Volume</h3><p>RAID 0，Striping Volume，条带卷，在多个存储设备上面，以 Block 为基本单位组成条带（Strip），数据分散写入到每个存储设备的对应的条带上，读取时从多个设备上的对应条带中读取。</p>
<ul>
<li><strong>不提供任何冗余（Redundancy）</strong>，任意存储设备损坏，会导致整个存储系统上的数据损坏</li>
<li><strong>有极高的读写速度</strong>，在多个设备上并发的读写</li>
<li><strong>存储设备利用率 100%</strong></li>
</ul>
<h3 id="RAID-1-Mirrored-Volume"><a href="#RAID-1-Mirrored-Volume" class="headerlink" title="RAID 1: Mirrored Volume"></a>RAID 1: Mirrored Volume</h3><p>由 2 或多块物理存储设备（physical storage device）组成一个逻辑存储设备（logical disk），每次写入数据时，同时写入到 2 个或多个物理存储设备。</p>
<ul>
<li><strong>提供冗余（Redundancy）</strong>，数据同时写入 2 个或多个物理存储设备上，只有在所有数据盘都损坏的情况下数据才会损坏</li>
<li><strong>有极高的读取速度</strong>，可以从每个镜像盘读取数据</li>
<li><strong>数据写入速度降低</strong>，因为要将数据写入多个数据盘，可能会导致写入速度下降</li>
<li><strong>存储设备利用率 50%</strong></li>
</ul>
<h3 id="RAID-4-Block-Interleaved-Parity"><a href="#RAID-4-Block-Interleaved-Parity" class="headerlink" title="RAID 4: Block-Interleaved Parity"></a>RAID 4: Block-Interleaved Parity</h3><p>RAID 4 使用 RAID 0 的 Strip（条带）作为基础，至少需要 3 块数据盘。数据存储以 Block 为单位。</p>
<p>假设由 3 块数据盘组成 RAID 4，数据写入过程如下：</p>
<ol>
<li>写入数据的第一个 block 写入到第 1 块数据盘中，第二个 block 写入到第 2 块数据盘中，对写入第一块盘和第二块盘上的这 2 个 block 做 Error Correcting Code 计算，计算结果存储在第 3 块数据盘中。</li>
<li>第三个 block 继续写入到第 1 块数据盘中，第四个 block 写入到第 2 块数据盘中，对此 2 个 block 做 Error Correcting Code 计算，计算结果存储在第 3 块数据盘中</li>
<li>依次类推，直到数据写入完成。</li>
</ol>
<ul>
<li>其中一块盘存储了 Error Correction Code</li>
<li>假如其中一个数据盘或其上的一个 Block 损坏，那么这块数据可以根据其他盘上的数据和 Error Correction Code 做计算进行恢复</li>
<li><strong>有极高的读写速度</strong>，在多个设备上并发的读写。</li>
<li><strong>存储设备利用率 (N-1)&#x2F;N</strong></li>
</ul>
<h3 id="RAID-5-Block-Interleaved-Distributed-Parity"><a href="#RAID-5-Block-Interleaved-Distributed-Parity" class="headerlink" title="RAID 5: Block-Interleaved Distributed Parity"></a>RAID 5: Block-Interleaved Distributed Parity</h3><p>和 RAID 4 唯一的不同是： <strong>RAID 4 使用一个单独的盘存储了 Error Correction Code（Parity Bit），RAID 5 将 Error Correction Code（Parity Bit）分布存储在所有数据盘上</strong>，通过将 Parity 分布到所有的数据盘上，避免了专用的 Parity Block 的盘压力太大。</p>
<h3 id="RAID-6-P-Q-redundancy-scheme"><a href="#RAID-6-P-Q-redundancy-scheme" class="headerlink" title="RAID 6: P + Q redundancy scheme"></a>RAID 6: P + Q redundancy scheme</h3><p>RAID 6 为每 4 个 Block 保留了 2 个冗余（Redundant）的 Block，使用了更复杂的算法来进行 Error Detect 和 Error Correcting，可以支持 2 块数据盘损坏。</p>
<h3 id="RAID-10"><a href="#RAID-10" class="headerlink" title="RAID 10"></a>RAID 10</h3><p><img src="https://i.csms.tech/img_248.png"><br>RAID 10 的结构：</p>
<ul>
<li>首先将硬盘分成多个镜像组（RAID 1），每个镜像组包含两个或多个硬盘。</li>
<li>然后将这些镜像组组合成一个条带组（RAID 0）。</li>
</ul>
<p>优缺点：</p>
<ul>
<li><p>高数据冗余：每个数据块都有一个镜像副本，因此可以抵抗单个硬盘故障。</p>
</li>
<li><p>高读写性能：通过条带化技术，可以提高读写速度。</p>
</li>
<li><p>成本较高：需要至少四个硬盘，而且有效存储容量只有硬盘总数的一半。</p>
</li>
</ul>
<h3 id="RAID-01"><a href="#RAID-01" class="headerlink" title="RAID 01"></a>RAID 01</h3><p>RAID 01 的结构：</p>
<ul>
<li>首先将硬盘分成多个条带组（RAID 0），每个条带组包含两个或多个硬盘。</li>
<li>然后将这些条带组组合成一个镜像组（RAID 1）。</li>
</ul>
<p>优缺点：</p>
<ul>
<li><p>高读写性能：通过条带化技术，可以提高读写速度。</p>
</li>
<li><p>数据冗余：整个条带组被镜像，因此可以抵抗硬盘故障。</p>
</li>
<li><p>成本较高：需要至少四个硬盘，而且有效存储容量只有硬盘总数的一半。</p>
</li>
<li><p>数据恢复复杂：如果一个硬盘发生故障，整个条带组都需要被重建，恢复时间较长。</p>
</li>
</ul>
<p><strong>RAID 10 和 RAID 01 在单一硬盘故障时的恢复方式基本一致，都是从对应的镜像组恢复数据到故障硬盘。</strong> 在涉及到多个硬盘的故障的情况下，RAID 10 相比 RAID 01 拥有更多的优势：</p>
<ul>
<li>RAID 10 提供了更高的冗余性和恢复灵活性，因为它允许多个独立的镜像组。</li>
<li>RAID 10 可以承受每个镜像组中的一个硬盘故障而不影响整体系统。</li>
<li>RAID 01 在任一条带组中失效的硬盘超过一个时，会导致整个 RAID 组不可用。</li>
</ul>
<h1 id="File-System"><a href="#File-System" class="headerlink" title="File System"></a>File System</h1><p><code>File Systems</code> 为访问（<code>stored</code>、<code>located</code>、<code>retrieve</code>）存储系统（Storage）上存储的文件提供了高效和便利的途径（方式）。文件系统的设计主要涉及到以下问题： <sup id="fnref:10"><a href="#fn:10" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Operating System Concepts v10 Online](https://os.ecci.ucr.ac.cr/slides/Abraham-Silberschatz-Operating-System-Concepts-10th-2018.pdf) 14.1 File-System Structure">[10]</span></a></sup></p>
<ul>
<li>File System 对用户（User）应该如何呈现。包括如何定义文件以及文件属性，允许哪些操作，目录结构是怎样的（如何组织）</li>
<li>使用怎样的算法来创建文件或者目录结构，以及如何将逻辑上的文件（logical files system）和物理存储（硬件）上的内容进行对应</li>
</ul>
<p>File System 通常由多个功能分层（Levels or layers）构成，其中 <strong>下层为上层提供服务，上层利用下层提供的服务来构建文件系统的功能（特性）</strong></p>
<p><img src="https://i.csms.tech/img_258.png"></p>
<p>在如上图所示的分层的文件系统架构中，主要包括以下层：</p>
<ul>
<li><code>I/O control</code> : 主要由存储设备驱动器（Device Drivers）和中断控制器（interrupt handlers）组成。主要功能是在存储设备和主内存之间传输数据。它接受更高层的指令（如 <code>retrieve block 123</code>），并将此指令转换为能被存储设备驱动器识别的针对存储硬件设备的指令。</li>
<li><code>basic file system</code> : 在 Linux 系统中被称为 <code>“block I/O subsystem</code>。这一层的主要功能是将上层的通用的读写 block 的指令发布给正确的存储设备驱动器（device driver）来读写存储设备上的 block。它发送给存储设备驱动器（device driver）的是 <strong>逻辑块地址（Logical block address）</strong>，它还负责 IO request scheduling 以及 buffers 和 caches。</li>
<li><code>file-organization module</code> : 主要存储了文件和他们对应的 <code>logical blocks</code> 的信息。还包括 <code>free-space manager</code>，用来跟踪未分配的 <code>logical blocks</code>，当 <code>file-organization module</code> 需要空闲块时提供空闲的块地址信息。</li>
<li><code>logical file system</code> : 负责管理 <code>metadata</code> 信息。Metadata 信息存储了所有的文件系统结构信息（包括 <strong>目录结构</strong>、<strong>文件名</strong>），只是不包括具体的数据。关键信息包括 FCB (<code>file-controle blocks</code>，即 <code>inode</code>)，存储了文件的具体信息如 <code>owership</code>、<code>permissions</code>、<code>locations of file contents(location of logical blocks)</code>。</li>
</ul>
<h2 id="VFS"><a href="#VFS" class="headerlink" title="VFS"></a>VFS</h2><p>VFS(Virtual File System) 是内核提供的用来抽象（Abstract）各种文件系统类型的接口。VFS 使添加各种新类型的文件系统到内核变得更加的灵活，Programs 可以使用相同的方式访问各种不同类型的文件系统。<br><img src="https://i.csms.tech/img_272.png"></p>
<h2 id="IO-Stack"><a href="#IO-Stack" class="headerlink" title="IO Stack"></a>IO Stack</h2><p>对 <strong>基于存储设备的文件系统（Storage-Device-based Filesystem）</strong> 来说，从应用软件（Application Software）到存储设备（Storage Device）之间的调用路径被成为 <code>I/O Stack</code><br><img src="https://i.csms.tech/img_273.png"></p>
<blockquote>
<p>图中左侧跨过 VFS 和 File System 直接调用块设备（Block Device）的路径一般是管理工具（Administrative）或者 Databases 使用。</p>
</blockquote>
<h2 id="Caching"><a href="#Caching" class="headerlink" title="Caching"></a>Caching</h2><p>硬盘 IO 通常有较高的延迟，文件系统模型又涉及多层，会导致更大的延迟，为了解决这些延迟问题，文件系统和存储设备通常使用 <strong>读写缓存（Caching Reads and Buffering Writes）</strong> <sup id="fnref:12"><a href="#fn:12" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Systems Performance: Enterprise and the Cloud v2](https://s.csms.tech/file/Systems.Performance.Enterprise.and.the.Cloud.2nd.Edition.2020.12.pdf) 3.2.11 Caching
">[12]</span></a></sup></p>
<p>Caching 可能会包括以下部分，这些缓存会自上而下搜索：</p>
<table>
<thead>
<tr>
<th>#</th>
<th>Cache</th>
<th>Examples</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Client Cache</td>
<td>Web browser Cache</td>
</tr>
<tr>
<td>2</td>
<td>Application Cache</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>Web Server Cache</td>
<td>Apache Cache</td>
</tr>
<tr>
<td>4</td>
<td>Caching Server</td>
<td><code>memcached</code></td>
</tr>
<tr>
<td>5</td>
<td>Database Cache</td>
<td>MySQL</td>
</tr>
<tr>
<td>6</td>
<td>Directory Cache</td>
<td><code>dcache</code></td>
</tr>
<tr>
<td>7</td>
<td>File Metadata Cache</td>
<td><code>inode cache</code></td>
</tr>
<tr>
<td>8</td>
<td>Operating System buffer Cache</td>
<td>Buffer Cache</td>
</tr>
<tr>
<td>9</td>
<td>File System Primary Cache</td>
<td>Page Cache, ZFS ARC</td>
</tr>
<tr>
<td>10</td>
<td>File System Secondary Cache</td>
<td>ZFS L2ARC</td>
</tr>
<tr>
<td>11</td>
<td>Device Cache</td>
<td>ZFS vdev</td>
</tr>
<tr>
<td>12</td>
<td>Block Cache</td>
<td>Buffer Cache</td>
</tr>
<tr>
<td>13</td>
<td>Disk Controller Cache</td>
<td>RAID Card Cache</td>
</tr>
<tr>
<td>14</td>
<td>Storage Array Cache</td>
<td></td>
</tr>
<tr>
<td>15</td>
<td>On-disk Cache</td>
<td></td>
</tr>
</tbody></table>
<h2 id="system-wide-open-file-table-And-per-process-open-file-table"><a href="#system-wide-open-file-table-And-per-process-open-file-table" class="headerlink" title="system-wide open-file table And per-process open-file table"></a>system-wide open-file table And per-process open-file table</h2><p>大多数操作系统再打开并使用文件之前，都需要（implicitly or explicitly）系统调用 <code>open()</code>，操作系统维护了一个 <code>open-file table</code>，维护着所有的打开文件的信息。当一个文件操作（如读，写，执行等）被请求前，系统调用 <code>open()</code>，文件会通过一个 <code>index</code> 被加入到 <code>open-file table</code>，当文件不在使用时，<code>open-file table</code> 中关于此文件的条目（<code>index</code>） 被移除。</p>
<p>系统中维护了 2 中类别的 <code>open-file table</code>:</p>
<ul>
<li><code>per-process open-file table</code> : 跟踪进程打开的文件列表，此表中的列表实际是指向 <code>system-wide open-file table</code> 中相关条目（entry）的指针（pointer）。</li>
<li><code>system-wide open-file table</code> ： 维护了系统上所有的打开的文件信息，保存了如 <strong>文件路径</strong>、<strong>文件大小</strong>、<strong>文件时间属性（access time 等）</strong>、<code>open count</code> 等信息，当一个进程打开一个文件后，<code>system-wide open-file table</code> 中就会添加一个此文件相关的条目，当另一个进程打开同样的文件后，进程的 <code>per-process open-file table</code> 中只是会添加一条到 <code>system-wide open-file table</code> 中对应文件的引用（entry）。<code>system-wide open-file table</code> 中的每个条目还维护了一个 <code>open count</code>，记录了有多少进程打开了此文件，当某个进程关闭此文件后，其 <code>open count</code> 会减少，值为 <code>0</code> 时，表示没有任何进程打开了此文件，此条目可以从 <code>system-wide open-file table</code> 中移除。</li>
</ul>
<p><strong><code>system-wide open-file table</code> 里面关于文件的信息，保存的主要是 FCB 的拷贝（Copy）</strong></p>
<p><strong><code>per-process open-file table</code> 里面存储的主要是到 <code>system-wide open-file table</code> 里面的对应文件的指针（pointers）</strong></p>
<p><strong>Linux 系统中要查看 <code>open-file table</code> 相关信息，可以使用 <code>lsof</code>、<code>fuser</code>、<code>/proc/&lt;pid&gt;/fd/</code> 等方法。</strong></p>
<h1 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h1><h2 id="Encryption"><a href="#Encryption" class="headerlink" title="Encryption"></a>Encryption</h2><h3 id="Symmetric-Encryption"><a href="#Symmetric-Encryption" class="headerlink" title="Symmetric Encryption"></a>Symmetric Encryption</h3><p>在 <strong>对称加密算法(Symmetric Encryption)</strong> 中，加密和解密使用同样的密钥（Key）</p>
<h1 id="Glossary"><a href="#Glossary" class="headerlink" title="Glossary"></a>Glossary</h1><p><code>GNU</code>： GNU’s Not Unix，Richard Stallman 于 1984 年开始开发的自由（free）的类 Unix 操作系统。包括编译器、编辑器、库文件、游戏等应用，没有内核。</p>
<p><code>GNU/Linux</code>： 1991 年，Linus Torvalds 发布了最初版类 Unix 操作系统内核，并使用了 GNU 提供的编译器和工具。</p>
<p><code>FSF</code>: Free Software Foundation，自由软件基金会，由 Richard Stallman 于 1985 年成立，旨在鼓励和推动自由软件的使用和开发。<strong>自由不等于免费</strong></p>
<p><code>GPL</code>： GNU General Public License。</p>
<p><code>ELF</code>: Executable and Linkable Format.</p>
<p><code>ABI</code> : Application Binary Interface. ABI 定义了在不同架构以及不同的操作系统中，一个二进制代码（Binary Code）提供的接口的差异性。ABI 定义了二进制代码的底层细节，如地址宽度、向系统调用（system calls）提供参数的方法、运行时的堆栈（stack）的组织方式、系统库的二进制格式、数据类型等信息。ABI 是架构级别（architecture-level）的定义，如果一个二进制文件是根据特点的架构（如 ARMv8 processor）编译（链接）而成，那将他迁移到支持此 ABI 的另外的系统上，理论上它也可以正常运行。<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Operating System Concepts v10 Online](https://os.ecci.ucr.ac.cr/slides/Abraham-Silberschatz-Operating-System-Concepts-10th-2018.pdf) 2.6 Why Applications Are Operating-System Specific">[3]</span></a></sup></p>
<p><code>RTE</code> : Run Time Environment. </p>
<p><code>LKMs</code> : Loadable Kernel Modules. </p>
<p><code>Darwin</code> : iOS&#x2F;MacOS 底层的类 Unix 操作系统，主要基于 BSD UNIX 的 microkernel</p>
<p><code>IPC</code> : Inter-Process Communication.</p>
<p><code>RPCs</code> : Remote Procedure Calls.</p>
<p><code>JNI</code> : Java Native Interface.</p>
<p><code>HAL</code> : Hardware Abstraction Layer.</p>
<p><code>UEFI</code> : Unified Extensible Firmware Interface. 最新的硬件初始化程序，用于取代 BIOS</p>
<p><code>initramfs</code> : 在系统启动过程中（Bootstrap Program 运行过程，比如 GRUB），因为根文件系统（<code>root file system</code>）还未挂载，为了挂载根文件系统，必须加载必要的驱动程序和内核模块，boot loader 会创建一个临时 RAM 文件系统，即 <code>initramfs</code>。一旦内核开始运行，必要的驱动已经安装，内核会将根文件系统从 <code>initramfs</code> 切换到已经挂载的根文件系统。然后启动 <code>systemd</code> 进程。</p>
<p><code>CMT</code> : Chip MultiThreading. 一个物理 CPU 核上实现了双线程或多线程的支持。在一个 CPU 线程因等待内存加载数据而空闲（Memory Stall）时，另一个 CPU 线程开始执行。每个 CPU 线程拥有自己独立的状态数据（architectural state）、指令指针（instruction pointer）、注册器（regester set）等，可以将其当作一个单独的逻辑 CPU 来运行单独的线程（进程&#x2F;Job）。如 Intel 的超线程（hyper-threading）或者叫 SMT（Simultaneous Multi-Threading）</p>
<p><code>CFS</code> : Completely Fail Scheduler。Linux kernel 2.6.23 版本开始默认的 CPU 调度算法。</p>
<p><code>MMU</code> : Memory Management Unit.</p>
<p><code>HDD</code> : Hard Disk Driver.</p>
<p><code>SSD</code> : Solid State Disk.</p>
<p><code>ATA</code> : Advanced Technology Attachment. 存储设备接口协议</p>
<p><code>SATA</code> : Serial ATA. 存储设备接口协议</p>
<p><code>SAS</code> : Serial Attached SCSI. 存储设备接口协议</p>
<p><code>USB</code> : Universal Serial Bus. 存储设备接口协议</p>
<p><code>FC</code> : Fibre Channel. 存储设备接口协议</p>
<p><code>NVMe</code> : NVM express. NVM 存储设备专用的通信接口协议。NVM 设备通过 NVMe 接口协议直接连接在系统 PCI 总线上。 相比其他存储接口协议（如 SATA 、SAS 等）增加了吞吐量及减少了延迟。</p>
<p><code>HBA</code> : Host Bus Adapter.</p>
<p><code>HAS</code> : Host Attached Storage. </p>
<p><code>NAS</code> : Network Attached Storage. 存储设备接口协议，使用基于 TCP&#x2F;IP 的 RPC 实现，如 NFS</p>
<p><code>FC</code> : Fibre Channel，光纤通道，存储设备接口协议</p>
<p><code>SANs</code> : Storage Area Networks. 使用基于 TCP&#x2F;IP 的 RPC 实现</p>
<p><code>RAIDs</code> : Redundant Arrays of Independent Disks.</p>
<p><code>DES</code> : Data Encryption Standard.</p>
<p><code>AES</code> : Advanced Encryption Standard</p>
<p><code>IKE</code> : Internet Key Exchange.</p>
<p><code>TLS</code> : Transport Layer Security.  SSL 的升级版</p>
<p><code>SSL</code> : Secure Sockets Layer.</p>
<p><code>MAC</code> ： Mandatory Access Control. Linux 系统中，是 SELinux 的一部分。</p>
<p><code>DAC</code> ： Discretionary Access Control. UNIX-based 系统上使用的权限控制策略（<code>chmod</code>、<code>chown</code>、<code>chgrp</code>）</p>
<p><code>PAM</code> : Pluggable Authentication Modules. UNIX-based 系统上使用的用户鉴权模块</p>
<p><code>BSD</code> : Berkeley Software Distribution. 第一个 Unix 发行版，由 California Berkeley 大学发行</p>
<p><code>FSF</code> ： Free Software Foundation, 自由软件基金会，由 理查德斯托曼 于 1984 年发起的开源运动，GNU 是其主要的一部分</p>
<p><code>IPIs</code> : Inter-Processor Interrupt, 也叫 <code>SMP Call</code> 或者 <code>CPU Cross Call</code>。在 SMP CPU 架构中，多个 CPU 可能需要相互协同工作，某个 CPU 需要其他一个或多个 CPU 执行某个操作，此时需要使用 IPS 通知其他 CPU</p>
<h1 id="参考链接-Bibliography"><a href="#参考链接-Bibliography" class="headerlink" title="参考链接|Bibliography"></a>参考链接|Bibliography</h1><p><a target="_blank" rel="noopener" href="https://os.ecci.ucr.ac.cr/slides/Abraham-Silberschatz-Operating-System-Concepts-10th-2018.pdf">Operating System Concepts v10 Online</a><br><a target="_blank" rel="noopener" href="https://s.csms.tech/file/Systems.Performance.Enterprise.and.the.Cloud.2nd.Edition.2020.12.pdf">Systems Performance: Enterprise and the Cloud v2</a></p>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a target="_blank" rel="noopener" href="https://os.ecci.ucr.ac.cr/slides/Abraham-Silberschatz-Operating-System-Concepts-10th-2018.pdf">Operating System Concepts v10 Online</a> 1.2.3 I/O Structure<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a target="_blank" rel="noopener" href="https://os.ecci.ucr.ac.cr/slides/Abraham-Silberschatz-Operating-System-Concepts-10th-2018.pdf">Operating System Concepts v10 Online</a> 1.3.2 Multiprocessor Systems<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a target="_blank" rel="noopener" href="https://os.ecci.ucr.ac.cr/slides/Abraham-Silberschatz-Operating-System-Concepts-10th-2018.pdf">Operating System Concepts v10 Online</a> 2.6 Why Applications Are Operating-System Specific<a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a target="_blank" rel="noopener" href="https://os.ecci.ucr.ac.cr/slides/Abraham-Silberschatz-Operating-System-Concepts-10th-2018.pdf">Operating System Concepts v10 Online</a> CHAPTER 5 CPU Scheduling<a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a target="_blank" rel="noopener" href="https://os.ecci.ucr.ac.cr/slides/Abraham-Silberschatz-Operating-System-Concepts-10th-2018.pdf">Operating System Concepts v10 Online</a> 5.5.4 Processor Affinity<a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a target="_blank" rel="noopener" href="https://os.ecci.ucr.ac.cr/slides/Abraham-Silberschatz-Operating-System-Concepts-10th-2018.pdf">Operating System Concepts v10 Online</a> 9.1.5 Dynamic Linking and Shared Libraries<a href="#fnref:6" rev="footnote"> ↩</a></span></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a target="_blank" rel="noopener" href="https://os.ecci.ucr.ac.cr/slides/Abraham-Silberschatz-Operating-System-Concepts-10th-2018.pdf">Operating System Concepts v10 Online</a> CHAPTER 10 Virtual Memory<a href="#fnref:7" rev="footnote"> ↩</a></span></li><li id="fn:8"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">8.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a target="_blank" rel="noopener" href="https://os.ecci.ucr.ac.cr/slides/Abraham-Silberschatz-Operating-System-Concepts-10th-2018.pdf">Operating System Concepts v10 Online</a> 10.8 Allocating Kernel Memory<a href="#fnref:8" rev="footnote"> ↩</a></span></li><li id="fn:9"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">9.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a target="_blank" rel="noopener" href="https://os.ecci.ucr.ac.cr/slides/Abraham-Silberschatz-Operating-System-Concepts-10th-2018.pdf">Operating System Concepts v10 Online</a> 11.1.1 Hard Disk Drives<a href="#fnref:9" rev="footnote"> ↩</a></span></li><li id="fn:10"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">10.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a target="_blank" rel="noopener" href="https://os.ecci.ucr.ac.cr/slides/Abraham-Silberschatz-Operating-System-Concepts-10th-2018.pdf">Operating System Concepts v10 Online</a> 14.1 File-System Structure<a href="#fnref:10" rev="footnote"> ↩</a></span></li><li id="fn:11"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">11.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a target="_blank" rel="noopener" href="https://s.csms.tech/file/Systems.Performance.Enterprise.and.the.Cloud.2nd.Edition.2020.12.pdf">Systems Performance: Enterprise and the Cloud v2</a> 3.2.6 Processes<a href="#fnref:11" rev="footnote"> ↩</a></span></li><li id="fn:12"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">12.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a target="_blank" rel="noopener" href="https://s.csms.tech/file/Systems.Performance.Enterprise.and.the.Cloud.2nd.Edition.2020.12.pdf">Systems Performance: Enterprise and the Cloud v2</a> 3.2.11 Caching<a href="#fnref:12" rev="footnote"> ↩</a></span></li></ol></div></div>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="../tags/Linux/" rel="tag"><i class="fa fa-tag"></i> Linux</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="../202405281728/" rel="prev" title="笔记">
                  <i class="fa fa-chevron-left"></i> 笔记
                </a>
            </div>
            <div class="post-nav-item">
                <a href="../202406141646/" rel="next" title="python set 用法">
                  python set 用法 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">COSMOS</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.3" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="../js/comments.js"></script><script src="../js/utils.js"></script><script src="../js/motion.js"></script><script src="../js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="../js/third-party/search/local-search.js"></script>




  <script src="../js/third-party/pace.js"></script>

  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"fl9999","repo":"fl9999.github.io","client_id":"a11bf6f7860762b725b5","client_secret":"a99046105f8bddc72ec718d54dc3fd7f22070821","admin_user":"fl9999","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":null,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"d41d8cd98f00b204e9800998ecf8427e"}</script>
<script src="../js/third-party/comments/gitalk.js"></script>

</body>
</html>
