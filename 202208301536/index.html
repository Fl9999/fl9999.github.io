<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="../images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="../images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="../images/favicon-16x16-next.png">
  <link rel="mask-icon" href="../images/logo.svg" color="#222">

<link rel="stylesheet" href="../css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"csms.tech","root":"/","images":"../images","scheme":"Gemini","darkmode":true,"version":"8.14.2","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeIn","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"../search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="../js/config.js"></script>

    <meta name="description" content="环境信息 Centos 7.9.2009 docker-ce-19.03.15  Docker 网络模式Bridge 模式bridge 模式是 docker 的默认网络模式，不使用 --network 参数，就是 bridge 模式。 当 Docker 进程启动时，会在主机上创建一个名为 docker0 的虚拟网桥，默认主机上启动的 Docker 容器会连接到这个虚拟网桥上。 容器启动时，dock">
<meta property="og:type" content="article">
<meta property="og:title" content="docker 网络">
<meta property="og:url" content="http://csms.tech/202208301536/index.html">
<meta property="og:site_name" content="L B T">
<meta property="og:description" content="环境信息 Centos 7.9.2009 docker-ce-19.03.15  Docker 网络模式Bridge 模式bridge 模式是 docker 的默认网络模式，不使用 --network 参数，就是 bridge 模式。 当 Docker 进程启动时，会在主机上创建一个名为 docker0 的虚拟网桥，默认主机上启动的 Docker 容器会连接到这个虚拟网桥上。 容器启动时，dock">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-08-30T07:36:14.000Z">
<meta property="article:modified_time" content="2024-09-10T09:09:00.000Z">
<meta property="article:author" content="COSMOS">
<meta property="article:tag" content="Docker">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://csms.tech/202208301536/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://csms.tech/202208301536/","path":"202208301536/","title":"docker 网络"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>docker 网络 | L B T</title>
  








  <noscript>
    <link rel="stylesheet" href="../css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">L B T</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">记 录 过 去 的 经 验</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="../index.html" rel="section"><i class="fa fa-earth-americas fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="../categories/" rel="section"><i class="fa fa-folder-tree fa-fw"></i>总目录<span class="badge">49</span></a></li><li class="menu-item menu-item-linux"><a href="../categories/Linux" rel="section"><i class="fa fa-brands fa-linux fa-fw"></i>Linux</a></li><li class="menu-item menu-item-python"><a href="../categories/Python" rel="section"><i class="fa fa-brands fa-python fa-fw"></i>Python</a></li><li class="menu-item menu-item-docker"><a href="../categories/Docker" rel="section"><i class="fa fa-brands fa-docker fa-fw"></i>Docker</a></li><li class="menu-item menu-item-kubernetes"><a href="../categories/Kubernetes" rel="section"><i class="fa fa-dharmachakra fa-fw"></i>Kubernetes</a></li><li class="menu-item menu-item-tags"><a href="../tags/" rel="section"><i class="fa fa-tornado fa-fw"></i>标签<span class="badge">78</span></a></li><li class="menu-item menu-item-archives"><a href="../archives/" rel="section"><i class="fa fa-rectangle-list fa-fw"></i>列表<span class="badge">227</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章总目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E4%BF%A1%E6%81%AF"><span class="nav-number">1.</span> <span class="nav-text">环境信息</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Docker-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.</span> <span class="nav-text">Docker 网络模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Bridge-%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.1.</span> <span class="nav-text">Bridge 模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Host-%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.2.</span> <span class="nav-text">Host 模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#None-%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.3.</span> <span class="nav-text">None 模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Container-%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.4.</span> <span class="nav-text">Container 模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Macvlan-%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.5.</span> <span class="nav-text">Macvlan 模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ipvlan-%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.6.</span> <span class="nav-text">ipvlan  模式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E7%BB%84%E7%BD%91%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.</span> <span class="nav-text">容器网络组网类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#overlay-%E7%BD%91%E7%BB%9C"><span class="nav-number">3.1.</span> <span class="nav-text">overlay 网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#L2-overlay"><span class="nav-number">3.1.1.</span> <span class="nav-text">L2 overlay</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#L3-overlay"><span class="nav-number">3.1.2.</span> <span class="nav-text">L3 overlay</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#underlay-%E7%BD%91%E7%BB%9C"><span class="nav-number">3.2.</span> <span class="nav-text">underlay 网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#L2-underlay"><span class="nav-number">3.2.1.</span> <span class="nav-text">L2 underlay</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#L3-underlay"><span class="nav-number">3.2.2.</span> <span class="nav-text">L3 underlay</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E4%BA%92%E8%81%94"><span class="nav-number">4.</span> <span class="nav-text">容器互联</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Docker-DNS-%E6%9C%8D%E5%8A%A1"><span class="nav-number">5.</span> <span class="nav-text">Docker DNS 服务</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Docker-%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="nav-number">6.</span> <span class="nav-text">Docker 网络相关问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%BD%8D-Docker-%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E7%BD%91%E5%8D%A1%E5%92%8C%E5%AE%BF%E4%B8%BB%E6%9C%BA%E4%B8%8A%E9%9D%A2%E7%9A%84-veth-%E7%9A%84-pair-%E5%85%B3%E7%B3%BB"><span class="nav-number">6.1.</span> <span class="nav-text">定位 Docker 容器中的网卡和宿主机上面的 veth 的 pair 关系</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95-1"><span class="nav-number">6.1.1.</span> <span class="nav-text">方法 1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95-2"><span class="nav-number">6.1.2.</span> <span class="nav-text">方法 2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95-3"><span class="nav-number">6.1.3.</span> <span class="nav-text">方法 3</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="nav-number">7.</span> <span class="nav-text">参考链接</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%84%9A%E6%B3%A8"><span class="nav-number">8.</span> <span class="nav-text">脚注</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">COSMOS</p>
  <div class="site-description" itemprop="description">得 能 莫 忘</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="../archives/">
          <span class="site-state-item-count">227</span>
          <span class="site-state-item-name">文章</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="../categories/">
        <span class="site-state-item-count">49</span>
        <span class="site-state-item-name">目录</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="../tags/">
        <span class="site-state-item-count">78</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://csms.tech/202208301536/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="../images/avatar.gif">
      <meta itemprop="name" content="COSMOS">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="L B T">
      <meta itemprop="description" content="得 能 莫 忘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="docker 网络 | L B T">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          docker 网络
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-30 15:36:14" itemprop="dateCreated datePublished" datetime="2022-08-30T15:36:14+08:00">2022-08-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-09-10 17:09:00" itemprop="dateModified" datetime="2024-09-10T17:09:00+08:00">2024-09-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">上层目录</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="../categories/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>Centos 7.9.2009</li>
<li>docker-ce-19.03.15</li>
</ul>
<h1 id="Docker-网络模式"><a href="#Docker-网络模式" class="headerlink" title="Docker 网络模式"></a>Docker 网络模式</h1><h2 id="Bridge-模式"><a href="#Bridge-模式" class="headerlink" title="Bridge 模式"></a>Bridge 模式</h2><p>bridge 模式是 docker 的默认网络模式，不使用 <code>--network</code> 参数，就是 bridge 模式。</p>
<p>当 Docker 进程启动时，会在主机上创建一个名为 docker0 的虚拟网桥，默认主机上启动的 Docker 容器会连接到这个虚拟网桥上。</p>
<p>容器启动时，docker 会从 docker0 网桥的子网中分配一个 IP 地址给容器中的网卡。大体流程为在主机上创建一个 <a href="/202304251611/" title="&#96;veth pair&#96;">&#96;veth pair&#96;</a>，Docker 将 <code>veth pair</code> 的一端放在容器中，命名为 <code>eth0</code> 并配置 IP，网关，路由等信息，将 <code>veth pair</code> 的另一端加入 docker0 网桥。</p>
<p><strong>通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。</strong></p>
<h2 id="Host-模式"><a href="#Host-模式" class="headerlink" title="Host 模式"></a>Host 模式</h2><p><strong>如果启动容器的时候使用 host 模式，那么这个容器将不会获得一个独立的 Network Namespace，而是和宿主机一样在 Root Network Namespace，容器中看到的网络方面的信息和宿主机一样，容器使用的网络资源在整个 Root Network Namespace 不能出现冲突</strong>。容器将不会虚拟出自己的网卡，配置自己的 IP 等，而是使用宿主机的 IP 和端口，主机名也是使用宿主机的。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。</p>
<p><strong>host 模式下的容器可以看到宿主机上的所有网卡信息，可以直接使用宿主机 IP 或主机名与外界通信，无需额外的 NAT，也无需通过 Linux bridge 进行转发或者数据包的封装，可以访问主机上的其他任一容器</strong>。</p>
<p>使用如下命令参数启动 host 网络模式的容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --network host --name test1 -p 80:80 -d -it centos:centos7.9.2009</span><br></pre></td></tr></table></figure>
<p>host 模式的容器，没有自己的 network namespace，在 root network namespace 中。进入测试容器 <code>test1</code>，查看网卡、 IP 信息及端口、主机名信息，会看到和宿主机一样的信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip <span class="built_in">link</span></span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 00:0c:29:e7:c0:27 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN mode DEFAULT group default </span><br><span class="line">    link/ether 02:42:f2:1b:dc:ea brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip add</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    link/ether 00:0c:29:e7:c0:27 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.142.10/24 brd 192.168.142.255 scope global noprefixroute ens33</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::20c:29ff:fee7:c027/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default </span><br><span class="line">    link/ether 02:42:f2:1b:dc:ea brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0</span><br><span class="line">       valid_lft forever preferred_lft forever    </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">[root@test1 /]<span class="comment"># netstat -anutp</span></span></span><br><span class="line">Active Internet connections (servers and established)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      -                   </span><br><span class="line">tcp        0      0 0.0.0.0:81              0.0.0.0:*               LISTEN      124/nginx: master p </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      -                   </span><br><span class="line">tcp        0     36 192.168.142.10:22       192.168.142.1:61396     ESTABLISHED -                   </span><br><span class="line">tcp6       0      0 :::80                   :::*                    LISTEN      -                   </span><br><span class="line">tcp6       0      0 :::81                   :::*                    LISTEN      124/nginx: master p </span><br><span class="line">tcp6       0      0 :::22                   :::*                    LISTEN      -          </span><br></pre></td></tr></table></figure>

<p><strong>host 模式的缺点</strong></p>
<ul>
<li>容器没有自己的 <code>network namespace</code> ，网络和宿主机或其他使用 <code>host</code> 模式的容器未隔离，容易出现资源冲突，比如同一个宿主机上，使用 <code>host</code> 模式的容器中启动的端口不能相同。</li>
</ul>
<h2 id="None-模式"><a href="#None-模式" class="headerlink" title="None 模式"></a>None 模式</h2><p>使用 <code>none</code> 模式，Docker 容器拥有自己的 <code>Network Namespace</code>，但是，系统并不为 Docker 容器进行任何网络配置。也就是说，这个 Docker 容器没有网卡（<code>lo</code> 回环网卡除外）、IP、路由等信息。需要我们自己为 Docker 容器添加网卡、配置 IP 等。</p>
<p>参考以下命令创建 <code>none</code> 模式的容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --network none --name test-none -p 82:80 -d -it centos7:my</span><br></pre></td></tr></table></figure>
<p>容器创建后，进入容器中，查看网卡和 IP 等信息，容器中默认只存在 <code>lo</code> 网卡，不存在其他网卡</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip add</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">       </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip <span class="built_in">link</span></span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00       </span><br></pre></td></tr></table></figure>
<p>以下操作演示手动为容器配置网络</p>
<ol>
<li><p>创建 <code>veth pair</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip link add veth0 type veth peer name veth0_p</span><br></pre></td></tr></table></figure></li>
<li><p>将 <code>veth pair</code> 的一端 <code>veth0</code> 放入 docker 默认的网桥 <code>docker0</code>，另一端 <code>veth0_p</code> 放入容器中</p>
<p>首先使用命令 <code>docker inspect test-none | grep &quot;Pid&quot;</code> 找到容器对应的 PID，此处为 84040，根据此 PID 将 veth 的一端放入容器的 network namespace 中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip link set dev veth0 master docker0</span><br><span class="line"></span><br><span class="line">ip link set dev veth0 up</span><br><span class="line"></span><br><span class="line">ip link set veth0_p netns 84040</span><br></pre></td></tr></table></figure>
<p>在宿主机上面检查 <code>veth0</code>，确定其已经加入网桥 <code>docker0</code>，并且 <code>veth0_p</code> 已不在 <code>root network namespace</code> 中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip <span class="built_in">link</span></span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 00:0c:29:e7:c0:27 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN mode DEFAULT group default </span><br><span class="line">    link/ether 02:42:f2:1b:dc:ea brd ff:ff:ff:ff:ff:ff</span><br><span class="line">12: veth0@if11: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue master docker0 state LOWERLAYERDOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 16:7f:98:d8:9d:dc brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br></pre></td></tr></table></figure>
<p>重新进入容器，检查网卡信息，可以看到容器中已经有了网卡 <code>veth0_p</code>，状态为 <code>DOWN</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip -d <span class="built_in">link</span></span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 promiscuity 0 addrgenmode eui64 numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535 </span><br><span class="line">11: veth0_p@if12: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether be:f1:94:9f:b8:c9 brd ff:ff:ff:ff:ff:ff link-netnsid 0 promiscuity 0 </span><br><span class="line">    veth addrgenmode eui64 numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535</span><br></pre></td></tr></table></figure>
</li>
<li><p>为容器中的网卡配置 IP 及网关等信息</p>
<p>为了能在宿主机对容器的 <code>network namespace</code> 进行操作，首先需要将容器的 <code>network namespace</code> 暴露出来，之后可以在宿主机通过 <code>network namespace</code> 名称(此处为 84040，可以自定义)操作 <code>network namespace</code> 。<a href="/202304031317/" title="Linux network namespace 参考">Linux network namespace 参考</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ln</span> -s /proc/84040/ns/net /var/run/netns/84040</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip netns <span class="built_in">ls</span></span></span><br><span class="line">84040 (id: 0)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过 <code>network namespace</code> 名称(此处为 84040)配置容器中网卡的 IP 地址信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip netns exec 84040 ip link set dev veth0_p name eth0</span><br><span class="line">ip netns exec 84040 ip link set dev eth0 up</span><br><span class="line"></span><br><span class="line">ip netns exec 84040 ip add add 172.17.0.10/16 dev eth0</span><br><span class="line"></span><br><span class="line">ip netns exec 84040 ip route add default via 172.17.0.1</span><br></pre></td></tr></table></figure>
<p>进入容器检查网络信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip add</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">15: eth0@if16: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000</span><br><span class="line">    link/ether 7e:36:b3:20:a1:8c brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.17.0.10/16 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">       </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip route show</span></span><br><span class="line">default via 172.17.0.1 dev eth0 </span><br><span class="line">172.17.0.0/16 dev eth0 proto kernel scope link src 172.17.0.10       </span><br></pre></td></tr></table></figure>

<p>进入容器测试网络连接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ping 8.8.8.8</span></span><br><span class="line">PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data.</span><br><span class="line">64 bytes from 8.8.8.8: icmp_seq=1 ttl=127 time=37.4 ms</span><br><span class="line">64 bytes from 8.8.8.8: icmp_seq=2 ttl=127 time=37.0 ms</span><br><span class="line">^C</span><br><span class="line">--- 8.8.8.8 ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 1000ms</span><br><span class="line">rtt min/avg/max/mdev = 37.047/37.234/37.422/0.269 ms</span><br></pre></td></tr></table></figure></li>
</ol>
<span id="more"></span>

<h2 id="Container-模式"><a href="#Container-模式" class="headerlink" title="Container 模式"></a>Container 模式</h2><p>在创建容器时通过参数 <code>--network container:已运行的容器名称|ID</code> 指定，处于这个模式下的 Docker 容器会共享一个网络栈，这样两个容器之间可以使用 localhost 高效快速通信。<br>Container 网络模式即新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围、主机名等。同样两个容器除了网络方面相同之外，其他的如文件系统、进程列表等还是隔离的。</p>
<blockquote>
<p>Kubernetes 的 POD 网络采用的就是 Docker 的 container 模式网络。</p>
</blockquote>
<h2 id="Macvlan-模式"><a href="#Macvlan-模式" class="headerlink" title="Macvlan 模式"></a>Macvlan 模式</h2><a href="/202304251611/" title="linux macvlan 网卡虚拟化技术">linux macvlan 网卡虚拟化技术</a>

<h2 id="ipvlan-模式"><a href="#ipvlan-模式" class="headerlink" title="ipvlan  模式"></a>ipvlan  模式</h2><p><a target="_blank" rel="noopener" href="https://blog.gazer.win/essay/connect-container-networks-to-physical-networks.html">IPVLAN&#x2F;MACVLAN 实现 Docker 和物理局域网络真正互联互通</a></p>
<h1 id="容器网络组网类型"><a href="#容器网络组网类型" class="headerlink" title="容器网络组网类型"></a>容器网络组网类型</h1><p>常见的非主机网络（<code>host network</code>）的容器组网类型有 L2 overlay、L3 overlay、L2 underlay、L3 underlay。</p>
<h2 id="overlay-网络"><a href="#overlay-网络" class="headerlink" title="overlay 网络"></a>overlay 网络</h2><p><code>overlay</code> 网络，也称为隧道网络或覆盖网络。</p>
<p><code>overlay</code> 网络是在传统网络（数据链路层、网络层）上虚拟出一个虚拟网络，承载虚拟网络的底层传统网络不再需要进行任何适配和变更。在容器的世界了，底层物理网络只需要承载主机的网络通信，虚拟网络只承载容器网络通信。</p>
<p><code>overlay</code> 网络的任何协议都要求发送方对报文进行封装（在虚拟网络报文的头部添加底层物理网络的地址信息，以将报文传输到容器所在的节点），接收方对报文进行解封装，使用 UDP 进行封装时，性能损失在 50% 以上，使用 VXLAN 也会有 20%-30% 的损耗。</p>
<p><code>overlay</code> 网络最大的优点是<strong>适用于几乎所有的网络基础架构，唯一要求是主机 IP 互通</strong>，问题是随着规模的增长，复杂度会随之增加，封包和解封包性能损坏较大且难于定位问题。</p>
<h3 id="L2-overlay"><a href="#L2-overlay" class="headerlink" title="L2 overlay"></a>L2 overlay</h3><p>传统的 L2 网络，通信双方在同一个逻辑网段内，如 <code>172.17.1.10/16</code> 和 <code>172.17.2.10/16</code></p>
<p><code>L2 overlay</code> 是构建在底层物理网络之上的 L2 网络，相较于传统的 L2 网络，<code>L2 overlay</code> 是个 <code>大二层</code>（可以跨越多个数据中心，即可以跨 L3 underlay 进行 L2 通信）。</p>
<p>VXLAN 就是 <code>L2 overlay</code> 网络的典型实现，其通过在 UDP 包中封装原始的 L2 报文，实现了容器的跨主机通信。</p>
<p><code>L2 overlay</code> 网络的容器可以在任意的宿主机间迁移而不改变其 IP 地址，这种特性使得构建在大二层 overlay 网络上的容器在动态迁移时具有很高的灵活性。</p>
<h3 id="L3-overlay"><a href="#L3-overlay" class="headerlink" title="L3 overlay"></a>L3 overlay</h3><p><code>L2 overlay</code> 类似于 <code>L2 overlay</code>，但会在节点上增加个网关，每个节点上的容器都在同一个子网内，可以直接进行二层通信。跨接点间的通信只能通过 L3，都会经过网关转发，性能相比于 L2 overlay 弱。优点是跨节点通信的容器可以在不同的网段。</p>
<p><code>flannel</code> 的 UDP 模式采用的就是 <code>L3 overlay</code> 模式。</p>
<h2 id="underlay-网络"><a href="#underlay-网络" class="headerlink" title="underlay 网络"></a>underlay 网络</h2><p><code>underlay</code> 网络通常指底层网络，即传统的网络组网，主要要来区别于 <code>overlay</code> 网络。</p>
<h3 id="L2-underlay"><a href="#L2-underlay" class="headerlink" title="L2 underlay"></a>L2 underlay</h3><p>指传统的二层网络。 <code>ipvlan</code> 的 L2 模式属于 <code>L2 underlay</code> 类型的网络</p>
<h3 id="L3-underlay"><a href="#L3-underlay" class="headerlink" title="L3 underlay"></a>L3 underlay</h3><p>指传统的三层网络。</p>
<p><code>ipvlan</code> 的 L3 模式、<code>flannel</code> 的 <code>host-gw</code> 模式和 Calico 的 BGP 组网都是 L3 underlay 类型的网络</p>
<h1 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h1><p>为了使容器互联，新版本建议将容器加入自定义的<code> Docker 网络</code> 来连接多个容器，而不是使用 <code>--link</code> 参数。</p>
<p>从 Docker 1.10 版本开始，<code>docker daemon</code> 实现了一个内嵌的 DNS server，使容器可以直接通过容器名称通信。方法很简单，只要在创建容器时使用 <code>--name</code> 为容器命名即可。但是使用 Docker DNS 有个限制：只能在 <code>user-defined</code> 网络中使用。也就是说，默认的 <code>bridge</code> 网络是无法使用 DNS 的，所以我们就需要自定义网络。</p>
<p>先创建一个新的 <code>Docker 网络</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker network create -d bridge my-net</span><br></pre></td></tr></table></figure>
<p><code>-d</code> 参数指定 Docker 网络类型，可选 <code>bridge</code> <code>overlay</code>  </p>
<p>查看 <code>Docker network</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker network <span class="built_in">ls</span></span></span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">1c751b3a52b9   bridge    bridge    local</span><br><span class="line">f8d9861e5797   host      host      local</span><br><span class="line">2e19366fb323   my-net    bridge    local</span><br><span class="line">4c188c59ff20   none      null      local</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>新建容器并连接到刚刚新建的 <code>Docker network</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -it --name c1 --network my-net centos</span><br><span class="line">docker run -d -it --name c2 --network my-net centos</span><br></pre></td></tr></table></figure>
<p>以上命令运行了 2 个 <code>centos</code> 最新版本的容器，并连接到了刚刚创建的网络： <code>--network my-net </code><br>登录到容器 <code>c1</code>的终端，并 <code>ping</code> 容器 <code>c2</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">exec</span> -it c1 bash</span></span><br><span class="line">[root@e520d1c8e30b /]# ping c2</span><br><span class="line">PING c2 (172.18.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from c2.my-net (172.18.0.3): icmp_seq=1 ttl=64 time=0.115 ms</span><br><span class="line">64 bytes from c2.my-net (172.18.0.3): icmp_seq=2 ttl=64 time=0.071 ms</span><br><span class="line">^C</span><br><span class="line">--- c2 ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 1000ms</span><br><span class="line">rtt min/avg/max/mdev = 0.071/0.093/0.115/0.022 ms</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，容器 <code>c1</code> 可以直接使用容器名 <code>c2</code>，来识别容器 <code>c2</code>，同理，容器 <code>c2</code> 也可以使用同样的方式识别到容器 <code>c1</code>，连接到同一个 <code>Docker network</code> 的容器 <code>c1</code>, <code>c2</code> 可以互相连接<br>使用以下命令，可以查看 <code>Docker network</code> 的详细信息，包括 ip 网段，ip 分配信息等</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker network inspect my-net</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;my-net&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;2e19366fb32312235a3571192d1a19e6ebb7adc3e6e25c1f5e6007e8c3315f08&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2022-08-30T15:44:54.241420767+08:00&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;172.18.0.0/16&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.18.0.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;4b6b1159073d3b70312f2b7e5da8c4a36133a6c00c4746fe2c58d37e81a86b12&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;c2&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;0cbe15ff760040d20cd10a04ffed5f4398e1c3c2b597a86461758606ebdc919d&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:12:00:03&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.18.0.3/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;e520d1c8e30bf97ece44fae53840d13e801648ca02899a17416a75563d3a64f6&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;c1&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;214c7596e2610208402cfa55a225fa67c0dd02d4b585c62b43a9a6c42f360147&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:12:00:02&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.18.0.2/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果容器启动时使用了自定义的 <code>Docker network</code>，并且启动过程中挂载了宿主机的 <code>/etc/resolv.conf</code>，则容器启动后无法再使用容器名和其他容器互联，比如使用以下命令启动容器 <code>c3</code>，<code>c3</code> 无法使用容器名和 <code>c1</code>,<code>c2</code> 互联，但是<code>c1</code>,<code>c2</code> 可以使用容器名 <code>c3</code> 连接到容器 <code>c3</code>  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -ti --network my-net -v /etc/resolv.conf:/etc/resolv.conf --name c3 centos</span><br></pre></td></tr></table></figure>
<p>以上示例中，如果登录 <code>c1</code> 终端后，修改 <code>/etc/resolv.conf</code> 文件，再次使用 <code>c2</code> ，会无法连接 <code>c2</code> 容器 <a href="#Docker-DNS-%E6%9C%8D%E5%8A%A1">相关原理参考 Docker DNS 服务</a>  </p>
</blockquote>
<p>如果容器启动时，需要为容器指定域名 ip 映射关系，可以使用选项 <code>--add-host host:ip</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --network my-net --add-host db:172.18.0.3 --name c3 centos</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>容器运行过程中，可以直接修改容器内的 <code>/etc/hosts</code> 文件</p>
<h1 id="Docker-DNS-服务"><a href="#Docker-DNS-服务" class="headerlink" title="Docker DNS 服务"></a>Docker DNS 服务</h1><p>从 Docker 1.10 版本开始，Docker 实现了一个内嵌的 DNS server，Docker 容器可以使用内部的 DNS 解析机制，而不是直接使用宿主机的 DNS 设置。<strong>在容器 <code>/etc/resolv.conf</code> 中看到 <code>nameserver 127.0.0.11</code> 表示 Docker 容器使用了 Docker 内部的 DNS 解析服务。</strong></p>
<p>通过使用此内部 DNS 服务器，Docker 实现了其 <strong>服务发现</strong> （ <strong>在容器运行的 Docker 网络中，每个容器的主机名和服务名（如 <code>docker compose</code> 中的 <code>service</code>）都会自动注册到 Docker 内部 DNS 中，这使得在同一网络中的容器可以通过服务名互相访问，而不需要知道彼此的 IP 地址</strong> 。）相关功能：</p>
<ul>
<li>当容器中的应用需要解析域名时，如果该请求是要 <strong>解析服务发现相关的内部 Docker 网络中的主机名</strong> ，Docker 的 DNS 服务器会优先解析容器网络中的主机名。例如，容器之间的互相访问可以通过服务名来解析。</li>
<li>如果请求的域名不属于 Docker 内部网络（如外部的互联网域名 <code>google.com</code>），Docker 会将请求转发到宿主机的 DNS 服务器（通常是由宿主机的 <code>/etc/resolv.conf</code> 文件中的配置来决定）。</li>
</ul>
<blockquote>
<p><code>127.0.0.11</code> 是 Docker 引擎提供的内部虚拟 DNS 服务器地址，负责处理容器的 DNS 请求。这个虚拟 DNS 服务会捕获容器发出的所有 DNS 查询，并根据 Docker 引擎的配置做进一步的处理。</p>
</blockquote>
<p><strong><code>127.0.0.11</code> 在系统环回地址段(本地网络)内（<code>127.0.0.0/8</code>）， Linux 网络栈对回环地址有特殊的处理机制</strong>：</p>
<ul>
<li>当数据包的目标地址是回环地址（<code>127.x.x.x</code>），内核会将其视为本地地址，<strong>不会通过默认网关路由转发，而是直接在本地处理</strong>。</li>
<li>回环地址 <code>127.0.0.0/8</code> 是保留用于本地通信的，这意味着任何发往回环地址的数据包都不会经过网络接口，而是直接在本地主机上处理。</li>
</ul>
<p>以下为 Docker Daemon 内嵌 DNS 服务的大体工作流程及相关关键点： <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[docker container DNS配置介绍和源码分析](https://blog.51cto.com/u_2839840/2448369)">[1]</span></a></sup> </p>
<ol>
<li><p>Docker Daemon 创建容器时，会为容器生成 <code>/etc/resolv.conf</code> 并写入 <code>Docker Embedded DNS Server</code> 的 IP，默认为 <code>nameserver 127.0.0.11</code>。并生成相关的 <code>iptables</code> 转发规则用于处理 DNS 请求。相关信息如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> /etc/resolv.conf</span> </span><br><span class="line">nameserver 127.0.0.11</span><br><span class="line">options edns0 trust-ad ndots:0</span><br></pre></td></tr></table></figure></li>
<li><p>Docker Daemon 启动容器时，会在容器中启动 2 个随机可用的端口， 作为 <code>Embedded DNS Server</code> （<code>127.0.0.11</code>）的 TCP&#x2F;UDP 监听端口，本示例中的 <code>tcp:127.0.0.11:42345</code> 和 <code>udp:127.0.0.11:60253</code></p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ip add</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">4990: eth0@if4991: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default </span><br><span class="line">    link/ether 02:42:ac:1b:00:03 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.27.0.3/16 brd 172.27.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ip route</span>   </span><br><span class="line">default via 172.27.0.1 dev eth0 </span><br><span class="line">172.27.0.0/16 dev eth0 proto kernel scope link src 172.27.0.3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">netstat -anutp</span></span><br><span class="line">Active Internet connections (servers and established)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 127.0.0.11:42345        0.0.0.0:*               LISTEN      -                   </span><br><span class="line">udp        0      0 127.0.0.11:60253        0.0.0.0:*                           -</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ps aux</span></span><br><span class="line">USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root           1  0.0  0.0   2696  1116 ?        Ss   Sep10   0:00 sleep 31536000    </span><br><span class="line">root           7  0.0  0.0   4588  3976 pts/0    Ss+  Sep10   0:00 bash</span><br><span class="line">root         231  0.4  0.0   4588  3912 pts/1    Ss   05:45   0:00 bash</span><br><span class="line">root         239  0.0  0.0   7888  3952 pts/1    R+   05:45   0:00 ps aux</span><br></pre></td></tr></table></figure></li>
<li><p>对容器内的 <code>iptables</code> （或者其他防火墙）进行配置，对 DNS 请求和响应分别做 DNAT 和 SNAT</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">iptables -t nat -L -v -n</span></span><br><span class="line">Chain PREROUTING (policy ACCEPT 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line"></span><br><span class="line">Chain INPUT (policy ACCEPT 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line">    6   485 DOCKER_OUTPUT  0    --  *      *       0.0.0.0/0            127.0.0.11          </span><br><span class="line"></span><br><span class="line">Chain POSTROUTING (policy ACCEPT 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line">    6   485 DOCKER_POSTROUTING  0    --  *      *       0.0.0.0/0            127.0.0.11          </span><br><span class="line"></span><br><span class="line">Chain DOCKER_OUTPUT (1 references)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line">    0     0 DNAT       6    --  *      *       0.0.0.0/0            127.0.0.11           tcp dpt:53 to:127.0.0.11:42345</span><br><span class="line">    6   485 DNAT       17   --  *      *       0.0.0.0/0            127.0.0.11           udp dpt:53 to:127.0.0.11:60253</span><br><span class="line"></span><br><span class="line">Chain DOCKER_POSTROUTING (1 references)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line">    0     0 SNAT       6    --  *      *       127.0.0.11           0.0.0.0/0            tcp spt:42345 to::53</span><br><span class="line">    0     0 SNAT       17   --  *      *       127.0.0.11           0.0.0.0/0            udp spt:60253 to::53</span><br></pre></td></tr></table></figure></li>
</ol>
<p>根据以上配置，详细的 DNS 请求过程如下：</p>
<ol>
<li><p>容器中的进程发起 DNS 请求，数据报文中 TCP&#x2F;IP 头部地址信息（源地址及目标地址）如下： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">172.27.0.3:12345 -&gt; 127.0.0.11:53</span><br></pre></td></tr></table></figure></li>
<li><p>数据报文从网络协议栈发出，到达 <code>iptables</code> 的 <code>OUTPUT</code> 链，根据 <code>iptables</code> 规则（<code>DOCKER_OUTPUT</code>），数据报文进行了 DNAT，由 <code>172.27.0.3:12345 -&gt; 127.0.0.11:53</code> 转换为 <code>172.27.0.3:12345 -&gt; 127.0.0.11:42345</code></p>
</li>
<li><p>数据报文中的目标 IP 地址(<code>127.0.0.11</code>)属于 <strong>环回地址段</strong>，根据 Linux 网络协议栈对回环地址特殊的处理机制，其不会根据路由表进行路由，而是直接由本地进程（<code>127.0.0.11:42345</code>）处理。</p>
<blockquote>
<p><code>127.0.0.11:42345</code> 由 Docker 内部 DNS 代理服务监听，它是由 Docker 引擎在宿主机上通过 <strong>虚拟网络层</strong> 和 <strong>内部机制</strong> 提供的 DNS 服务，因此你无法在容器内部使用标准进程监控工具（如 <code>ps</code> 或 <code>netstat</code>）直接看到负责监听 <code>127.0.0.11</code> 端口的进程。</p>
<p>Docker 在启动容器时自动配置了一个 <strong>虚拟网络栈</strong>，包括虚拟的 DNS 中继服务。该服务是在宿主机的网络命名空间中运行的，而不是在每个容器内部运行单独的 DNS 进程。</p>
<p>由于 DNS 代理运行在 Docker 守护进程之下，它不需要在容器内通过用户空间进程直接提供服务。因此，容器内部不会显示负责监听 127.0.0.11 的具体进程。 </p>
</blockquote>
</li>
<li><p>DNS 请求（<code>172.27.0.3:12345 -&gt; 127.0.0.11:42345</code>） 由 Docker 内部 DNS 代理服务处理</p>
<ul>
<li>如果该请求是针对 Docker 网络内部的容器或服务名，Docker DNS 代理会直接解析并返回对应的 IP 地址。</li>
<li>如果是外部域名（如 <code>google.com</code>），Docker DNS 服务会将请求转发给宿主机配置的外部 DNS 服务器进行解析，即 DNS 转发。</li>
</ul>
</li>
<li><p>DNS 请求（<code>172.27.0.3:12345 -&gt; 127.0.0.11:42345</code>）的响应类似（<code>127.0.0.11:42345 -&gt; 172.27.0.3:12345</code>），<strong>虽然这个数据包是本地生成的，但经过 Docker 内部使用的 <strong>虚拟网络栈</strong> ，数据包在离开 Docker Daemon 的虚拟 DNS 处理服务（<code>127.0.0.11:42345</code>）后，被视为一个出站数据包，并进入 <code>POSTROUTING</code> 链</strong></p>
</li>
<li><p>响应数据报文（<code>127.0.0.11:42345 -&gt; 172.27.0.3:12345</code>）到达 <code>iptables</code> 的 <code>POSTROUTING</code> 链，根据规则进行源端口转换，由 <code>127.0.0.11:42345 -&gt; 172.27.0.3:12345</code> SNAT 为 <code>127.0.0.11:53 -&gt; 172.27.0.3:12345</code>，确保发起 DNS 请求的进程识别响应的数据报文。</p>
</li>
</ol>
<p>如果在 <strong>使用了 Docker 内嵌 DNS 服务的容器中启用防火墙，为了让内嵌 DNS 服务正常工作</strong> ，可以参考以下防火墙（<code>nftables</code>）规则</p>
<figure class="highlight shell"><figcaption><span>/etc/nftables.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/sbin/nft -f</span></span><br><span class="line"></span><br><span class="line">flush ruleset</span><br><span class="line"></span><br><span class="line">table inet filter &#123;</span><br><span class="line">	chain input &#123;</span><br><span class="line">		type filter hook input priority filter; policy drop;</span><br><span class="line">        #ip protocol icmp accept;   # allow all IPv4 ICMP</span><br><span class="line">        #ip6 nexthdr icmpv6 accept;  # allow all IPv6 ICMP</span><br><span class="line">        ip protocol icmp icmp type  echo-reply accept;</span><br><span class="line">	    ip protocol icmp icmp type echo-request accept;</span><br><span class="line">	</span><br><span class="line">	    ip saddr 127.0.0.11 counter accept;	    # Docker Embedded DNS 服务必须</span><br><span class="line">        ip daddr 127.0.0.11 counter accept;     # Docker Embedded DNS 服务必须</span><br><span class="line">	</span><br><span class="line">	    counter drop;</span><br><span class="line">	&#125;</span><br><span class="line">	chain forward &#123;</span><br><span class="line">		type filter hook forward priority filter; policy drop;</span><br><span class="line">		counter drop;</span><br><span class="line">	&#125;</span><br><span class="line">	chain output &#123;</span><br><span class="line">		type filter hook output priority filter;</span><br><span class="line">		counter accept;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#  以下 nat 表中的规则为 Docker Embedded DNS 服务必须，其中的随即端口要根据实际情况修改</span></span></span><br><span class="line">table inet nat &#123;</span><br><span class="line">	chain OUTPUT &#123;</span><br><span class="line">		type nat hook output priority dstnat; policy accept;</span><br><span class="line">		ip daddr 127.0.0.11 counter jump DOCKER_OUTPUT;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    chain DOCKER_OUTPUT &#123;</span><br><span class="line">		meta l4proto tcp ip daddr 127.0.0.11 tcp dport 53 counter dnat to 127.0.0.11:37313;</span><br><span class="line">		meta l4proto udp ip daddr 127.0.0.11 udp dport 53 counter dnat to 127.0.0.11:33631;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	chain POSTROUTING &#123;</span><br><span class="line">	    type nat hook postrouting priority srcnat; policy accept;</span><br><span class="line">		ip daddr 127.0.0.11 counter jump DOCKER_POSTROUTING;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	chain DOCKER_POSTROUTING &#123;</span><br><span class="line">		meta l4proto tcp ip saddr 127.0.0.11 tcp sport 37313 counter snat to :53;</span><br><span class="line">		meta l4proto udp ip saddr 127.0.0.11 udp sport 33631 counter snat to :53;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Docker-网络相关问题"><a href="#Docker-网络相关问题" class="headerlink" title="Docker 网络相关问题"></a>Docker 网络相关问题</h1><h2 id="定位-Docker-容器中的网卡和宿主机上面的-veth-的-pair-关系"><a href="#定位-Docker-容器中的网卡和宿主机上面的-veth-的-pair-关系" class="headerlink" title="定位 Docker 容器中的网卡和宿主机上面的 veth 的 pair 关系"></a>定位 Docker 容器中的网卡和宿主机上面的 veth 的 pair 关系</h2><p>在经典容器组网中，主要是使用 <a href="!--swig%EF%BF%BC33--"><code>veth</code></a> + <code>bridge</code> 的模式，容器中的 <code>eth0</code> 实际上和宿主机上面的某个 <code>veth</code> 是成对（pair）关系，要查看容器中的网卡和宿主机上面的 <code>veth</code> 网卡的成对关系，可以参考以下方法</p>
<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法 1"></a>方法 1</h3><ol>
<li>在目标容器中查看 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat /sys/class/net/eth0/iflink </span><br><span class="line">60</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>在宿主机上遍历 <code>/sys/class/net/</code> 下面的全部目录，查看子目录中的 <code>ifindex</code> 文件的内容，找出和容器中 <code>/sys/class/net/eth0/iflink</code> 的值一样的 <code>veth</code> 的名称，这样就找到了容器和主机的 <code>veth pair</code> 的关系 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat /sys/class/net/vethc41ba34/ifindex </span><br><span class="line">60</span><br></pre></td></tr></table></figure>
 本示例中，宿主机上的 <code>vethc41ba34</code> 和容器中的网卡是 <code>veth pair</code></li>
</ol>
<h3 id="方法-2"><a href="#方法-2" class="headerlink" title="方法 2"></a>方法 2</h3><ol>
<li>目标容器中查看<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip <span class="built_in">link</span> show eth0</span></span><br><span class="line">59: eth0@if60: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default </span><br><span class="line"> link/ether 02:42:ac:16:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br></pre></td></tr></table></figure>
从上面的命令可以看到 <code>59: eth0@if60</code>，其中 <code>59</code> 是 <code>eth0</code> 接口的 index，<code>60</code> 是和它成对的 <code>veth</code> 的 index。</li>
<li>在 host 上面执行下面的命令，可以看到对应 <code>60</code> 的 <code>veth</code> 网卡是哪一个<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip link show | grep 60</span><br><span class="line">60: vethc41ba34@if59: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master br-9d2a9fc0ff85 state UP mode DEFAULT group default </span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="方法-3"><a href="#方法-3" class="headerlink" title="方法 3"></a>方法 3</h3><p>通过 <code>ethtool -S</code> 命令列出 <code>veth pair</code> 对端的网卡 index</p>
<ol>
<li>目标容器中执行<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ethtool -S eth0</span></span><br><span class="line">NIC statistics:</span><br><span class="line">  peer_ifindex: 60</span><br></pre></td></tr></table></figure></li>
<li>在宿主机上面查找 index 为 60 的 <code>veth</code> 网卡是哪一个<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip link show | grep 60</span><br><span class="line">60: vethc41ba34@if59: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master br-9d2a9fc0ff85 state UP mode DEFAULT group default </span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_2839840/2448369">docker container DNS配置介绍和源码分析</a></p>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_2839840/2448369">docker container DNS配置介绍和源码分析</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="../tags/Docker/" rel="tag"><i class="fa fa-tag"></i> Docker</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="../202208250937/" rel="prev" title="Confluence 常用基本操作">
                  <i class="fa fa-chevron-left"></i> Confluence 常用基本操作
                </a>
            </div>
            <div class="post-nav-item">
                <a href="../202208301738/" rel="next" title="docker compose 简介">
                  docker compose 简介 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">COSMOS</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.3" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="../js/comments.js"></script><script src="../js/utils.js"></script><script src="../js/motion.js"></script><script src="../js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="../js/third-party/search/local-search.js"></script>




  <script src="../js/third-party/pace.js"></script>

  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"fl9999","repo":"fl9999.github.io","client_id":"a11bf6f7860762b725b5","client_secret":"a99046105f8bddc72ec718d54dc3fd7f22070821","admin_user":"fl9999","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":null,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"d41d8cd98f00b204e9800998ecf8427e"}</script>
<script src="../js/third-party/comments/gitalk.js"></script>

</body>
</html>
